#include <cstddef>
#include <cstdint>
#include <array>
#include <algorithm>
#include <chrono>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iterator>
#include <limits>
#include <mutex>
#include <thread>
#include <tuple>
#include <type_traits>
#include <vector>
#include <condition_variable>

#include "aerogpu_d3d9_objects.h"
#include "aerogpu_d3d9_blit.h"
#include "aerogpu_d3d9_fixedfunc_shaders.h"
#include "aerogpu_d3d9_submit.h"
#include "aerogpu_kmd_query.h"

#include "aerogpu_cmd_stream_writer.h"
#include "aerogpu_pci.h"
#include "aerogpu_wddm_alloc.h"
#include "fixedfunc_test_constants.h"

namespace aerogpu {

// aerogpu_d3d9_driver.cpp helpers (not part of the public UMD header).
uint32_t d3d9_format_to_aerogpu(uint32_t d3d9_format);

// Host-test entrypoints (defined in `src/aerogpu_d3d9_driver.cpp` under "Host-side
// test entrypoints").
HRESULT AEROGPU_D3D9_CALL device_set_material(D3DDDI_HDEVICE hDevice, const D3DMATERIAL9* pMaterial);
HRESULT AEROGPU_D3D9_CALL device_set_light(D3DDDI_HDEVICE hDevice, uint32_t index, const D3DLIGHT9* pLight);
HRESULT AEROGPU_D3D9_CALL device_light_enable(D3DDDI_HDEVICE hDevice, uint32_t index, BOOL enabled);
HRESULT AEROGPU_D3D9_CALL device_test_enable_wddm_context(D3DDDI_HDEVICE hDevice);
HRESULT AEROGPU_D3D9_CALL device_test_rebind_alloc_list_tracker(
    D3DDDI_HDEVICE hDevice,
    D3DDDI_ALLOCATIONLIST* pAllocationList,
    uint32_t allocation_list_capacity,
    uint32_t max_allocation_list_slot_id);
HRESULT AEROGPU_D3D9_CALL device_test_reset_alloc_list_tracker(D3DDDI_HDEVICE hDevice);
AllocRef AEROGPU_D3D9_CALL device_test_track_buffer_read(
    D3DDDI_HDEVICE hDevice,
    WddmAllocationHandle hAllocation,
    uint32_t alloc_id,
    uint64_t share_token);
AllocRef AEROGPU_D3D9_CALL device_test_track_texture_read(
    D3DDDI_HDEVICE hDevice,
    WddmAllocationHandle hAllocation,
    uint32_t alloc_id,
    uint64_t share_token);
AllocRef AEROGPU_D3D9_CALL device_test_track_render_target_write(
    D3DDDI_HDEVICE hDevice,
    WddmAllocationHandle hAllocation,
    uint32_t alloc_id,
    uint64_t share_token);
HRESULT AEROGPU_D3D9_CALL device_test_force_umd_private_features(D3DDDI_HDEVICE hDevice, uint64_t device_features);
HRESULT AEROGPU_D3D9_CALL adapter_test_set_completed_fence(D3DDDI_HADAPTER hAdapter, uint64_t completed_fence);
HRESULT AEROGPU_D3D9_CALL device_test_set_resource_backing(
    D3DDDI_HDEVICE hDevice,
    D3DDDI_HRESOURCE hResource,
    uint32_t backing_alloc_id,
    uint32_t backing_offset_bytes,
    WddmAllocationHandle wddm_hAllocation);
HRESULT AEROGPU_D3D9_CALL device_test_alias_fixedfunc_stage0_ps_variant(
    D3DDDI_HDEVICE hDevice,
    uint32_t src_index,
    uint32_t dst_index);

// Best-effort context string used by `Check()` to include the current test name
// in failure output (helps when the binary continues after failures).
static const char* g_current_test_name = nullptr;

namespace {

// D3DERR_INVALIDCALL from d3d9.h.
constexpr HRESULT kD3DErrInvalidCall = 0x8876086CUL;
constexpr uint32_t kD3d9ShaderStageVs = 0u;
constexpr uint32_t kD3d9ShaderStagePs = 1u;

constexpr D3DDDIFORMAT kD3dFmtIndex16 = static_cast<D3DDDIFORMAT>(101); // D3DFMT_INDEX16
constexpr D3DDDIFORMAT kD3dFmtIndex32 = static_cast<D3DDDIFORMAT>(102); // D3DFMT_INDEX32

// Minimal D3D9 shader tokens used by fixed-function PS selection tests.
constexpr uint32_t kPs20Version = 0xFFFF0200u;
constexpr uint32_t kPsEnd = 0x0000FFFFu;
constexpr uint32_t kPsOpAdd = 0x04000002u;
constexpr uint32_t kPsOpMul = 0x04000005u;
constexpr uint32_t kPsOpTexld = 0x04000042u;

// D3DRESOURCETYPE numeric constants (from d3d9types.h). Tests use numeric values
// so they can run in portable (non-WDK/non-Windows) builds.
constexpr uint32_t kD3dRTypeSurface = 1u; // D3DRTYPE_SURFACE
constexpr uint32_t kD3dRTypeVolume = 2u; // D3DRTYPE_VOLUME
constexpr uint32_t kD3dRTypeTexture = 3u; // D3DRTYPE_TEXTURE
constexpr uint32_t kD3dRTypeVolumeTexture = 4u; // D3DRTYPE_VOLUMETEXTURE
constexpr uint32_t kD3dRTypeCubeTexture = 5u; // D3DRTYPE_CUBETEXTURE

template <typename T, typename = void>
struct HasPfnSetShaderConstI : std::false_type {};
template <typename T>
struct HasPfnSetShaderConstI<T, std::void_t<decltype(&T::pfnSetShaderConstI)>>
    : std::true_type {};

template <typename T, typename = void>
struct HasPfnSetShaderConstF : std::false_type {};
template <typename T>
struct HasPfnSetShaderConstF<T, std::void_t<decltype(&T::pfnSetShaderConstF)>>
    : std::true_type {};

template <typename T, typename = void>
struct HasPfnSetShaderConstB : std::false_type {};
template <typename T>
struct HasPfnSetShaderConstB<T, std::void_t<decltype(&T::pfnSetShaderConstB)>>
    : std::true_type {};

template <typename T, typename = void>
struct HasPfnGetShaderConstI : std::false_type {};
template <typename T>
struct HasPfnGetShaderConstI<T, std::void_t<decltype(&T::pfnGetShaderConstI)>>
    : std::true_type {};

template <typename T, typename = void>
struct HasPfnGetShaderConstB : std::false_type {};
template <typename T>
struct HasPfnGetShaderConstB<T, std::void_t<decltype(&T::pfnGetShaderConstB)>>
    : std::true_type {};

template <typename T, typename = void>
struct HasPfnCaptureStateBlock : std::false_type {};
template <typename T>
struct HasPfnCaptureStateBlock<T, std::void_t<decltype(&T::pfnCaptureStateBlock)>>
    : std::true_type {};

template <typename T, typename = void>
struct HasPfnCreateStateBlock : std::false_type {};
template <typename T>
struct HasPfnCreateStateBlock<T, std::void_t<decltype(&T::pfnCreateStateBlock)>>
    : std::true_type {};

template <typename Fn>
struct FnTraits;
template <typename Ret, typename... Args>
struct FnTraits<Ret(*)(Args...)> {
  using RetT = Ret;
  using ArgsTuple = std::tuple<Args...>;
  static constexpr size_t kArity = sizeof...(Args);
  template <size_t I>
  using Arg = std::tuple_element_t<I, ArgsTuple>;
};
template <typename Ret, typename... Args>
struct FnTraits<Ret(__stdcall*)(Args...)> {
  using RetT = Ret;
  using ArgsTuple = std::tuple<Args...>;
  static constexpr size_t kArity = sizeof...(Args);
  template <size_t I>
  using Arg = std::tuple_element_t<I, ArgsTuple>;
};

template <typename T, typename = void>
struct HasMemberStateBlockType : std::false_type {};
template <typename T>
struct HasMemberStateBlockType<T, std::void_t<decltype(&T::StateBlockType)>> : std::true_type {};

template <typename T, typename = void>
struct HasMemberType : std::false_type {};
template <typename T>
struct HasMemberType<T, std::void_t<decltype(&T::Type)>> : std::true_type {};

template <typename T, typename = void>
struct HasMembertype : std::false_type {};
template <typename T>
struct HasMembertype<T, std::void_t<decltype(&T::type)>> : std::true_type {};

template <typename T, typename = void>
struct HasMemberhStateBlock : std::false_type {};
template <typename T>
struct HasMemberhStateBlock<T, std::void_t<decltype(&T::hStateBlock)>> : std::true_type {};

template <typename CreateArgsT>
void InitCreateStateBlockArgs(CreateArgsT* args, uint32_t type_u32) {
  if (!args) {
    return;
  }
  if constexpr (HasMemberStateBlockType<CreateArgsT>::value) {
    args->StateBlockType = static_cast<decltype(args->StateBlockType)>(type_u32);
  } else if constexpr (HasMemberType<CreateArgsT>::value) {
    args->Type = static_cast<decltype(args->Type)>(type_u32);
  } else if constexpr (HasMembertype<CreateArgsT>::value) {
    args->type = static_cast<decltype(args->type)>(type_u32);
  }
  if constexpr (HasMemberhStateBlock<CreateArgsT>::value) {
    args->hStateBlock.pDrvPrivate = nullptr;
  }
}

template <typename DeviceFuncsT>
HRESULT CallCreateStateBlock(DeviceFuncsT* funcs,
                             D3DDDI_HDEVICE hDevice,
                             uint32_t type_u32,
                             D3D9DDI_HSTATEBLOCK* out) {
  if (!funcs || !out) {
    return E_INVALIDARG;
  }
  out->pDrvPrivate = nullptr;

  if constexpr (!HasPfnCreateStateBlock<DeviceFuncsT>::value) {
    return E_NOTIMPL;
  } else {
    if (!funcs->pfnCreateStateBlock) {
      return E_NOTIMPL;
    }
    using PfnT = decltype(funcs->pfnCreateStateBlock);
    constexpr size_t kArity = FnTraits<PfnT>::kArity;
    if constexpr (kArity == 3) {
      return funcs->pfnCreateStateBlock(hDevice, type_u32, out);
    } else if constexpr (kArity == 2) {
      using CreateArgsPtrT = typename FnTraits<PfnT>::template Arg<1>;
      using CreateArgsT = std::remove_pointer_t<CreateArgsPtrT>;
      CreateArgsT args{};
      InitCreateStateBlockArgs(&args, type_u32);
      HRESULT hr = funcs->pfnCreateStateBlock(hDevice, &args);
      if constexpr (HasMemberhStateBlock<CreateArgsT>::value) {
        *out = args.hStateBlock;
      }
      return hr;
    } else {
      return E_NOTIMPL;
    }
  }
}

// ABI-compatible D3DVERTEXELEMENT9 encoding (8 bytes, packed). The UMD treats
// vertex decls as opaque blobs at the DDI boundary, so tests define a portable
// layout here.
#pragma pack(push, 1)
struct D3DVERTEXELEMENT9_COMPAT {
  uint16_t Stream;
  uint16_t Offset;
  uint8_t Type;
  uint8_t Method;
  uint8_t Usage;
  uint8_t UsageIndex;
};
#pragma pack(pop)

static_assert(sizeof(D3DVERTEXELEMENT9_COMPAT) == 8, "D3DVERTEXELEMENT9 must be 8 bytes");

// D3D9 vertex declaration + FVF numeric constants (from d3d9types.h).
constexpr uint8_t kD3dDeclTypeFloat1 = 0;
constexpr uint8_t kD3dDeclTypeFloat2 = 1;
constexpr uint8_t kD3dDeclTypeFloat3 = 2;
constexpr uint8_t kD3dDeclTypeFloat4 = 3;
constexpr uint8_t kD3dDeclTypeD3dColor = 4;
constexpr uint8_t kD3dDeclTypeUnused = 17;
constexpr uint8_t kD3dDeclMethodDefault = 0;

constexpr uint8_t kD3dDeclUsagePosition = 0;
constexpr uint8_t kD3dDeclUsageTexcoord = 5;
constexpr uint8_t kD3dDeclUsagePositionT = 9;
constexpr uint8_t kD3dDeclUsageColor = 10;

constexpr uint32_t kD3dFvfXyz = 0x00000002u;
constexpr uint32_t kD3dFvfXyzRhw = 0x00000004u;
constexpr uint32_t kD3dFvfDiffuse = 0x00000040u;
constexpr uint32_t kD3dFvfTex1 = 0x00000100u;

bool Check(bool cond, const char* msg) {
  if (!cond) {
    if (g_current_test_name && *g_current_test_name) {
      std::fprintf(stderr, "FAIL: %s: %s\n", g_current_test_name, msg);
    } else {
      std::fprintf(stderr, "FAIL: %s\n", msg);
    }
    return false;
  }
  return true;
}

bool CheckHrImpl(HRESULT hr, HRESULT expected, const char* msg, int line) {
  if (hr != expected) {
    std::fprintf(stderr,
                 "FAIL: %s (hr=0x%08x expected=0x%08x @%d)\n",
                 msg,
                 static_cast<unsigned>(hr),
                 static_cast<unsigned>(expected),
                 line);
    return false;
  }
  return true;
}

#define CheckHr(hr, expected, msg) CheckHrImpl((hr), (expected), (msg), __LINE__)

bool BytecodeContainsToken(const uint8_t* bytes, size_t size, uint32_t token) {
  if (!bytes || size < sizeof(uint32_t) || (size % sizeof(uint32_t)) != 0) {
    return false;
  }
  for (size_t off = 0; off < size; off += sizeof(uint32_t)) {
    uint32_t w = 0;
    std::memcpy(&w, bytes + off, sizeof(uint32_t));
    if (w == token) {
      return true;
    }
  }
  return false;
}

bool BytecodeWordAt(const uint8_t* bytes, size_t size, size_t word_index, uint32_t* out) {
  if (!out) {
    return false;
  }
  *out = 0;
  if (!bytes || size < sizeof(uint32_t) || (size % sizeof(uint32_t)) != 0) {
    return false;
  }
  const size_t offset = word_index * sizeof(uint32_t);
  if (offset + sizeof(uint32_t) > size) {
    return false;
  }
  std::memcpy(out, bytes + offset, sizeof(uint32_t));
  return true;
}
// Tests often bind `Device::cmd` to a span-backed buffer owned by the test (e.g. a
// local `std::vector<uint8_t>`). Driver cleanup paths may emit additional packets
// (e.g. DESTROY_RESOURCE) from RAII destructors after the local buffer has been
// freed, which would turn into a use-after-free if the command writer still points
// at the span.
//
// Ensure span-backed writers are always returned to vector mode before RAII
// teardown runs, even on early-return error paths.
struct ScopedDeviceCmdVectorReset {
  explicit ScopedDeviceCmdVectorReset(Device* d) : dev(d) {}
  ScopedDeviceCmdVectorReset(const ScopedDeviceCmdVectorReset&) = delete;
  ScopedDeviceCmdVectorReset& operator=(const ScopedDeviceCmdVectorReset&) = delete;
  ~ScopedDeviceCmdVectorReset() {
    if (dev) {
      dev->cmd.set_vector();
    }
  }
  Device* dev = nullptr;
};

size_t AlignUp(size_t v, size_t a) {
  return (v + (a - 1)) & ~(a - 1);
}

struct unknown_cmd_fixed {
  aerogpu_cmd_hdr hdr;
  uint32_t value;
};

struct CmdLoc {
  const aerogpu_cmd_hdr* hdr = nullptr;
  size_t offset = 0;
};

size_t StreamBytesUsed(const uint8_t* buf, size_t capacity) {
  if (!buf || capacity < sizeof(aerogpu_cmd_stream_header)) {
    return 0;
  }

  // Forward-compat: `aerogpu_cmd_stream_header.size_bytes` is bytes-used. Callers may provide a
  // backing buffer (capacity) larger than `size_bytes` (page rounding / reuse). Helpers must only
  // walk the declared prefix and ignore trailing bytes.
  const auto* stream = reinterpret_cast<const aerogpu_cmd_stream_header*>(buf);
  const size_t used = stream->size_bytes;
  if (used < sizeof(aerogpu_cmd_stream_header) || used > capacity) {
    return 0;
  }
  return used;
}

CmdLoc FindLastOpcode(const uint8_t* buf, size_t capacity, uint32_t opcode) {
  CmdLoc loc{};
  const size_t stream_len = StreamBytesUsed(buf, capacity);
  if (stream_len == 0) {
    return loc;
  }

  size_t offset = sizeof(aerogpu_cmd_stream_header);
  while (offset + sizeof(aerogpu_cmd_hdr) <= stream_len) {
    const auto* hdr = reinterpret_cast<const aerogpu_cmd_hdr*>(buf + offset);
    if (hdr->opcode == opcode) {
      loc.hdr = hdr;
      loc.offset = offset;
    }
    if (hdr->size_bytes == 0 || hdr->size_bytes > stream_len - offset) {
      break;
    }
    offset += hdr->size_bytes;
  }
  return loc;
}

CmdLoc FindLastOpcodeBefore(const uint8_t* buf, size_t capacity, size_t end_offset, uint32_t opcode) {
  CmdLoc loc{};
  const size_t stream_len = StreamBytesUsed(buf, capacity);
  if (stream_len == 0) {
    return loc;
  }
  if (end_offset > stream_len) {
    end_offset = stream_len;
  }

  size_t offset = sizeof(aerogpu_cmd_stream_header);
  while (offset + sizeof(aerogpu_cmd_hdr) <= stream_len && offset < end_offset) {
    const auto* hdr = reinterpret_cast<const aerogpu_cmd_hdr*>(buf + offset);
    if (hdr->opcode == opcode) {
      loc.hdr = hdr;
      loc.offset = offset;
    }
    if (hdr->size_bytes == 0 || hdr->size_bytes > stream_len - offset) {
      break;
    }
    offset += hdr->size_bytes;
  }
  return loc;
}

CmdLoc FindLastUploadResourceBefore(const uint8_t* buf, size_t capacity, size_t end_offset, uint32_t resource_handle) {
  CmdLoc loc{};
  const size_t stream_len = StreamBytesUsed(buf, capacity);
  if (stream_len == 0) {
    return loc;
  }
  if (end_offset > stream_len) {
    end_offset = stream_len;
  }

  size_t offset = sizeof(aerogpu_cmd_stream_header);
  while (offset + sizeof(aerogpu_cmd_hdr) <= stream_len && offset < end_offset) {
    const auto* hdr = reinterpret_cast<const aerogpu_cmd_hdr*>(buf + offset);
    if (hdr->opcode == AEROGPU_CMD_UPLOAD_RESOURCE) {
      const auto* upload = reinterpret_cast<const aerogpu_cmd_upload_resource*>(hdr);
      if (upload->resource_handle == resource_handle) {
        loc.hdr = hdr;
        loc.offset = offset;
      }
    }
    if (hdr->size_bytes == 0 || hdr->size_bytes > stream_len - offset) {
      break;
    }
    offset += hdr->size_bytes;
  }
  return loc;
}

CmdLoc FindLastUploadForHandle(const uint8_t* buf, size_t capacity, aerogpu_handle_t handle) {
  const size_t stream_len = StreamBytesUsed(buf, capacity);
  if (stream_len == 0) {
    return {};
  }
  return FindLastUploadResourceBefore(buf, capacity, stream_len, static_cast<uint32_t>(handle));
}

size_t CountOpcode(const uint8_t* buf, size_t capacity, uint32_t opcode) {
  const size_t stream_len = StreamBytesUsed(buf, capacity);
  if (stream_len == 0) {
    return 0;
  }

  size_t count = 0;
  size_t offset = sizeof(aerogpu_cmd_stream_header);
  while (offset + sizeof(aerogpu_cmd_hdr) <= stream_len) {
    const auto* hdr = reinterpret_cast<const aerogpu_cmd_hdr*>(buf + offset);
    if (hdr->opcode == opcode) {
      count++;
    }
    if (hdr->size_bytes == 0 || hdr->size_bytes > stream_len - offset) {
      break;
    }
    offset += hdr->size_bytes;
  }
  return count;
}

bool CheckUploadResourceWithinSingleTextureSubresource(const Resource* res, uint64_t start, uint64_t end) {
  if (!Check(res != nullptr, "UPLOAD_RESOURCE: resource pointer valid")) {
    return false;
  }
  if (!Check(end >= start, "UPLOAD_RESOURCE: range must not overflow")) {
    return false;
  }
  if (!Check(end <= static_cast<uint64_t>(res->size_bytes), "UPLOAD_RESOURCE: range within resource")) {
    return false;
  }
  if (res->kind == ResourceKind::Buffer) {
    return true;
  }

  Texture2dSubresourceLayout sub{};
  const uint32_t layers = std::max(1u, res->depth);
  if (!Check(calc_texture2d_subresource_layout_for_offset(
                 res->format,
                 res->width,
                 res->height,
                 res->mip_levels,
                 layers,
                 start,
                 &sub),
             "UPLOAD_RESOURCE: offset maps to texture subresource")) {
    return false;
  }

  // The host executor rejects uploads that span multiple mip levels within a
  // single command.
  if (!Check(end <= sub.subresource_end_bytes, "UPLOAD_RESOURCE: does not cross mip boundary")) {
    return false;
  }

  // The host executor requires texture uploads to start/end on row boundaries.
  if (!Check(sub.row_pitch_bytes != 0, "UPLOAD_RESOURCE: subresource row_pitch non-zero")) {
    return false;
  }
  const uint64_t rel_start = start - sub.subresource_start_bytes;
  const uint64_t rel_end = end - sub.subresource_start_bytes;
  if (!Check((rel_start % sub.row_pitch_bytes) == 0, "UPLOAD_RESOURCE: start is row-aligned")) {
    return false;
  }
  if (!Check((rel_end % sub.row_pitch_bytes) == 0, "UPLOAD_RESOURCE: end is row-aligned")) {
    return false;
  }
  return true;
}

CmdLoc FindLastShaderConstsFBefore(const uint8_t* buf,
                                  size_t capacity,
                                  size_t end_offset,
                                  uint32_t stage,
                                  uint32_t start_register,
                                  uint32_t vec4_count) {
  CmdLoc loc{};
  const size_t stream_len = StreamBytesUsed(buf, capacity);
  if (stream_len == 0) {
    return loc;
  }
  if (end_offset > stream_len) {
    end_offset = stream_len;
  }

  size_t offset = sizeof(aerogpu_cmd_stream_header);
  while (offset + sizeof(aerogpu_cmd_hdr) <= stream_len && offset < end_offset) {
    const auto* hdr = reinterpret_cast<const aerogpu_cmd_hdr*>(buf + offset);
    if (hdr->opcode == AEROGPU_CMD_SET_SHADER_CONSTANTS_F &&
        hdr->size_bytes >= sizeof(aerogpu_cmd_set_shader_constants_f) &&
        hdr->size_bytes <= stream_len - offset) {
      const auto* cmd = reinterpret_cast<const aerogpu_cmd_set_shader_constants_f*>(hdr);
      if (cmd->stage == stage && cmd->start_register == start_register && cmd->vec4_count == vec4_count) {
        loc.hdr = hdr;
        loc.offset = offset;
      }
    }
    if (hdr->size_bytes == 0 || hdr->size_bytes > stream_len - offset) {
      break;
    }
    offset += hdr->size_bytes;
  }
  return loc;
}

CmdLoc FindLastVsWvpConstants(const uint8_t* buf, size_t capacity) {
  const size_t stream_len = StreamBytesUsed(buf, capacity);
  if (stream_len == 0) {
    return {};
  }
  return FindLastShaderConstsFBefore(buf,
                                     capacity,
                                     stream_len,
                                     AEROGPU_SHADER_STAGE_VERTEX,
                                     kFixedfuncMatrixStartRegister,
                                     kFixedfuncMatrixVec4Count);
}

bool CheckWvpConstantsUploadedBeforeDraw(const uint8_t* buf,
                                        size_t capacity,
                                        size_t draw_offset,
                                        const float wvp_row_major[16],
                                        const char* what) {
  if (!buf || !wvp_row_major) {
    return Check(false, "CheckWvpConstantsUploadedBeforeDraw: invalid args");
  }

  const CmdLoc loc = FindLastShaderConstsFBefore(buf,
                                                 capacity,
                                                 draw_offset,
                                                 AEROGPU_SHADER_STAGE_VERTEX,
                                                 kFixedfuncMatrixStartRegister,
                                                 kFixedfuncMatrixVec4Count);
  if (!Check(loc.hdr != nullptr, what)) {
    return false;
  }
  const auto* cmd = reinterpret_cast<const aerogpu_cmd_set_shader_constants_f*>(loc.hdr);
  if (!Check(cmd->hdr.size_bytes >= sizeof(*cmd) + (kFixedfuncMatrixVec4Count * 4u * sizeof(float)),
             "WVP constant payload present")) {
    return false;
  }

  float expected_cols[16] = {};
  for (uint32_t c = 0; c < 4; ++c) {
    expected_cols[c * 4 + 0] = wvp_row_major[0 * 4 + c];
    expected_cols[c * 4 + 1] = wvp_row_major[1 * 4 + c];
    expected_cols[c * 4 + 2] = wvp_row_major[2 * 4 + c];
    expected_cols[c * 4 + 3] = wvp_row_major[3 * 4 + c];
  }

  const auto* payload = reinterpret_cast<const float*>(reinterpret_cast<const uint8_t*>(cmd) + sizeof(*cmd));
  constexpr float kEps = 1e-6f;
  for (uint32_t i = 0; i < 16; ++i) {
    if (std::fabs(payload[i] - expected_cols[i]) > kEps) {
      std::fprintf(stderr,
                   "FAIL: %s (WVP constant[%u]=%.9g expected=%.9g)\n",
                   what ? what : "WVP constants",
                   static_cast<unsigned>(i),
                   payload[i],
                   expected_cols[i]);
      return false;
    }
  }
  return true;
}

void MulMat4RowMajor(const float a[16], const float b[16], float out[16]) {
  for (int r = 0; r < 4; ++r) {
    for (int c = 0; c < 4; ++c) {
      out[r * 4 + c] =
          a[r * 4 + 0] * b[0 * 4 + c] +
          a[r * 4 + 1] * b[1 * 4 + c] +
          a[r * 4 + 2] * b[2 * 4 + c] +
          a[r * 4 + 3] * b[3 * 4 + c];
    }
  }
}

void MulVec4Mat4RowMajor(const float v[4], const float m[16], float out[4]) {
  out[0] = v[0] * m[0] + v[1] * m[4] + v[2] * m[8] + v[3] * m[12];
  out[1] = v[0] * m[1] + v[1] * m[5] + v[2] * m[9] + v[3] * m[13];
  out[2] = v[0] * m[2] + v[1] * m[6] + v[2] * m[10] + v[3] * m[14];
  out[3] = v[0] * m[3] + v[1] * m[7] + v[2] * m[11] + v[3] * m[15];
}

const aerogpu_cmd_create_shader_dxbc* FindCreateShaderByHandle(
    const uint8_t* buf,
    size_t capacity,
    aerogpu_handle_t handle) {
  if (!buf || capacity < sizeof(aerogpu_cmd_stream_header) || handle == 0) {
    return nullptr;
  }
  const size_t stream_len = StreamBytesUsed(buf, capacity);
  if (stream_len == 0) {
    return nullptr;
  }

  size_t offset = sizeof(aerogpu_cmd_stream_header);
  while (offset + sizeof(aerogpu_cmd_hdr) <= stream_len) {
    const auto* hdr = reinterpret_cast<const aerogpu_cmd_hdr*>(buf + offset);
    if (hdr->opcode == AEROGPU_CMD_CREATE_SHADER_DXBC) {
      if (hdr->size_bytes >= sizeof(aerogpu_cmd_create_shader_dxbc) && hdr->size_bytes <= stream_len - offset) {
        const auto* cmd = reinterpret_cast<const aerogpu_cmd_create_shader_dxbc*>(hdr);
        if (cmd->shader_handle == handle) {
          return cmd;
        }
      }
    }
    if (hdr->size_bytes == 0 || hdr->size_bytes > stream_len - offset) {
      break;
    }
    offset += hdr->size_bytes;
  }
  return nullptr;
}

size_t CountCreateShaderDxbcWithHandle(const uint8_t* buf, size_t capacity, aerogpu_handle_t shader_handle, uint32_t stage) {
  const size_t stream_len = StreamBytesUsed(buf, capacity);
  if (stream_len == 0) {
    return 0;
  }

  size_t count = 0;
  size_t offset = sizeof(aerogpu_cmd_stream_header);
  while (offset + sizeof(aerogpu_cmd_hdr) <= stream_len) {
    const auto* hdr = reinterpret_cast<const aerogpu_cmd_hdr*>(buf + offset);
    if (hdr->opcode == AEROGPU_CMD_CREATE_SHADER_DXBC) {
      const auto* cmd = reinterpret_cast<const aerogpu_cmd_create_shader_dxbc*>(hdr);
      if (cmd->shader_handle == shader_handle && cmd->stage == stage) {
        count++;
      }
    }
    if (hdr->size_bytes == 0 || hdr->size_bytes > stream_len - offset) {
      break;
    }
    offset += hdr->size_bytes;
  }
  return count;
}

bool CheckLastBoundPixelShaderMatches(
    const uint8_t* buf,
    size_t capacity,
    const void* expected_bytes,
    size_t expected_size,
    const char* what) {
  if (!Check(buf != nullptr, "cmd buffer must be non-null")) {
    return false;
  }
  if (!Check(expected_bytes != nullptr && expected_size != 0, "expected shader bytes must be non-null")) {
    return false;
  }

  const CmdLoc bind = FindLastOpcode(buf, capacity, AEROGPU_CMD_BIND_SHADERS);
  if (!Check(bind.hdr != nullptr, what)) {
    return false;
  }
  const auto* bind_cmd = reinterpret_cast<const aerogpu_cmd_bind_shaders*>(bind.hdr);
  if (!Check(bind_cmd->ps != 0, "bind_shaders ps handle is non-zero")) {
    return false;
  }

  const auto* create = FindCreateShaderByHandle(buf, capacity, bind_cmd->ps);
  if (!Check(create != nullptr, "CREATE_SHADER_DXBC for bound ps is present")) {
    return false;
  }
  if (!Check(create->stage == AEROGPU_SHADER_STAGE_PIXEL, "bound shader stage is PIXEL")) {
    return false;
  }

  const uint8_t* payload = reinterpret_cast<const uint8_t*>(create) + sizeof(*create);
  const size_t payload_size = create->dxbc_size_bytes;
  if (!Check(payload_size != 0, "pixel shader bytecode non-empty")) {
    return false;
  }
  if (!Check((payload_size % sizeof(uint32_t)) == 0, "pixel shader bytecode 4-byte aligned")) {
    return false;
  }
  if (!Check(sizeof(*create) + payload_size <= create->hdr.size_bytes, "pixel shader payload fits command")) {
    return false;
  }

  uint32_t actual_version = 0;
  uint32_t expected_version = 0;
  if (!Check(BytecodeWordAt(payload, payload_size, 0, &actual_version), "pixel shader version token readable")) {
    return false;
  }
  if (!Check(BytecodeWordAt(reinterpret_cast<const uint8_t*>(expected_bytes), expected_size, 0, &expected_version),
             "expected shader version token readable")) {
    return false;
  }
  if (!Check(actual_version == expected_version, "pixel shader version token matches")) {
    return false;
  }

  // Fixed-function pixel shaders are runtime-generated now, so the exact token
  // stream size/bytes are not stable. Instead, compare core instruction usage
  // against a reference token stream.
  //
  // This intentionally only checks a small opcode set used by the fixed-function
  // stage0 emulation.
  const uint8_t* expected = reinterpret_cast<const uint8_t*>(expected_bytes);
  const bool exp_texld = BytecodeContainsToken(expected, expected_size, kPsOpTexld);
  const bool exp_add = BytecodeContainsToken(expected, expected_size, kPsOpAdd);
  const bool exp_mul = BytecodeContainsToken(expected, expected_size, kPsOpMul);

  const bool act_texld = BytecodeContainsToken(payload, payload_size, kPsOpTexld);
  const bool act_add = BytecodeContainsToken(payload, payload_size, kPsOpAdd);
  const bool act_mul = BytecodeContainsToken(payload, payload_size, kPsOpMul);

  if (!Check(act_texld == exp_texld, "pixel shader texld token expectation")) {
    return false;
  }
  if (!Check(act_add == exp_add, "pixel shader add token expectation")) {
    return false;
  }
  if (!Check(act_mul == exp_mul, "pixel shader mul token expectation")) {
    return false;
  }
  if (!Check(BytecodeContainsToken(payload, payload_size, kPsEnd), "pixel shader contains END token")) {
    return false;
  }

  return true;
}

bool CheckLastBoundPixelShaderOps(
    const uint8_t* buf,
    size_t capacity,
    bool expect_texld,
    bool expect_add,
    bool expect_mul,
    const char* what) {
  if (!Check(buf != nullptr, "cmd buffer must be non-null")) {
    return false;
  }

  const CmdLoc bind = FindLastOpcode(buf, capacity, AEROGPU_CMD_BIND_SHADERS);
  if (!Check(bind.hdr != nullptr, what)) {
    return false;
  }
  const auto* bind_cmd = reinterpret_cast<const aerogpu_cmd_bind_shaders*>(bind.hdr);
  if (!Check(bind_cmd->ps != 0, "bind_shaders ps handle is non-zero")) {
    return false;
  }

  const auto* create = FindCreateShaderByHandle(buf, capacity, bind_cmd->ps);
  if (!Check(create != nullptr, "CREATE_SHADER_DXBC for bound ps is present")) {
    return false;
  }
  if (!Check(create->stage == AEROGPU_SHADER_STAGE_PIXEL, "bound shader stage is PIXEL")) {
    return false;
  }

  const uint8_t* payload = reinterpret_cast<const uint8_t*>(create) + sizeof(*create);
  const size_t payload_size = create->dxbc_size_bytes;
  if (!Check(payload_size != 0, "pixel shader bytecode non-empty")) {
    return false;
  }
  if (!Check((payload_size % sizeof(uint32_t)) == 0, "pixel shader bytecode 4-byte aligned")) {
    return false;
  }
  if (!Check(sizeof(*create) + payload_size <= create->hdr.size_bytes, "pixel shader payload fits command")) {
    return false;
  }

  uint32_t version = 0;
  if (!Check(BytecodeWordAt(payload, payload_size, 0, &version), "pixel shader version token readable")) {
    return false;
  }
  if (!Check(version == kPs20Version, "pixel shader version token == ps_2_0")) {
    return false;
  }

  if (!Check(BytecodeContainsToken(payload, payload_size, kPsOpTexld) == expect_texld, "pixel shader texld token expectation")) {
    return false;
  }
  if (!Check(BytecodeContainsToken(payload, payload_size, kPsOpAdd) == expect_add, "pixel shader add token expectation")) {
    return false;
  }
  if (!Check(BytecodeContainsToken(payload, payload_size, kPsOpMul) == expect_mul, "pixel shader mul token expectation")) {
    return false;
  }
  if (!Check(BytecodeContainsToken(payload, payload_size, kPsEnd), "pixel shader contains END token")) {
    return false;
  }
  return true;
}

size_t CountCreateInputLayoutWithHandle(const uint8_t* buf, size_t capacity, aerogpu_handle_t layout_handle) {
  const size_t stream_len = StreamBytesUsed(buf, capacity);
  if (stream_len == 0) {
    return 0;
  }

  size_t count = 0;
  size_t offset = sizeof(aerogpu_cmd_stream_header);
  while (offset + sizeof(aerogpu_cmd_hdr) <= stream_len) {
    const auto* hdr = reinterpret_cast<const aerogpu_cmd_hdr*>(buf + offset);
    if (hdr->opcode == AEROGPU_CMD_CREATE_INPUT_LAYOUT) {
      const auto* cmd = reinterpret_cast<const aerogpu_cmd_create_input_layout*>(hdr);
      if (cmd->input_layout_handle == layout_handle) {
        count++;
      }
    }
    if (hdr->size_bytes == 0 || hdr->size_bytes > stream_len - offset) {
      break;
    }
    offset += hdr->size_bytes;
  }
  return count;
}

bool ValidateStream(const uint8_t* buf, size_t capacity) {
  if (!Check(buf != nullptr, "buffer must be non-null")) {
    return false;
  }
  if (!Check(capacity >= sizeof(aerogpu_cmd_stream_header), "buffer must contain stream header")) {
    return false;
  }

  const auto* stream = reinterpret_cast<const aerogpu_cmd_stream_header*>(buf);
  if (!Check(stream->magic == AEROGPU_CMD_STREAM_MAGIC, "stream magic")) {
    return false;
  }
  if (!Check(stream->abi_version == AEROGPU_ABI_VERSION_U32, "stream abi_version")) {
    return false;
  }
  if (!Check(stream->flags == AEROGPU_CMD_STREAM_FLAG_NONE, "stream flags")) {
    return false;
  }
  if (!Check(stream->size_bytes >= sizeof(aerogpu_cmd_stream_header), "stream size_bytes >= header")) {
    return false;
  }
  if (!Check(stream->size_bytes <= capacity, "stream size_bytes within capacity")) {
    return false;
  }

  size_t offset = sizeof(aerogpu_cmd_stream_header);
  while (offset < stream->size_bytes) {
    if (!Check((offset & 3u) == 0, "packet offset 4-byte aligned")) {
      return false;
    }
    if (!Check(offset + sizeof(aerogpu_cmd_hdr) <= stream->size_bytes, "packet header within stream")) {
      return false;
    }

    const auto* hdr = reinterpret_cast<const aerogpu_cmd_hdr*>(buf + offset);
    if (!Check(hdr->size_bytes >= sizeof(aerogpu_cmd_hdr), "packet size >= hdr")) {
      return false;
    }
    if (!Check((hdr->size_bytes & 3u) == 0, "packet size 4-byte aligned")) {
      return false;
    }
    if (!Check(offset + hdr->size_bytes <= stream->size_bytes, "packet fits within stream")) {
      return false;
    }

    offset += hdr->size_bytes;
  }
  return Check(offset == stream->size_bytes, "parser consumed entire stream");
}

bool TestHeaderFieldsAndFinalize() {
  uint8_t buf[256];
  std::memset(buf, 0xCD, sizeof(buf));

  SpanCmdStreamWriter w(buf, sizeof(buf));
  w.reset();

  if (!Check(w.error() == CmdStreamError::kOk, "reset error == kOk")) {
    return false;
  }

  if (!Check(w.bytes_used() == sizeof(aerogpu_cmd_stream_header), "bytes_used after reset")) {
    return false;
  }
  if (!Check(w.bytes_remaining() == sizeof(buf) - sizeof(aerogpu_cmd_stream_header), "bytes_remaining after reset")) {
    return false;
  }
  if (!Check(w.empty(), "empty after reset")) {
    return false;
  }

  const auto* stream = reinterpret_cast<const aerogpu_cmd_stream_header*>(buf);
  if (!Check(stream->magic == AEROGPU_CMD_STREAM_MAGIC, "header magic")) {
    return false;
  }
  if (!Check(stream->abi_version == AEROGPU_ABI_VERSION_U32, "header abi_version")) {
    return false;
  }
  if (!Check(stream->flags == AEROGPU_CMD_STREAM_FLAG_NONE, "header flags")) {
    return false;
  }
  if (!Check(stream->size_bytes == sizeof(aerogpu_cmd_stream_header), "header size_bytes after reset")) {
    return false;
  }

  auto* present = w.append_fixed<aerogpu_cmd_present>(AEROGPU_CMD_PRESENT);
  if (!Check(present != nullptr, "append_fixed(PRESENT)")) {
    return false;
  }
  present->scanout_id = 0;
  present->flags = AEROGPU_PRESENT_FLAG_NONE;

  const size_t expected = sizeof(aerogpu_cmd_stream_header) + AlignUp(sizeof(aerogpu_cmd_present), 4);
  if (!Check(w.bytes_used() == expected, "bytes_used after append")) {
    return false;
  }
  if (!Check(!w.empty(), "not empty after append")) {
    return false;
  }

  w.finalize();
  if (!Check(stream->size_bytes == expected, "header size_bytes after finalize")) {
    return false;
  }

  return ValidateStream(buf, sizeof(buf));
}

bool TestAlignmentAndPadding() {
  uint8_t buf[256];
  std::memset(buf, 0xAB, sizeof(buf));

  SpanCmdStreamWriter w(buf, sizeof(buf));
  w.reset();

  const uint8_t payload[3] = {0x01, 0x02, 0x03};
  auto* cmd = w.append_with_payload<aerogpu_cmd_create_shader_dxbc>(
      AEROGPU_CMD_CREATE_SHADER_DXBC, payload, sizeof(payload));
  if (!Check(cmd != nullptr, "append_with_payload(CREATE_SHADER_DXBC)")) {
    return false;
  }

  cmd->shader_handle = 42;
  cmd->stage = AEROGPU_SHADER_STAGE_PIXEL;
  cmd->dxbc_size_bytes = static_cast<uint32_t>(sizeof(payload));
  cmd->reserved0 = 0;

  const size_t cmd_size = sizeof(aerogpu_cmd_create_shader_dxbc) + sizeof(payload);
  const size_t aligned_size = AlignUp(cmd_size, 4);
  if (!Check(cmd->hdr.size_bytes == aligned_size, "cmd hdr.size_bytes aligned")) {
    return false;
  }

  const size_t payload_off = sizeof(aerogpu_cmd_stream_header) + sizeof(aerogpu_cmd_create_shader_dxbc);
  if (!Check(std::memcmp(buf + payload_off, payload, sizeof(payload)) == 0, "payload bytes match")) {
    return false;
  }

  // Validate padding bytes are zeroed.
  for (size_t i = cmd_size; i < aligned_size; i++) {
    if (!Check(buf[sizeof(aerogpu_cmd_stream_header) + i] == 0, "payload padding is zero")) {
      return false;
    }
  }

  w.finalize();
  return ValidateStream(buf, sizeof(buf));
}

bool TestUnknownOpcodeSkipBySize() {
  uint8_t buf[256] = {};

  SpanCmdStreamWriter w(buf, sizeof(buf));
  w.reset();

  auto* u = w.append_fixed<unknown_cmd_fixed>(0xDEADBEEFu);
  if (!Check(u != nullptr, "append_fixed(unknown opcode)")) {
    return false;
  }
  u->value = 0x12345678u;

  auto* present = w.append_fixed<aerogpu_cmd_present>(AEROGPU_CMD_PRESENT);
  if (!Check(present != nullptr, "append_fixed(PRESENT)")) {
    return false;
  }
  present->scanout_id = 0;
  present->flags = AEROGPU_PRESENT_FLAG_NONE;

  w.finalize();
  return ValidateStream(buf, sizeof(buf));
}

bool TestOutOfSpaceReturnsNullptrAndSetsError() {
  uint8_t buf[sizeof(aerogpu_cmd_stream_header) + 4] = {};

  SpanCmdStreamWriter w(buf, sizeof(buf));
  w.reset();
  if (!Check(w.empty(), "empty after reset")) {
    return false;
  }

  auto* present = w.append_fixed<aerogpu_cmd_present>(AEROGPU_CMD_PRESENT);
  if (!Check(present == nullptr, "append_fixed returns nullptr on overflow")) {
    return false;
  }
  if (!Check(w.error() == CmdStreamError::kInsufficientSpace, "overflow sets kInsufficientSpace")) {
    return false;
  }
  if (!Check(w.bytes_used() == sizeof(aerogpu_cmd_stream_header), "bytes_used unchanged after overflow")) {
    return false;
  }

  w.finalize();
  const auto* stream = reinterpret_cast<const aerogpu_cmd_stream_header*>(buf);
  return Check(stream->size_bytes == sizeof(aerogpu_cmd_stream_header), "finalize keeps size_bytes at header");
}

bool TestCmdStreamWriterOverflowReturnsNullAndSetsError() {
  std::vector<uint8_t> buf(sizeof(aerogpu_cmd_stream_header) + 4, 0);

  CmdStreamWriter w;
  w.set_span(buf.data(), buf.size());

  if (!Check(w.empty(), "CmdStreamWriter empty after set_span")) {
    return false;
  }

  auto* present = w.append_fixed<aerogpu_cmd_present>(AEROGPU_CMD_PRESENT);
  if (!Check(present == nullptr, "CmdStreamWriter append_fixed returns nullptr on overflow")) {
    return false;
  }
  if (!Check(w.error() == CmdStreamError::kInsufficientSpace, "CmdStreamWriter overflow sets kInsufficientSpace")) {
    return false;
  }
  if (!Check(w.bytes_used() == sizeof(aerogpu_cmd_stream_header), "CmdStreamWriter bytes_used unchanged after overflow")) {
    return false;
  }

  w.finalize();
  const auto* stream = reinterpret_cast<const aerogpu_cmd_stream_header*>(buf.data());
  return Check(stream->size_bytes == sizeof(aerogpu_cmd_stream_header), "CmdStreamWriter finalize keeps size_bytes at header");
}

bool TestFixedPacketPadding() {
  uint8_t buf[256];
  std::memset(buf, 0xEF, sizeof(buf));

#pragma pack(push, 1)
  struct odd_fixed {
    aerogpu_cmd_hdr hdr;
    uint16_t v;
  };
#pragma pack(pop)

  if (!Check(sizeof(odd_fixed) == 10, "odd_fixed packed size")) {
    return false;
  }

  SpanCmdStreamWriter w(buf, sizeof(buf));
  w.reset();

  auto* cmd = w.append_fixed<odd_fixed>(0x9000u);
  if (!Check(cmd != nullptr, "append_fixed(odd_fixed)")) {
    return false;
  }
  cmd->v = 0xBEEFu;

  if (!Check(cmd->hdr.size_bytes == 12, "odd_fixed size_bytes padded to 12")) {
    return false;
  }

  const size_t cmd_off = sizeof(aerogpu_cmd_stream_header);
  if (!Check(buf[cmd_off + sizeof(odd_fixed) + 0] == 0, "padding byte 0 zero")) {
    return false;
  }
  if (!Check(buf[cmd_off + sizeof(odd_fixed) + 1] == 0, "padding byte 1 zero")) {
    return false;
  }

  w.finalize();
  return ValidateStream(buf, sizeof(buf));
}

struct ExpectedBindShadersPacket {
  aerogpu_handle_t vs = 0;
  aerogpu_handle_t ps = 0;
  aerogpu_handle_t cs = 0;
  aerogpu_handle_t reserved0 = 0;

  bool has_tail = false;
  aerogpu_handle_t gs = 0;
  aerogpu_handle_t hs = 0;
  aerogpu_handle_t ds = 0;
};

bool CheckBindShadersPacket(const uint8_t* buf, size_t len, const ExpectedBindShadersPacket& expected) {
  if (!Check(buf != nullptr, "bind_shaders buffer non-null")) {
    return false;
  }
  if (!Check(len >= sizeof(aerogpu_cmd_stream_header) + sizeof(aerogpu_cmd_hdr),
             "bind_shaders stream has header + cmd")) {
    return false;
  }
  if (!Check(ValidateStream(buf, len), "bind_shaders stream validates")) {
    return false;
  }

  const auto* stream = reinterpret_cast<const aerogpu_cmd_stream_header*>(buf);
  const size_t off = sizeof(aerogpu_cmd_stream_header);
  const auto* hdr = reinterpret_cast<const aerogpu_cmd_hdr*>(buf + off);
  if (!Check(hdr->opcode == AEROGPU_CMD_BIND_SHADERS, "bind_shaders opcode")) {
    return false;
  }

  const size_t expected_size =
      expected.has_tail ? sizeof(aerogpu_cmd_bind_shaders) + 3 * sizeof(aerogpu_handle_t)
                        : sizeof(aerogpu_cmd_bind_shaders);
  if (!Check(hdr->size_bytes == AlignUp(expected_size, 4), "bind_shaders size_bytes")) {
    return false;
  }
  if (!Check(stream->size_bytes == off + hdr->size_bytes, "bind_shaders stream size_bytes")) {
    return false;
  }

  const auto* cmd = reinterpret_cast<const aerogpu_cmd_bind_shaders*>(hdr);
  if (!Check(cmd->vs == expected.vs, "bind_shaders vs")) {
    return false;
  }
  if (!Check(cmd->ps == expected.ps, "bind_shaders ps")) {
    return false;
  }
  if (!Check(cmd->cs == expected.cs, "bind_shaders cs")) {
    return false;
  }
  if (!Check(cmd->reserved0 == expected.reserved0, "bind_shaders reserved0")) {
    return false;
  }

  if (expected.has_tail) {
    aerogpu_handle_t tail[3] = {};
    std::memcpy(tail, buf + off + sizeof(aerogpu_cmd_bind_shaders), sizeof(tail));
    if (!Check(tail[0] == expected.gs, "bind_shaders tail gs")) {
      return false;
    }
    if (!Check(tail[1] == expected.hs, "bind_shaders tail hs")) {
      return false;
    }
    if (!Check(tail[2] == expected.ds, "bind_shaders tail ds")) {
      return false;
    }
  }
  return true;
}

bool TestBindShadersHelpers() {
  // Validate the convenience helpers on the concrete writers (`SpanCmdStreamWriter` and
  // `VectorCmdStreamWriter`) match the protocol's append-only BIND_SHADERS extension:
  // - base 24-byte packet: {vs,ps,cs,reserved0}
  // - extended packet: appends {gs,hs,ds} and (by default) keeps reserved0=0.

  ExpectedBindShadersPacket expected{};

  // SpanCmdStreamWriter: base packet (reserved0=0).
  {
    uint8_t buf[256] = {};
    SpanCmdStreamWriter w(buf, sizeof(buf));
    w.reset();
    auto* cmd = w.bind_shaders(1, 2, 3);
    if (!Check(cmd != nullptr, "SpanCmdStreamWriter.bind_shaders")) {
      return false;
    }
    w.finalize();
    expected = ExpectedBindShadersPacket{};
    expected.vs = 1;
    expected.ps = 2;
    expected.cs = 3;
    expected.reserved0 = 0;
    expected.has_tail = false;
    if (!CheckBindShadersPacket(buf, sizeof(buf), expected)) {
      return false;
    }
  }

  // SpanCmdStreamWriter: legacy GS encoding in reserved0.
  {
    uint8_t buf[256] = {};
    SpanCmdStreamWriter w(buf, sizeof(buf));
    w.reset();
    auto* cmd = w.bind_shaders_with_gs(1, 2, 3, 4);
    if (!Check(cmd != nullptr, "SpanCmdStreamWriter.bind_shaders_with_gs")) {
      return false;
    }
    w.finalize();
    expected = ExpectedBindShadersPacket{};
    expected.vs = 1;
    expected.ps = 2;
    expected.cs = 3;
    expected.reserved0 = 4;
    expected.has_tail = false;
    if (!CheckBindShadersPacket(buf, sizeof(buf), expected)) {
      return false;
    }
  }

  // SpanCmdStreamWriter: extended packet, default reserved0=0.
  {
    uint8_t buf[256] = {};
    SpanCmdStreamWriter w(buf, sizeof(buf));
    w.reset();
    auto* cmd = w.bind_shaders_ex(1, 2, 3, 4, 5, 6);
    if (!Check(cmd != nullptr, "SpanCmdStreamWriter.bind_shaders_ex")) {
      return false;
    }
    w.finalize();
    expected = ExpectedBindShadersPacket{};
    expected.vs = 1;
    expected.ps = 2;
    expected.cs = 3;
    expected.reserved0 = 0;
    expected.has_tail = true;
    expected.gs = 4;
    expected.hs = 5;
    expected.ds = 6;
    if (!CheckBindShadersPacket(buf, sizeof(buf), expected)) {
      return false;
    }
  }

  // SpanCmdStreamWriter: extended packet, mirroring gs into reserved0.
  {
    uint8_t buf[256] = {};
    SpanCmdStreamWriter w(buf, sizeof(buf));
    w.reset();
    auto* cmd = w.bind_shaders_ex(1, 2, 3, 4, 5, 6, /*mirror_gs_to_reserved0=*/true);
    if (!Check(cmd != nullptr, "SpanCmdStreamWriter.bind_shaders_ex(mirror)")) {
      return false;
    }
    w.finalize();
    expected = ExpectedBindShadersPacket{};
    expected.vs = 1;
    expected.ps = 2;
    expected.cs = 3;
    expected.reserved0 = 4;
    expected.has_tail = true;
    expected.gs = 4;
    expected.hs = 5;
    expected.ds = 6;
    if (!CheckBindShadersPacket(buf, sizeof(buf), expected)) {
      return false;
    }
  }

  // SpanCmdStreamWriter: HS/DS-only sugar (extended packet with vs/ps/cs/gs unbound).
  {
    uint8_t buf[256] = {};
    SpanCmdStreamWriter w(buf, sizeof(buf));
    w.reset();
    auto* cmd = w.bind_shaders_hs_ds(5, 6);
    if (!Check(cmd != nullptr, "SpanCmdStreamWriter.bind_shaders_hs_ds")) {
      return false;
    }
    w.finalize();
    expected = ExpectedBindShadersPacket{};
    expected.vs = 0;
    expected.ps = 0;
    expected.cs = 0;
    expected.reserved0 = 0;
    expected.has_tail = true;
    expected.gs = 0;
    expected.hs = 5;
    expected.ds = 6;
    if (!CheckBindShadersPacket(buf, sizeof(buf), expected)) {
      return false;
    }
  }

  // VectorCmdStreamWriter: ensure it produces the same bytes as the span-backed writer for a
  // representative extended packet.
  {
    VectorCmdStreamWriter vec;
    vec.reset();
    auto* vec_cmd = vec.bind_shaders_ex(1, 2, 3, 4, 5, 6, /*mirror_gs_to_reserved0=*/true);
    if (!Check(vec_cmd != nullptr, "VectorCmdStreamWriter.bind_shaders_ex(mirror)")) {
      return false;
    }
    vec.finalize();
    expected = ExpectedBindShadersPacket{};
    expected.vs = 1;
    expected.ps = 2;
    expected.cs = 3;
    expected.reserved0 = 4;
    expected.has_tail = true;
    expected.gs = 4;
    expected.hs = 5;
    expected.ds = 6;
    if (!CheckBindShadersPacket(vec.data(), vec.bytes_used(), expected)) {
      return false;
    }

    uint8_t span_buf[256] = {};
    SpanCmdStreamWriter span(span_buf, sizeof(span_buf));
    span.reset();
    auto* span_cmd = span.bind_shaders_ex(1, 2, 3, 4, 5, 6, /*mirror_gs_to_reserved0=*/true);
    if (!Check(span_cmd != nullptr, "SpanCmdStreamWriter.bind_shaders_ex(mirror) parity")) {
      return false;
    }
    span.finalize();
    if (!Check(vec.bytes_used() == span.bytes_used(), "bind_shaders_ex span/vector size match")) {
      return false;
    }
    if (!Check(std::memcmp(vec.data(), span.data(), vec.bytes_used()) == 0, "bind_shaders_ex span/vector bytes match")) {
      return false;
    }
  }

  // CmdStreamWriter: cover the type-erased wrapper helpers (both vector-backed and span-backed).
  //
  // This is the API surface most UMD code uses (e.g. `aerogpu::CmdWriter` in the D3D9/D3D10/11
  // bring-up paths), so keep a small direct test here even though the underlying concrete writers
  // are tested above.

  // CmdStreamWriter (vector): base packet (reserved0=0).
  {
    CmdStreamWriter w;
    w.set_vector();
    auto* cmd = w.bind_shaders(1, 2, 3);
    if (!Check(cmd != nullptr, "CmdStreamWriter.bind_shaders (vector)")) {
      return false;
    }
    w.finalize();
    expected = ExpectedBindShadersPacket{};
    expected.vs = 1;
    expected.ps = 2;
    expected.cs = 3;
    expected.reserved0 = 0;
    expected.has_tail = false;
    if (!CheckBindShadersPacket(w.data(), w.bytes_used(), expected)) {
      return false;
    }
  }

  // CmdStreamWriter (span): legacy GS encoding in reserved0.
  {
    uint8_t buf[256] = {};
    CmdStreamWriter w;
    w.set_span(buf, sizeof(buf));
    auto* cmd = w.bind_shaders_with_gs(1, 2, 3, 4);
    if (!Check(cmd != nullptr, "CmdStreamWriter.bind_shaders_with_gs (span)")) {
      return false;
    }
    w.finalize();
    expected = ExpectedBindShadersPacket{};
    expected.vs = 1;
    expected.ps = 2;
    expected.cs = 3;
    expected.reserved0 = 4;
    expected.has_tail = false;
    if (!CheckBindShadersPacket(buf, sizeof(buf), expected)) {
      return false;
    }
  }

  // CmdStreamWriter (vector): extended packet default reserved0=0 + appended {gs,hs,ds}.
  {
    CmdStreamWriter w;
    w.set_vector();
    auto* cmd = w.bind_shaders_ex(1, 2, 3, 4, 5, 6);
    if (!Check(cmd != nullptr, "CmdStreamWriter.bind_shaders_ex (vector)")) {
      return false;
    }
    w.finalize();
    expected = ExpectedBindShadersPacket{};
    expected.vs = 1;
    expected.ps = 2;
    expected.cs = 3;
    expected.reserved0 = 0;
    expected.has_tail = true;
    expected.gs = 4;
    expected.hs = 5;
    expected.ds = 6;
    if (!CheckBindShadersPacket(w.data(), w.bytes_used(), expected)) {
      return false;
    }
  }

  return true;
}

bool EmitRepresentativeCommands(CmdStreamWriter& w, const uint8_t* dxbc, size_t dxbc_len) {
  w.reset();

  auto* create_buf = w.append_fixed<aerogpu_cmd_create_buffer>(AEROGPU_CMD_CREATE_BUFFER);
  if (!Check(create_buf != nullptr, "CREATE_BUFFER")) {
    return false;
  }
  create_buf->buffer_handle = 0x100;
  create_buf->usage_flags = AEROGPU_RESOURCE_USAGE_VERTEX_BUFFER;
  create_buf->size_bytes = 4096;
  create_buf->backing_alloc_id = 0;
  create_buf->backing_offset_bytes = 0;
  create_buf->reserved0 = 0;

  auto* create_tex = w.append_fixed<aerogpu_cmd_create_texture2d>(AEROGPU_CMD_CREATE_TEXTURE2D);
  if (!Check(create_tex != nullptr, "CREATE_TEXTURE2D")) {
    return false;
  }
  create_tex->texture_handle = 0x200;
  create_tex->usage_flags = AEROGPU_RESOURCE_USAGE_TEXTURE;
  create_tex->format = AEROGPU_FORMAT_B8G8R8A8_UNORM;
  create_tex->width = 128;
  create_tex->height = 64;
  create_tex->mip_levels = 1;
  create_tex->array_layers = 1;
  create_tex->row_pitch_bytes = 128 * 4;
  create_tex->backing_alloc_id = 0;
  create_tex->backing_offset_bytes = 0;
  create_tex->reserved0 = 0;

  auto* create_shader = w.append_with_payload<aerogpu_cmd_create_shader_dxbc>(
      AEROGPU_CMD_CREATE_SHADER_DXBC, dxbc, dxbc_len);
  if (!Check(create_shader != nullptr, "CREATE_SHADER_DXBC")) {
    return false;
  }
  create_shader->shader_handle = 0x300;
  create_shader->stage = AEROGPU_SHADER_STAGE_VERTEX;
  create_shader->dxbc_size_bytes = static_cast<uint32_t>(dxbc_len);
  create_shader->reserved0 = 0;

  auto* present = w.append_fixed<aerogpu_cmd_present_ex>(AEROGPU_CMD_PRESENT_EX);
  if (!Check(present != nullptr, "PRESENT_EX")) {
    return false;
  }
  present->scanout_id = 0;
  present->flags = AEROGPU_PRESENT_FLAG_VSYNC;
  present->d3d9_present_flags = 0x1234u;
  present->reserved0 = 0;

  auto* export_shared = w.append_fixed<aerogpu_cmd_export_shared_surface>(AEROGPU_CMD_EXPORT_SHARED_SURFACE);
  if (!Check(export_shared != nullptr, "EXPORT_SHARED_SURFACE")) {
    return false;
  }
  export_shared->resource_handle = 0x200;
  export_shared->reserved0 = 0;
  export_shared->share_token = 0x1122334455667788ull;

  w.finalize();
  return Check(w.error() == CmdStreamError::kOk, "writer error == kOk");
}

bool TestOwnedAndBorrowedStreamsMatch() {
  const uint8_t dxbc[] = {0x44, 0x58, 0x42, 0x43, 0x01, 0x02, 0x03};

  CmdStreamWriter owned;
  owned.set_vector();
  if (!EmitRepresentativeCommands(owned, dxbc, sizeof(dxbc))) {
    return false;
  }

  std::vector<uint8_t> span_buf(4096, 0xCD);
  CmdStreamWriter borrowed;
  borrowed.set_span(span_buf.data(), span_buf.size());
  if (!EmitRepresentativeCommands(borrowed, dxbc, sizeof(dxbc))) {
    return false;
  }

  if (!Check(owned.bytes_used() == borrowed.bytes_used(), "owned and borrowed sizes match")) {
    return false;
  }
  if (!Check(std::memcmp(owned.data(), borrowed.data(), owned.bytes_used()) == 0, "owned and borrowed bytes match")) {
    return false;
  }

  return ValidateStream(borrowed.data(), span_buf.size()) && ValidateStream(owned.data(), owned.bytes_used());
}

bool TestEventQueryGetDataSemantics() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3D9DDI_HQUERY hQuery{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_query = false;

    ~Cleanup() {
      if (has_query && device_funcs.pfnDestroyQuery) {
        device_funcs.pfnDestroyQuery(hDevice, hQuery);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  if (!Check(create_dev.hDevice.pDrvPrivate != nullptr, "CreateDevice returned device handle")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  hr = cleanup.device_funcs.pfnClear(create_dev.hDevice,
                                     /*flags=*/0x1u,
                                     /*color_rgba8=*/0xFFFFFFFFu,
                                     /*depth=*/1.0f,
                                     /*stencil=*/0);
  if (!Check(hr == S_OK, "Clear")) {
    return false;
  }

  // D3DQUERYTYPE_EVENT = 8 (public D3D9 encoding). The UMD also accepts 0.
  D3D9DDIARG_CREATEQUERY create_query{};
  create_query.type = 8u;
  hr = cleanup.device_funcs.pfnCreateQuery(create_dev.hDevice, &create_query);
  if (!Check(hr == S_OK, "CreateQuery(EVENT)")) {
    return false;
  }
  if (!Check(create_query.hQuery.pDrvPrivate != nullptr, "CreateQuery returned query handle")) {
    return false;
  }
  cleanup.hQuery = create_query.hQuery;
  cleanup.has_query = true;
 
  auto* adapter = reinterpret_cast<Adapter*>(open.hAdapter.pDrvPrivate);
  auto* query = reinterpret_cast<Query*>(create_query.hQuery.pDrvPrivate);
  uint64_t base_render_submits = 0;
  uint64_t base_present_submits = 0;
  {
    std::lock_guard<std::mutex> lock(adapter->fence_mutex);
    base_render_submits = adapter->render_submit_count;
    base_present_submits = adapter->present_submit_count;
  }
 
  // Some D3D9Ex callers have been observed to pass 0 for END, so cover both the
  // explicit D3DISSUE_END bit and the 0-valued encoding.
  D3D9DDIARG_ISSUEQUERY issue{};
  issue.hQuery = create_query.hQuery;
  issue.flags = 0; // END (0 encoding)
  hr = cleanup.device_funcs.pfnIssueQuery(create_dev.hDevice, &issue);
  if (!Check(hr == S_OK, "IssueQuery(END=0)")) {
    return false;
  }
  // IssueQuery(END) should submit recorded work so fence-based tests can observe
  // a real submission (Win7: d3d9ex_submit_fence_stress). It must be classified
  // as a render submission (not present).
  {
    std::lock_guard<std::mutex> lock(adapter->fence_mutex);
    if (!Check(adapter->render_submit_count >= base_render_submits + 1,
               "IssueQuery(END) triggers at least one render submission")) {
      return false;
    }
    if (!Check(adapter->present_submit_count == base_present_submits,
               "IssueQuery(END) does not increment present submission count")) {
      return false;
    }
  }
 
  const uint64_t fence_value0 = query->fence_value.load(std::memory_order_acquire);
  if (!Check(fence_value0 != 0, "event query fence_value (END=0)")) {
    return false;
  }

  // Issue again with the explicit END bit so we lock in both paths.
  hr = cleanup.device_funcs.pfnClear(create_dev.hDevice,
                                     /*flags=*/0x1u,
                                     /*color_rgba8=*/0xFFFFFFFFu,
                                     /*depth=*/1.0f,
                                     /*stencil=*/0);
  if (!Check(hr == S_OK, "Clear (before IssueQuery(D3DISSUE_END))")) {
    return false;
  }

  issue.flags = 0x1u; // D3DISSUE_END
  hr = cleanup.device_funcs.pfnIssueQuery(create_dev.hDevice, &issue);
  if (!Check(hr == S_OK, "IssueQuery(D3DISSUE_END)")) {
    return false;
  }

  const uint64_t fence_value1 = query->fence_value.load(std::memory_order_acquire);
  if (!Check(fence_value1 >= fence_value0, "event query fence_value monotonic (END=1)")) {
    return false;
  }

  // Some DDI paths use 0x2 to mean END. Cover that encoding as well.
  hr = cleanup.device_funcs.pfnClear(create_dev.hDevice,
                                     /*flags=*/0x1u,
                                     /*color_rgba8=*/0xFFFFFFFFu,
                                     /*depth=*/1.0f,
                                     /*stencil=*/0);
  if (!Check(hr == S_OK, "Clear (before IssueQuery(END=2))")) {
    return false;
  }

  issue.flags = 0x2u;
  hr = cleanup.device_funcs.pfnIssueQuery(create_dev.hDevice, &issue);
  if (!Check(hr == S_OK, "IssueQuery(END=2)")) {
    return false;
  }

  const uint64_t fence_value = query->fence_value.load(std::memory_order_acquire);
  if (!Check(fence_value >= fence_value1, "event query fence_value monotonic (END=2)")) {
    return false;
  }

  // Force the query into the "not ready" state.
  hr = adapter_test_set_completed_fence(open.hAdapter, 0);
  if (!Check(hr == S_OK, "adapter_test_set_completed_fence (not ready)")) {
    return false;
  }

  uint32_t done = 0;
  D3D9DDIARG_GETQUERYDATA get_data{};
  get_data.hQuery = create_query.hQuery;
  get_data.pData = &done;
  get_data.data_size = sizeof(done);
  get_data.flags = 0;

  hr = cleanup.device_funcs.pfnGetQueryData(create_dev.hDevice, &get_data);
  if (!Check(hr == S_FALSE, "GetQueryData not-ready returns S_FALSE")) {
    return false;
  }

  // D3D9Ex clients (including DWM) often poll EVENT queries with D3DGETDATA_FLUSH
  // while other threads are concurrently submitting work. Ensure our GetQueryData
  // implementation does not block on the device mutex in that scenario.
  {
    auto* device = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
    if (!Check(device != nullptr, "device pointer")) {
      return false;
    }

    std::mutex state_mutex;
    std::condition_variable state_cv;
    bool started = false;
    bool finished = false;
    HRESULT thread_hr = E_FAIL;

    std::unique_lock<std::mutex> dev_lock(device->mutex);
    std::thread t([&] {
      {
        std::lock_guard<std::mutex> lk(state_mutex);
        started = true;
      }
      state_cv.notify_one();

      uint32_t thread_done = 0;
      D3D9DDIARG_GETQUERYDATA gd = get_data;
      gd.pData = &thread_done;
      gd.flags = 0x1u; // D3DGETDATA_FLUSH
      thread_hr = cleanup.device_funcs.pfnGetQueryData(create_dev.hDevice, &gd);

      {
        std::lock_guard<std::mutex> lk(state_mutex);
        finished = true;
      }
      state_cv.notify_one();
    });

    // Wait until the thread is actually running while still holding device->mutex.
    {
      std::unique_lock<std::mutex> lk(state_mutex);
       if (!state_cv.wait_for(lk, std::chrono::milliseconds(500), [&] { return started; })) {
         dev_lock.unlock();
         t.join();
         return Check(false, "GetQueryData(FLUSH) thread failed to start");
       }
       // Now ensure it finishes even though device->mutex is held.
       if (!state_cv.wait_for(lk, std::chrono::milliseconds(200), [&] { return finished; })) {
         // Avoid a deadlock: release the mutex so the thread can complete, then fail.
         dev_lock.unlock();
         t.join();
         return Check(false, "GetQueryData(FLUSH) blocked on device mutex");
       }
    }
    dev_lock.unlock();
    t.join();

    if (!Check(thread_hr == S_FALSE, "GetQueryData(FLUSH) under device mutex returns S_FALSE")) {
      return false;
    }
  }

  // D3D9 allows polling readiness without providing an output buffer.
  D3D9DDIARG_GETQUERYDATA get_no_data = get_data;
  get_no_data.pData = nullptr;
  get_no_data.data_size = 0;
  hr = cleanup.device_funcs.pfnGetQueryData(create_dev.hDevice, &get_no_data);
  if (!Check(hr == S_FALSE, "GetQueryData (no buffer) not-ready returns S_FALSE")) {
    return false;
  }

  // Invalid pointer/size combinations should fail even if the query is not ready.
  D3D9DDIARG_GETQUERYDATA get_bad = get_data;
  get_bad.pData = nullptr;
  get_bad.data_size = sizeof(done);
  hr = cleanup.device_funcs.pfnGetQueryData(create_dev.hDevice, &get_bad);
  if (!Check(hr == D3DERR_INVALIDCALL, "GetQueryData rejects null pData with non-zero size")) {
    return false;
  }

  get_bad.pData = &done;
  get_bad.data_size = 0;
  hr = cleanup.device_funcs.pfnGetQueryData(create_dev.hDevice, &get_bad);
  if (!Check(hr == D3DERR_INVALIDCALL, "GetQueryData rejects non-null pData with zero size")) {
    return false;
  }

  uint16_t small = 0;
  get_bad.pData = &small;
  get_bad.data_size = sizeof(small);
  hr = cleanup.device_funcs.pfnGetQueryData(create_dev.hDevice, &get_bad);
  if (!Check(hr == D3DERR_INVALIDCALL, "GetQueryData rejects undersized buffer")) {
    return false;
  }

  // Mark the fence complete and re-poll.
  hr = adapter_test_set_completed_fence(open.hAdapter, fence_value);
  if (!Check(hr == S_OK, "adapter_test_set_completed_fence (fence complete)")) {
    return false;
  }

  // The UMD may defer making an EVENT query "visible" to GetData(DONOTFLUSH)
  // until an explicit flush boundary is observed. Even if the fence is already
  // complete, the query should remain not-ready until a flush/submission
  // boundary arms it.
  hr = cleanup.device_funcs.pfnGetQueryData(create_dev.hDevice, &get_no_data);
  if (!Check(hr == S_FALSE, "GetQueryData (no buffer) fence complete but unsubmitted returns S_FALSE")) {
    return false;
  }

  // GetData(FLUSH) should arm the query without blocking and then report
  // readiness based on the fence.
  get_no_data.flags = 0x1u; // D3DGETDATA_FLUSH
  hr = cleanup.device_funcs.pfnGetQueryData(create_dev.hDevice, &get_no_data);
  if (!Check(hr == S_OK, "GetQueryData(FLUSH) (no buffer) ready returns S_OK")) {
    return false;
  }
  if (!Check(query->submitted.load(std::memory_order_acquire), "event query marked submitted after FLUSH")) {
    return false;
  }

  get_no_data.flags = 0;
  hr = cleanup.device_funcs.pfnGetQueryData(create_dev.hDevice, &get_no_data);
  if (!Check(hr == S_OK, "GetQueryData (no buffer) ready returns S_OK after submit")) {
    return false;
  }

  done = 0;
  hr = cleanup.device_funcs.pfnGetQueryData(create_dev.hDevice, &get_data);
  if (!Check(hr == S_OK, "GetQueryData ready returns S_OK")) {
    return false;
  }
  if (!Check(done != 0, "GetQueryData ready writes TRUE")) {
    return false;
  }

  // Validate argument checking for the D3D9 GetData contract: pData must be NULL
  // iff data_size is 0.
  D3D9DDIARG_GETQUERYDATA invalid_args = get_data;
  invalid_args.pData = &done;
  invalid_args.data_size = 0;
  hr = cleanup.device_funcs.pfnGetQueryData(create_dev.hDevice, &invalid_args);
  if (!Check(hr == D3DERR_INVALIDCALL, "GetQueryData pData!=NULL but size==0 returns INVALIDCALL")) {
    return false;
  }

  invalid_args.pData = nullptr;
  invalid_args.data_size = sizeof(done);
  hr = cleanup.device_funcs.pfnGetQueryData(create_dev.hDevice, &invalid_args);
  if (!Check(hr == D3DERR_INVALIDCALL, "GetQueryData pData==NULL but size!=0 returns INVALIDCALL")) {
    return false;
  }

  invalid_args.pData = nullptr;
  invalid_args.data_size = 0;
  hr = cleanup.device_funcs.pfnGetQueryData(create_dev.hDevice, &invalid_args);
  if (!Check(hr == S_OK, "GetQueryData pData==NULL and size==0 returns S_OK when ready")) {
    return false;
  }

  return true;
}

bool TestDeviceFuncsIncludePatchAndProcessVertices() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  if (!Check(cleanup.adapter_funcs.pfnCreateDevice != nullptr, "CreateDevice entrypoint must be available")) {
    return false;
  }

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  if (!Check(create_dev.hDevice.pDrvPrivate != nullptr, "CreateDevice returned device handle")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnDrawRectPatch != nullptr,
             "D3D9DDI_DEVICEFUNCS.pfnDrawRectPatch must be non-null")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawTriPatch != nullptr,
             "D3D9DDI_DEVICEFUNCS.pfnDrawTriPatch must be non-null")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDeletePatch != nullptr,
             "D3D9DDI_DEVICEFUNCS.pfnDeletePatch must be non-null")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnProcessVertices != nullptr,
             "D3D9DDI_DEVICEFUNCS.pfnProcessVertices must be non-null")) {
    return false;
  }

  return true;
}

bool TestAdapterCapsAndQueryAdapterInfo() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    bool has_adapter = false;
    ~Cleanup() {
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  if (!Check(cleanup.adapter_funcs.pfnGetCaps != nullptr, "pfnGetCaps is non-null")) {
    return false;
  }
  if (!Check(cleanup.adapter_funcs.pfnQueryAdapterInfo != nullptr, "pfnQueryAdapterInfo is non-null")) {
    return false;
  }

  D3DCAPS9 caps{};
  D3D9DDIARG_GETCAPS get_caps{};
  get_caps.Type = D3DDDICAPS_GETD3D9CAPS;
  get_caps.pData = &caps;
  get_caps.DataSize = sizeof(caps);
  hr = cleanup.adapter_funcs.pfnGetCaps(open.hAdapter, &get_caps);
  if (!Check(hr == S_OK, "GetCaps(GETD3D9CAPS)")) {
    return false;
  }
  if (!Check((caps.Caps2 & D3DCAPS2_CANRENDERWINDOWED) != 0, "Caps2 includes CANRENDERWINDOWED")) {
    return false;
  }
  if (!Check((caps.Caps2 & D3DCAPS2_CANSHARERESOURCE) != 0, "Caps2 includes CANSHARERESOURCE")) {
    return false;
  }
  if (!Check((caps.Caps & D3DCAPS_READ_SCANLINE) != 0, "Caps includes READ_SCANLINE")) {
    return false;
  }
  if (!Check(caps.VertexShaderVersion >= D3DVS_VERSION(2, 0), "VertexShaderVersion >= 2.0")) {
    return false;
  }
  if (!Check(caps.PixelShaderVersion >= D3DPS_VERSION(2, 0), "PixelShaderVersion >= 2.0")) {
    return false;
  }
  if (!Check((caps.DevCaps & D3DDEVCAPS_HWTRANSFORMANDLIGHT) != 0, "DevCaps includes HWTRANSFORMANDLIGHT")) {
    return false;
  }
  if (!Check((caps.PrimitiveMiscCaps & D3DPMISCCAPS_BLENDOP) != 0, "PrimitiveMiscCaps includes BLENDOP")) {
    return false;
  }
  if (!Check((caps.PrimitiveMiscCaps & D3DPMISCCAPS_SEPARATEALPHABLEND) != 0,
             "PrimitiveMiscCaps includes SEPARATEALPHABLEND")) {
    return false;
  }
  if (!Check((caps.TextureCaps & D3DPTEXTURECAPS_POW2) == 0, "TextureCaps does not include POW2")) {
    return false;
  }
  if (!Check((caps.TextureCaps & D3DPTEXTURECAPS_CUBEMAP) != 0, "TextureCaps includes CUBEMAP")) {
    return false;
  }
  const uint32_t raster_required =
      D3DPRASTERCAPS_SCISSORTEST |
      D3DPRASTERCAPS_ZTEST |
      D3DPRASTERCAPS_CULLCCW |
      D3DPRASTERCAPS_CULLCW;
  if (!Check((caps.RasterCaps & raster_required) == raster_required,
             "RasterCaps includes SCISSORTEST/ZTEST/CULLCCW/CULLCW")) {
    return false;
  }
  const uint32_t required_texfilt_caps =
      D3DPTFILTERCAPS_MINFPOINT | D3DPTFILTERCAPS_MINFLINEAR |
      D3DPTFILTERCAPS_MAGFPOINT | D3DPTFILTERCAPS_MAGFLINEAR |
      D3DPTFILTERCAPS_MIPFPOINT | D3DPTFILTERCAPS_MIPFLINEAR;
  if (!Check((caps.CubeTextureFilterCaps & required_texfilt_caps) == required_texfilt_caps,
             "CubeTextureFilterCaps includes point/linear+mip filtering")) {
    return false;
  }
  // StretchRect filtering supports only min/mag point/linear (no mip filtering).
  const uint32_t stretchrect_required =
      D3DPTFILTERCAPS_MINFPOINT | D3DPTFILTERCAPS_MINFLINEAR |
      D3DPTFILTERCAPS_MAGFPOINT | D3DPTFILTERCAPS_MAGFLINEAR;
  if (!Check((caps.TextureFilterCaps & stretchrect_required) == stretchrect_required,
             "TextureFilterCaps includes point+linear min/mag filtering")) {
    return false;
  }
  const uint32_t texture_mip_caps = D3DPTFILTERCAPS_MIPFPOINT | D3DPTFILTERCAPS_MIPFLINEAR;
  if (!Check((caps.TextureFilterCaps & texture_mip_caps) == texture_mip_caps,
             "TextureFilterCaps includes mip point+linear filtering")) {
    return false;
  }
  if (!Check((caps.StretchRectFilterCaps & stretchrect_required) == stretchrect_required,
             "StretchRectFilterCaps includes point+linear min/mag filtering")) {
    return false;
  }
  const uint32_t stretchrect_mip_caps = D3DPTFILTERCAPS_MIPFPOINT | D3DPTFILTERCAPS_MIPFLINEAR;
  if (!Check((caps.StretchRectFilterCaps & stretchrect_mip_caps) == 0,
             "StretchRectFilterCaps does not include mip filter caps")) {
    return false;
  }
  // Fixed-function texture stage operation caps must include the subset of
  // combiner ops that the UMD's fixed-function fallback supports (stages 0..3).
  const uint32_t required_texop_caps =
      D3DTEXOPCAPS_DISABLE |
      D3DTEXOPCAPS_SELECTARG1 |
      D3DTEXOPCAPS_SELECTARG2 |
      D3DTEXOPCAPS_MODULATE |
      D3DTEXOPCAPS_MODULATE2X |
      D3DTEXOPCAPS_MODULATE4X |
      D3DTEXOPCAPS_ADD |
      D3DTEXOPCAPS_SUBTRACT |
      D3DTEXOPCAPS_ADDSIGNED |
      D3DTEXOPCAPS_BLENDTEXTUREALPHA |
      D3DTEXOPCAPS_BLENDDIFFUSEALPHA;
  if (!Check((caps.TextureOpCaps & required_texop_caps) == required_texop_caps,
               "TextureOpCaps includes fixed-function subset ops")) {
    return false;
  }
  const uint32_t blend_required = D3DPBLENDCAPS_ZERO | D3DPBLENDCAPS_ONE |
                                  D3DPBLENDCAPS_SRCALPHA | D3DPBLENDCAPS_INVSRCALPHA |
                                  D3DPBLENDCAPS_DESTALPHA | D3DPBLENDCAPS_INVDESTALPHA |
                                  D3DPBLENDCAPS_BLENDFACTOR | D3DPBLENDCAPS_INVBLENDFACTOR;
  if (!Check((caps.SrcBlendCaps & blend_required) == blend_required, "SrcBlendCaps includes required blend factors")) {
    return false;
  }
  if (!Check((caps.DestBlendCaps & blend_required) == blend_required, "DestBlendCaps includes required blend factors")) {
    return false;
  }
  const uint32_t blendop_required = D3DBLENDOPCAPS_ADD |
                                    D3DBLENDOPCAPS_SUBTRACT |
                                    D3DBLENDOPCAPS_REVSUBTRACT |
                                    D3DBLENDOPCAPS_MIN |
                                    D3DBLENDOPCAPS_MAX;
  if (!Check((caps.BlendOpCaps & blendop_required) == blendop_required, "BlendOpCaps includes ADD/SUB/REVSUB/MIN/MAX")) {
    return false;
  }
  // Patch rendering is implemented (DrawRectPatch/DrawTriPatch/DeletePatch), but
  // N-patches and quintic RT patches are not.
  if (!Check((caps.DevCaps & D3DDEVCAPS_RTPATCHES) != 0, "DevCaps advertises RTPATCHES")) {
    return false;
  }
  const uint32_t unsupported_patch_caps = D3DDEVCAPS_NPATCHES | D3DDEVCAPS_QUINTICRTPATCHES;
  if (!Check((caps.DevCaps & unsupported_patch_caps) == 0, "DevCaps does not advertise unsupported patch caps")) {
    return false;
  }
  if (!Check(caps.MaxNpatchTessellationLevel > 0.0f, "MaxNpatchTessellationLevel > 0")) {
    return false;
  }
  if (!Check((caps.TextureAddressCaps & D3DPTADDRESSCAPS_CLAMP) != 0, "TextureAddressCaps includes CLAMP")) {
    return false;
  }
  if (!Check((caps.TextureAddressCaps & D3DPTADDRESSCAPS_WRAP) != 0, "TextureAddressCaps includes WRAP")) {
    return false;
  }
  if (!Check((caps.TextureAddressCaps & D3DPTADDRESSCAPS_MIRROR) != 0, "TextureAddressCaps includes MIRROR")) {
    return false;
  }
  // If we enumerate a depth/stencil format, we must advertise the corresponding
  // compare-function caps so the runtime accepts render-state updates.
  if (!Check((caps.ZCmpCaps & D3DPCMPCAPS_ALWAYS) != 0, "ZCmpCaps includes ALWAYS")) {
    return false;
  }
  if (!Check((caps.AlphaCmpCaps & D3DPCMPCAPS_ALWAYS) != 0, "AlphaCmpCaps includes ALWAYS")) {
    return false;
  }

  uint32_t format_count = 0;
  D3D9DDIARG_GETCAPS get_fmt_count{};
  get_fmt_count.Type = D3DDDICAPS_GETFORMATCOUNT;
  get_fmt_count.pData = &format_count;
  get_fmt_count.DataSize = sizeof(format_count);
  hr = cleanup.adapter_funcs.pfnGetCaps(open.hAdapter, &get_fmt_count);
  if (!Check(hr == S_OK, "GetCaps(GETFORMATCOUNT)")) {
    return false;
  }

  struct GetFormatPayload {
    uint32_t index;
    uint32_t format;
    uint32_t ops;
  };

  constexpr uint32_t kD3DUsageRenderTarget = 0x00000001u;
  constexpr uint32_t kD3DUsageDepthStencil = 0x00000002u;
  // Expected enumeration order (matches `aerogpu_d3d9_caps.cpp`).
  constexpr uint32_t kBaseExpectedFormats[] = {
      22u, // D3DFMT_X8R8G8B8
      21u, // D3DFMT_A8R8G8B8
      23u, // D3DFMT_R5G6B5
      24u, // D3DFMT_X1R5G5B5
      25u, // D3DFMT_A1R5G5B5
      32u, // D3DFMT_A8B8G8R8
      75u, // D3DFMT_D24S8
  };
  constexpr uint32_t kBcExpectedFormats[] = {
      static_cast<uint32_t>(kD3dFmtDxt1), // D3DFMT_DXT1
      static_cast<uint32_t>(kD3dFmtDxt2), // D3DFMT_DXT2
      static_cast<uint32_t>(kD3dFmtDxt3), // D3DFMT_DXT3
      static_cast<uint32_t>(kD3dFmtDxt4), // D3DFMT_DXT4
      static_cast<uint32_t>(kD3dFmtDxt5), // D3DFMT_DXT5
  };

  const uint32_t base_count = static_cast<uint32_t>(sizeof(kBaseExpectedFormats) / sizeof(kBaseExpectedFormats[0]));
  const uint32_t bc_count = static_cast<uint32_t>(sizeof(kBcExpectedFormats) / sizeof(kBcExpectedFormats[0]));
  if (!Check((format_count == base_count) || (format_count == base_count + bc_count),
             "format_count matches expected base(+optional BC) formats")) {
    std::fprintf(stderr, "FAIL: unexpected format_count=%u (base=%u bc=%u)\n",
                 static_cast<unsigned>(format_count),
                 static_cast<unsigned>(base_count),
                 static_cast<unsigned>(bc_count));
    return false;
  }

  std::vector<uint32_t> expected_formats;
  expected_formats.reserve(format_count);
  expected_formats.insert(expected_formats.end(), std::begin(kBaseExpectedFormats), std::end(kBaseExpectedFormats));
  if (format_count == base_count + bc_count) {
    expected_formats.insert(expected_formats.end(), std::begin(kBcExpectedFormats), std::end(kBcExpectedFormats));
  }
  if (!Check(format_count == static_cast<uint32_t>(expected_formats.size()), "expected_formats size matches format_count")) {
    return false;
  }
  std::vector<uint32_t> formats;
  formats.reserve(format_count);
  for (uint32_t i = 0; i < format_count; ++i) {
    GetFormatPayload payload{};
    payload.index = i;
    payload.format = 0;
    payload.ops = 0;

    D3D9DDIARG_GETCAPS get_fmt{};
    get_fmt.Type = D3DDDICAPS_GETFORMAT;
    get_fmt.pData = &payload;
    get_fmt.DataSize = sizeof(payload);
    hr = cleanup.adapter_funcs.pfnGetCaps(open.hAdapter, &get_fmt);
    if (!Check(hr == S_OK, "GetCaps(GETFORMAT)")) {
      return false;
    }
    if (!Check(i < expected_formats.size(), "expected_formats bounds")) {
      return false;
    }
    if (!Check(payload.format == expected_formats[i], "format enumeration matches expected list")) {
      std::fprintf(stderr, "FAIL: GETFORMAT index=%u expected=0x%08X got=0x%08X\n",
                   static_cast<unsigned>(i),
                   static_cast<unsigned>(expected_formats[i]),
                   static_cast<unsigned>(payload.format));
      return false;
    }
    formats.push_back(payload.format);

    uint32_t expected_ops = (payload.format == 75u) ? kD3DUsageDepthStencil : kD3DUsageRenderTarget;
    if (payload.format == static_cast<uint32_t>(kD3dFmtDxt1) ||
        payload.format == static_cast<uint32_t>(kD3dFmtDxt2) ||
        payload.format == static_cast<uint32_t>(kD3dFmtDxt3) ||
        payload.format == static_cast<uint32_t>(kD3dFmtDxt4) ||
        payload.format == static_cast<uint32_t>(kD3dFmtDxt5)) {
      expected_ops = 0;
    }
    if (!Check(payload.ops == expected_ops, "format ops mask matches expected usage")) {
      std::fprintf(stderr, "FAIL: GETFORMAT ops mismatch index=%u format=0x%08X expected_ops=0x%08X got_ops=0x%08X\n",
                   static_cast<unsigned>(i),
                   static_cast<unsigned>(payload.format),
                   static_cast<unsigned>(expected_ops),
                   static_cast<unsigned>(payload.ops));
      return false;
    }

    // Host-facing invariants: any format we advertise via GETFORMAT must have a
    // non-INVALID protocol mapping and a coherent packed texture layout.
    const uint32_t agpu_format = d3d9_format_to_aerogpu(payload.format);
    if (!Check(agpu_format != AEROGPU_FORMAT_INVALID, "d3d9_format_to_aerogpu(format) != INVALID")) {
      std::fprintf(stderr, "FAIL: d3d9_format_to_aerogpu returned INVALID for D3D9 format=0x%08X\n",
                   static_cast<unsigned>(payload.format));
      return false;
    }

    const D3DDDIFORMAT fmt = static_cast<D3DDDIFORMAT>(payload.format);
    uint32_t expected_bpp = 0;
    switch (payload.format) {
      case 21u: // D3DFMT_A8R8G8B8
      case 22u: // D3DFMT_X8R8G8B8
      case 32u: // D3DFMT_A8B8G8R8
      case 75u: // D3DFMT_D24S8
        expected_bpp = 4;
        break;
      case 23u: // D3DFMT_R5G6B5
      case 24u: // D3DFMT_X1R5G5B5
      case 25u: // D3DFMT_A1R5G5B5
        expected_bpp = 2;
        break;
      default:
        break;
    }
    if (expected_bpp) {
      const uint32_t bpp = bytes_per_pixel(fmt);
      if (!Check(bpp == expected_bpp, "bytes_per_pixel(format) matches expected bpp")) {
        std::fprintf(stderr, "FAIL: bytes_per_pixel mismatch format=0x%08X expected=%u got=%u\n",
                     static_cast<unsigned>(payload.format),
                     static_cast<unsigned>(expected_bpp),
                     static_cast<unsigned>(bpp));
        return false;
      }
    }

    constexpr uint32_t kTestW = 7;
    constexpr uint32_t kTestH = 5;
    constexpr uint32_t kTestMips = 3;
    constexpr uint32_t kTestDepth = 1;
    Texture2dLayout layout{};
    if (!Check(calc_texture2d_layout(fmt, kTestW, kTestH, kTestMips, kTestDepth, &layout),
               "calc_texture2d_layout(format) succeeds")) {
      std::fprintf(stderr, "FAIL: calc_texture2d_layout failed format=0x%08X\n",
                   static_cast<unsigned>(payload.format));
      return false;
    }

    const bool is_bc = is_block_compressed_format(fmt);
    const uint32_t bpp = bytes_per_pixel(fmt);
    const uint32_t block_bytes = is_bc ? block_bytes_per_4x4(fmt) : 0u;

    uint64_t expected_total = 0;
    uint32_t w = kTestW;
    uint32_t h = kTestH;
    for (uint32_t level = 0; level < kTestMips; ++level) {
      uint64_t row_pitch = 0;
      uint64_t slice_pitch = 0;
      if (is_bc) {
        if (!Check(block_bytes != 0u, "block_bytes_per_4x4 non-zero for BC format")) {
          std::fprintf(stderr, "FAIL: block_bytes_per_4x4 returned 0 for format=0x%08X\n",
                       static_cast<unsigned>(payload.format));
          return false;
        }
        const uint32_t blocks_w = std::max(1u, (w + 3u) / 4u);
        const uint32_t blocks_h = std::max(1u, (h + 3u) / 4u);
        row_pitch = static_cast<uint64_t>(blocks_w) * block_bytes;
        slice_pitch = row_pitch * blocks_h;
      } else {
        if (!Check(bpp != 0u, "bytes_per_pixel non-zero for uncompressed format")) {
          std::fprintf(stderr, "FAIL: bytes_per_pixel returned 0 for format=0x%08X\n",
                       static_cast<unsigned>(payload.format));
          return false;
        }
        row_pitch = static_cast<uint64_t>(w) * bpp;
        slice_pitch = row_pitch * h;
      }

      if (level == 0) {
        if (!Check(layout.row_pitch_bytes == row_pitch, "layout.row_pitch_bytes matches expected")) {
          std::fprintf(stderr, "FAIL: row_pitch mismatch format=0x%08X expected=%llu got=%u\n",
                       static_cast<unsigned>(payload.format),
                       static_cast<unsigned long long>(row_pitch),
                       static_cast<unsigned>(layout.row_pitch_bytes));
          return false;
        }
        if (!Check(layout.slice_pitch_bytes == slice_pitch, "layout.slice_pitch_bytes matches expected")) {
          std::fprintf(stderr, "FAIL: slice_pitch mismatch format=0x%08X expected=%llu got=%u\n",
                       static_cast<unsigned>(payload.format),
                       static_cast<unsigned long long>(slice_pitch),
                       static_cast<unsigned>(layout.slice_pitch_bytes));
          return false;
        }
      }

      expected_total += slice_pitch;
      w = std::max(1u, w / 2u);
      h = std::max(1u, h / 2u);
    }
    expected_total *= kTestDepth;
    if (!Check(layout.total_size_bytes == expected_total, "layout.total_size_bytes matches expected")) {
      std::fprintf(stderr, "FAIL: total_size mismatch format=0x%08X expected=%llu got=%llu\n",
                   static_cast<unsigned>(payload.format),
                   static_cast<unsigned long long>(expected_total),
                   static_cast<unsigned long long>(layout.total_size_bytes));
      return false;
    }
  }

  // Validate the format list is exactly the expected set (no duplicates, no
  // missing entries).
  std::sort(formats.begin(), formats.end());
  formats.erase(std::unique(formats.begin(), formats.end()), formats.end());
  if (!Check(formats.size() == format_count, "format list contains no duplicates")) {
    return false;
  }
  for (uint32_t expected : expected_formats) {
    if (!Check(std::binary_search(formats.begin(), formats.end(), expected), "format list contains expected entry")) {
      return false;
    }
  }

  // Unknown caps types should not fail device bring-up; validate the driver
  // returns deterministic (zeroed) output.
  uint8_t unknown_buf[32];
  std::memset(unknown_buf, 0xCD, sizeof(unknown_buf));
  D3D9DDIARG_GETCAPS unknown_caps{};
  unknown_caps.Type = 0xDEADBEEFu;
  unknown_caps.pData = unknown_buf;
  unknown_caps.DataSize = sizeof(unknown_buf);
  hr = cleanup.adapter_funcs.pfnGetCaps(open.hAdapter, &unknown_caps);
  if (!Check(hr == S_OK, "GetCaps(unknown type) returns S_OK")) {
    return false;
  }
  for (uint8_t b : unknown_buf) {
    if (!Check(b == 0, "unknown caps type zeroes output buffer")) {
      return false;
    }
  }

  // Size validation: the UMD should not write past caller-provided buffers.
  D3D9DDIARG_GETCAPS invalid_size{};
  invalid_size.Type = D3DDDICAPS_GETD3D9CAPS;
  invalid_size.pData = &caps;
  invalid_size.DataSize = sizeof(caps) - 1;
  hr = cleanup.adapter_funcs.pfnGetCaps(open.hAdapter, &invalid_size);
  if (!Check(hr == E_INVALIDARG, "GetCaps(GETD3D9CAPS) rejects undersized buffer")) {
    return false;
  }

  uint32_t too_small_u32 = 0;
  invalid_size.Type = D3DDDICAPS_GETFORMATCOUNT;
  invalid_size.pData = &too_small_u32;
  invalid_size.DataSize = sizeof(too_small_u32) - 1;
  hr = cleanup.adapter_funcs.pfnGetCaps(open.hAdapter, &invalid_size);
  if (!Check(hr == E_INVALIDARG, "GetCaps(GETFORMATCOUNT) rejects undersized buffer")) {
    return false;
  }

  GetFormatPayload too_small_fmt{};
  too_small_fmt.index = 0;
  invalid_size.Type = D3DDDICAPS_GETFORMAT;
  invalid_size.pData = &too_small_fmt;
  invalid_size.DataSize = sizeof(uint32_t); // smaller than required payload
  hr = cleanup.adapter_funcs.pfnGetCaps(open.hAdapter, &invalid_size);
  if (!Check(hr == E_INVALIDARG, "GetCaps(GETFORMAT) rejects undersized buffer")) {
    return false;
  }

  D3DADAPTER_IDENTIFIER9 ident{};
  D3D9DDIARG_QUERYADAPTERINFO query_ident{};
  query_ident.Type = D3DDDIQUERYADAPTERINFO_GETADAPTERIDENTIFIER;
  query_ident.pPrivateDriverData = &ident;
  query_ident.PrivateDriverDataSize = sizeof(ident);
  hr = cleanup.adapter_funcs.pfnQueryAdapterInfo(open.hAdapter, &query_ident);
  if (!Check(hr == S_OK, "QueryAdapterInfo(GETADAPTERIDENTIFIER)")) {
    return false;
  }
  if (!Check(ident.Driver[0] != '\0', "identifier Driver is non-empty")) {
    return false;
  }
  if (!Check(ident.VendorId == AEROGPU_PCI_VENDOR_ID, "identifier VendorId matches AeroGPU")) {
    return false;
  }
  if (!Check(ident.DeviceId == AEROGPU_PCI_DEVICE_ID, "identifier DeviceId matches AeroGPU")) {
    return false;
  }

  LUID luid{};
  D3D9DDIARG_QUERYADAPTERINFO query_luid{};
  query_luid.Type = D3DDDIQUERYADAPTERINFO_GETADAPTERLUID;
  query_luid.pPrivateDriverData = &luid;
  query_luid.PrivateDriverDataSize = sizeof(luid);
  hr = cleanup.adapter_funcs.pfnQueryAdapterInfo(open.hAdapter, &query_luid);
  if (!Check(hr == S_OK, "QueryAdapterInfo(GETADAPTERLUID)")) {
    return false;
  }
  return true;
}

bool TestAdapterMultisampleQualityLevels() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    bool has_adapter = false;
    ~Cleanup() {
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  struct GetMultisampleQualityLevelsPayload {
    uint32_t format;
    uint32_t multisample_type;
    uint32_t flags;
    uint32_t quality_levels;
  };

  GetMultisampleQualityLevelsPayload payload{};
  payload.format = 22u; // D3DFMT_X8R8G8B8 (supported)
  payload.multisample_type = 0;
  payload.flags = 0;
  payload.quality_levels = 0;

  D3D9DDIARG_GETCAPS get_caps{};
  get_caps.Type = D3DDDICAPS_GETMULTISAMPLEQUALITYLEVELS;
  get_caps.pData = &payload;
  get_caps.DataSize = sizeof(payload);
  hr = cleanup.adapter_funcs.pfnGetCaps(open.hAdapter, &get_caps);
  if (!Check(hr == S_OK, "GetCaps(GETMULTISAMPLEQUALITYLEVELS)")) {
    return false;
  }
  if (!Check(payload.quality_levels == 1, "quality_levels==1 for NONE on supported format")) {
    return false;
  }

  payload.multisample_type = 1;
  payload.quality_levels = 0xCDCDCDCDu;
  hr = cleanup.adapter_funcs.pfnGetCaps(open.hAdapter, &get_caps);
  if (!Check(hr == S_OK, "GetCaps(GETMULTISAMPLEQUALITYLEVELS) non-zero type")) {
    return false;
  }
  if (!Check(payload.quality_levels == 0, "quality_levels==0 for non-zero multisample type")) {
    return false;
  }

  payload.format = 0xFFFFFFFFu;
  payload.multisample_type = 0;
  payload.quality_levels = 0xCDCDCDCDu;
  hr = cleanup.adapter_funcs.pfnGetCaps(open.hAdapter, &get_caps);
  if (!Check(hr == S_OK, "GetCaps(GETMULTISAMPLEQUALITYLEVELS) unsupported format")) {
    return false;
  }
  if (!Check(payload.quality_levels == 0, "quality_levels==0 for unsupported format")) {
    return false;
  }

  // Texture-only formats should not report multisample quality levels.
  payload.format = static_cast<uint32_t>(kD3dFmtDxt1); // D3DFMT_DXT1 (supported, but not renderable)
  payload.multisample_type = 0;
  payload.quality_levels = 0xCDCDCDCDu;
  hr = cleanup.adapter_funcs.pfnGetCaps(open.hAdapter, &get_caps);
  if (!Check(hr == S_OK, "GetCaps(GETMULTISAMPLEQUALITYLEVELS) texture-only format")) {
    return false;
  }
  if (!Check(payload.quality_levels == 0, "quality_levels==0 for texture-only format")) {
    return false;
  }

  struct GetMultisampleQualityLevelsPayloadV1 {
    uint32_t format;
    uint32_t multisample_type;
    uint32_t quality_levels;
  };

  GetMultisampleQualityLevelsPayloadV1 payload_v1{};
  payload_v1.format = 21u; // D3DFMT_A8R8G8B8 (supported)
  payload_v1.multisample_type = 0;
  payload_v1.quality_levels = 0;

  get_caps.pData = &payload_v1;
  get_caps.DataSize = sizeof(payload_v1);
  hr = cleanup.adapter_funcs.pfnGetCaps(open.hAdapter, &get_caps);
  if (!Check(hr == S_OK, "GetCaps(GETMULTISAMPLEQUALITYLEVELS) v1 payload")) {
    return false;
  }
  if (!Check(payload_v1.quality_levels == 1, "quality_levels==1 for v1 payload")) {
    return false;
  }

  // Undersized payload should be rejected.
  uint32_t too_small[2] = {0, 0};
  get_caps.pData = too_small;
  get_caps.DataSize = sizeof(too_small);
  hr = cleanup.adapter_funcs.pfnGetCaps(open.hAdapter, &get_caps);
  return Check(hr == E_INVALIDARG, "GetCaps(GETMULTISAMPLEQUALITYLEVELS) rejects undersized buffer");
}

bool TestAdapterCachingUpdatesCallbacks() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    bool has_adapter = false;
    ~Cleanup() {
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup1, cleanup2;

  D3DDDIARG_OPENADAPTER2 open1{};
  open1.Interface = 1;
  open1.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks1{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks1_2{};
  callbacks1.pfnDummy = reinterpret_cast<void*>(static_cast<uintptr_t>(0x11111111u));
  callbacks1_2.pfnDummy = reinterpret_cast<void*>(static_cast<uintptr_t>(0x22222222u));
  open1.pAdapterCallbacks = &callbacks1;
  open1.pAdapterCallbacks2 = &callbacks1_2;
  open1.pAdapterFuncs = &cleanup1.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open1);
  if (!Check(hr == S_OK, "OpenAdapter2 (first)")) {
    return false;
  }
  if (!Check(open1.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 (first) returned adapter handle")) {
    return false;
  }
  cleanup1.hAdapter = open1.hAdapter;
  cleanup1.has_adapter = true;

  auto* adapter = reinterpret_cast<Adapter*>(open1.hAdapter.pDrvPrivate);
  if (!Check(adapter != nullptr, "adapter pointer")) {
    return false;
  }

  const LUID luid = adapter->luid;

  if (!Check(adapter->adapter_callbacks_valid, "adapter_callbacks_valid after first open")) {
    return false;
  }
  if (!Check(adapter->adapter_callbacks2_valid, "adapter_callbacks2_valid after first open")) {
    return false;
  }
  if (!Check(adapter->adapter_callbacks_copy.pfnDummy == callbacks1.pfnDummy, "adapter_callbacks_copy matches first")) {
    return false;
  }
  if (!Check(adapter->adapter_callbacks2_copy.pfnDummy == callbacks1_2.pfnDummy, "adapter_callbacks2_copy matches first")) {
    return false;
  }

  D3DDDIARG_OPENADAPTERFROMLUID open2{};
  open2.Interface = 1;
  open2.Version = 1;
  open2.AdapterLuid = luid;
  D3DDDI_ADAPTERCALLBACKS callbacks2{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2_2{};
  callbacks2.pfnDummy = reinterpret_cast<void*>(static_cast<uintptr_t>(0x33333333u));
  callbacks2_2.pfnDummy = reinterpret_cast<void*>(static_cast<uintptr_t>(0x44444444u));
  open2.pAdapterCallbacks = &callbacks2;
  open2.pAdapterCallbacks2 = &callbacks2_2;
  open2.pAdapterFuncs = &cleanup2.adapter_funcs;

  hr = ::OpenAdapterFromLuid(&open2);
  if (!Check(hr == S_OK, "OpenAdapterFromLuid (second)")) {
    return false;
  }
  if (!Check(open2.hAdapter.pDrvPrivate != nullptr, "OpenAdapterFromLuid returned adapter handle")) {
    return false;
  }
  cleanup2.hAdapter = open2.hAdapter;
  cleanup2.has_adapter = true;

  if (!Check(open2.hAdapter.pDrvPrivate == open1.hAdapter.pDrvPrivate, "adapter cached across opens")) {
    return false;
  }

  if (!Check(adapter->adapter_callbacks_copy.pfnDummy == callbacks2.pfnDummy, "adapter_callbacks_copy updated on re-open")) {
    return false;
  }
  return Check(adapter->adapter_callbacks2_copy.pfnDummy == callbacks2_2.pfnDummy,
               "adapter_callbacks2_copy updated on re-open");
}

bool TestCreateResourceRejectsUnsupportedGpuFormat() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }

  // Use an obviously invalid D3D9 format value to ensure the UMD rejects unknown
  // GPU formats in the default pool (rather than emitting invalid host commands).
  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = kD3dRTypeTexture;
  create_res.format = 0xFFFFFFFFu;
  create_res.width = 4;
  create_res.height = 4;
  create_res.depth = 1;
  create_res.mip_levels = 1;
  create_res.usage = 0;
  create_res.pool = 0;
  create_res.size = 0;
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr;
  create_res.pPrivateDriverData = nullptr;
  create_res.PrivateDriverDataSize = 0;
  create_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == D3DERR_INVALIDCALL, "CreateResource rejects unsupported GPU format")) {
    return false;
  }
  return Check(create_res.hResource.pDrvPrivate == nullptr, "CreateResource failure does not return a handle");
}

bool TestCreateResourceRejectsUnknownNonBufferType() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  ScopedDeviceCmdVectorReset cmd_reset(dev);

  // Bind a span-backed command buffer so we can assert that no CREATE_TEXTURE2D
  // packets are emitted when CreateResource fails validation.
  std::vector<uint8_t> dma(4096, 0);
  dev->cmd.set_span(dma.data(), dma.size());
  dev->cmd.reset();

  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = 0xDEADBEEFu; // unknown/unsupported when Size==0
  create_res.format = 22u; // D3DFMT_X8R8G8B8
  create_res.width = 4;
  create_res.height = 4;
  create_res.depth = 1;
  create_res.mip_levels = 1;
  create_res.usage = 0;
  create_res.pool = 0;
  create_res.size = 0;
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr;
  create_res.pPrivateDriverData = nullptr;
  create_res.PrivateDriverDataSize = 0;
  create_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == D3DERR_INVALIDCALL, "CreateResource rejects unknown Type for size==0 resources")) {
    return false;
  }
  if (!Check(create_res.hResource.pDrvPrivate == nullptr, "CreateResource failure does not return a handle")) {
    return false;
  }

  dev->cmd.finalize();
  if (!Check(ValidateStream(dma.data(), dma.size()), "stream validates after failed CreateResource")) {
    return false;
  }
  return Check(CountOpcode(dma.data(), dma.size(), AEROGPU_CMD_CREATE_TEXTURE2D) == 0,
               "failed CreateResource must not emit CREATE_TEXTURE2D");
}

bool TestCreateResourceRejectsNon2dDepth() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  ScopedDeviceCmdVectorReset cmd_reset(dev);

  // Bind a span-backed command buffer so we can assert that no CREATE_TEXTURE2D
  // packets are emitted when CreateResource fails validation.
  std::vector<uint8_t> dma(4096, 0);
  dev->cmd.set_span(dma.data(), dma.size());
  dev->cmd.reset();

  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = kD3dRTypeVolumeTexture; // explicit non-2D resource type
  create_res.format = 22u; // D3DFMT_X8R8G8B8
  create_res.width = 4;
  create_res.height = 4;
  create_res.depth = 2;
  create_res.mip_levels = 1;
  create_res.usage = 0;
  create_res.pool = 0;
  create_res.size = 0;
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr;
  create_res.pPrivateDriverData = nullptr;
  create_res.PrivateDriverDataSize = 0;
  create_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == D3DERR_INVALIDCALL, "CreateResource rejects unsupported non-2D resource types")) {
    return false;
  }
  if (!Check(create_res.hResource.pDrvPrivate == nullptr, "CreateResource failure does not return a handle")) {
    return false;
  }

  dev->cmd.finalize();
  if (!Check(ValidateStream(dma.data(), dma.size()), "stream validates after failed CreateResource")) {
    return false;
  }
  const bool ok = Check(CountOpcode(dma.data(), dma.size(), AEROGPU_CMD_CREATE_TEXTURE2D) == 0,
                        "failed CreateResource must not emit CREATE_TEXTURE2D");

  // Make cleanup safe: switch back to vector mode so subsequent destroy calls
  // don't reference the span-backed command buffer after it is freed.
  dev->cmd.set_vector();
  return ok;
}

bool TestCreateResourceMipLevelsZeroOverflowReturnsOutOfMemory() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  ScopedDeviceCmdVectorReset cmd_reset(dev);

  // Bind a span-backed command buffer so we can assert that no CREATE_TEXTURE2D
  // packets are emitted when CreateResource fails validation.
  std::vector<uint8_t> dma(4096, 0);
  dev->cmd.set_span(dma.data(), dma.size());
  dev->cmd.reset();

  // D3DRESOURCETYPE::D3DRTYPE_TEXTURE == 3.
  constexpr uint32_t kD3dRTypeTexture = 3u;

  // Width chosen so width*4 overflows a 32-bit row pitch (and should be caught
  // safely by calc_texture2d_layout), even though MipLevels==0 expands to a full
  // chain.
  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = kD3dRTypeTexture;
  create_res.format = 22u; // D3DFMT_X8R8G8B8
  create_res.width = 0x80000000u;
  create_res.height = 1;
  create_res.depth = 1;
  create_res.mip_levels = 0; // full chain => would be 32 if size were representable
  create_res.usage = 0;
  create_res.pool = 0;
  create_res.size = 0;
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr;
  create_res.pPrivateDriverData = nullptr;
  create_res.PrivateDriverDataSize = 0;
  create_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == E_OUTOFMEMORY, "CreateResource(huge, MipLevels==0) returns E_OUTOFMEMORY")) {
    return false;
  }
  if (!Check(create_res.hResource.pDrvPrivate == nullptr, "CreateResource failure does not return a handle")) {
    return false;
  }

  dev->cmd.finalize();
  if (!Check(ValidateStream(dma.data(), dma.size()), "stream validates after failed CreateResource")) {
    return false;
  }
  return Check(CountOpcode(dma.data(), dma.size(), AEROGPU_CMD_CREATE_TEXTURE2D) == 0,
               "failed CreateResource must not emit CREATE_TEXTURE2D");
}

bool TestCreateResourceComputesBcTexturePitchAndSize() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    std::vector<D3DDDI_HRESOURCE> resources;
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyResource) {
        for (auto& hResource : resources) {
          if (hResource.pDrvPrivate) {
            device_funcs.pfnDestroyResource(hDevice, hResource);
          }
        }
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  ScopedDeviceCmdVectorReset cmd_reset(dev);

  // Bind a span-backed command buffer so we can validate CREATE_TEXTURE2D output.
  std::vector<uint8_t> dma(4096, 0);
  dev->cmd.set_span(dma.data(), dma.size());
  struct Case {
    uint32_t d3d9_format;
    uint32_t agpu_format;
    uint32_t expected_row_pitch;
    uint32_t expected_slice_pitch;
    uint32_t expected_size;
    const char* name;
  };

  const Case cases[] = {
      // DXT1/BC1: 4x4 blocks, 8 bytes per block.
      // width=7,height=5 => blocks_w=2, blocks_h=2 => row_pitch=16, slice_pitch=32.
      // mip chain:
      //  - 7x5 => 32 bytes
      //  - 3x2 =>  8 bytes
      //  - 1x1 =>  8 bytes
      // total = 48 bytes.
      {static_cast<uint32_t>(kD3dFmtDxt1), AEROGPU_FORMAT_BC1_RGBA_UNORM, 16u, 32u, 48u, "DXT1"},

      // DXT3/BC2: 4x4 blocks, 16 bytes per block.
      // width=7,height=5 => blocks_w=2, blocks_h=2 => row_pitch=32, slice_pitch=64.
      // mip chain:
      //  - 7x5 => 64 bytes
      //  - 3x2 => 16 bytes
      //  - 1x1 => 16 bytes
      // total = 96 bytes.
      {static_cast<uint32_t>(kD3dFmtDxt3), AEROGPU_FORMAT_BC2_RGBA_UNORM, 32u, 64u, 96u, "DXT3"},

      // DXT5/BC3: 4x4 blocks, 16 bytes per block.
      {static_cast<uint32_t>(kD3dFmtDxt5), AEROGPU_FORMAT_BC3_RGBA_UNORM, 32u, 64u, 96u, "DXT5"},
  };

  bool ok = true;
  for (const Case& c : cases) {
    dev->cmd.reset();

    D3D9DDIARG_CREATERESOURCE create_res{};
    create_res.type = kD3dRTypeTexture;
    create_res.format = c.d3d9_format;
    create_res.width = 7;
    create_res.height = 5;
    create_res.depth = 1;
    create_res.mip_levels = 3;
    create_res.usage = 0;
    create_res.pool = 0; // default pool (GPU resource)
    create_res.size = 0;
    create_res.hResource.pDrvPrivate = nullptr;
    create_res.pSharedHandle = nullptr;
    create_res.pPrivateDriverData = nullptr;
    create_res.PrivateDriverDataSize = 0;
    create_res.wddm_hAllocation = 0;

    char create_msg[64] = {};
    std::snprintf(create_msg, sizeof(create_msg), "CreateResource(%s)", c.name);
    hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
    if (!Check(hr == S_OK, create_msg)) {
      return false;
    }
    cleanup.resources.push_back(create_res.hResource);

    auto* res = reinterpret_cast<Resource*>(create_res.hResource.pDrvPrivate);
    if (!Check(res != nullptr, "resource pointer")) {
      return false;
    }

    char row_msg[64] = {};
    std::snprintf(row_msg, sizeof(row_msg), "%s row_pitch bytes", c.name);
    ok &= Check(res->row_pitch == c.expected_row_pitch, row_msg);

    char slice_msg[64] = {};
    std::snprintf(slice_msg, sizeof(slice_msg), "%s slice_pitch bytes", c.name);
    ok &= Check(res->slice_pitch == c.expected_slice_pitch, slice_msg);

    char size_msg[64] = {};
    std::snprintf(size_msg, sizeof(size_msg), "%s mip chain size_bytes", c.name);
    ok &= Check(res->size_bytes == c.expected_size, size_msg);

    dev->cmd.finalize();
    if (!Check(ValidateStream(dma.data(), dma.size()), "stream validates")) {
      return false;
    }

    const CmdLoc create_loc = FindLastOpcode(dma.data(), dma.size(), AEROGPU_CMD_CREATE_TEXTURE2D);
    if (!Check(create_loc.hdr != nullptr, "CREATE_TEXTURE2D emitted")) {
      return false;
    }

    const auto* cmd = reinterpret_cast<const aerogpu_cmd_create_texture2d*>(create_loc.hdr);

    char fmt_msg[96] = {};
    std::snprintf(fmt_msg, sizeof(fmt_msg), "CREATE_TEXTURE2D format matches %s", c.name);
    ok &= Check(cmd->format == c.agpu_format, fmt_msg);

    char pitch_msg[96] = {};
    std::snprintf(pitch_msg, sizeof(pitch_msg), "CREATE_TEXTURE2D row_pitch_bytes matches %s", c.name);
    ok &= Check(cmd->row_pitch_bytes == c.expected_row_pitch, pitch_msg);

    ok &= Check(cmd->mip_levels == 3u, "CREATE_TEXTURE2D mip_levels");
  }

  // Make cleanup safe: switch back to vector mode so subsequent destroy calls
  // don't reference the span-backed buffer after it is freed, and can't fail due
  // to span-buffer capacity constraints.
  dev->cmd.set_vector();
  return ok;
}

bool TestCreateResourceMipmappedTextureEmitsMipLevels() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hResource{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_resource = false;

    ~Cleanup() {
      if (has_resource && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hResource);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  ScopedDeviceCmdVectorReset cmd_reset(dev);

  // Bind a span-backed command buffer so we can validate CREATE_TEXTURE2D output.
  std::vector<uint8_t> dma(4096, 0);
  dev->cmd.set_span(dma.data(), dma.size());
  dev->cmd.reset();

  // D3DRESOURCETYPE::D3DRTYPE_TEXTURE == 3.
  constexpr uint32_t kD3dRTypeTexture = 3u;

  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = kD3dRTypeTexture;
  create_res.format = 22u; // D3DFMT_X8R8G8B8
  create_res.width = 64;
  create_res.height = 64;
  create_res.depth = 1;
  create_res.mip_levels = 4;
  create_res.usage = 0;
  create_res.pool = 0; // default pool
  create_res.size = 0;
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr;
  create_res.pPrivateDriverData = nullptr;
  create_res.PrivateDriverDataSize = 0;
  create_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == S_OK, "CreateResource(mipmapped texture)")) {
    return false;
  }
  cleanup.hResource = create_res.hResource;
  cleanup.has_resource = true;

  auto* res = reinterpret_cast<Resource*>(create_res.hResource.pDrvPrivate);
  if (!Check(res != nullptr, "resource pointer")) {
    return false;
  }
  if (!Check(res->mip_levels == 4u, "resource stores mip_levels==4")) {
    return false;
  }

  dev->cmd.finalize();
  if (!Check(ValidateStream(dma.data(), dma.size()), "stream validates")) {
    return false;
  }

  const CmdLoc create_loc = FindLastOpcode(dma.data(), dma.size(), AEROGPU_CMD_CREATE_TEXTURE2D);
  if (!Check(create_loc.hdr != nullptr, "CREATE_TEXTURE2D emitted")) {
    return false;
  }
  const auto* cmd = reinterpret_cast<const aerogpu_cmd_create_texture2d*>(create_loc.hdr);
  if (!Check(cmd->mip_levels == 4u, "CREATE_TEXTURE2D mip_levels==4")) {
    return false;
  }

  // Make cleanup safe: switch back to vector mode so subsequent destroy calls
  // can't fail due to span-buffer capacity constraints.
  dev->cmd.set_vector();
  return true;
}

bool TestLockMipmappedTextureReportsSubresourcePitch() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hResource{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_resource = false;

    ~Cleanup() {
      if (has_resource && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hResource);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnLock != nullptr && cleanup.device_funcs.pfnUnlock != nullptr,
             "Lock/Unlock must be available")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  ScopedDeviceCmdVectorReset cmd_reset(dev);

  // Bind a span-backed command buffer so we can validate the emitted upload range.
  std::vector<uint8_t> dma(4096, 0);
  dev->cmd.set_span(dma.data(), dma.size());
  dev->cmd.reset();

  // D3DRESOURCETYPE::D3DRTYPE_TEXTURE == 3.
  constexpr uint32_t kD3dRTypeTexture = 3u;

  constexpr uint32_t kWidth = 8;
  constexpr uint32_t kHeight = 8;
  constexpr uint32_t kMipLevels = 2;

  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = kD3dRTypeTexture;
  create_res.format = 22u; // D3DFMT_X8R8G8B8
  create_res.width = kWidth;
  create_res.height = kHeight;
  create_res.depth = 1;
  create_res.mip_levels = kMipLevels;
  create_res.usage = 0;
  create_res.pool = 0; // default pool
  create_res.size = 0;
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr;
  create_res.pPrivateDriverData = nullptr;
  create_res.PrivateDriverDataSize = 0;
  create_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == S_OK, "CreateResource(mipmapped texture)")) {
    return false;
  }
  cleanup.hResource = create_res.hResource;
  cleanup.has_resource = true;

  auto* res = reinterpret_cast<Resource*>(create_res.hResource.pDrvPrivate);
  if (!Check(res != nullptr, "resource pointer")) {
    return false;
  }
  if (!Check(res->mip_levels == kMipLevels, "resource stores mip_levels")) {
    return false;
  }

  // The packed texture layout stores mip levels sequentially.
  const uint32_t mip0_row_pitch = kWidth * 4;
  const uint32_t mip0_slice_pitch = mip0_row_pitch * kHeight;
  const uint32_t mip1_row_pitch = (kWidth / 2) * 4;
  const uint32_t mip1_slice_pitch = mip1_row_pitch * (kHeight / 2);
  const uint32_t mip1_offset = mip0_slice_pitch;

  D3D9DDIARG_LOCK lock{};
  lock.hResource = create_res.hResource;
  lock.offset_bytes = mip1_offset;
  lock.size_bytes = 0;
  lock.flags = 0;
  D3DDDI_LOCKEDBOX locked{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &locked);
  if (!Check(hr == S_OK, "Lock(mip1)")) {
    return false;
  }
  if (!Check(locked.pData != nullptr, "Lock(mip1) returns pData")) {
    return false;
  }
  if (!Check(locked.RowPitch == mip1_row_pitch, "Lock(mip1) RowPitch matches mip1")) {
    return false;
  }
  if (!Check(locked.SlicePitch == mip1_slice_pitch, "Lock(mip1) SlicePitch matches mip1")) {
    return false;
  }

  // Mark the entire mip as dirty.
  std::memset(locked.pData, 0xAB, mip1_slice_pitch);

  D3D9DDIARG_UNLOCK unlock{};
  unlock.hResource = create_res.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(mip1)")) {
    return false;
  }

  dev->cmd.finalize();
  const size_t used = dev->cmd.bytes_used();
  if (!Check(ValidateStream(dma.data(), dma.size()), "stream validates")) {
    return false;
  }

  const CmdLoc upload_loc = FindLastUploadResourceBefore(dma.data(), dma.size(), used, res->handle);
  if (!Check(upload_loc.hdr != nullptr, "upload_resource emitted for mipmapped texture")) {
    return false;
  }
  const auto* upload_cmd = reinterpret_cast<const aerogpu_cmd_upload_resource*>(upload_loc.hdr);
  if (!Check(upload_cmd->offset_bytes == static_cast<uint64_t>(mip1_offset), "upload_resource offset matches mip1")) {
    return false;
  }
  if (!Check(upload_cmd->size_bytes == static_cast<uint64_t>(mip1_slice_pitch), "upload_resource size matches mip1")) {
    return false;
  }

  // Make cleanup safe: switch back to vector mode so subsequent destroy calls
  // can't fail due to span-buffer capacity constraints.
  dev->cmd.set_vector();
  return true;
}

bool TestCreateResourceMipLevelsZeroAllocatesFullMipChainForNonShared() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;
    std::vector<D3DDDI_HRESOURCE> resources;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyResource) {
        for (auto& h : resources) {
          device_funcs.pfnDestroyResource(hDevice, h);
        }
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  ScopedDeviceCmdVectorReset cmd_reset(dev);

  // Bind a span-backed command buffer so we can validate CREATE_TEXTURE2D output.
  std::vector<uint8_t> dma(4096, 0);

  // D3DRESOURCETYPE::D3DRTYPE_TEXTURE == 3.
  constexpr uint32_t kD3dRTypeTexture = 3u;

  struct Case {
    uint32_t width;
    uint32_t height;
    uint32_t expected_mip_levels;
    const char* name;
  };

  const Case cases[] = {
      {64u, 64u, 7u, "64x64"},
      {100u, 60u, 7u, "100x60"},
  };

  for (const Case& c : cases) {
    std::memset(dma.data(), 0, dma.size());
    dev->cmd.set_span(dma.data(), dma.size());
    dev->cmd.reset();

    D3D9DDIARG_CREATERESOURCE create_res{};
    create_res.type = kD3dRTypeTexture;
    create_res.format = 22u; // D3DFMT_X8R8G8B8
    create_res.width = c.width;
    create_res.height = c.height;
    create_res.depth = 1;
    create_res.mip_levels = 0; // D3D9: allocate full mip chain
    create_res.usage = 0;
    create_res.pool = 0; // default pool (GPU resource)
    create_res.size = 0;
    create_res.hResource.pDrvPrivate = nullptr;
    create_res.pSharedHandle = nullptr; // non-shared
    create_res.pPrivateDriverData = nullptr;
    create_res.PrivateDriverDataSize = 0;
    create_res.wddm_hAllocation = 0;

    char create_msg[128] = {};
    std::snprintf(create_msg, sizeof(create_msg), "CreateResource(MipLevels=0 %s)", c.name);
    hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
    if (!Check(hr == S_OK, create_msg)) {
      return false;
    }
    cleanup.resources.push_back(create_res.hResource);

    auto* res = reinterpret_cast<Resource*>(create_res.hResource.pDrvPrivate);
    if (!Check(res != nullptr, "resource pointer")) {
      return false;
    }
    if (!Check(res->mip_levels == c.expected_mip_levels, "resource expands MipLevels=0 to full chain")) {
      return false;
    }

    Texture2dLayout expected{};
    if (!Check(calc_texture2d_layout(static_cast<D3DDDIFORMAT>(create_res.format),
                                     create_res.width,
                                     create_res.height,
                                     c.expected_mip_levels,
                                     create_res.depth,
                                     &expected),
               "calc_texture2d_layout(full mip chain)")) {
      return false;
    }
    if (!Check(res->size_bytes == expected.total_size_bytes, "resource size_bytes matches packed mip chain")) {
      return false;
    }

    dev->cmd.finalize();
    if (!Check(ValidateStream(dma.data(), dma.size()), "stream validates")) {
      return false;
    }

    const CmdLoc create_loc = FindLastOpcode(dma.data(), dma.size(), AEROGPU_CMD_CREATE_TEXTURE2D);
    if (!Check(create_loc.hdr != nullptr, "CREATE_TEXTURE2D emitted")) {
      return false;
    }
    const auto* cmd = reinterpret_cast<const aerogpu_cmd_create_texture2d*>(create_loc.hdr);
    if (!Check(cmd->mip_levels == c.expected_mip_levels, "CREATE_TEXTURE2D mip_levels uses computed full chain")) {
      return false;
    }
  }

  // Make cleanup safe: switch back to vector mode so subsequent destroy calls
  // can't fail due to span-buffer capacity constraints.
  dev->cmd.set_vector();
  return true;
}

bool TestLockSizeZeroClampsToMipSubresource() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hResource{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_resource = false;

    ~Cleanup() {
      if (has_resource && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hResource);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnLock != nullptr && cleanup.device_funcs.pfnUnlock != nullptr,
             "Lock/Unlock must be available")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  ScopedDeviceCmdVectorReset cmd_reset(dev);

  // Capture CREATE_TEXTURE2D + the subsequent UPLOAD_RESOURCE emitted by Unlock.
  std::vector<uint8_t> dma(65536, 0);
  dev->cmd.set_span(dma.data(), dma.size());
  dev->cmd.reset();

  // D3DRESOURCETYPE::D3DRTYPE_TEXTURE == 3.
  constexpr uint32_t kD3dRTypeTexture = 3u;

  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = kD3dRTypeTexture;
  create_res.format = 22u; // D3DFMT_X8R8G8B8
  create_res.width = 64;
  create_res.height = 64;
  create_res.depth = 1;
  create_res.mip_levels = 4;
  create_res.usage = 0;
  create_res.pool = 0; // default pool
  create_res.size = 0;
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr;
  create_res.pPrivateDriverData = nullptr;
  create_res.PrivateDriverDataSize = 0;
  create_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == S_OK, "CreateResource(mipmapped texture)")) {
    return false;
  }
  cleanup.hResource = create_res.hResource;
  cleanup.has_resource = true;

  auto* res = reinterpret_cast<Resource*>(create_res.hResource.pDrvPrivate);
  if (!Check(res != nullptr, "resource pointer")) {
    return false;
  }
  if (!Check(res->backing_alloc_id == 0, "mipmapped texture is host-backed (alloc_id==0)")) {
    return false;
  }

  // Mip 0 is 64x64 @ 4 bytes/px => row_pitch=256, slice_pitch=16384.
  // Mip 1 is 32x32 @ 4 bytes/px => row_pitch=128, slice_pitch=4096.
  constexpr uint32_t kMip0SlicePitch = 64u * 64u * 4u;
  constexpr uint32_t kMip1RowPitch = 32u * 4u;
  constexpr uint32_t kMip1SlicePitch = kMip1RowPitch * 32u;
  constexpr uint32_t kMip1Offset = kMip0SlicePitch;

  D3D9DDIARG_LOCK lock{};
  lock.hResource = create_res.hResource;
  lock.offset_bytes = kMip1Offset;
  lock.size_bytes = 0; // default size semantics (driver clamps to the containing mip level)
  lock.flags = 0;
  D3DDDI_LOCKEDBOX box{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(mip 1, size=0)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock(mip 1) returns pData")) {
    return false;
  }
  if (!Check(box.RowPitch == kMip1RowPitch, "Lock(mip 1) RowPitch")) {
    return false;
  }
  if (!Check(box.SlicePitch == kMip1SlicePitch, "Lock(mip 1) SlicePitch")) {
    return false;
  }

  // Touch a byte so Unlock emits an upload.
  reinterpret_cast<uint8_t*>(box.pData)[0] ^= 0xFFu;

  D3D9DDIARG_UNLOCK unlock{};
  unlock.hResource = create_res.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(mip 1, size=0)")) {
    return false;
  }

  dev->cmd.finalize();
  if (!Check(ValidateStream(dma.data(), dma.size()), "stream validates")) {
    return false;
  }

  if (!Check(CountOpcode(dma.data(), dma.size(), AEROGPU_CMD_UPLOAD_RESOURCE) == 1,
             "Unlock emits exactly one UPLOAD_RESOURCE")) {
    return false;
  }
  const CmdLoc upload = FindLastOpcode(dma.data(), dma.size(), AEROGPU_CMD_UPLOAD_RESOURCE);
  if (!Check(upload.hdr != nullptr, "UPLOAD_RESOURCE emitted")) {
    return false;
  }
  const auto* upload_cmd = reinterpret_cast<const aerogpu_cmd_upload_resource*>(upload.hdr);
  if (!Check(upload_cmd->offset_bytes == kMip1Offset, "UPLOAD_RESOURCE offset_bytes clamps to mip 1")) {
    return false;
  }
  if (!Check(upload_cmd->size_bytes == kMip1SlicePitch, "UPLOAD_RESOURCE size_bytes clamps to mip 1")) {
    return false;
  }

  // Make cleanup safe: switch back to vector mode so subsequent destroy calls
  // can't fail due to span-buffer capacity constraints.
  dev->cmd.set_vector();
  return true;
}

bool TestLockSizeZeroClampsToMipSubresourceFromInteriorOffset() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hResource{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_resource = false;

    ~Cleanup() {
      if (has_resource && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hResource);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnLock != nullptr && cleanup.device_funcs.pfnUnlock != nullptr,
             "Lock/Unlock must be available")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  ScopedDeviceCmdVectorReset cmd_reset(dev);

  // Capture CREATE_TEXTURE2D + the subsequent UPLOAD_RESOURCE emitted by Unlock.
  std::vector<uint8_t> dma(65536, 0);
  dev->cmd.set_span(dma.data(), dma.size());
  dev->cmd.reset();

  // D3DRESOURCETYPE::D3DRTYPE_TEXTURE == 3.
  constexpr uint32_t kD3dRTypeTexture = 3u;

  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = kD3dRTypeTexture;
  create_res.format = 22u; // D3DFMT_X8R8G8B8
  create_res.width = 64;
  create_res.height = 64;
  create_res.depth = 1;
  create_res.mip_levels = 4;
  create_res.usage = 0;
  create_res.pool = 0; // default pool
  create_res.size = 0;
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr;
  create_res.pPrivateDriverData = nullptr;
  create_res.PrivateDriverDataSize = 0;
  create_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == S_OK, "CreateResource(mipmapped texture)")) {
    return false;
  }
  cleanup.hResource = create_res.hResource;
  cleanup.has_resource = true;

  auto* res = reinterpret_cast<Resource*>(create_res.hResource.pDrvPrivate);
  if (!Check(res != nullptr, "resource pointer")) {
    return false;
  }
  if (!Check(res->backing_alloc_id == 0, "mipmapped texture is host-backed (alloc_id==0)")) {
    return false;
  }

  // Mip 0 is 64x64 @ 4 bytes/px => row_pitch=256, slice_pitch=16384.
  // Mip 1 is 32x32 @ 4 bytes/px => row_pitch=128, slice_pitch=4096.
  constexpr uint32_t kMip0SlicePitch = 64u * 64u * 4u;
  constexpr uint32_t kMip1RowPitch = 32u * 4u;
  constexpr uint32_t kMip1SlicePitch = kMip1RowPitch * 32u;
  constexpr uint32_t kMip1Offset = kMip0SlicePitch;

  constexpr uint32_t kInteriorOffset = kMip1Offset + 4u;
  constexpr uint32_t kExpectedSize = kMip1SlicePitch;

  D3D9DDIARG_LOCK lock{};
  lock.hResource = create_res.hResource;
  lock.offset_bytes = kInteriorOffset;
  lock.size_bytes = 0; // default size semantics (driver clamps to the containing subresource)
  lock.flags = 0;
  D3DDDI_LOCKEDBOX box{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(mip 1+4, size=0)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock(mip 1+4) returns pData")) {
    return false;
  }
  if (!Check(box.RowPitch == kMip1RowPitch, "Lock(mip 1+4) RowPitch")) {
    return false;
  }
  if (!Check(box.SlicePitch == kMip1SlicePitch, "Lock(mip 1+4) SlicePitch")) {
    return false;
  }

  // Touch a byte so Unlock emits an upload.
  reinterpret_cast<uint8_t*>(box.pData)[0] ^= 0xFFu;

  D3D9DDIARG_UNLOCK unlock{};
  unlock.hResource = create_res.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(mip 1+4, size=0)")) {
    return false;
  }

  dev->cmd.finalize();
  if (!Check(ValidateStream(dma.data(), dma.size()), "stream validates")) {
    return false;
  }

  if (!Check(CountOpcode(dma.data(), dma.size(), AEROGPU_CMD_UPLOAD_RESOURCE) == 1,
             "Unlock emits exactly one UPLOAD_RESOURCE")) {
    return false;
  }
  const CmdLoc upload = FindLastOpcode(dma.data(), dma.size(), AEROGPU_CMD_UPLOAD_RESOURCE);
  if (!Check(upload.hdr != nullptr, "UPLOAD_RESOURCE emitted")) {
    return false;
  }
  const auto* upload_cmd = reinterpret_cast<const aerogpu_cmd_upload_resource*>(upload.hdr);
  if (!Check(upload_cmd->offset_bytes == static_cast<uint64_t>(kMip1Offset), "UPLOAD_RESOURCE offset_bytes")) {
    return false;
  }
  return Check(upload_cmd->size_bytes == static_cast<uint64_t>(kExpectedSize), "UPLOAD_RESOURCE size_bytes");
}

bool TestLockSizeZeroClampsToBcMipSubresourceFromInteriorOffset() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hResource{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_resource = false;

    ~Cleanup() {
      if (has_resource && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hResource);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnLock != nullptr && cleanup.device_funcs.pfnUnlock != nullptr,
             "Lock/Unlock must be available")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  ScopedDeviceCmdVectorReset cmd_reset(dev);

  // Capture CREATE_TEXTURE2D + the subsequent UPLOAD_RESOURCE emitted by Unlock.
  std::vector<uint8_t> dma(65536, 0);
  dev->cmd.set_span(dma.data(), dma.size());
  dev->cmd.reset();

  // D3DRESOURCETYPE::D3DRTYPE_TEXTURE == 3.
  constexpr uint32_t kD3dRTypeTexture = 3u;

  // Block-compressed DXT1 (BC1): 7x5, mip_levels=3.
  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = kD3dRTypeTexture;
  create_res.format = static_cast<uint32_t>(kD3dFmtDxt1); // D3DFMT_DXT1
  create_res.width = 7;
  create_res.height = 5;
  create_res.depth = 1;
  create_res.mip_levels = 3;
  create_res.usage = 0;
  create_res.pool = 0; // default pool (GPU resource)
  create_res.size = 0;
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr;
  create_res.pPrivateDriverData = nullptr;
  create_res.PrivateDriverDataSize = 0;
  create_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == S_OK, "CreateResource(BC1 mipmapped texture)")) {
    return false;
  }
  cleanup.hResource = create_res.hResource;
  cleanup.has_resource = true;

  auto* res = reinterpret_cast<Resource*>(create_res.hResource.pDrvPrivate);
  if (!Check(res != nullptr, "resource pointer")) {
    return false;
  }
  if (!Check(res->backing_alloc_id == 0, "BC1 mipmapped texture is host-backed (alloc_id==0)")) {
    return false;
  }

  // BC1 block size = 8 bytes.
  // Mip 0: 7x5 => blocks_w=2 blocks_h=2 => row_pitch=16 slice_pitch=32.
  // Mip 1: 3x2 => blocks_w=1 blocks_h=1 => row_pitch=8  slice_pitch=8.
  constexpr uint32_t kMip0SlicePitch = 32u;
  constexpr uint32_t kMip1RowPitch = 8u;
  constexpr uint32_t kMip1SlicePitch = 8u;
  constexpr uint32_t kMip1Offset = kMip0SlicePitch;

  constexpr uint32_t kInteriorOffset = kMip1Offset + 1u;
  constexpr uint32_t kExpectedSize = kMip1SlicePitch;

  D3D9DDIARG_LOCK lock{};
  lock.hResource = create_res.hResource;
  lock.offset_bytes = kInteriorOffset;
  lock.size_bytes = 0; // default size semantics (driver clamps to the containing subresource)
  lock.flags = 0;
  D3DDDI_LOCKEDBOX box{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(BC1 mip1+1, size=0)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock(BC1 mip1+1) returns pData")) {
    return false;
  }
  if (!Check(box.RowPitch == kMip1RowPitch, "Lock(BC1 mip1+1) RowPitch")) {
    return false;
  }
  if (!Check(box.SlicePitch == kMip1SlicePitch, "Lock(BC1 mip1+1) SlicePitch")) {
    return false;
  }

  // Touch a byte so Unlock emits an upload.
  reinterpret_cast<uint8_t*>(box.pData)[0] ^= 0xFFu;

  D3D9DDIARG_UNLOCK unlock{};
  unlock.hResource = create_res.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(BC1 mip1+1, size=0)")) {
    return false;
  }

  dev->cmd.finalize();
  if (!Check(ValidateStream(dma.data(), dma.size()), "stream validates")) {
    return false;
  }

  if (!Check(CountOpcode(dma.data(), dma.size(), AEROGPU_CMD_UPLOAD_RESOURCE) == 1,
             "Unlock emits exactly one UPLOAD_RESOURCE")) {
    return false;
  }
  const CmdLoc upload = FindLastOpcode(dma.data(), dma.size(), AEROGPU_CMD_UPLOAD_RESOURCE);
  if (!Check(upload.hdr != nullptr, "UPLOAD_RESOURCE emitted")) {
    return false;
  }
  const auto* upload_cmd = reinterpret_cast<const aerogpu_cmd_upload_resource*>(upload.hdr);
  if (!Check(upload_cmd->offset_bytes == static_cast<uint64_t>(kMip1Offset), "UPLOAD_RESOURCE offset_bytes")) {
    return false;
  }
  return Check(upload_cmd->size_bytes == static_cast<uint64_t>(kExpectedSize), "UPLOAD_RESOURCE size_bytes");
}

bool TestLockSizeZeroClampsToBc2MipSubresourceFromInteriorOffset() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hResource{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_resource = false;

    ~Cleanup() {
      if (has_resource && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hResource);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnLock != nullptr && cleanup.device_funcs.pfnUnlock != nullptr,
             "Lock/Unlock must be available")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  ScopedDeviceCmdVectorReset cmd_reset(dev);

  // Capture CREATE_TEXTURE2D + the subsequent UPLOAD_RESOURCE emitted by Unlock.
  std::vector<uint8_t> dma(65536, 0);
  dev->cmd.set_span(dma.data(), dma.size());
  dev->cmd.reset();

  // D3DRESOURCETYPE::D3DRTYPE_TEXTURE == 3.
  constexpr uint32_t kD3dRTypeTexture = 3u;

  // Block-compressed DXT3 (BC2): 7x5, mip_levels=3.
  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = kD3dRTypeTexture;
  create_res.format = static_cast<uint32_t>(kD3dFmtDxt3); // D3DFMT_DXT3
  create_res.width = 7;
  create_res.height = 5;
  create_res.depth = 1;
  create_res.mip_levels = 3;
  create_res.usage = 0;
  create_res.pool = 0; // default pool (GPU resource)
  create_res.size = 0;
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr;
  create_res.pPrivateDriverData = nullptr;
  create_res.PrivateDriverDataSize = 0;
  create_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == S_OK, "CreateResource(BC2 mipmapped texture)")) {
    return false;
  }
  cleanup.hResource = create_res.hResource;
  cleanup.has_resource = true;

  auto* res = reinterpret_cast<Resource*>(create_res.hResource.pDrvPrivate);
  if (!Check(res != nullptr, "resource pointer")) {
    return false;
  }
  if (!Check(res->backing_alloc_id == 0, "BC2 mipmapped texture is host-backed (alloc_id==0)")) {
    return false;
  }

  // BC2 block size = 16 bytes.
  // Mip 0: 7x5 => blocks_w=2 blocks_h=2 => row_pitch=32 slice_pitch=64.
  // Mip 1: 3x2 => blocks_w=1 blocks_h=1 => row_pitch=16 slice_pitch=16.
  constexpr uint32_t kMip0SlicePitch = 64u;
  constexpr uint32_t kMip1RowPitch = 16u;
  constexpr uint32_t kMip1SlicePitch = 16u;
  constexpr uint32_t kMip1Offset = kMip0SlicePitch;

  constexpr uint32_t kInteriorOffset = kMip1Offset + 1u;
  constexpr uint32_t kExpectedSize = kMip1SlicePitch;

  D3D9DDIARG_LOCK lock{};
  lock.hResource = create_res.hResource;
  lock.offset_bytes = kInteriorOffset;
  lock.size_bytes = 0; // default size semantics (driver clamps to the containing subresource)
  lock.flags = 0;
  D3DDDI_LOCKEDBOX box{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(BC2 mip1+1, size=0)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock(BC2 mip1+1) returns pData")) {
    return false;
  }
  if (!Check(box.RowPitch == kMip1RowPitch, "Lock(BC2 mip1+1) RowPitch")) {
    return false;
  }
  if (!Check(box.SlicePitch == kMip1SlicePitch, "Lock(BC2 mip1+1) SlicePitch")) {
    return false;
  }

  // Touch a byte so Unlock emits an upload.
  reinterpret_cast<uint8_t*>(box.pData)[0] ^= 0xFFu;

  D3D9DDIARG_UNLOCK unlock{};
  unlock.hResource = create_res.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(BC2 mip1+1, size=0)")) {
    return false;
  }

  dev->cmd.finalize();
  if (!Check(ValidateStream(dma.data(), dma.size()), "stream validates")) {
    return false;
  }

  if (!Check(CountOpcode(dma.data(), dma.size(), AEROGPU_CMD_UPLOAD_RESOURCE) == 1,
             "Unlock emits exactly one UPLOAD_RESOURCE")) {
    return false;
  }
  const CmdLoc upload = FindLastOpcode(dma.data(), dma.size(), AEROGPU_CMD_UPLOAD_RESOURCE);
  if (!Check(upload.hdr != nullptr, "UPLOAD_RESOURCE emitted")) {
    return false;
  }
  const auto* upload_cmd = reinterpret_cast<const aerogpu_cmd_upload_resource*>(upload.hdr);
  if (!Check(upload_cmd->offset_bytes == static_cast<uint64_t>(kMip1Offset), "UPLOAD_RESOURCE offset_bytes")) {
    return false;
  }
  return Check(upload_cmd->size_bytes == static_cast<uint64_t>(kExpectedSize), "UPLOAD_RESOURCE size_bytes");
}

bool TestLockSizeZeroClampsToBc3MipSubresourceFromInteriorOffset() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hResource{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_resource = false;

    ~Cleanup() {
      if (has_resource && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hResource);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnLock != nullptr && cleanup.device_funcs.pfnUnlock != nullptr,
             "Lock/Unlock must be available")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  ScopedDeviceCmdVectorReset cmd_reset(dev);

  // Capture CREATE_TEXTURE2D + the subsequent UPLOAD_RESOURCE emitted by Unlock.
  std::vector<uint8_t> dma(65536, 0);
  dev->cmd.set_span(dma.data(), dma.size());
  dev->cmd.reset();

  // D3DRESOURCETYPE::D3DRTYPE_TEXTURE == 3.
  constexpr uint32_t kD3dRTypeTexture = 3u;

  // Block-compressed DXT5 (BC3): 7x5, mip_levels=3.
  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = kD3dRTypeTexture;
  create_res.format = static_cast<uint32_t>(kD3dFmtDxt5); // D3DFMT_DXT5
  create_res.width = 7;
  create_res.height = 5;
  create_res.depth = 1;
  create_res.mip_levels = 3;
  create_res.usage = 0;
  create_res.pool = 0; // default pool (GPU resource)
  create_res.size = 0;
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr;
  create_res.pPrivateDriverData = nullptr;
  create_res.PrivateDriverDataSize = 0;
  create_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == S_OK, "CreateResource(BC3 mipmapped texture)")) {
    return false;
  }
  cleanup.hResource = create_res.hResource;
  cleanup.has_resource = true;

  auto* res = reinterpret_cast<Resource*>(create_res.hResource.pDrvPrivate);
  if (!Check(res != nullptr, "resource pointer")) {
    return false;
  }
  if (!Check(res->backing_alloc_id == 0, "BC3 mipmapped texture is host-backed (alloc_id==0)")) {
    return false;
  }

  // BC3 block size = 16 bytes.
  // Mip 0: 7x5 => blocks_w=2 blocks_h=2 => row_pitch=32 slice_pitch=64.
  // Mip 1: 3x2 => blocks_w=1 blocks_h=1 => row_pitch=16 slice_pitch=16.
  constexpr uint32_t kMip0SlicePitch = 64u;
  constexpr uint32_t kMip1RowPitch = 16u;
  constexpr uint32_t kMip1SlicePitch = 16u;
  constexpr uint32_t kMip1Offset = kMip0SlicePitch;

  constexpr uint32_t kInteriorOffset = kMip1Offset + 1u;
  constexpr uint32_t kExpectedSize = kMip1SlicePitch;

  D3D9DDIARG_LOCK lock{};
  lock.hResource = create_res.hResource;
  lock.offset_bytes = kInteriorOffset;
  lock.size_bytes = 0; // default size semantics (driver clamps to the containing subresource)
  lock.flags = 0;
  D3DDDI_LOCKEDBOX box{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(BC3 mip1+1, size=0)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock(BC3 mip1+1) returns pData")) {
    return false;
  }
  if (!Check(box.RowPitch == kMip1RowPitch, "Lock(BC3 mip1+1) RowPitch")) {
    return false;
  }
  if (!Check(box.SlicePitch == kMip1SlicePitch, "Lock(BC3 mip1+1) SlicePitch")) {
    return false;
  }

  // Touch a byte so Unlock emits an upload.
  reinterpret_cast<uint8_t*>(box.pData)[0] ^= 0xFFu;

  D3D9DDIARG_UNLOCK unlock{};
  unlock.hResource = create_res.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(BC3 mip1+1, size=0)")) {
    return false;
  }

  dev->cmd.finalize();
  if (!Check(ValidateStream(dma.data(), dma.size()), "stream validates")) {
    return false;
  }

  if (!Check(CountOpcode(dma.data(), dma.size(), AEROGPU_CMD_UPLOAD_RESOURCE) == 1,
             "Unlock emits exactly one UPLOAD_RESOURCE")) {
    return false;
  }
  const CmdLoc upload = FindLastOpcode(dma.data(), dma.size(), AEROGPU_CMD_UPLOAD_RESOURCE);
  if (!Check(upload.hdr != nullptr, "UPLOAD_RESOURCE emitted")) {
    return false;
  }
  const auto* upload_cmd = reinterpret_cast<const aerogpu_cmd_upload_resource*>(upload.hdr);
  if (!Check(upload_cmd->offset_bytes == static_cast<uint64_t>(kMip1Offset), "UPLOAD_RESOURCE offset_bytes")) {
    return false;
  }
  return Check(upload_cmd->size_bytes == static_cast<uint64_t>(kExpectedSize), "UPLOAD_RESOURCE size_bytes");
}

bool TestLockSizeZeroClampsTo16BitMipSubresourceFromInteriorOffset() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hResource{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_resource = false;

    ~Cleanup() {
      if (has_resource && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hResource);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnLock != nullptr && cleanup.device_funcs.pfnUnlock != nullptr,
             "Lock/Unlock must be available")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  ScopedDeviceCmdVectorReset cmd_reset(dev);

  // Capture CREATE_TEXTURE2D + the subsequent UPLOAD_RESOURCE emitted by Unlock.
  std::vector<uint8_t> dma(65536, 0);
  dev->cmd.set_span(dma.data(), dma.size());
  dev->cmd.reset();

  // D3DRESOURCETYPE::D3DRTYPE_TEXTURE == 3.
  constexpr uint32_t kD3dRTypeTexture = 3u;

  // Uncompressed 16-bit (D3DFMT_R5G6B5): 13x7, mip_levels=3.
  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = kD3dRTypeTexture;
  create_res.format = 23u; // D3DFMT_R5G6B5
  create_res.width = 13;
  create_res.height = 7;
  create_res.depth = 1;
  create_res.mip_levels = 3;
  create_res.usage = 0;
  create_res.pool = 0; // default pool (GPU resource)
  create_res.size = 0;
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr;
  create_res.pPrivateDriverData = nullptr;
  create_res.PrivateDriverDataSize = 0;
  create_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == S_OK, "CreateResource(R5G6B5 mipmapped texture)")) {
    return false;
  }
  cleanup.hResource = create_res.hResource;
  cleanup.has_resource = true;

  auto* res = reinterpret_cast<Resource*>(create_res.hResource.pDrvPrivate);
  if (!Check(res != nullptr, "resource pointer")) {
    return false;
  }
  if (!Check(res->backing_alloc_id == 0, "R5G6B5 mipmapped texture is host-backed (alloc_id==0)")) {
    return false;
  }

  // R5G6B5: 2 bytes per pixel.
  // Mip 0: 13x7 => row_pitch=26 slice_pitch=182.
  // Mip 1: 6x3  => row_pitch=12 slice_pitch=36.
  constexpr uint32_t kMip0SlicePitch = 182u;
  constexpr uint32_t kMip1RowPitch = 12u;
  constexpr uint32_t kMip1SlicePitch = 36u;
  constexpr uint32_t kMip1Offset = kMip0SlicePitch;

  constexpr uint32_t kInteriorOffset = kMip1Offset + 2u;
  constexpr uint32_t kExpectedSize = kMip1SlicePitch;

  D3D9DDIARG_LOCK lock{};
  lock.hResource = create_res.hResource;
  lock.offset_bytes = kInteriorOffset;
  lock.size_bytes = 0; // default size semantics (driver clamps to the containing subresource)
  lock.flags = 0;
  D3DDDI_LOCKEDBOX box{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(R5G6B5 mip1+2, size=0)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock(R5G6B5 mip1+2) returns pData")) {
    return false;
  }
  if (!Check(box.RowPitch == kMip1RowPitch, "Lock(R5G6B5 mip1+2) RowPitch")) {
    return false;
  }
  if (!Check(box.SlicePitch == kMip1SlicePitch, "Lock(R5G6B5 mip1+2) SlicePitch")) {
    return false;
  }

  // Touch a byte so Unlock emits an upload.
  reinterpret_cast<uint8_t*>(box.pData)[0] ^= 0xFFu;

  D3D9DDIARG_UNLOCK unlock{};
  unlock.hResource = create_res.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(R5G6B5 mip1+2, size=0)")) {
    return false;
  }

  dev->cmd.finalize();
  if (!Check(ValidateStream(dma.data(), dma.size()), "stream validates")) {
    return false;
  }

  if (!Check(CountOpcode(dma.data(), dma.size(), AEROGPU_CMD_UPLOAD_RESOURCE) == 1,
             "Unlock emits exactly one UPLOAD_RESOURCE")) {
    return false;
  }
  const CmdLoc upload = FindLastOpcode(dma.data(), dma.size(), AEROGPU_CMD_UPLOAD_RESOURCE);
  if (!Check(upload.hdr != nullptr, "UPLOAD_RESOURCE emitted")) {
    return false;
  }
  const auto* upload_cmd = reinterpret_cast<const aerogpu_cmd_upload_resource*>(upload.hdr);
  if (!Check(upload_cmd->offset_bytes == static_cast<uint64_t>(kMip1Offset), "UPLOAD_RESOURCE offset_bytes")) {
    return false;
  }
  return Check(upload_cmd->size_bytes == static_cast<uint64_t>(kExpectedSize), "UPLOAD_RESOURCE size_bytes");
}

bool TestLockSizeZeroClampsToArraySubresource() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hResource{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_resource = false;

    ~Cleanup() {
      if (has_resource && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hResource);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnLock != nullptr && cleanup.device_funcs.pfnUnlock != nullptr,
             "Lock/Unlock must be available")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  ScopedDeviceCmdVectorReset cmd_reset(dev);

  // Capture CREATE_TEXTURE2D + the subsequent UPLOAD_RESOURCE emitted by Unlock.
  std::vector<uint8_t> dma(65536, 0);
  dev->cmd.set_span(dma.data(), dma.size());
  dev->cmd.reset();

  // D3DRESOURCETYPE::D3DRTYPE_TEXTURE == 3.
  constexpr uint32_t kD3dRTypeTexture = 3u;

  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = kD3dRTypeTexture;
  create_res.format = 22u; // D3DFMT_X8R8G8B8
  create_res.width = 64;
  create_res.height = 64;
  create_res.depth = 6;
  create_res.mip_levels = 4;
  create_res.usage = 0;
  create_res.pool = 0; // default pool
  create_res.size = 0;
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr;
  create_res.pPrivateDriverData = nullptr;
  create_res.PrivateDriverDataSize = 0;
  create_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == S_OK, "CreateResource(array mipmapped texture)")) {
    return false;
  }
  cleanup.hResource = create_res.hResource;
  cleanup.has_resource = true;

  auto* res = reinterpret_cast<Resource*>(create_res.hResource.pDrvPrivate);
  if (!Check(res != nullptr, "resource pointer")) {
    return false;
  }
  if (!Check(res->backing_alloc_id == 0, "array mipmapped texture is host-backed (alloc_id==0)")) {
    return false;
  }

  // X8R8G8B8: 4 bytes per pixel.
  constexpr uint32_t kMip0SlicePitch = 64u * 64u * 4u;
  constexpr uint32_t kMip1RowPitch = 32u * 4u;
  constexpr uint32_t kMip1SlicePitch = kMip1RowPitch * 32u;
  constexpr uint32_t kMip2SlicePitch = 16u * 16u * 4u;
  constexpr uint32_t kMip3SlicePitch = 8u * 8u * 4u;
  constexpr uint32_t kLayerSize = kMip0SlicePitch + kMip1SlicePitch + kMip2SlicePitch + kMip3SlicePitch;

  constexpr uint32_t kLayer1Index = 1;
  constexpr uint32_t kLayer1Base = kLayerSize * kLayer1Index;
  constexpr uint32_t kLayer1Mip1Offset = kLayer1Base + kMip0SlicePitch;

  D3D9DDIARG_LOCK lock{};
  lock.hResource = create_res.hResource;
  lock.offset_bytes = kLayer1Mip1Offset;
  lock.size_bytes = 0; // default size semantics (driver clamps to the containing subresource)
  lock.flags = 0;
  D3DDDI_LOCKEDBOX box{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(layer 1 mip 1, size=0)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock(layer 1 mip 1) returns pData")) {
    return false;
  }
  if (!Check(box.RowPitch == kMip1RowPitch, "Lock(layer 1 mip 1) RowPitch")) {
    return false;
  }
  if (!Check(box.SlicePitch == kMip1SlicePitch, "Lock(layer 1 mip 1) SlicePitch")) {
    return false;
  }

  // Touch a byte so Unlock emits an upload.
  reinterpret_cast<uint8_t*>(box.pData)[0] ^= 0xFFu;

  D3D9DDIARG_UNLOCK unlock{};
  unlock.hResource = create_res.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(layer 1 mip 1, size=0)")) {
    return false;
  }

  dev->cmd.finalize();
  if (!Check(ValidateStream(dma.data(), dma.size()), "stream validates")) {
    return false;
  }

  if (!Check(CountOpcode(dma.data(), dma.size(), AEROGPU_CMD_UPLOAD_RESOURCE) == 1,
             "Unlock emits exactly one UPLOAD_RESOURCE")) {
    return false;
  }
  const CmdLoc upload = FindLastOpcode(dma.data(), dma.size(), AEROGPU_CMD_UPLOAD_RESOURCE);
  if (!Check(upload.hdr != nullptr, "UPLOAD_RESOURCE emitted")) {
    return false;
  }
  const auto* upload_cmd = reinterpret_cast<const aerogpu_cmd_upload_resource*>(upload.hdr);
  if (!Check(upload_cmd->offset_bytes == kLayer1Mip1Offset, "UPLOAD_RESOURCE offset_bytes clamps to layer 1 mip 1")) {
    return false;
  }
  if (!Check(upload_cmd->size_bytes == kMip1SlicePitch, "UPLOAD_RESOURCE size_bytes clamps to layer 1 mip 1")) {
    return false;
  }

  // Make cleanup safe: switch back to vector mode so subsequent destroy calls
  // can't fail due to span-buffer capacity constraints.
  dev->cmd.set_vector();
  return true;
}

bool TestLockSizeZeroClampsToArraySubresourceFromInteriorOffset() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hResource{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_resource = false;

    ~Cleanup() {
      if (has_resource && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hResource);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnLock != nullptr && cleanup.device_funcs.pfnUnlock != nullptr,
             "Lock/Unlock must be available")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  ScopedDeviceCmdVectorReset cmd_reset(dev);

  // Capture CREATE_TEXTURE2D + the subsequent UPLOAD_RESOURCE emitted by Unlock.
  std::vector<uint8_t> dma(65536, 0);
  dev->cmd.set_span(dma.data(), dma.size());
  dev->cmd.reset();

  // D3DRESOURCETYPE::D3DRTYPE_TEXTURE == 3.
  constexpr uint32_t kD3dRTypeTexture = 3u;

  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = kD3dRTypeTexture;
  create_res.format = 22u; // D3DFMT_X8R8G8B8
  create_res.width = 64;
  create_res.height = 64;
  create_res.depth = 6;
  create_res.mip_levels = 4;
  create_res.usage = 0;
  create_res.pool = 0; // default pool
  create_res.size = 0;
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr;
  create_res.pPrivateDriverData = nullptr;
  create_res.PrivateDriverDataSize = 0;
  create_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == S_OK, "CreateResource(array mipmapped texture)")) {
    return false;
  }
  cleanup.hResource = create_res.hResource;
  cleanup.has_resource = true;

  auto* res = reinterpret_cast<Resource*>(create_res.hResource.pDrvPrivate);
  if (!Check(res != nullptr, "resource pointer")) {
    return false;
  }
  if (!Check(res->backing_alloc_id == 0, "array mipmapped texture is host-backed (alloc_id==0)")) {
    return false;
  }

  // X8R8G8B8: 4 bytes per pixel.
  constexpr uint32_t kMip0SlicePitch = 64u * 64u * 4u;
  constexpr uint32_t kMip1RowPitch = 32u * 4u;
  constexpr uint32_t kMip1SlicePitch = kMip1RowPitch * 32u;
  constexpr uint32_t kMip2SlicePitch = 16u * 16u * 4u;
  constexpr uint32_t kMip3SlicePitch = 8u * 8u * 4u;
  constexpr uint32_t kLayerSize = kMip0SlicePitch + kMip1SlicePitch + kMip2SlicePitch + kMip3SlicePitch;

  constexpr uint32_t kLayer1Index = 1;
  constexpr uint32_t kLayer1Base = kLayerSize * kLayer1Index;
  constexpr uint32_t kLayer1Mip1Offset = kLayer1Base + kMip0SlicePitch;

  constexpr uint32_t kInteriorOffset = kLayer1Mip1Offset + 4u;
  constexpr uint32_t kExpectedSize = kMip1SlicePitch;

  D3D9DDIARG_LOCK lock{};
  lock.hResource = create_res.hResource;
  lock.offset_bytes = kInteriorOffset;
  lock.size_bytes = 0; // default size semantics (driver clamps to the containing subresource)
  lock.flags = 0;
  D3DDDI_LOCKEDBOX box{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(layer 1 mip 1+4, size=0)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock(layer 1 mip 1+4) returns pData")) {
    return false;
  }
  if (!Check(box.RowPitch == kMip1RowPitch, "Lock(layer 1 mip 1+4) RowPitch")) {
    return false;
  }
  if (!Check(box.SlicePitch == kMip1SlicePitch, "Lock(layer 1 mip 1+4) SlicePitch")) {
    return false;
  }

  // Touch a byte so Unlock emits an upload.
  reinterpret_cast<uint8_t*>(box.pData)[0] ^= 0xFFu;

  D3D9DDIARG_UNLOCK unlock{};
  unlock.hResource = create_res.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(layer 1 mip 1+4, size=0)")) {
    return false;
  }

  dev->cmd.finalize();
  if (!Check(ValidateStream(dma.data(), dma.size()), "stream validates")) {
    return false;
  }

  if (!Check(CountOpcode(dma.data(), dma.size(), AEROGPU_CMD_UPLOAD_RESOURCE) == 1,
             "Unlock emits exactly one UPLOAD_RESOURCE")) {
    return false;
  }
  const CmdLoc upload = FindLastOpcode(dma.data(), dma.size(), AEROGPU_CMD_UPLOAD_RESOURCE);
  if (!Check(upload.hdr != nullptr, "UPLOAD_RESOURCE emitted")) {
    return false;
  }
  const auto* upload_cmd = reinterpret_cast<const aerogpu_cmd_upload_resource*>(upload.hdr);
  if (!Check(upload_cmd->offset_bytes == static_cast<uint64_t>(kLayer1Mip1Offset), "UPLOAD_RESOURCE offset_bytes")) {
    return false;
  }
  return Check(upload_cmd->size_bytes == static_cast<uint64_t>(kExpectedSize), "UPLOAD_RESOURCE size_bytes");
}

bool TestCreateResourceArrayTextureEmitsArrayLayers() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hResource{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_resource = false;

    ~Cleanup() {
      if (has_resource && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hResource);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  ScopedDeviceCmdVectorReset cmd_reset(dev);

  // Bind a span-backed command buffer so we can validate CREATE_TEXTURE2D output.
  std::vector<uint8_t> dma(4096, 0);
  dev->cmd.set_span(dma.data(), dma.size());
  dev->cmd.reset();

  // D3DRESOURCETYPE::D3DRTYPE_TEXTURE == 3.
  constexpr uint32_t kD3dRTypeTexture = 3u;

  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = kD3dRTypeTexture;
  create_res.format = 22u; // D3DFMT_X8R8G8B8
  create_res.width = 64;
  create_res.height = 64;
  create_res.depth = 6;
  create_res.mip_levels = 1;
  create_res.usage = 0;
  create_res.pool = 0; // default pool
  create_res.size = 0;
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr;
  create_res.pPrivateDriverData = nullptr;
  create_res.PrivateDriverDataSize = 0;
  create_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == S_OK, "CreateResource(array texture)")) {
    return false;
  }
  cleanup.hResource = create_res.hResource;
  cleanup.has_resource = true;

  auto* res = reinterpret_cast<Resource*>(create_res.hResource.pDrvPrivate);
  if (!Check(res != nullptr, "resource pointer")) {
    return false;
  }
  if (!Check(res->depth == 6u, "resource stores depth==6")) {
    return false;
  }
  if (!Check(res->size_bytes == res->slice_pitch * res->depth, "resource size_bytes includes array layers")) {
    return false;
  }

  dev->cmd.finalize();
  if (!Check(ValidateStream(dma.data(), dma.size()), "stream validates")) {
    return false;
  }

  const CmdLoc create_loc = FindLastOpcode(dma.data(), dma.size(), AEROGPU_CMD_CREATE_TEXTURE2D);
  if (!Check(create_loc.hdr != nullptr, "CREATE_TEXTURE2D emitted")) {
    return false;
  }
  const auto* cmd = reinterpret_cast<const aerogpu_cmd_create_texture2d*>(create_loc.hdr);
  if (!Check(cmd->array_layers == 6u, "CREATE_TEXTURE2D array_layers==6")) {
    return false;
  }

  // Make cleanup safe: switch back to vector mode so subsequent destroy calls
  // can't fail due to span-buffer capacity constraints.
  dev->cmd.set_vector();
  return true;
}

bool TestCreateResourceCubeTextureTypeEmitsArrayLayers() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hResource{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_resource = false;

    ~Cleanup() {
      if (has_resource && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hResource);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  ScopedDeviceCmdVectorReset cmd_reset(dev);

  // Bind a span-backed command buffer so we can validate CREATE_TEXTURE2D output.
  std::vector<uint8_t> dma(4096, 0);
  dev->cmd.set_span(dma.data(), dma.size());
  dev->cmd.reset();

  // D3DRESOURCETYPE::D3DRTYPE_CUBETEXTURE == 5.
  constexpr uint32_t kD3dRTypeCubeTexture = 5u;

  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = kD3dRTypeCubeTexture;
  create_res.format = 22u; // D3DFMT_X8R8G8B8
  create_res.width = 64;
  create_res.height = 64;
  // D3D9 runtimes differ in whether they populate the Depth field for cube
  // textures. The UMD normalizes cube textures to 6 array layers.
  create_res.depth = 1;
  create_res.mip_levels = 1;
  create_res.usage = 0;
  create_res.pool = 0; // default pool
  create_res.size = 0;
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr;
  create_res.pPrivateDriverData = nullptr;
  create_res.PrivateDriverDataSize = 0;
  create_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == S_OK, "CreateResource(cube texture)")) {
    return false;
  }
  cleanup.hResource = create_res.hResource;
  cleanup.has_resource = true;

  auto* res = reinterpret_cast<Resource*>(create_res.hResource.pDrvPrivate);
  if (!Check(res != nullptr, "resource pointer")) {
    return false;
  }
  if (!Check(res->type == kD3dRTypeCubeTexture, "resource stores type==CUBETEXTURE")) {
    return false;
  }
  if (!Check(res->depth == 6u, "resource normalizes cube texture depth to 6")) {
    return false;
  }
  if (!Check(res->size_bytes == res->slice_pitch * res->depth, "resource size_bytes includes cube faces")) {
    return false;
  }

  dev->cmd.finalize();
  if (!Check(ValidateStream(dma.data(), dma.size()), "stream validates")) {
    return false;
  }

  const CmdLoc create_loc = FindLastOpcode(dma.data(), dma.size(), AEROGPU_CMD_CREATE_TEXTURE2D);
  if (!Check(create_loc.hdr != nullptr, "CREATE_TEXTURE2D emitted")) {
    return false;
  }
  const auto* cmd = reinterpret_cast<const aerogpu_cmd_create_texture2d*>(create_loc.hdr);
  if (!Check(cmd->array_layers == 6u, "CREATE_TEXTURE2D array_layers==6")) {
    return false;
  }

  // Make cleanup safe: switch back to vector mode so subsequent destroy calls
  // can't fail due to span-buffer capacity constraints.
  dev->cmd.set_vector();
  return true;
}

bool TestCreateResourceCubeTextureRequiresSquare() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  ScopedDeviceCmdVectorReset cmd_reset(dev);

  // Bind a span-backed command buffer so we can validate that no CREATE_TEXTURE2D
  // is emitted on failure.
  std::vector<uint8_t> dma(4096, 0);
  dev->cmd.set_span(dma.data(), dma.size());
  dev->cmd.reset();

  // D3DRESOURCETYPE::D3DRTYPE_TEXTURE == 3.
  constexpr uint32_t kD3dRTypeTexture = 3u;

  // array_layers==6 is treated as cube texture by the host executor. Cube
  // textures must be square.
  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = kD3dRTypeTexture;
  create_res.format = 22u; // D3DFMT_X8R8G8B8
  create_res.width = 8;
  create_res.height = 4; // non-square
  create_res.depth = 6;
  create_res.mip_levels = 1;
  create_res.usage = 0;
  create_res.pool = 0;
  create_res.size = 0;
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr;
  create_res.pPrivateDriverData = nullptr;
  create_res.PrivateDriverDataSize = 0;
  create_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == D3DERR_INVALIDCALL, "CreateResource(cube, non-square) rejects")) {
    return false;
  }
  if (!Check(create_res.hResource.pDrvPrivate == nullptr, "CreateResource failure does not return a handle")) {
    return false;
  }

  dev->cmd.finalize();
  if (!Check(ValidateStream(dma.data(), dma.size()), "stream validates after failed CreateResource")) {
    return false;
  }
  return Check(CountOpcode(dma.data(), dma.size(), AEROGPU_CMD_CREATE_TEXTURE2D) == 0,
               "failed CreateResource must not emit CREATE_TEXTURE2D");
}

bool TestCreateResourceMipLevelsZeroAllocatesFullMipChainForArrayTexture() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hResource{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_resource = false;

    ~Cleanup() {
      if (has_resource && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hResource);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  ScopedDeviceCmdVectorReset cmd_reset(dev);

  // Bind a span-backed command buffer so we can validate CREATE_TEXTURE2D output.
  std::vector<uint8_t> dma(4096, 0);
  dev->cmd.set_span(dma.data(), dma.size());
  dev->cmd.reset();

  // D3DRESOURCETYPE::D3DRTYPE_TEXTURE == 3.
  constexpr uint32_t kD3dRTypeTexture = 3u;

  // Keep this square to match cube-texture semantics (array_layers=6).
  constexpr uint32_t kWidth = 8;
  constexpr uint32_t kHeight = 8;
  constexpr uint32_t kArrayLayers = 6;

  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = kD3dRTypeTexture;
  create_res.format = 22u; // D3DFMT_X8R8G8B8
  create_res.width = kWidth;
  create_res.height = kHeight;
  create_res.depth = kArrayLayers;
  create_res.mip_levels = 0; // D3D9: allocate full mip chain
  create_res.usage = 0;
  create_res.pool = 0; // default pool (GPU resource)
  create_res.size = 0;
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr; // non-shared
  create_res.pPrivateDriverData = nullptr;
  create_res.PrivateDriverDataSize = 0;
  create_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == S_OK, "CreateResource(array, MipLevels=0)")) {
    return false;
  }
  cleanup.hResource = create_res.hResource;
  cleanup.has_resource = true;

  auto* res = reinterpret_cast<Resource*>(create_res.hResource.pDrvPrivate);
  if (!Check(res != nullptr, "resource pointer")) {
    return false;
  }

  constexpr uint32_t kExpectedMipLevels = 4; // log2(8) + 1
  if (!Check(res->mip_levels == kExpectedMipLevels, "resource mip_levels == 4 for 8x8 array with MipLevels=0")) {
    return false;
  }

  // X8R8G8B8: 4 bytes per pixel. Sum sizes for each level down to 1x1.
  uint32_t w = kWidth;
  uint32_t h = kHeight;
  uint64_t expected_layer_size = 0;
  for (uint32_t level = 0; level < kExpectedMipLevels; ++level) {
    expected_layer_size += static_cast<uint64_t>(w) * static_cast<uint64_t>(h) * 4ull;
    w = std::max(1u, w / 2);
    h = std::max(1u, h / 2);
  }
  const uint64_t expected_size = expected_layer_size * static_cast<uint64_t>(kArrayLayers);
  if (!Check(res->size_bytes == expected_size, "resource size_bytes matches full mip chain sum across array layers")) {
    return false;
  }

  dev->cmd.finalize();
  if (!Check(ValidateStream(dma.data(), dma.size()), "stream validates")) {
    return false;
  }

  const CmdLoc create_loc = FindLastOpcode(dma.data(), dma.size(), AEROGPU_CMD_CREATE_TEXTURE2D);
  if (!Check(create_loc.hdr != nullptr, "CREATE_TEXTURE2D emitted")) {
    return false;
  }
  const auto* cmd = reinterpret_cast<const aerogpu_cmd_create_texture2d*>(create_loc.hdr);
  if (!Check(cmd->mip_levels == kExpectedMipLevels, "CREATE_TEXTURE2D mip_levels uses computed full chain")) {
    return false;
  }
  return Check(cmd->array_layers == kArrayLayers, "CREATE_TEXTURE2D array_layers matches depth");
}

bool TestLockInfersMipLevelPitchFromOffsetBytes() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    std::vector<D3DDDI_HRESOURCE> resources{};
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyResource) {
        for (auto it = resources.rbegin(); it != resources.rend(); ++it) {
          device_funcs.pfnDestroyResource(hDevice, *it);
        }
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnLock != nullptr && cleanup.device_funcs.pfnUnlock != nullptr, "Lock/Unlock must be available")) {
    return false;
  }

  auto lock_check = [&](D3DDDI_HRESOURCE hResource,
                        uint32_t offset_bytes,
                        uint32_t expected_row_pitch,
                        uint32_t expected_slice_pitch,
                        const char* label) -> bool {
    D3D9DDIARG_LOCK lock{};
    lock.hResource = hResource;
    lock.offset_bytes = offset_bytes;
    lock.size_bytes = 0;
    lock.flags = 0;
    D3DDDI_LOCKEDBOX box{};
    HRESULT hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
    if (!Check(hr == S_OK, label)) {
      return false;
    }
    if (!Check(box.pData != nullptr, "Lock returns pData")) {
      return false;
    }
    if (!Check(box.RowPitch == expected_row_pitch, "Lock RowPitch")) {
      return false;
    }
    if (!Check(box.SlicePitch == expected_slice_pitch, "Lock SlicePitch")) {
      return false;
    }
    D3D9DDIARG_UNLOCK unlock{};
    unlock.hResource = hResource;
    unlock.offset_bytes = 0;
    unlock.size_bytes = 0;
    hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
    return Check(hr == S_OK, "Unlock");
  };

  auto lock_fail = [&](D3DDDI_HRESOURCE hResource,
                       uint32_t offset_bytes,
                       HRESULT expected_hr,
                       const char* label) -> bool {
    D3D9DDIARG_LOCK lock{};
    lock.hResource = hResource;
    lock.offset_bytes = offset_bytes;
    lock.size_bytes = 0;
    lock.flags = 0;
    D3DDDI_LOCKEDBOX box{};
    const HRESULT hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
    return Check(hr == expected_hr, label);
  };

  // D3DRESOURCETYPE::D3DRTYPE_TEXTURE == 3.
  constexpr uint32_t kD3dRTypeTexture = 3u;

  // Uncompressed BGRA32 (D3DFMT_X8R8G8B8): 4x4, mip_levels=3.
  // - level0: 4x4 => row_pitch=16, slice_pitch=64, offset=0
  // - level1: 2x2 => row_pitch=8,  slice_pitch=16, offset=64
  // - level2: 1x1 => row_pitch=4,  slice_pitch=4,  offset=80
  D3D9DDIARG_CREATERESOURCE create_rgba{};
  create_rgba.type = kD3dRTypeTexture;
  create_rgba.format = 22u; // D3DFMT_X8R8G8B8
  create_rgba.width = 4;
  create_rgba.height = 4;
  create_rgba.depth = 1;
  create_rgba.mip_levels = 3;
  create_rgba.usage = 0;
  create_rgba.pool = 2u; // D3DPOOL_SYSTEMMEM
  create_rgba.size = 0;
  create_rgba.hResource.pDrvPrivate = nullptr;
  create_rgba.pSharedHandle = nullptr;
  create_rgba.pPrivateDriverData = nullptr;
  create_rgba.PrivateDriverDataSize = 0;
  create_rgba.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_rgba);
  if (!Check(hr == S_OK, "CreateResource(BGRA mip chain)")) {
    return false;
  }
  cleanup.resources.push_back(create_rgba.hResource);

  if (!lock_check(create_rgba.hResource, /*offset_bytes=*/0, /*row=*/16, /*slice=*/64, "Lock(BGRA level0)")) {
    return false;
  }
  if (!lock_check(create_rgba.hResource, /*offset_bytes=*/64, /*row=*/8, /*slice=*/16, "Lock(BGRA level1)")) {
    return false;
  }
  // Offsets can point into a subresource, not just its base. Pitches must still
  // correspond to the containing mip level.
  if (!lock_check(create_rgba.hResource, /*offset_bytes=*/68, /*row=*/8, /*slice=*/16, "Lock(BGRA level1+4)")) {
    return false;
  }
  if (!lock_check(create_rgba.hResource, /*offset_bytes=*/80, /*row=*/4, /*slice=*/4, "Lock(BGRA level2)")) {
    return false;
  }
  // Validate robust error handling: offsets outside the mip chain should be
  // rejected rather than returning nonsense pitches.
  if (!lock_fail(create_rgba.hResource, /*offset_bytes=*/84, E_INVALIDARG, "Lock(BGRA offset==size) rejects")) {
    return false;
  }

  // Block-compressed DXT1 (BC1): 7x5, mip_levels=3.
  // - level0: blocks_w=2, blocks_h=2 => row_pitch=16, slice_pitch=32, offset=0
  // - level1: 3x2 => blocks_w=1, blocks_h=1 => row_pitch=8,  slice_pitch=8,  offset=32
  // - level2: 1x1 => blocks_w=1, blocks_h=1 => row_pitch=8,  slice_pitch=8,  offset=40
  D3D9DDIARG_CREATERESOURCE create_dxt1{};
  create_dxt1.type = kD3dRTypeTexture;
  create_dxt1.format = static_cast<uint32_t>(kD3dFmtDxt1); // D3DFMT_DXT1
  create_dxt1.width = 7;
  create_dxt1.height = 5;
  create_dxt1.depth = 1;
  create_dxt1.mip_levels = 3;
  create_dxt1.usage = 0;
  create_dxt1.pool = 2u; // D3DPOOL_SYSTEMMEM
  create_dxt1.size = 0;
  create_dxt1.hResource.pDrvPrivate = nullptr;
  create_dxt1.pSharedHandle = nullptr;
  create_dxt1.pPrivateDriverData = nullptr;
  create_dxt1.PrivateDriverDataSize = 0;
  create_dxt1.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_dxt1);
  if (!Check(hr == S_OK, "CreateResource(DXT1 mip chain)")) {
    return false;
  }
  cleanup.resources.push_back(create_dxt1.hResource);

  if (!lock_check(create_dxt1.hResource, /*offset_bytes=*/0, /*row=*/16, /*slice=*/32, "Lock(DXT1 level0)")) {
    return false;
  }
  if (!lock_check(create_dxt1.hResource, /*offset_bytes=*/32, /*row=*/8, /*slice=*/8, "Lock(DXT1 level1)")) {
    return false;
  }
  if (!lock_check(create_dxt1.hResource, /*offset_bytes=*/33, /*row=*/8, /*slice=*/8, "Lock(DXT1 level1+1)")) {
    return false;
  }
  if (!lock_fail(create_dxt1.hResource, /*offset_bytes=*/48, E_INVALIDARG, "Lock(DXT1 offset==size) rejects")) {
    return false;
  }
  if (!lock_check(create_dxt1.hResource, /*offset_bytes=*/40, /*row=*/8, /*slice=*/8, "Lock(DXT1 level2)")) {
    return false;
  }

  // Repeat the above checks for array textures (depth/array_layers > 1) to
  // ensure offsets into later layers are interpreted correctly.
  //
  // BGRA32: 4x4, mip_levels=3, array_layers=2.
  // Each layer packs the same mip chain as above (84 bytes).
  D3D9DDIARG_CREATERESOURCE create_rgba_array{};
  create_rgba_array.type = kD3dRTypeTexture;
  create_rgba_array.format = 22u; // D3DFMT_X8R8G8B8
  create_rgba_array.width = 4;
  create_rgba_array.height = 4;
  create_rgba_array.depth = 2;
  create_rgba_array.mip_levels = 3;
  create_rgba_array.usage = 0;
  create_rgba_array.pool = 2u; // D3DPOOL_SYSTEMMEM
  create_rgba_array.size = 0;
  create_rgba_array.hResource.pDrvPrivate = nullptr;
  create_rgba_array.pSharedHandle = nullptr;
  create_rgba_array.pPrivateDriverData = nullptr;
  create_rgba_array.PrivateDriverDataSize = 0;
  create_rgba_array.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_rgba_array);
  if (!Check(hr == S_OK, "CreateResource(BGRA array mip chain)")) {
    return false;
  }
  cleanup.resources.push_back(create_rgba_array.hResource);

  // Layer1 starts at offset 84.
  if (!lock_check(create_rgba_array.hResource, /*offset_bytes=*/84, /*row=*/16, /*slice=*/64, "Lock(BGRA layer1 level0)")) {
    return false;
  }
  if (!lock_check(create_rgba_array.hResource, /*offset_bytes=*/148, /*row=*/8, /*slice=*/16, "Lock(BGRA layer1 level1)")) {
    return false;
  }
  if (!lock_check(create_rgba_array.hResource, /*offset_bytes=*/152, /*row=*/8, /*slice=*/16, "Lock(BGRA layer1 level1+4)")) {
    return false;
  }
  if (!lock_fail(create_rgba_array.hResource, /*offset_bytes=*/168, E_INVALIDARG, "Lock(BGRA array offset==size) rejects")) {
    return false;
  }

  // DXT1: 7x5, mip_levels=3, array_layers=2. Each layer is 48 bytes.
  D3D9DDIARG_CREATERESOURCE create_dxt1_array{};
  create_dxt1_array.type = kD3dRTypeTexture;
  create_dxt1_array.format = static_cast<uint32_t>(kD3dFmtDxt1); // D3DFMT_DXT1
  create_dxt1_array.width = 7;
  create_dxt1_array.height = 5;
  create_dxt1_array.depth = 2;
  create_dxt1_array.mip_levels = 3;
  create_dxt1_array.usage = 0;
  create_dxt1_array.pool = 2u; // D3DPOOL_SYSTEMMEM
  create_dxt1_array.size = 0;
  create_dxt1_array.hResource.pDrvPrivate = nullptr;
  create_dxt1_array.pSharedHandle = nullptr;
  create_dxt1_array.pPrivateDriverData = nullptr;
  create_dxt1_array.PrivateDriverDataSize = 0;
  create_dxt1_array.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_dxt1_array);
  if (!Check(hr == S_OK, "CreateResource(DXT1 array mip chain)")) {
    return false;
  }
  cleanup.resources.push_back(create_dxt1_array.hResource);

  // Layer1 starts at offset 48.
  if (!lock_check(create_dxt1_array.hResource, /*offset_bytes=*/48, /*row=*/16, /*slice=*/32, "Lock(DXT1 layer1 level0)")) {
    return false;
  }
  if (!lock_check(create_dxt1_array.hResource, /*offset_bytes=*/80, /*row=*/8, /*slice=*/8, "Lock(DXT1 layer1 level1)")) {
    return false;
  }
  if (!lock_check(create_dxt1_array.hResource, /*offset_bytes=*/81, /*row=*/8, /*slice=*/8, "Lock(DXT1 layer1 level1+1)")) {
    return false;
  }
  if (!lock_fail(create_dxt1_array.hResource, /*offset_bytes=*/96, E_INVALIDARG, "Lock(DXT1 array offset==size) rejects")) {
    return false;
  }

  // Uncompressed 16-bit (D3DFMT_R5G6B5): 13x7, mip_levels=3.
  // - level0: 13x7 => row_pitch=26, slice_pitch=182, offset=0
  // - level1: 6x3  => row_pitch=12, slice_pitch=36,  offset=182
  // - level2: 3x1  => row_pitch=6,  slice_pitch=6,   offset=218
  D3D9DDIARG_CREATERESOURCE create_r5g6b5{};
  create_r5g6b5.type = kD3dRTypeTexture;
  create_r5g6b5.format = 23u; // D3DFMT_R5G6B5
  create_r5g6b5.width = 13;
  create_r5g6b5.height = 7;
  create_r5g6b5.depth = 1;
  create_r5g6b5.mip_levels = 3;
  create_r5g6b5.usage = 0;
  create_r5g6b5.pool = 2u; // D3DPOOL_SYSTEMMEM
  create_r5g6b5.size = 0;
  create_r5g6b5.hResource.pDrvPrivate = nullptr;
  create_r5g6b5.pSharedHandle = nullptr;
  create_r5g6b5.pPrivateDriverData = nullptr;
  create_r5g6b5.PrivateDriverDataSize = 0;
  create_r5g6b5.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_r5g6b5);
  if (!Check(hr == S_OK, "CreateResource(R5G6B5 mip chain)")) {
    return false;
  }
  cleanup.resources.push_back(create_r5g6b5.hResource);

  if (!lock_check(create_r5g6b5.hResource, /*offset_bytes=*/0, /*row=*/26, /*slice=*/182, "Lock(R5G6B5 level0)")) {
    return false;
  }
  if (!lock_check(create_r5g6b5.hResource, /*offset_bytes=*/182, /*row=*/12, /*slice=*/36, "Lock(R5G6B5 level1)")) {
    return false;
  }
  if (!lock_check(create_r5g6b5.hResource, /*offset_bytes=*/184, /*row=*/12, /*slice=*/36, "Lock(R5G6B5 level1+2)")) {
    return false;
  }
  if (!lock_check(create_r5g6b5.hResource, /*offset_bytes=*/218, /*row=*/6, /*slice=*/6, "Lock(R5G6B5 level2)")) {
    return false;
  }
  if (!lock_fail(create_r5g6b5.hResource, /*offset_bytes=*/224, E_INVALIDARG, "Lock(R5G6B5 offset==size) rejects")) {
    return false;
  }

  // Block-compressed DXT5 (BC3): 7x5, mip_levels=3.
  // - level0: blocks_w=2, blocks_h=2 => row_pitch=32, slice_pitch=64, offset=0
  // - level1: 3x2 => blocks_w=1, blocks_h=1 => row_pitch=16, slice_pitch=16, offset=64
  // - level2: 1x1 => blocks_w=1, blocks_h=1 => row_pitch=16, slice_pitch=16, offset=80
  D3D9DDIARG_CREATERESOURCE create_dxt5{};
  create_dxt5.type = kD3dRTypeTexture;
  create_dxt5.format = static_cast<uint32_t>(kD3dFmtDxt5); // D3DFMT_DXT5
  create_dxt5.width = 7;
  create_dxt5.height = 5;
  create_dxt5.depth = 1;
  create_dxt5.mip_levels = 3;
  create_dxt5.usage = 0;
  create_dxt5.pool = 2u; // D3DPOOL_SYSTEMMEM
  create_dxt5.size = 0;
  create_dxt5.hResource.pDrvPrivate = nullptr;
  create_dxt5.pSharedHandle = nullptr;
  create_dxt5.pPrivateDriverData = nullptr;
  create_dxt5.PrivateDriverDataSize = 0;
  create_dxt5.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_dxt5);
  if (!Check(hr == S_OK, "CreateResource(DXT5 mip chain)")) {
    return false;
  }
  cleanup.resources.push_back(create_dxt5.hResource);

  if (!lock_check(create_dxt5.hResource, /*offset_bytes=*/0, /*row=*/32, /*slice=*/64, "Lock(DXT5 level0)")) {
    return false;
  }
  if (!lock_check(create_dxt5.hResource, /*offset_bytes=*/64, /*row=*/16, /*slice=*/16, "Lock(DXT5 level1)")) {
    return false;
  }
  if (!lock_check(create_dxt5.hResource, /*offset_bytes=*/65, /*row=*/16, /*slice=*/16, "Lock(DXT5 level1+1)")) {
    return false;
  }
  if (!lock_check(create_dxt5.hResource, /*offset_bytes=*/80, /*row=*/16, /*slice=*/16, "Lock(DXT5 level2)")) {
    return false;
  }
  return lock_fail(create_dxt5.hResource, /*offset_bytes=*/96, E_INVALIDARG, "Lock(DXT5 offset==size) rejects");
}

bool TestCreateResourceMipLevelsZeroAllocatesFullMipChain() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hResA{};
    D3DDDI_HRESOURCE hResB{};
    D3DDDI_HRESOURCE hResC{};
    D3DDDI_HRESOURCE hResD{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_res_a = false;
    bool has_res_b = false;
    bool has_res_c = false;
    bool has_res_d = false;

    ~Cleanup() {
      if (has_res_d && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hResD);
      }
      if (has_res_c && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hResC);
      }
      if (has_res_b && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hResB);
      }
      if (has_res_a && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hResA);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }

  // D3DRESOURCETYPE::D3DRTYPE_TEXTURE == 3.
  constexpr uint32_t kD3dRTypeTexture = 3u;

  // Non-shared texture (4x4) with MipLevels == 0 should allocate the full chain:
  // 4x4, 2x2, 1x1 => 3 levels.
  {
    D3D9DDIARG_CREATERESOURCE create_res{};
    create_res.type = kD3dRTypeTexture;
    create_res.format = 22u; // D3DFMT_X8R8G8B8
    create_res.width = 4;
    create_res.height = 4;
    create_res.depth = 1;
    create_res.mip_levels = 0;
    create_res.usage = 0;
    create_res.pool = 0;
    create_res.size = 0;
    create_res.hResource.pDrvPrivate = nullptr;
    create_res.pSharedHandle = nullptr;
    create_res.pPrivateDriverData = nullptr;
    create_res.PrivateDriverDataSize = 0;
    create_res.wddm_hAllocation = 0;

    hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
    if (!Check(hr == S_OK, "CreateResource(MipLevels==0, 4x4)")) {
      return false;
    }
    cleanup.hResA = create_res.hResource;
    cleanup.has_res_a = true;

    auto* res = reinterpret_cast<Resource*>(create_res.hResource.pDrvPrivate);
    if (!Check(res != nullptr, "resource pointer")) {
      return false;
    }
    if (!Check(res->mip_levels == 3u, "MipLevels==0 expands to full chain (4x4 => 3)")) {
      return false;
    }

    Texture2dLayout expected{};
    if (!Check(calc_texture2d_layout(static_cast<D3DDDIFORMAT>(create_res.format),
                                     create_res.width,
                                     create_res.height,
                                     /*mip_levels=*/3,
                                     create_res.depth,
                                     &expected),
               "calc_texture2d_layout(4x4 full chain)")) {
      return false;
    }
    if (!Check(res->row_pitch == expected.row_pitch_bytes, "row_pitch matches layout (4x4)")) {
      return false;
    }
    if (!Check(res->slice_pitch == expected.slice_pitch_bytes, "slice_pitch matches layout (4x4)")) {
      return false;
    }
    if (!Check(res->size_bytes == expected.total_size_bytes, "size_bytes matches layout (4x4 full chain)")) {
      return false;
    }
  }

  // Non-shared texture (8x4) with MipLevels == 0 should allocate the full chain:
  // 8x4, 4x2, 2x1, 1x1 => 4 levels.
  {
    D3D9DDIARG_CREATERESOURCE create_res{};
    create_res.type = kD3dRTypeTexture;
    create_res.format = 22u; // D3DFMT_X8R8G8B8
    create_res.width = 8;
    create_res.height = 4;
    create_res.depth = 1;
    create_res.mip_levels = 0;
    create_res.usage = 0;
    create_res.pool = 0;
    create_res.size = 0;
    create_res.hResource.pDrvPrivate = nullptr;
    create_res.pSharedHandle = nullptr;
    create_res.pPrivateDriverData = nullptr;
    create_res.PrivateDriverDataSize = 0;
    create_res.wddm_hAllocation = 0;

    hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
    if (!Check(hr == S_OK, "CreateResource(MipLevels==0, 8x4)")) {
      return false;
    }
    cleanup.hResB = create_res.hResource;
    cleanup.has_res_b = true;

    auto* res = reinterpret_cast<Resource*>(create_res.hResource.pDrvPrivate);
    if (!Check(res != nullptr, "resource pointer")) {
      return false;
    }
    if (!Check(res->mip_levels == 4u, "MipLevels==0 expands to full chain (8x4 => 4)")) {
      return false;
    }

    Texture2dLayout expected{};
    if (!Check(calc_texture2d_layout(static_cast<D3DDDIFORMAT>(create_res.format),
                                     create_res.width,
                                     create_res.height,
                                     /*mip_levels=*/4,
                                     create_res.depth,
                                     &expected),
               "calc_texture2d_layout(8x4 full chain)")) {
      return false;
    }
    if (!Check(res->size_bytes == expected.total_size_bytes, "size_bytes matches layout (8x4 full chain)")) {
      return false;
    }
  }

  // Non-shared BC1 texture with MipLevels == 0 should allocate the full chain.
  {
    constexpr uint32_t kWidth = 16;
    constexpr uint32_t kHeight = 8;
    constexpr uint32_t kExpectedMipLevels = 5; // 16x8, 8x4, 4x2, 2x1, 1x1
    constexpr uint32_t kBc1BlockBytes = 8;

    D3D9DDIARG_CREATERESOURCE create_res{};
    create_res.type = kD3dRTypeTexture;
    create_res.format = static_cast<uint32_t>(kD3dFmtDxt1); // D3DFMT_DXT1 (BC1)
    create_res.width = kWidth;
    create_res.height = kHeight;
    create_res.depth = 1;
    create_res.mip_levels = 0;
    create_res.usage = 0;
    create_res.pool = 0;
    create_res.size = 0;
    create_res.hResource.pDrvPrivate = nullptr;
    create_res.pSharedHandle = nullptr;
    create_res.pPrivateDriverData = nullptr;
    create_res.PrivateDriverDataSize = 0;
    create_res.wddm_hAllocation = 0;

    hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
    if (!Check(hr == S_OK, "CreateResource(BC1, MipLevels==0, 16x8)")) {
      return false;
    }
    cleanup.hResD = create_res.hResource;
    cleanup.has_res_d = true;

    auto* res = reinterpret_cast<Resource*>(create_res.hResource.pDrvPrivate);
    if (!Check(res != nullptr, "resource pointer")) {
      return false;
    }
    if (!Check(res->mip_levels == kExpectedMipLevels, "MipLevels==0 expands to full chain (BC1 16x8 => 5)")) {
      return false;
    }

    // Validate computed size using the BC1 block layout rules (independent of
    // calc_texture2d_layout).
    uint32_t w = kWidth;
    uint32_t h = kHeight;
    uint32_t expected_row_pitch = 0;
    uint32_t expected_slice_pitch = 0;
    uint64_t expected_size = 0;
    for (uint32_t level = 0; level < kExpectedMipLevels; ++level) {
      const uint32_t blocks_w = std::max(1u, (w + 3u) / 4u);
      const uint32_t blocks_h = std::max(1u, (h + 3u) / 4u);
      const uint32_t row_pitch = blocks_w * kBc1BlockBytes;
      const uint32_t slice_pitch = row_pitch * blocks_h;
      if (level == 0) {
        expected_row_pitch = row_pitch;
        expected_slice_pitch = slice_pitch;
      }
      expected_size += slice_pitch;
      w = std::max(1u, w / 2);
      h = std::max(1u, h / 2);
    }

    if (!Check(res->row_pitch == expected_row_pitch, "row_pitch matches BC1 layout (16x8)")) {
      return false;
    }
    if (!Check(res->slice_pitch == expected_slice_pitch, "slice_pitch matches BC1 layout (16x8)")) {
      return false;
    }
    if (!Check(res->size_bytes == expected_size, "size_bytes matches BC1 full chain (16x8)")) {
      return false;
    }
  }

  // Non-shared texture with MipLevels == 1 must remain a single-level surface.
  {
    D3D9DDIARG_CREATERESOURCE create_res{};
    create_res.type = kD3dRTypeTexture;
    create_res.format = 22u; // D3DFMT_X8R8G8B8
    create_res.width = 4;
    create_res.height = 4;
    create_res.depth = 1;
    create_res.mip_levels = 1;
    create_res.usage = 0;
    create_res.pool = 0;
    create_res.size = 0;
    create_res.hResource.pDrvPrivate = nullptr;
    create_res.pSharedHandle = nullptr;
    create_res.pPrivateDriverData = nullptr;
    create_res.PrivateDriverDataSize = 0;
    create_res.wddm_hAllocation = 0;

    hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
    if (!Check(hr == S_OK, "CreateResource(MipLevels==1, 4x4)")) {
      return false;
    }
    cleanup.hResC = create_res.hResource;
    cleanup.has_res_c = true;

    auto* res = reinterpret_cast<Resource*>(create_res.hResource.pDrvPrivate);
    if (!Check(res != nullptr, "resource pointer")) {
      return false;
    }
    if (!Check(res->mip_levels == 1u, "MipLevels==1 remains 1")) {
      return false;
    }

    Texture2dLayout expected{};
    if (!Check(calc_texture2d_layout(static_cast<D3DDDIFORMAT>(create_res.format),
                                     create_res.width,
                                     create_res.height,
                                     /*mip_levels=*/1,
                                     create_res.depth,
                                     &expected),
               "calc_texture2d_layout(4x4 mip_levels=1)")) {
      return false;
    }
    if (!Check(res->size_bytes == expected.total_size_bytes, "size_bytes matches layout (mip_levels=1)")) {
      return false;
    }
  }

  // Shared textures must reject MipLevels != 1.
  {
    aerogpu_wddm_alloc_priv priv{};
    std::memset(&priv, 0, sizeof(priv));
    HANDLE shared_handle = nullptr;

    D3D9DDIARG_CREATERESOURCE create_shared{};
    create_shared.type = kD3dRTypeSurface;
    create_shared.format = 22u; // D3DFMT_X8R8G8B8
    create_shared.width = 32;
    create_shared.height = 32;
    create_shared.depth = 1;
    create_shared.mip_levels = 0;
    create_shared.usage = 0x00000001u; // D3DUSAGE_RENDERTARGET
    create_shared.pool = 0;
    create_shared.size = 0;
    create_shared.hResource.pDrvPrivate = nullptr;
    create_shared.pSharedHandle = &shared_handle;
    create_shared.pPrivateDriverData = &priv;
    create_shared.PrivateDriverDataSize = sizeof(priv);
    create_shared.wddm_hAllocation = 0;

    hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_shared);
    if (!Check(hr == D3DERR_INVALIDCALL, "CreateResource(shared, MipLevels==0) rejects")) {
      return false;
    }
    if (!Check(create_shared.hResource.pDrvPrivate == nullptr, "CreateResource(shared) failure does not return a handle")) {
      return false;
    }
  }

  return true;
}

bool TestRgb16FormatMappingAndLayout() {
  constexpr uint32_t kD3dFmtR5G6B5 = 23u;
  constexpr uint32_t kD3dFmtX1R5G5B5 = 24u;
  constexpr uint32_t kD3dFmtA1R5G5B5 = 25u;

  if (!Check(d3d9_format_to_aerogpu(kD3dFmtR5G6B5) == AEROGPU_FORMAT_B5G6R5_UNORM,
             "d3d9_format_to_aerogpu(R5G6B5)")) {
    return false;
  }
  if (!Check(d3d9_format_to_aerogpu(kD3dFmtX1R5G5B5) == AEROGPU_FORMAT_B5G5R5A1_UNORM,
             "d3d9_format_to_aerogpu(X1R5G5B5)")) {
    return false;
  }
  if (!Check(d3d9_format_to_aerogpu(kD3dFmtA1R5G5B5) == AEROGPU_FORMAT_B5G5R5A1_UNORM,
             "d3d9_format_to_aerogpu(A1R5G5B5)")) {
    return false;
  }

  if (!Check(bytes_per_pixel(static_cast<D3DDDIFORMAT>(kD3dFmtR5G6B5)) == 2u, "bytes_per_pixel(R5G6B5)==2")) {
    return false;
  }
  if (!Check(bytes_per_pixel(static_cast<D3DDDIFORMAT>(kD3dFmtX1R5G5B5)) == 2u, "bytes_per_pixel(X1R5G5B5)==2")) {
    return false;
  }
  if (!Check(bytes_per_pixel(static_cast<D3DDDIFORMAT>(kD3dFmtA1R5G5B5)) == 2u, "bytes_per_pixel(A1R5G5B5)==2")) {
    return false;
  }

  // Uncompressed 16-bit: row_pitch = width * 2.
  Texture2dLayout layout{};
  if (!Check(calc_texture2d_layout(static_cast<D3DDDIFORMAT>(kD3dFmtR5G6B5), 7, 5, 3, 1, &layout),
             "calc_texture2d_layout(R5G6B5)")) {
    return false;
  }
  if (!Check(layout.row_pitch_bytes == 14u, "R5G6B5 row_pitch_bytes (7*2)")) {
    return false;
  }
  if (!Check(layout.slice_pitch_bytes == 70u, "R5G6B5 slice_pitch_bytes (14*5)")) {
    return false;
  }
  return Check(layout.total_size_bytes == 84ull, "R5G6B5 total_size_bytes (mip chain)");
}

bool TestCreateResourceComputes16BitTexturePitchAndFormat() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDestroyResource != nullptr, "DestroyResource must be available")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  ScopedDeviceCmdVectorReset cmd_reset(dev);

  // Bind a span-backed command buffer so we can validate CREATE_TEXTURE2D output.
  std::vector<uint8_t> dma(4096, 0);

  struct Case {
    uint32_t d3d9_format;
    uint32_t agpu_format;
    const char* name;
  };

  const Case cases[] = {
      {23u, AEROGPU_FORMAT_B5G6R5_UNORM, "R5G6B5"},       // D3DFMT_R5G6B5
      {24u, AEROGPU_FORMAT_B5G5R5A1_UNORM, "X1R5G5B5"},   // D3DFMT_X1R5G5B5
      {25u, AEROGPU_FORMAT_B5G5R5A1_UNORM, "A1R5G5B5"},   // D3DFMT_A1R5G5B5
  };

  constexpr uint32_t kWidth = 13;
  constexpr uint32_t kHeight = 7;
  constexpr uint32_t kExpectedRowPitch = kWidth * 2;
  constexpr uint32_t kExpectedSlicePitch = kExpectedRowPitch * kHeight;
  constexpr uint32_t kExpectedSize = kExpectedSlicePitch;

  for (const Case& c : cases) {
    std::memset(dma.data(), 0, dma.size());
    dev->cmd.set_span(dma.data(), dma.size());
    dev->cmd.reset();

    D3D9DDIARG_CREATERESOURCE create_res{};
    create_res.type = kD3dRTypeTexture;
    create_res.format = c.d3d9_format;
    create_res.width = kWidth;
    create_res.height = kHeight;
    create_res.depth = 1;
    create_res.mip_levels = 1;
    create_res.usage = 0;
    create_res.pool = 0; // default pool (GPU resource)
    create_res.size = 0;
    create_res.hResource.pDrvPrivate = nullptr;
    create_res.pSharedHandle = nullptr;
    create_res.pPrivateDriverData = nullptr;
    create_res.PrivateDriverDataSize = 0;
    create_res.wddm_hAllocation = 0;

    char create_msg[128] = {};
    std::snprintf(create_msg, sizeof(create_msg), "CreateResource(%s)", c.name);
    hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
    if (!Check(hr == S_OK, create_msg)) {
      return false;
    }
    if (!Check(create_res.hResource.pDrvPrivate != nullptr, "CreateResource returned resource handle")) {
      return false;
    }

    auto* res = reinterpret_cast<Resource*>(create_res.hResource.pDrvPrivate);
    if (!Check(res != nullptr, "resource pointer")) {
      return false;
    }
    if (!Check(res->row_pitch == kExpectedRowPitch, "16-bit row_pitch bytes")) {
      return false;
    }
    if (!Check(res->slice_pitch == kExpectedSlicePitch, "16-bit slice_pitch bytes")) {
      return false;
    }
    if (!Check(res->size_bytes == kExpectedSize, "16-bit size_bytes")) {
      return false;
    }

    dev->cmd.finalize();
    if (!Check(ValidateStream(dma.data(), dma.size()), "stream validates")) {
      return false;
    }

    const CmdLoc create_loc = FindLastOpcode(dma.data(), dma.size(), AEROGPU_CMD_CREATE_TEXTURE2D);
    if (!Check(create_loc.hdr != nullptr, "CREATE_TEXTURE2D emitted")) {
      return false;
    }
    const auto* cmd = reinterpret_cast<const aerogpu_cmd_create_texture2d*>(create_loc.hdr);
    if (!Check(cmd->format == c.agpu_format, "CREATE_TEXTURE2D format matches expected")) {
      return false;
    }
    if (!Check(cmd->row_pitch_bytes == kExpectedRowPitch, "CREATE_TEXTURE2D row_pitch_bytes matches expected")) {
      return false;
    }

    hr = cleanup.device_funcs.pfnDestroyResource(create_dev.hDevice, create_res.hResource);
    if (!Check(hr == S_OK, "DestroyResource")) {
      return false;
    }
  }

  // Make cleanup safe: switch back to vector mode so subsequent destroy calls
  // can't fail due to span-buffer capacity constraints.
  dev->cmd.set_vector();
  return true;
}

bool TestX1R5G5B5UnlockForcesOpaqueAlphaForMisalignedWrites() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hResource{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_resource = false;

    ~Cleanup() {
      if (has_resource && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hResource);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnLock != nullptr && cleanup.device_funcs.pfnUnlock != nullptr,
             "Lock/Unlock must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDestroyResource != nullptr, "DestroyResource must be available")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  ScopedDeviceCmdVectorReset cmd_reset(dev);

  constexpr uint32_t kD3dFmtX1R5G5B5 = 24u;

  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = kD3dRTypeTexture;
  create_res.format = kD3dFmtX1R5G5B5;
  create_res.width = 2;
  create_res.height = 1;
  create_res.depth = 1;
  create_res.mip_levels = 1;
  create_res.usage = 0;
  create_res.pool = 0; // default pool (GPU resource)
  create_res.size = 0;
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr;
  create_res.pPrivateDriverData = nullptr;
  create_res.PrivateDriverDataSize = 0;
  create_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == S_OK, "CreateResource(X1R5G5B5)")) {
    return false;
  }
  if (!Check(create_res.hResource.pDrvPrivate != nullptr, "CreateResource returned resource handle")) {
    return false;
  }
  cleanup.hResource = create_res.hResource;
  cleanup.has_resource = true;

  auto* res = reinterpret_cast<Resource*>(create_res.hResource.pDrvPrivate);
  if (!Check(res != nullptr, "resource pointer")) {
    return false;
  }
  if (!Check(res->storage.size() >= 4, "resource has CPU shadow storage")) {
    return false;
  }

  D3D9DDIARG_LOCK lock{};
  lock.hResource = create_res.hResource;
  lock.offset_bytes = 0;
  lock.size_bytes = 0; // lock full resource
  lock.flags = 0;
  D3DDDI_LOCKEDBOX box{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(X1R5G5B5)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock returns pData")) {
    return false;
  }

  // Write two texels with alpha bit cleared.
  uint16_t texel0 = 0x1234u;
  uint16_t texel1 = 0x5678u;
  texel0 &= 0x7FFFu;
  texel1 &= 0x7FFFu;
  std::memcpy(static_cast<uint8_t*>(box.pData) + 0, &texel0, sizeof(texel0));
  std::memcpy(static_cast<uint8_t*>(box.pData) + 2, &texel1, sizeof(texel1));

  // Misaligned write range: cover full texel0 plus only the low byte of texel1.
  // The driver should still force texel1's alpha bit to 1 because X1 formats
  // have implicit opaque alpha regardless of how the CPU updated the bytes.
  D3D9DDIARG_UNLOCK unlock{};
  unlock.hResource = create_res.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 3;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(X1R5G5B5 misaligned range)")) {
    return false;
  }

  uint16_t got0 = 0;
  uint16_t got1 = 0;
  std::memcpy(&got0, &res->storage[0], sizeof(got0));
  std::memcpy(&got1, &res->storage[2], sizeof(got1));

  if (!Check(got0 == static_cast<uint16_t>(texel0 | 0x8000u), "texel0 alpha bit forced to 1")) {
    return false;
  }
  return Check(got1 == static_cast<uint16_t>(texel1 | 0x8000u), "texel1 alpha bit forced to 1 for misaligned write");
}

bool TestCreateSwapChainComputes16BitBackbufferPitchAndFormat() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3D9DDI_HSWAPCHAIN hSwapChain{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_swapchain = false;

    ~Cleanup() {
      if (has_swapchain && device_funcs.pfnDestroySwapChain) {
        device_funcs.pfnDestroySwapChain(hDevice, hSwapChain);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  ScopedDeviceCmdVectorReset cmd_reset(dev);

  struct Case {
    uint32_t d3d9_format;
    uint32_t agpu_format;
    const char* name;
  };

  const Case cases[] = {
      {23u, AEROGPU_FORMAT_B5G6R5_UNORM, "R5G6B5"},       // D3DFMT_R5G6B5
      {24u, AEROGPU_FORMAT_B5G5R5A1_UNORM, "X1R5G5B5"},   // D3DFMT_X1R5G5B5
      {25u, AEROGPU_FORMAT_B5G5R5A1_UNORM, "A1R5G5B5"},   // D3DFMT_A1R5G5B5
  };

  // Bind a span-backed command buffer so we can validate CREATE_TEXTURE2D output.
  std::vector<uint8_t> dma(4096, 0);

  constexpr uint32_t kWidth = 13;
  constexpr uint32_t kHeight = 7;
  constexpr uint32_t kExpectedRowPitch = kWidth * 2;

  for (const Case& c : cases) {
    std::memset(dma.data(), 0, dma.size());
    dev->cmd.set_span(dma.data(), dma.size());
    dev->cmd.reset();

    D3D9DDIARG_CREATESWAPCHAIN create_sc{};
    create_sc.present_params.backbuffer_width = kWidth;
    create_sc.present_params.backbuffer_height = kHeight;
    create_sc.present_params.backbuffer_format = c.d3d9_format;
    create_sc.present_params.backbuffer_count = 1;
    create_sc.present_params.swap_effect = 1;
    create_sc.present_params.flags = 0;
    create_sc.present_params.hDeviceWindow = nullptr;
    create_sc.present_params.windowed = TRUE;
    create_sc.present_params.presentation_interval = 1;

    char create_msg[128] = {};
    std::snprintf(create_msg, sizeof(create_msg), "CreateSwapChain(%s)", c.name);
    hr = cleanup.device_funcs.pfnCreateSwapChain(create_dev.hDevice, &create_sc);
    if (!Check(hr == S_OK, create_msg)) {
      return false;
    }
    if (!Check(create_sc.hSwapChain.pDrvPrivate != nullptr, "CreateSwapChain returned swapchain handle")) {
      return false;
    }
    cleanup.hSwapChain = create_sc.hSwapChain;
    cleanup.has_swapchain = true;

    auto* bb = reinterpret_cast<Resource*>(create_sc.hBackBuffer.pDrvPrivate);
    if (!Check(bb != nullptr, "CreateSwapChain returned backbuffer handle")) {
      return false;
    }

    if (!Check(bb->row_pitch == kExpectedRowPitch, "16-bit backbuffer row_pitch bytes")) {
      return false;
    }
    if (!Check(bb->slice_pitch == kExpectedRowPitch * kHeight, "16-bit backbuffer slice_pitch bytes")) {
      return false;
    }
    if (!Check(bb->size_bytes == bb->slice_pitch, "16-bit backbuffer size_bytes matches slice_pitch")) {
      return false;
    }

    dev->cmd.finalize();
    if (!Check(ValidateStream(dma.data(), dma.size()), "stream validates")) {
      return false;
    }

    const CmdLoc create_loc = FindLastOpcode(dma.data(), dma.size(), AEROGPU_CMD_CREATE_TEXTURE2D);
    if (!Check(create_loc.hdr != nullptr, "CREATE_TEXTURE2D emitted")) {
      return false;
    }
    const auto* cmd = reinterpret_cast<const aerogpu_cmd_create_texture2d*>(create_loc.hdr);
    if (!Check(cmd->format == c.agpu_format, "CREATE_TEXTURE2D format matches expected")) {
      return false;
    }
    if (!Check(cmd->row_pitch_bytes == kExpectedRowPitch, "CREATE_TEXTURE2D row_pitch_bytes")) {
      return false;
    }
    if (!Check((cmd->usage_flags & AEROGPU_RESOURCE_USAGE_RENDER_TARGET) != 0,
               "CREATE_TEXTURE2D usage_flags includes RT")) {
      return false;
    }

    // Make cleanup safe: switch back to vector mode so swapchain teardown is not
    // constrained by the span-backed buffer capacity.
    dev->cmd.set_vector();
    hr = cleanup.device_funcs.pfnDestroySwapChain(create_dev.hDevice, create_sc.hSwapChain);
    if (!Check(hr == S_OK, "DestroySwapChain")) {
      return false;
    }
    cleanup.has_swapchain = false;
    cleanup.hSwapChain = {};
  }

  return true;
}

bool TestGenerateMipSubLevelsBoxFilter2d() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hResource{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_resource = false;

    ~Cleanup() {
      if (has_resource && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hResource);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnGenerateMipSubLevels != nullptr, "GenerateMipSubLevels must be available")) {
    return false;
  }

  // Create a 4x4 texture with 3 mip levels (4x4, 2x2, 1x1).
  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = kD3dRTypeTexture;
  create_res.format = 22u; // D3DFMT_X8R8G8B8
  create_res.width = 4;
  create_res.height = 4;
  create_res.depth = 1;
  create_res.mip_levels = 3;
  create_res.usage = 0;
  create_res.pool = 0;
  create_res.size = 0;
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr;
  create_res.pPrivateDriverData = nullptr;
  create_res.PrivateDriverDataSize = 0;
  create_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == S_OK, "CreateResource(4x4 texture mips)")) {
    return false;
  }
  cleanup.hResource = create_res.hResource;
  cleanup.has_resource = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  auto* res = reinterpret_cast<Resource*>(create_res.hResource.pDrvPrivate);
  if (!Check(dev != nullptr && res != nullptr, "device/resource pointers")) {
    return false;
  }
  if (!Check(res->mip_levels == 3, "resource mip_levels==3")) {
    return false;
  }
  if (!Check(res->backing_alloc_id == 0, "resource is host-allocated (alloc_id==0)")) {
    return false;
  }
  if (!Check(res->storage.size() >= res->size_bytes, "resource storage sized")) {
    return false;
  }

  // Fill mip0 with a known pattern:
  // R = x + y*4, G = 0, B = 0, X (alpha) = 0. Mip gen should force alpha to 0xFF.
  const uint32_t row_pitch = res->row_pitch;
  if (!Check(row_pitch == 16u, "mip0 row_pitch==16")) {
    return false;
  }
  uint8_t* base = res->storage.data();
  for (uint32_t y = 0; y < 4; ++y) {
    for (uint32_t x = 0; x < 4; ++x) {
      const uint8_t r = static_cast<uint8_t>(x + y * 4u);
      const size_t off = static_cast<size_t>(y) * row_pitch + static_cast<size_t>(x) * 4u;
      base[off + 0] = 0; // B
      base[off + 1] = 0; // G
      base[off + 2] = r; // R
      base[off + 3] = 0; // X (ignored)
    }
  }

  // Clear command buffer so we only observe visibility packets from mip generation.
  dev->cmd.reset();

  hr = cleanup.device_funcs.pfnGenerateMipSubLevels(create_dev.hDevice, create_res.hResource);
  if (!Check(hr == S_OK, "GenerateMipSubLevels")) {
    return false;
  }

  Texture2dMipLevelLayout mip1{};
  Texture2dMipLevelLayout mip2{};
  if (!Check(calc_texture2d_mip_level_layout(res->format, res->width, res->height, res->mip_levels, res->depth, 1, &mip1),
             "mip1 layout")) {
    return false;
  }
  if (!Check(calc_texture2d_mip_level_layout(res->format, res->width, res->height, res->mip_levels, res->depth, 2, &mip2),
             "mip2 layout")) {
    return false;
  }
  if (!Check(mip1.width == 2 && mip1.height == 2, "mip1 dims 2x2")) {
    return false;
  }
  if (!Check(mip2.width == 1 && mip2.height == 1, "mip2 dims 1x1")) {
    return false;
  }

  const uint8_t expected_mip1[16] = {
      0, 0, 3, 0xFF, 0, 0, 5, 0xFF,
      0, 0, 11, 0xFF, 0, 0, 13, 0xFF,
  };
  const uint8_t expected_mip2[4] = {0, 0, 8, 0xFF};

  if (!Check(mip1.slice_pitch_bytes == sizeof(expected_mip1), "mip1 slice_pitch==16")) {
    return false;
  }
  if (!Check(mip2.slice_pitch_bytes == sizeof(expected_mip2), "mip2 slice_pitch==4")) {
    return false;
  }

  if (!Check(std::memcmp(res->storage.data() + static_cast<size_t>(mip1.offset_bytes), expected_mip1, sizeof(expected_mip1)) == 0,
             "mip1 bytes match")) {
    return false;
  }
  if (!Check(std::memcmp(res->storage.data() + static_cast<size_t>(mip2.offset_bytes), expected_mip2, sizeof(expected_mip2)) == 0,
             "mip2 bytes match")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  if (!Check(ValidateStream(buf, len), "stream validates")) {
    return false;
  }

  // Host-allocated textures should embed updates via UPLOAD_RESOURCE.
  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_UPLOAD_RESOURCE) >= 1, "GenerateMipSubLevels emits UPLOAD_RESOURCE")) {
    return false;
  }
  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_RESOURCE_DIRTY_RANGE) == 0, "GenerateMipSubLevels does not emit DIRTY_RANGE for host alloc")) {
    return false;
  }

  const uint64_t expected_start = mip1.offset_bytes;
  const uint64_t expected_end = static_cast<uint64_t>(res->size_bytes);

  std::vector<uint8_t> covered(res->size_bytes, 0);
  const size_t stream_len = StreamBytesUsed(buf, len);
  size_t off = sizeof(aerogpu_cmd_stream_header);
  while (off + sizeof(aerogpu_cmd_hdr) <= stream_len) {
    const auto* hdr = reinterpret_cast<const aerogpu_cmd_hdr*>(buf + off);
    if (hdr->opcode == AEROGPU_CMD_UPLOAD_RESOURCE) {
      const auto* cmd = reinterpret_cast<const aerogpu_cmd_upload_resource*>(hdr);
      if (cmd->resource_handle == res->handle) {
        const uint64_t start = cmd->offset_bytes;
        const uint64_t end = start + cmd->size_bytes;
        if (!Check(end <= expected_end, "UPLOAD_RESOURCE range within resource")) {
          return false;
        }
        // Uploads must not touch mip0 bytes.
        if (!Check(start >= expected_start, "UPLOAD_RESOURCE does not touch mip0")) {
          return false;
        }

        if (!CheckUploadResourceWithinSingleTextureSubresource(res, start, end)) {
          return false;
        }

        const uint8_t* payload = reinterpret_cast<const uint8_t*>(cmd) + sizeof(*cmd);
        if (!Check(std::memcmp(payload, res->storage.data() + start, static_cast<size_t>(cmd->size_bytes)) == 0,
                   "UPLOAD_RESOURCE payload matches storage bytes")) {
          return false;
        }

        for (uint64_t i = start; i < end && i < static_cast<uint64_t>(covered.size()); ++i) {
          covered[static_cast<size_t>(i)] = 1;
        }
      }
    }
    if (hdr->size_bytes == 0 || hdr->size_bytes > stream_len - off) {
      break;
    }
    off += hdr->size_bytes;
  }

  for (uint64_t i = expected_start; i < expected_end && i < static_cast<uint64_t>(covered.size()); ++i) {
    if (!Check(covered[static_cast<size_t>(i)] != 0, "UPLOAD_RESOURCE covers full generated mip range")) {
      return false;
    }
  }
  return true;
}

bool TestGenerateMipSubLevelsBoxFilter2dA8R8G8B8PreservesAlpha() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hResource{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_resource = false;

    ~Cleanup() {
      if (has_resource && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hResource);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnGenerateMipSubLevels != nullptr, "GenerateMipSubLevels must be available")) {
    return false;
  }

  // Create a 2x2 texture with 2 mip levels (2x2, 1x1).
  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = kD3dRTypeTexture;
  create_res.format = 21u; // D3DFMT_A8R8G8B8
  create_res.width = 2;
  create_res.height = 2;
  create_res.depth = 1;
  create_res.mip_levels = 2;
  create_res.usage = 0;
  create_res.pool = 0;
  create_res.size = 0;
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr;
  create_res.pPrivateDriverData = nullptr;
  create_res.PrivateDriverDataSize = 0;
  create_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == S_OK, "CreateResource(2x2 A8R8G8B8 texture mips)")) {
    return false;
  }
  cleanup.hResource = create_res.hResource;
  cleanup.has_resource = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  auto* res = reinterpret_cast<Resource*>(create_res.hResource.pDrvPrivate);
  if (!Check(dev != nullptr && res != nullptr, "device/resource pointers")) {
    return false;
  }
  if (!Check(res->mip_levels == 2, "resource mip_levels==2")) {
    return false;
  }
  if (!Check(res->backing_alloc_id == 0, "resource is host-allocated (alloc_id==0)")) {
    return false;
  }
  if (!Check(res->storage.size() >= res->size_bytes, "resource storage sized")) {
    return false;
  }

  // Fill mip0 with a known pattern:
  // BGRA = (0,0,R,A).
  // Expected mip1 is box-filter average in 8-bit space (rounded) and should
  // preserve/average alpha (A8 formats do not force it to opaque).
  const uint32_t row_pitch = res->row_pitch;
  if (!Check(row_pitch == 8u, "mip0 row_pitch==8")) {
    return false;
  }
  uint8_t* base = res->storage.data();
  struct Px {
    uint8_t r;
    uint8_t a;
  };
  const Px px[4] = {
      {0, 0},    // (0,0)
      {10, 20},  // (1,0)
      {30, 40},  // (0,1)
      {50, 60},  // (1,1)
  };
  for (uint32_t y = 0; y < 2; ++y) {
    for (uint32_t x = 0; x < 2; ++x) {
      const Px p = px[y * 2u + x];
      const size_t off = static_cast<size_t>(y) * row_pitch + static_cast<size_t>(x) * 4u;
      base[off + 0] = 0;   // B
      base[off + 1] = 0;   // G
      base[off + 2] = p.r; // R
      base[off + 3] = p.a; // A
    }
  }

  // Clear command buffer so we only observe visibility packets from mip generation.
  dev->cmd.reset();

  hr = cleanup.device_funcs.pfnGenerateMipSubLevels(create_dev.hDevice, create_res.hResource);
  if (!Check(hr == S_OK, "GenerateMipSubLevels")) {
    return false;
  }

  Texture2dMipLevelLayout mip1{};
  if (!Check(calc_texture2d_mip_level_layout(res->format, res->width, res->height, res->mip_levels, res->depth, 1, &mip1),
             "mip1 layout")) {
    return false;
  }
  if (!Check(mip1.width == 1 && mip1.height == 1, "mip1 dims 1x1")) {
    return false;
  }

  // Average R: (0+10+30+50)/4 = 22.5 -> 23 (sum+2)/4 rounding.
  // Average A: (0+20+40+60)/4 = 30.
  const uint8_t expected_mip1[4] = {0, 0, 23, 30};
  if (!Check(mip1.slice_pitch_bytes == sizeof(expected_mip1), "mip1 slice_pitch==4")) {
    return false;
  }
  if (!Check(std::memcmp(res->storage.data() + static_cast<size_t>(mip1.offset_bytes), expected_mip1, sizeof(expected_mip1)) == 0,
             "mip1 bytes match")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  if (!Check(ValidateStream(buf, len), "stream validates")) {
    return false;
  }

  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_UPLOAD_RESOURCE) == 1, "GenerateMipSubLevels emits exactly one UPLOAD_RESOURCE")) {
    return false;
  }
  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_RESOURCE_DIRTY_RANGE) == 0, "GenerateMipSubLevels does not emit DIRTY_RANGE for host alloc")) {
    return false;
  }

  const CmdLoc upload = FindLastOpcode(buf, len, AEROGPU_CMD_UPLOAD_RESOURCE);
  if (!Check(upload.hdr != nullptr, "UPLOAD_RESOURCE packet present")) {
    return false;
  }
  const auto* upload_cmd = reinterpret_cast<const aerogpu_cmd_upload_resource*>(upload.hdr);
  if (!Check(upload_cmd->resource_handle == res->handle, "UPLOAD_RESOURCE resource_handle matches")) {
    return false;
  }
  if (!Check(upload_cmd->offset_bytes == mip1.offset_bytes, "UPLOAD_RESOURCE offset starts at mip1")) {
    return false;
  }
  if (!Check(upload_cmd->size_bytes == static_cast<uint64_t>(res->size_bytes) - mip1.offset_bytes, "UPLOAD_RESOURCE size covers mips")) {
    return false;
  }
  const auto* payload = reinterpret_cast<const uint8_t*>(upload_cmd) + sizeof(*upload_cmd);
  return Check(std::memcmp(payload, expected_mip1, sizeof(expected_mip1)) == 0, "UPLOAD_RESOURCE payload matches mip bytes");
}

bool TestGenerateMipSubLevelsBoxFilter1x1ClampsSourceCoords() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hResource{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_resource = false;

    ~Cleanup() {
      if (has_resource && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hResource);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnGenerateMipSubLevels != nullptr, "GenerateMipSubLevels must be available")) {
    return false;
  }

  // 1x1 texture with 2 mip levels (1x1, 1x1). This forces sx1/sy1 clamping in the
  // 2x2 box filter sampling (sx1/sy1 would otherwise read out-of-bounds).
  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = kD3dRTypeTexture;
  create_res.format = 22u; // D3DFMT_X8R8G8B8
  create_res.width = 1;
  create_res.height = 1;
  create_res.depth = 1;
  create_res.mip_levels = 2;
  create_res.usage = 0;
  create_res.pool = 0;
  create_res.size = 0;
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr;
  create_res.pPrivateDriverData = nullptr;
  create_res.PrivateDriverDataSize = 0;
  create_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == S_OK, "CreateResource(1x1 X8R8G8B8 texture mips)")) {
    return false;
  }
  cleanup.hResource = create_res.hResource;
  cleanup.has_resource = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  auto* res = reinterpret_cast<Resource*>(create_res.hResource.pDrvPrivate);
  if (!Check(dev != nullptr && res != nullptr, "device/resource pointers")) {
    return false;
  }
  if (!Check(res->mip_levels == 2u, "resource mip_levels==2")) {
    return false;
  }
  if (!Check(res->backing_alloc_id == 0, "resource is host-allocated (alloc_id==0)")) {
    return false;
  }
  if (!Check(res->storage.size() >= res->size_bytes, "resource storage sized")) {
    return false;
  }

  // Fill mip0 with BGRA=(0,0,7,0). X is ignored; mipgen must clamp reads to mip0
  // so the generated mip is based only on this texel.
  if (!Check(res->row_pitch == 4u, "mip0 row_pitch==4")) {
    return false;
  }
  res->storage[0] = 0;
  res->storage[1] = 0;
  res->storage[2] = 7;
  res->storage[3] = 0; // X (ignored)

  dev->cmd.reset();

  hr = cleanup.device_funcs.pfnGenerateMipSubLevels(create_dev.hDevice, create_res.hResource);
  if (!Check(hr == S_OK, "GenerateMipSubLevels")) {
    return false;
  }

  Texture2dMipLevelLayout mip1{};
  if (!Check(calc_texture2d_mip_level_layout(res->format, res->width, res->height, res->mip_levels, res->depth, 1, &mip1),
             "mip1 layout")) {
    return false;
  }
  if (!Check(mip1.width == 1 && mip1.height == 1, "mip1 dims 1x1")) {
    return false;
  }

  // X8 formats force alpha to 1.0 (0xFF).
  const uint8_t expected_mip1[4] = {0, 0, 7, 0xFF};
  if (!Check(mip1.slice_pitch_bytes == sizeof(expected_mip1), "mip1 slice_pitch==4")) {
    return false;
  }
  if (!Check(std::memcmp(res->storage.data() + static_cast<size_t>(mip1.offset_bytes), expected_mip1, sizeof(expected_mip1)) == 0,
             "mip1 bytes match")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();
  if (!Check(ValidateStream(buf, len), "stream validates")) {
    return false;
  }

  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_UPLOAD_RESOURCE) == 1, "GenerateMipSubLevels emits exactly one UPLOAD_RESOURCE")) {
    return false;
  }
  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_RESOURCE_DIRTY_RANGE) == 0, "GenerateMipSubLevels does not emit DIRTY_RANGE for host alloc")) {
    return false;
  }

  const CmdLoc upload = FindLastOpcode(buf, len, AEROGPU_CMD_UPLOAD_RESOURCE);
  if (!Check(upload.hdr != nullptr, "UPLOAD_RESOURCE packet present")) {
    return false;
  }
  const auto* upload_cmd = reinterpret_cast<const aerogpu_cmd_upload_resource*>(upload.hdr);
  if (!Check(upload_cmd->resource_handle == res->handle, "UPLOAD_RESOURCE resource_handle matches")) {
    return false;
  }
  if (!Check(upload_cmd->offset_bytes == mip1.offset_bytes, "UPLOAD_RESOURCE offset starts at mip1")) {
    return false;
  }
  if (!Check(upload_cmd->size_bytes == static_cast<uint64_t>(res->size_bytes) - mip1.offset_bytes, "UPLOAD_RESOURCE size covers mips")) {
    return false;
  }
  const auto* payload = reinterpret_cast<const uint8_t*>(upload_cmd) + sizeof(*upload_cmd);
  return Check(std::memcmp(payload, expected_mip1, sizeof(expected_mip1)) == 0, "UPLOAD_RESOURCE payload matches mip bytes");
}

bool TestGenerateMipSubLevelsBoxFilter2dA8B8G8R8ChannelOrder() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hResource{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_resource = false;

    ~Cleanup() {
      if (has_resource && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hResource);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnGenerateMipSubLevels != nullptr, "GenerateMipSubLevels must be available")) {
    return false;
  }

  // 2x2 texture with 2 mips (2x2, 1x1).
  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = kD3dRTypeTexture;
  create_res.format = 32u; // D3DFMT_A8B8G8R8 (little-endian RGBA bytes)
  create_res.width = 2;
  create_res.height = 2;
  create_res.depth = 1;
  create_res.mip_levels = 2;
  create_res.usage = 0;
  create_res.pool = 0;
  create_res.size = 0;
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr;
  create_res.pPrivateDriverData = nullptr;
  create_res.PrivateDriverDataSize = 0;
  create_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == S_OK, "CreateResource(2x2 A8B8G8R8 texture mips)")) {
    return false;
  }
  cleanup.hResource = create_res.hResource;
  cleanup.has_resource = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  auto* res = reinterpret_cast<Resource*>(create_res.hResource.pDrvPrivate);
  if (!Check(dev != nullptr && res != nullptr, "device/resource pointers")) {
    return false;
  }
  if (!Check(res->mip_levels == 2, "resource mip_levels==2")) {
    return false;
  }
  if (!Check(res->backing_alloc_id == 0, "resource is host-allocated (alloc_id==0)")) {
    return false;
  }
  if (!Check(res->storage.size() >= res->size_bytes, "resource storage sized")) {
    return false;
  }

  // Fill mip0 with unique per-channel data to validate byte ordering:
  // A8B8G8R8 is stored as RGBA in little-endian memory.
  if (!Check(res->row_pitch == 8u, "mip0 row_pitch==8")) {
    return false;
  }
  struct Rgba {
    uint8_t r;
    uint8_t g;
    uint8_t b;
    uint8_t a;
  };
  const Rgba px[4] = {
      {0, 1, 2, 3},
      {10, 11, 12, 13},
      {20, 21, 22, 23},
      {30, 31, 32, 33},
  };
  for (uint32_t y = 0; y < 2; ++y) {
    for (uint32_t x = 0; x < 2; ++x) {
      const Rgba p = px[y * 2u + x];
      const size_t off = static_cast<size_t>(y) * res->row_pitch + static_cast<size_t>(x) * 4u;
      res->storage[off + 0] = p.r;
      res->storage[off + 1] = p.g;
      res->storage[off + 2] = p.b;
      res->storage[off + 3] = p.a;
    }
  }

  dev->cmd.reset();
  hr = cleanup.device_funcs.pfnGenerateMipSubLevels(create_dev.hDevice, create_res.hResource);
  if (!Check(hr == S_OK, "GenerateMipSubLevels")) {
    return false;
  }

  Texture2dMipLevelLayout mip1{};
  if (!Check(calc_texture2d_mip_level_layout(res->format, res->width, res->height, res->mip_levels, res->depth, 1, &mip1),
             "mip1 layout")) {
    return false;
  }
  if (!Check(mip1.width == 1 && mip1.height == 1, "mip1 dims 1x1")) {
    return false;
  }

  // Per-channel averages (sum+2)/4 rounding:
  // R: (0+10+20+30)=60 -> 15
  // G: (1+11+21+31)=64 -> 16
  // B: (2+12+22+32)=68 -> 17
  // A: (3+13+23+33)=72 -> 18
  const uint8_t expected_mip1[4] = {15, 16, 17, 18};
  if (!Check(mip1.slice_pitch_bytes == sizeof(expected_mip1), "mip1 slice_pitch==4")) {
    return false;
  }
  if (!Check(std::memcmp(res->storage.data() + static_cast<size_t>(mip1.offset_bytes), expected_mip1, sizeof(expected_mip1)) == 0,
             "mip1 bytes match")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();
  if (!Check(ValidateStream(buf, len), "stream validates")) {
    return false;
  }

  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_UPLOAD_RESOURCE) == 1, "GenerateMipSubLevels emits exactly one UPLOAD_RESOURCE")) {
    return false;
  }
  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_RESOURCE_DIRTY_RANGE) == 0, "GenerateMipSubLevels does not emit DIRTY_RANGE for host alloc")) {
    return false;
  }

  const CmdLoc upload = FindLastOpcode(buf, len, AEROGPU_CMD_UPLOAD_RESOURCE);
  if (!Check(upload.hdr != nullptr, "UPLOAD_RESOURCE packet present")) {
    return false;
  }
  const auto* upload_cmd = reinterpret_cast<const aerogpu_cmd_upload_resource*>(upload.hdr);
  if (!Check(upload_cmd->resource_handle == res->handle, "UPLOAD_RESOURCE resource_handle matches")) {
    return false;
  }
  if (!Check(upload_cmd->offset_bytes == mip1.offset_bytes, "UPLOAD_RESOURCE offset starts at mip1")) {
    return false;
  }
  if (!Check(upload_cmd->size_bytes == static_cast<uint64_t>(res->size_bytes) - mip1.offset_bytes, "UPLOAD_RESOURCE size covers mips")) {
    return false;
  }
  const auto* payload = reinterpret_cast<const uint8_t*>(upload_cmd) + sizeof(*upload_cmd);
  return Check(std::memcmp(payload, expected_mip1, sizeof(expected_mip1)) == 0, "UPLOAD_RESOURCE payload matches mip bytes");
}

bool TestGenerateMipSubLevelsRejectsSingleMipTexture() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hResource{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_resource = false;

    ~Cleanup() {
      if (has_resource && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hResource);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnGenerateMipSubLevels != nullptr, "GenerateMipSubLevels must be available")) {
    return false;
  }

  // Create a non-mipmapped texture (mip_levels==1). GenerateMipSubLevels should
  // reject it.
  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = kD3dRTypeTexture;
  create_res.format = 22u; // D3DFMT_X8R8G8B8
  create_res.width = 4;
  create_res.height = 4;
  create_res.depth = 1;
  create_res.mip_levels = 1;
  create_res.usage = 0;
  create_res.pool = 0;
  create_res.size = 0;
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr;
  create_res.pPrivateDriverData = nullptr;
  create_res.PrivateDriverDataSize = 0;
  create_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == S_OK, "CreateResource(single-mip texture)")) {
    return false;
  }
  cleanup.hResource = create_res.hResource;
  cleanup.has_resource = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  dev->cmd.reset();
  hr = cleanup.device_funcs.pfnGenerateMipSubLevels(create_dev.hDevice, create_res.hResource);
  if (!Check(hr == kD3DErrInvalidCall, "GenerateMipSubLevels(single-mip) returns D3DERR_INVALIDCALL")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();
  if (!Check(ValidateStream(buf, len), "stream validates")) {
    return false;
  }
  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_UPLOAD_RESOURCE) == 0, "no UPLOAD_RESOURCE emitted on failure")) {
    return false;
  }
  return Check(CountOpcode(buf, len, AEROGPU_CMD_RESOURCE_DIRTY_RANGE) == 0, "no DIRTY_RANGE emitted on failure");
}

bool TestGenerateMipSubLevelsRejectsLockedTexture() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hResource{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_resource = false;

    ~Cleanup() {
      if (has_resource && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hResource);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnGenerateMipSubLevels != nullptr, "GenerateMipSubLevels must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnLock != nullptr && cleanup.device_funcs.pfnUnlock != nullptr, "Lock/Unlock must be available")) {
    return false;
  }

  // Create a mipmapped texture and lock it. GenerateMipSubLevels should reject
  // the call while the resource is locked.
  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = kD3dRTypeTexture;
  create_res.format = 22u; // D3DFMT_X8R8G8B8
  create_res.width = 4;
  create_res.height = 4;
  create_res.depth = 1;
  create_res.mip_levels = 2;
  create_res.usage = 0;
  create_res.pool = 0;
  create_res.size = 0;
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr;
  create_res.pPrivateDriverData = nullptr;
  create_res.PrivateDriverDataSize = 0;
  create_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == S_OK, "CreateResource(mipmapped texture)")) {
    return false;
  }
  cleanup.hResource = create_res.hResource;
  cleanup.has_resource = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  // Lock read-only to avoid any upload/dirty packets during unlock.
  D3D9DDIARG_LOCK lock{};
  lock.hResource = create_res.hResource;
  lock.offset_bytes = 0;
  lock.size_bytes = 0;
  lock.flags = 0x00000010u; // D3DLOCK_READONLY
  D3DDDI_LOCKEDBOX box{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(readonly)")) {
    return false;
  }

  dev->cmd.reset();
  hr = cleanup.device_funcs.pfnGenerateMipSubLevels(create_dev.hDevice, create_res.hResource);
  if (!Check(hr == kD3DErrInvalidCall, "GenerateMipSubLevels(locked) returns D3DERR_INVALIDCALL")) {
    return false;
  }

  D3D9DDIARG_UNLOCK unlock{};
  unlock.hResource = create_res.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(readonly)")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();
  if (!Check(ValidateStream(buf, len), "stream validates")) {
    return false;
  }
  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_UPLOAD_RESOURCE) == 0, "no UPLOAD_RESOURCE emitted on failure")) {
    return false;
  }
  return Check(CountOpcode(buf, len, AEROGPU_CMD_RESOURCE_DIRTY_RANGE) == 0, "no DIRTY_RANGE emitted on failure");
}

bool TestGenerateMipSubLevelsRejectsDepthStencilFormat() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hResource{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_resource = false;

    ~Cleanup() {
      if (has_resource && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hResource);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnGenerateMipSubLevels != nullptr, "GenerateMipSubLevels must be available")) {
    return false;
  }

  // Create a depth/stencil texture. Even if mipmapped, mip generation should be
  // unsupported and must fail cleanly.
  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = kD3dRTypeTexture;
  create_res.format = 75u; // D3DFMT_D24S8
  create_res.width = 4;
  create_res.height = 4;
  create_res.depth = 1;
  create_res.mip_levels = 2;
  create_res.usage = 0x00000002u; // D3DUSAGE_DEPTHSTENCIL
  create_res.pool = 0;
  create_res.size = 0;
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr;
  create_res.pPrivateDriverData = nullptr;
  create_res.PrivateDriverDataSize = 0;
  create_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == S_OK, "CreateResource(depth-stencil texture)")) {
    return false;
  }
  cleanup.hResource = create_res.hResource;
  cleanup.has_resource = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  dev->cmd.reset();
  hr = cleanup.device_funcs.pfnGenerateMipSubLevels(create_dev.hDevice, create_res.hResource);
  if (!Check(hr == kD3DErrInvalidCall, "GenerateMipSubLevels(D24S8) returns D3DERR_INVALIDCALL")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();
  if (!Check(ValidateStream(buf, len), "stream validates")) {
    return false;
  }
  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_UPLOAD_RESOURCE) == 0, "no UPLOAD_RESOURCE emitted on failure")) {
    return false;
  }
  return Check(CountOpcode(buf, len, AEROGPU_CMD_RESOURCE_DIRTY_RANGE) == 0, "no DIRTY_RANGE emitted on failure");
}

bool TestGenerateMipSubLevelsBoxFilterCubeTexture() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hResource{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_resource = false;

    ~Cleanup() {
      if (has_resource && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hResource);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnGenerateMipSubLevels != nullptr, "GenerateMipSubLevels must be available")) {
    return false;
  }

  // Create a 4x4 cube texture with 3 mip levels (4x4, 2x2, 1x1).
  // Cube textures are represented as array textures with 6 layers.
  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = kD3dRTypeCubeTexture;
  create_res.format = 22u; // D3DFMT_X8R8G8B8
  create_res.width = 4;
  create_res.height = 4;
  create_res.depth = 1; // ignored/normalized by driver for cube textures
  create_res.mip_levels = 3;
  create_res.usage = 0;
  create_res.pool = 0;
  create_res.size = 0;
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr;
  create_res.pPrivateDriverData = nullptr;
  create_res.PrivateDriverDataSize = 0;
  create_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == S_OK, "CreateResource(cube texture mips)")) {
    return false;
  }
  cleanup.hResource = create_res.hResource;
  cleanup.has_resource = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  auto* res = reinterpret_cast<Resource*>(create_res.hResource.pDrvPrivate);
  if (!Check(dev != nullptr && res != nullptr, "device/resource pointers")) {
    return false;
  }
  if (!Check(res->depth == 6u, "cube texture normalized to depth==6")) {
    return false;
  }
  if (!Check(res->mip_levels == 3u, "resource mip_levels==3")) {
    return false;
  }
  if (!Check(res->backing_alloc_id == 0, "resource is host-allocated (alloc_id==0)")) {
    return false;
  }
  if (!Check(res->storage.size() >= res->size_bytes, "resource storage sized")) {
    return false;
  }

  Texture2dLayout full_layout{};
  if (!Check(calc_texture2d_layout(res->format, res->width, res->height, res->mip_levels, res->depth, &full_layout), "full layout")) {
    return false;
  }
  const uint64_t layer_size = full_layout.total_size_bytes / static_cast<uint64_t>(res->depth);

  Texture2dMipLevelLayout mip1{};
  Texture2dMipLevelLayout mip2{};
  if (!Check(calc_texture2d_mip_level_layout(res->format, res->width, res->height, res->mip_levels, res->depth, 1, &mip1), "mip1 layout")) {
    return false;
  }
  if (!Check(calc_texture2d_mip_level_layout(res->format, res->width, res->height, res->mip_levels, res->depth, 2, &mip2), "mip2 layout")) {
    return false;
  }

  // Fill each face's mip0 with a known pattern:
  // R = face_base + (x + y*4), G = 0, B = 0, X (alpha) = 0. Mip gen should force alpha to 0xFF.
  const uint32_t row_pitch = res->row_pitch;
  if (!Check(row_pitch == 16u, "mip0 row_pitch==16")) {
    return false;
  }
  constexpr uint32_t kFaces = 6u;
  for (uint32_t face = 0; face < kFaces; ++face) {
    const uint8_t face_base = static_cast<uint8_t>(face * 40u);
    const uint64_t base_off = static_cast<uint64_t>(face) * layer_size;
    for (uint32_t y = 0; y < 4; ++y) {
      for (uint32_t x = 0; x < 4; ++x) {
        const uint8_t r = static_cast<uint8_t>(face_base + x + y * 4u);
        const size_t off = static_cast<size_t>(base_off) + static_cast<size_t>(y) * row_pitch + static_cast<size_t>(x) * 4u;
        res->storage[off + 0] = 0; // B
        res->storage[off + 1] = 0; // G
        res->storage[off + 2] = r; // R
        res->storage[off + 3] = 0; // X
      }
    }
  }

  dev->cmd.reset();
  hr = cleanup.device_funcs.pfnGenerateMipSubLevels(create_dev.hDevice, create_res.hResource);
  if (!Check(hr == S_OK, "GenerateMipSubLevels")) {
    return false;
  }

  for (uint32_t face = 0; face < kFaces; ++face) {
    const uint8_t face_base = static_cast<uint8_t>(face * 40u);
    const uint8_t expected_mip1[16] = {
        0, 0, static_cast<uint8_t>(face_base + 3u), 0xFF, 0, 0, static_cast<uint8_t>(face_base + 5u), 0xFF,
        0, 0, static_cast<uint8_t>(face_base + 11u), 0xFF, 0, 0, static_cast<uint8_t>(face_base + 13u), 0xFF,
    };
    const uint8_t expected_mip2[4] = {0, 0, static_cast<uint8_t>(face_base + 8u), 0xFF};

    const uint64_t mip1_off = static_cast<uint64_t>(face) * layer_size + mip1.offset_bytes;
    const uint64_t mip2_off = static_cast<uint64_t>(face) * layer_size + mip2.offset_bytes;
    if (!Check(std::memcmp(res->storage.data() + static_cast<size_t>(mip1_off), expected_mip1, sizeof(expected_mip1)) == 0,
               "cube face mip1 bytes match")) {
      return false;
    }
    if (!Check(std::memcmp(res->storage.data() + static_cast<size_t>(mip2_off), expected_mip2, sizeof(expected_mip2)) == 0,
               "cube face mip2 bytes match")) {
      return false;
    }
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();
  if (!Check(ValidateStream(buf, len), "stream validates")) {
    return false;
  }

  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_RESOURCE_DIRTY_RANGE) == 0,
             "GenerateMipSubLevels does not emit DIRTY_RANGE for host alloc")) {
    return false;
  }
  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_UPLOAD_RESOURCE) >= kFaces,
             "GenerateMipSubLevels emits UPLOAD_RESOURCE for each cube face")) {
    return false;
  }

  // Ensure uploads cover each face's "mip1..end-of-layer" range and do not upload any mip0 bytes.
  const uint64_t mip0_end = mip1.offset_bytes;
  std::vector<uint8_t> covered(static_cast<size_t>(full_layout.total_size_bytes), 0);
  const size_t stream_len = StreamBytesUsed(buf, len);
  size_t off = sizeof(aerogpu_cmd_stream_header);
  while (off + sizeof(aerogpu_cmd_hdr) <= stream_len) {
    const auto* hdr = reinterpret_cast<const aerogpu_cmd_hdr*>(buf + off);
    if (hdr->opcode == AEROGPU_CMD_UPLOAD_RESOURCE) {
      const auto* cmd = reinterpret_cast<const aerogpu_cmd_upload_resource*>(hdr);
      if (cmd->resource_handle == res->handle) {
        const uint64_t start = cmd->offset_bytes;
        const uint64_t end = start + cmd->size_bytes;
        if (!Check(end <= static_cast<uint64_t>(res->size_bytes), "UPLOAD_RESOURCE range within resource")) {
          return false;
        }

        // Uploads must not include any mip0 bytes from any face.
        for (uint32_t face = 0; face < kFaces; ++face) {
          const uint64_t face_mip0_start = static_cast<uint64_t>(face) * layer_size;
          const uint64_t face_mip0_end = face_mip0_start + mip0_end;
          if (!Check(!(start < face_mip0_end && end > face_mip0_start), "UPLOAD_RESOURCE does not touch face mip0")) {
            return false;
          }
        }

        if (!CheckUploadResourceWithinSingleTextureSubresource(res, start, end)) {
          return false;
        }

        // Payload must match storage bytes.
        const uint8_t* payload = reinterpret_cast<const uint8_t*>(cmd) + sizeof(*cmd);
        if (!Check(std::memcmp(payload, res->storage.data() + start, static_cast<size_t>(cmd->size_bytes)) == 0,
                   "UPLOAD_RESOURCE payload matches storage bytes")) {
          return false;
        }

        for (uint64_t i = start; i < end && i < static_cast<uint64_t>(covered.size()); ++i) {
          covered[static_cast<size_t>(i)] = 1;
        }
      }
    }
    if (hdr->size_bytes == 0 || hdr->size_bytes > stream_len - off) {
      break;
    }
    off += hdr->size_bytes;
  }

  for (uint32_t face = 0; face < kFaces; ++face) {
    const uint64_t start = static_cast<uint64_t>(face) * layer_size + mip1.offset_bytes;
    const uint64_t end = static_cast<uint64_t>(face + 1u) * layer_size;
    for (uint64_t i = start; i < end && i < static_cast<uint64_t>(covered.size()); ++i) {
      if (!Check(covered[static_cast<size_t>(i)] != 0, "UPLOAD_RESOURCE covers full generated mip range")) {
        return false;
      }
    }
  }

  return true;
}

bool TestGenerateMipSubLevelsBoxFilter2dArrayTexture() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hResource{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_resource = false;

    ~Cleanup() {
      if (has_resource && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hResource);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnGenerateMipSubLevels != nullptr, "GenerateMipSubLevels must be available")) {
    return false;
  }

  // D3DRESOURCETYPE::D3DRTYPE_TEXTURE == 3 (used by the portable UMD to interpret depth>1 as array layers).
  constexpr uint32_t kD3dRTypeTexture = 3u;
  constexpr uint32_t kArrayLayers = 2u;

  // Create a 4x4 array texture with 2 layers and 3 mip levels (4x4, 2x2, 1x1).
  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = kD3dRTypeTexture;
  create_res.format = 22u; // D3DFMT_X8R8G8B8
  create_res.width = 4;
  create_res.height = 4;
  create_res.depth = kArrayLayers;
  create_res.mip_levels = 3;
  create_res.usage = 0;
  create_res.pool = 0;
  create_res.size = 0;
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr;
  create_res.pPrivateDriverData = nullptr;
  create_res.PrivateDriverDataSize = 0;
  create_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == S_OK, "CreateResource(array texture mips)")) {
    return false;
  }
  cleanup.hResource = create_res.hResource;
  cleanup.has_resource = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  auto* res = reinterpret_cast<Resource*>(create_res.hResource.pDrvPrivate);
  if (!Check(dev != nullptr && res != nullptr, "device/resource pointers")) {
    return false;
  }
  if (!Check(res->depth == kArrayLayers, "resource depth==array_layers")) {
    return false;
  }
  if (!Check(res->mip_levels == 3u, "resource mip_levels==3")) {
    return false;
  }
  if (!Check(res->backing_alloc_id == 0, "resource is host-allocated (alloc_id==0)")) {
    return false;
  }
  if (!Check(res->storage.size() >= res->size_bytes, "resource storage sized")) {
    return false;
  }

  Texture2dLayout full_layout{};
  if (!Check(calc_texture2d_layout(res->format, res->width, res->height, res->mip_levels, res->depth, &full_layout), "full layout")) {
    return false;
  }
  const uint64_t layer_size = full_layout.total_size_bytes / static_cast<uint64_t>(res->depth);

  Texture2dMipLevelLayout mip1{};
  Texture2dMipLevelLayout mip2{};
  if (!Check(calc_texture2d_mip_level_layout(res->format, res->width, res->height, res->mip_levels, res->depth, 1, &mip1), "mip1 layout")) {
    return false;
  }
  if (!Check(calc_texture2d_mip_level_layout(res->format, res->width, res->height, res->mip_levels, res->depth, 2, &mip2), "mip2 layout")) {
    return false;
  }

  // Fill each layer's mip0 with a known pattern:
  // R = layer_base + (x + y*4), G = 0, B = 0, X (alpha) = 0. Mip gen should force alpha to 0xFF.
  const uint32_t row_pitch = res->row_pitch;
  if (!Check(row_pitch == 16u, "mip0 row_pitch==16")) {
    return false;
  }
  for (uint32_t layer = 0; layer < kArrayLayers; ++layer) {
    const uint64_t base_off = static_cast<uint64_t>(layer) * layer_size;
    for (uint32_t y = 0; y < 4; ++y) {
      for (uint32_t x = 0; x < 4; ++x) {
        const uint8_t r = static_cast<uint8_t>(static_cast<uint32_t>(layer) * 100u + x + y * 4u);
        const size_t off = static_cast<size_t>(base_off) + static_cast<size_t>(y) * row_pitch + static_cast<size_t>(x) * 4u;
        res->storage[off + 0] = 0; // B
        res->storage[off + 1] = 0; // G
        res->storage[off + 2] = r; // R
        res->storage[off + 3] = 0; // X (ignored)
      }
    }
  }

  // Clear command buffer so we only observe visibility packets from mip generation.
  dev->cmd.reset();

  hr = cleanup.device_funcs.pfnGenerateMipSubLevels(create_dev.hDevice, create_res.hResource);
  if (!Check(hr == S_OK, "GenerateMipSubLevels")) {
    return false;
  }

  const uint8_t expected_mip1_layer0[16] = {
      0, 0, 3, 0xFF, 0, 0, 5, 0xFF,
      0, 0, 11, 0xFF, 0, 0, 13, 0xFF,
  };
  const uint8_t expected_mip2_layer0[4] = {0, 0, 8, 0xFF};
  const uint8_t expected_mip1_layer1[16] = {
      0, 0, 103, 0xFF, 0, 0, 105, 0xFF,
      0, 0, 111, 0xFF, 0, 0, 113, 0xFF,
  };
  const uint8_t expected_mip2_layer1[4] = {0, 0, 108, 0xFF};

  const uint64_t mip1_layer0_off = 0ull * layer_size + mip1.offset_bytes;
  const uint64_t mip2_layer0_off = 0ull * layer_size + mip2.offset_bytes;
  const uint64_t mip1_layer1_off = 1ull * layer_size + mip1.offset_bytes;
  const uint64_t mip2_layer1_off = 1ull * layer_size + mip2.offset_bytes;

  if (!Check(std::memcmp(res->storage.data() + static_cast<size_t>(mip1_layer0_off), expected_mip1_layer0, sizeof(expected_mip1_layer0)) == 0,
             "layer0 mip1 bytes match")) {
    return false;
  }
  if (!Check(std::memcmp(res->storage.data() + static_cast<size_t>(mip2_layer0_off), expected_mip2_layer0, sizeof(expected_mip2_layer0)) == 0,
             "layer0 mip2 bytes match")) {
    return false;
  }
  if (!Check(std::memcmp(res->storage.data() + static_cast<size_t>(mip1_layer1_off), expected_mip1_layer1, sizeof(expected_mip1_layer1)) == 0,
             "layer1 mip1 bytes match")) {
    return false;
  }
  if (!Check(std::memcmp(res->storage.data() + static_cast<size_t>(mip2_layer1_off), expected_mip2_layer1, sizeof(expected_mip2_layer1)) == 0,
             "layer1 mip2 bytes match")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();
  if (!Check(ValidateStream(buf, len), "stream validates")) {
    return false;
  }

  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_RESOURCE_DIRTY_RANGE) == 0,
             "GenerateMipSubLevels does not emit DIRTY_RANGE for host alloc")) {
    return false;
  }
  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_UPLOAD_RESOURCE) >= kArrayLayers,
             "GenerateMipSubLevels emits UPLOAD_RESOURCE for each array layer")) {
    return false;
  }

  // Ensure uploads cover each layer's "mip1..end-of-layer" range and do not upload any mip0 bytes.
  const uint64_t layer0_mip0_end = 0ull * layer_size + mip1.offset_bytes;
  const uint64_t layer1_mip0_start = 1ull * layer_size;
  const uint64_t layer1_mip0_end = 1ull * layer_size + mip1.offset_bytes;

  std::vector<uint8_t> covered(static_cast<size_t>(full_layout.total_size_bytes), 0);
  const size_t stream_len = StreamBytesUsed(buf, len);
  size_t off = sizeof(aerogpu_cmd_stream_header);
  while (off + sizeof(aerogpu_cmd_hdr) <= stream_len) {
    const auto* hdr = reinterpret_cast<const aerogpu_cmd_hdr*>(buf + off);
    if (hdr->opcode == AEROGPU_CMD_UPLOAD_RESOURCE) {
      const auto* cmd = reinterpret_cast<const aerogpu_cmd_upload_resource*>(hdr);
      if (cmd->resource_handle == res->handle) {
        const uint64_t start = cmd->offset_bytes;
        const uint64_t end = start + cmd->size_bytes;
        if (!Check(end <= static_cast<uint64_t>(res->size_bytes), "UPLOAD_RESOURCE range within resource")) {
          return false;
        }

        // Uploads must not include any mip0 bytes from either layer.
        if (!Check(!(start < layer0_mip0_end && end > 0), "UPLOAD_RESOURCE does not touch layer0 mip0")) {
          return false;
        }
        if (!Check(!(start < layer1_mip0_end && end > layer1_mip0_start), "UPLOAD_RESOURCE does not touch layer1 mip0")) {
          return false;
        }

        if (!CheckUploadResourceWithinSingleTextureSubresource(res, start, end)) {
          return false;
        }

        // Payload must match storage bytes.
        const uint8_t* payload = reinterpret_cast<const uint8_t*>(cmd) + sizeof(*cmd);
        if (!Check(std::memcmp(payload, res->storage.data() + start, static_cast<size_t>(cmd->size_bytes)) == 0,
                   "UPLOAD_RESOURCE payload matches storage bytes")) {
          return false;
        }

        for (uint64_t i = start; i < end && i < static_cast<uint64_t>(covered.size()); ++i) {
          covered[static_cast<size_t>(i)] = 1;
        }
      }
    }
    if (hdr->size_bytes == 0 || hdr->size_bytes > stream_len - off) {
      break;
    }
    off += hdr->size_bytes;
  }

  for (uint32_t layer = 0; layer < kArrayLayers; ++layer) {
    const uint64_t start = static_cast<uint64_t>(layer) * layer_size + mip1.offset_bytes;
    const uint64_t end = static_cast<uint64_t>(layer + 1u) * layer_size;
    for (uint64_t i = start; i < end && i < static_cast<uint64_t>(covered.size()); ++i) {
      if (!Check(covered[static_cast<size_t>(i)] != 0, "UPLOAD_RESOURCE covers full generated mip range")) {
        return false;
      }
    }
  }

  return true;
}

bool TestGenerateMipSubLevelsBoxFilter2dX1R5G5B5() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hResource{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_resource = false;

    ~Cleanup() {
      if (has_resource && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hResource);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnGenerateMipSubLevels != nullptr, "GenerateMipSubLevels must be available")) {
    return false;
  }

  // Create a 4x4 texture with 3 mip levels (4x4, 2x2, 1x1).
  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = kD3dRTypeTexture;
  create_res.format = 24u; // D3DFMT_X1R5G5B5
  create_res.width = 4;
  create_res.height = 4;
  create_res.depth = 1;
  create_res.mip_levels = 3;
  create_res.usage = 0;
  create_res.pool = 0;
  create_res.size = 0;
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr;
  create_res.pPrivateDriverData = nullptr;
  create_res.PrivateDriverDataSize = 0;
  create_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == S_OK, "CreateResource(4x4 X1R5G5B5 texture mips)")) {
    return false;
  }
  cleanup.hResource = create_res.hResource;
  cleanup.has_resource = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  auto* res = reinterpret_cast<Resource*>(create_res.hResource.pDrvPrivate);
  if (!Check(dev != nullptr && res != nullptr, "device/resource pointers")) {
    return false;
  }
  if (!Check(res->mip_levels == 3, "resource mip_levels==3")) {
    return false;
  }
  if (!Check(res->backing_alloc_id == 0, "resource is host-allocated (alloc_id==0)")) {
    return false;
  }
  if (!Check(res->storage.size() >= res->size_bytes, "resource storage sized")) {
    return false;
  }

  // Fill mip0 with a known pattern in the R channel:
  // R5 = x + y*4, G5 = 0, B5 = 0. (Input X bit left clear; mipgen should force it to 1 in generated mips.)
  const uint32_t row_pitch = res->row_pitch;
  if (!Check(row_pitch == 8u, "mip0 row_pitch==8")) {
    return false;
  }
  uint8_t* base = res->storage.data();
  for (uint32_t y = 0; y < 4; ++y) {
    for (uint32_t x = 0; x < 4; ++x) {
      const uint16_t r5 = static_cast<uint16_t>(x + y * 4u);
      const uint16_t v = static_cast<uint16_t>((r5 << 10));
      const size_t off = static_cast<size_t>(y) * row_pitch + static_cast<size_t>(x) * 2u;
      base[off + 0] = static_cast<uint8_t>(v & 0xFFu);
      base[off + 1] = static_cast<uint8_t>((v >> 8) & 0xFFu);
    }
  }

  // Clear command buffer so we only observe visibility packets from mip generation.
  dev->cmd.reset();

  hr = cleanup.device_funcs.pfnGenerateMipSubLevels(create_dev.hDevice, create_res.hResource);
  if (!Check(hr == S_OK, "GenerateMipSubLevels")) {
    return false;
  }

  Texture2dMipLevelLayout mip1{};
  Texture2dMipLevelLayout mip2{};
  if (!Check(calc_texture2d_mip_level_layout(res->format, res->width, res->height, res->mip_levels, res->depth, 1, &mip1),
             "mip1 layout")) {
    return false;
  }
  if (!Check(calc_texture2d_mip_level_layout(res->format, res->width, res->height, res->mip_levels, res->depth, 2, &mip2),
             "mip2 layout")) {
    return false;
  }
  if (!Check(mip1.width == 2 && mip1.height == 2, "mip1 dims 2x2")) {
    return false;
  }
  if (!Check(mip2.width == 1 && mip2.height == 1, "mip2 dims 1x1")) {
    return false;
  }

  // Expected results (box filter in decoded 8-bit space, then quantized back to 5-bit):
  // mip1 R5 values: {3, 4, 11, 13}; mip2 R5 value: {8}. X bit forced to 1.
  const uint8_t expected_mip1[8] = {
      0x00, 0x8C, 0x00, 0x90,
      0x00, 0xAC, 0x00, 0xB4,
  };
  const uint8_t expected_mip2[2] = {0x00, 0xA0};

  if (!Check(mip1.slice_pitch_bytes == sizeof(expected_mip1), "mip1 slice_pitch==8")) {
    return false;
  }
  if (!Check(mip2.slice_pitch_bytes == sizeof(expected_mip2), "mip2 slice_pitch==2")) {
    return false;
  }

  if (!Check(std::memcmp(res->storage.data() + static_cast<size_t>(mip1.offset_bytes), expected_mip1, sizeof(expected_mip1)) == 0,
             "mip1 bytes match")) {
    return false;
  }
  if (!Check(std::memcmp(res->storage.data() + static_cast<size_t>(mip2.offset_bytes), expected_mip2, sizeof(expected_mip2)) == 0,
             "mip2 bytes match")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  if (!Check(ValidateStream(buf, len), "stream validates")) {
    return false;
  }

  // Host-allocated textures should embed updates via UPLOAD_RESOURCE.
  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_UPLOAD_RESOURCE) >= 1, "GenerateMipSubLevels emits UPLOAD_RESOURCE")) {
    return false;
  }
  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_RESOURCE_DIRTY_RANGE) == 0, "GenerateMipSubLevels does not emit DIRTY_RANGE for host alloc")) {
    return false;
  }

  const uint64_t expected_start = mip1.offset_bytes;
  const uint64_t expected_end = static_cast<uint64_t>(res->size_bytes);

  std::vector<uint8_t> covered(res->size_bytes, 0);
  const size_t stream_len = StreamBytesUsed(buf, len);
  size_t off = sizeof(aerogpu_cmd_stream_header);
  while (off + sizeof(aerogpu_cmd_hdr) <= stream_len) {
    const auto* hdr = reinterpret_cast<const aerogpu_cmd_hdr*>(buf + off);
    if (hdr->opcode == AEROGPU_CMD_UPLOAD_RESOURCE) {
      const auto* cmd = reinterpret_cast<const aerogpu_cmd_upload_resource*>(hdr);
      if (cmd->resource_handle == res->handle) {
        const uint64_t start = cmd->offset_bytes;
        const uint64_t end = start + cmd->size_bytes;
        if (!Check(end <= expected_end, "UPLOAD_RESOURCE range within resource")) {
          return false;
        }
        if (!Check(start >= expected_start, "UPLOAD_RESOURCE does not touch mip0")) {
          return false;
        }

        if (!CheckUploadResourceWithinSingleTextureSubresource(res, start, end)) {
          return false;
        }

        const uint8_t* payload = reinterpret_cast<const uint8_t*>(cmd) + sizeof(*cmd);
        if (!Check(std::memcmp(payload, res->storage.data() + start, static_cast<size_t>(cmd->size_bytes)) == 0,
                   "UPLOAD_RESOURCE payload matches storage bytes")) {
          return false;
        }

        for (uint64_t i = start; i < end && i < static_cast<uint64_t>(covered.size()); ++i) {
          covered[static_cast<size_t>(i)] = 1;
        }
      }
    }
    if (hdr->size_bytes == 0 || hdr->size_bytes > stream_len - off) {
      break;
    }
    off += hdr->size_bytes;
  }

  for (uint64_t i = expected_start; i < expected_end && i < static_cast<uint64_t>(covered.size()); ++i) {
    if (!Check(covered[static_cast<size_t>(i)] != 0, "UPLOAD_RESOURCE covers full generated mip range")) {
      return false;
    }
  }
  return true;
}

bool TestGenerateMipSubLevelsBoxFilter2dR5G6B5() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hResource{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_resource = false;

    ~Cleanup() {
      if (has_resource && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hResource);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnGenerateMipSubLevels != nullptr, "GenerateMipSubLevels must be available")) {
    return false;
  }

  // Create a 4x4 texture with 3 mip levels (4x4, 2x2, 1x1).
  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = kD3dRTypeTexture;
  create_res.format = 23u; // D3DFMT_R5G6B5
  create_res.width = 4;
  create_res.height = 4;
  create_res.depth = 1;
  create_res.mip_levels = 3;
  create_res.usage = 0;
  create_res.pool = 0;
  create_res.size = 0;
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr;
  create_res.pPrivateDriverData = nullptr;
  create_res.PrivateDriverDataSize = 0;
  create_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == S_OK, "CreateResource(4x4 R5G6B5 texture mips)")) {
    return false;
  }
  cleanup.hResource = create_res.hResource;
  cleanup.has_resource = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  auto* res = reinterpret_cast<Resource*>(create_res.hResource.pDrvPrivate);
  if (!Check(dev != nullptr && res != nullptr, "device/resource pointers")) {
    return false;
  }
  if (!Check(res->mip_levels == 3, "resource mip_levels==3")) {
    return false;
  }
  if (!Check(res->backing_alloc_id == 0, "resource is host-allocated (alloc_id==0)")) {
    return false;
  }
  if (!Check(res->storage.size() >= res->size_bytes, "resource storage sized")) {
    return false;
  }

  // Fill mip0 with a known pattern in the R channel:
  // R5 = x + y*4, G6 = 0, B5 = 0.
  const uint32_t row_pitch = res->row_pitch;
  if (!Check(row_pitch == 8u, "mip0 row_pitch==8")) {
    return false;
  }
  uint8_t* base = res->storage.data();
  for (uint32_t y = 0; y < 4; ++y) {
    for (uint32_t x = 0; x < 4; ++x) {
      const uint16_t r5 = static_cast<uint16_t>(x + y * 4u);
      const uint16_t v = static_cast<uint16_t>((r5 << 11));
      const size_t off = static_cast<size_t>(y) * row_pitch + static_cast<size_t>(x) * 2u;
      base[off + 0] = static_cast<uint8_t>(v & 0xFFu);
      base[off + 1] = static_cast<uint8_t>((v >> 8) & 0xFFu);
    }
  }

  // Clear command buffer so we only observe visibility packets from mip generation.
  dev->cmd.reset();

  hr = cleanup.device_funcs.pfnGenerateMipSubLevels(create_dev.hDevice, create_res.hResource);
  if (!Check(hr == S_OK, "GenerateMipSubLevels")) {
    return false;
  }

  Texture2dMipLevelLayout mip1{};
  Texture2dMipLevelLayout mip2{};
  if (!Check(calc_texture2d_mip_level_layout(res->format, res->width, res->height, res->mip_levels, res->depth, 1, &mip1),
             "mip1 layout")) {
    return false;
  }
  if (!Check(calc_texture2d_mip_level_layout(res->format, res->width, res->height, res->mip_levels, res->depth, 2, &mip2),
             "mip2 layout")) {
    return false;
  }
  if (!Check(mip1.width == 2 && mip1.height == 2, "mip1 dims 2x2")) {
    return false;
  }
  if (!Check(mip2.width == 1 && mip2.height == 1, "mip2 dims 1x1")) {
    return false;
  }

  // Expected results (box filter in decoded 8-bit space, then quantized back to 5-bit):
  // mip1 R5 values: {3, 4, 11, 13}; mip2 R5 value: {8}.
  const uint8_t expected_mip1[8] = {
      0x00, 0x18, 0x00, 0x20,
      0x00, 0x58, 0x00, 0x68,
  };
  const uint8_t expected_mip2[2] = {0x00, 0x40};

  if (!Check(mip1.slice_pitch_bytes == sizeof(expected_mip1), "mip1 slice_pitch==8")) {
    return false;
  }
  if (!Check(mip2.slice_pitch_bytes == sizeof(expected_mip2), "mip2 slice_pitch==2")) {
    return false;
  }

  if (!Check(std::memcmp(res->storage.data() + static_cast<size_t>(mip1.offset_bytes), expected_mip1, sizeof(expected_mip1)) == 0,
             "mip1 bytes match")) {
    return false;
  }
  if (!Check(std::memcmp(res->storage.data() + static_cast<size_t>(mip2.offset_bytes), expected_mip2, sizeof(expected_mip2)) == 0,
             "mip2 bytes match")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  if (!Check(ValidateStream(buf, len), "stream validates")) {
    return false;
  }

  // Host-allocated textures should embed updates via UPLOAD_RESOURCE.
  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_UPLOAD_RESOURCE) >= 1, "GenerateMipSubLevels emits UPLOAD_RESOURCE")) {
    return false;
  }
  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_RESOURCE_DIRTY_RANGE) == 0, "GenerateMipSubLevels does not emit DIRTY_RANGE for host alloc")) {
    return false;
  }

  const uint64_t expected_start = mip1.offset_bytes;
  const uint64_t expected_end = static_cast<uint64_t>(res->size_bytes);

  std::vector<uint8_t> covered(res->size_bytes, 0);
  const size_t stream_len = StreamBytesUsed(buf, len);
  size_t off = sizeof(aerogpu_cmd_stream_header);
  while (off + sizeof(aerogpu_cmd_hdr) <= stream_len) {
    const auto* hdr = reinterpret_cast<const aerogpu_cmd_hdr*>(buf + off);
    if (hdr->opcode == AEROGPU_CMD_UPLOAD_RESOURCE) {
      const auto* cmd = reinterpret_cast<const aerogpu_cmd_upload_resource*>(hdr);
      if (cmd->resource_handle == res->handle) {
        const uint64_t start = cmd->offset_bytes;
        const uint64_t end = start + cmd->size_bytes;
        if (!Check(end <= expected_end, "UPLOAD_RESOURCE range within resource")) {
          return false;
        }
        if (!Check(start >= expected_start, "UPLOAD_RESOURCE does not touch mip0")) {
          return false;
        }

        if (!CheckUploadResourceWithinSingleTextureSubresource(res, start, end)) {
          return false;
        }

        const uint8_t* payload = reinterpret_cast<const uint8_t*>(cmd) + sizeof(*cmd);
        if (!Check(std::memcmp(payload, res->storage.data() + start, static_cast<size_t>(cmd->size_bytes)) == 0,
                   "UPLOAD_RESOURCE payload matches storage bytes")) {
          return false;
        }

        for (uint64_t i = start; i < end && i < static_cast<uint64_t>(covered.size()); ++i) {
          covered[static_cast<size_t>(i)] = 1;
        }
      }
    }
    if (hdr->size_bytes == 0 || hdr->size_bytes > stream_len - off) {
      break;
    }
    off += hdr->size_bytes;
  }

  for (uint64_t i = expected_start; i < expected_end && i < static_cast<uint64_t>(covered.size()); ++i) {
    if (!Check(covered[static_cast<size_t>(i)] != 0, "UPLOAD_RESOURCE covers full generated mip range")) {
      return false;
    }
  }
  return true;
}

bool TestGenerateMipSubLevelsBoxFilter2dA1R5G5B5() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hResource{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_resource = false;

    ~Cleanup() {
      if (has_resource && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hResource);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnGenerateMipSubLevels != nullptr, "GenerateMipSubLevels must be available")) {
    return false;
  }

  // Create a 4x4 texture with 3 mip levels (4x4, 2x2, 1x1).
  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = kD3dRTypeTexture;
  create_res.format = 25u; // D3DFMT_A1R5G5B5
  create_res.width = 4;
  create_res.height = 4;
  create_res.depth = 1;
  create_res.mip_levels = 3;
  create_res.usage = 0;
  create_res.pool = 0;
  create_res.size = 0;
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr;
  create_res.pPrivateDriverData = nullptr;
  create_res.PrivateDriverDataSize = 0;
  create_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == S_OK, "CreateResource(4x4 A1R5G5B5 texture mips)")) {
    return false;
  }
  cleanup.hResource = create_res.hResource;
  cleanup.has_resource = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  auto* res = reinterpret_cast<Resource*>(create_res.hResource.pDrvPrivate);
  if (!Check(dev != nullptr && res != nullptr, "device/resource pointers")) {
    return false;
  }
  if (!Check(res->mip_levels == 3, "resource mip_levels==3")) {
    return false;
  }
  if (!Check(res->backing_alloc_id == 0, "resource is host-allocated (alloc_id==0)")) {
    return false;
  }
  if (!Check(res->storage.size() >= res->size_bytes, "resource storage sized")) {
    return false;
  }

  // Fill mip0 with a known pattern in the R channel:
  // - R5 = x + y*4, G5 = 0, B5 = 0
  // - A1 = 1 for y<2, else 0 (ensures mip1 has mixed alpha bits; mip2 tests threshold behavior).
  const uint32_t row_pitch = res->row_pitch;
  if (!Check(row_pitch == 8u, "mip0 row_pitch==8")) {
    return false;
  }
  uint8_t* base = res->storage.data();
  for (uint32_t y = 0; y < 4; ++y) {
    for (uint32_t x = 0; x < 4; ++x) {
      const uint16_t a1 = static_cast<uint16_t>(y < 2 ? 1u : 0u);
      const uint16_t r5 = static_cast<uint16_t>(x + y * 4u);
      const uint16_t v = static_cast<uint16_t>((a1 << 15) | (r5 << 10));
      const size_t off = static_cast<size_t>(y) * row_pitch + static_cast<size_t>(x) * 2u;
      base[off + 0] = static_cast<uint8_t>(v & 0xFFu);
      base[off + 1] = static_cast<uint8_t>((v >> 8) & 0xFFu);
    }
  }

  // Clear command buffer so we only observe visibility packets from mip generation.
  dev->cmd.reset();

  hr = cleanup.device_funcs.pfnGenerateMipSubLevels(create_dev.hDevice, create_res.hResource);
  if (!Check(hr == S_OK, "GenerateMipSubLevels")) {
    return false;
  }

  Texture2dMipLevelLayout mip1{};
  Texture2dMipLevelLayout mip2{};
  if (!Check(calc_texture2d_mip_level_layout(res->format, res->width, res->height, res->mip_levels, res->depth, 1, &mip1),
             "mip1 layout")) {
    return false;
  }
  if (!Check(calc_texture2d_mip_level_layout(res->format, res->width, res->height, res->mip_levels, res->depth, 2, &mip2),
             "mip2 layout")) {
    return false;
  }
  if (!Check(mip1.width == 2 && mip1.height == 2, "mip1 dims 2x2")) {
    return false;
  }
  if (!Check(mip2.width == 1 && mip2.height == 1, "mip2 dims 1x1")) {
    return false;
  }

  // Expected results:
  // - mip1 R5 values: {3, 4, 11, 13}; alpha bits: top row = 1, bottom row = 0.
  // - mip2 R5 value: {8}; alpha bit = 1 (2/4 mip1 pixels had alpha=1 => avg==128 => threshold sets bit).
  const uint8_t expected_mip1[8] = {
      0x00, 0x8C, 0x00, 0x90,
      0x00, 0x2C, 0x00, 0x34,
  };
  const uint8_t expected_mip2[2] = {0x00, 0xA0};

  if (!Check(mip1.slice_pitch_bytes == sizeof(expected_mip1), "mip1 slice_pitch==8")) {
    return false;
  }
  if (!Check(mip2.slice_pitch_bytes == sizeof(expected_mip2), "mip2 slice_pitch==2")) {
    return false;
  }

  if (!Check(std::memcmp(res->storage.data() + static_cast<size_t>(mip1.offset_bytes), expected_mip1, sizeof(expected_mip1)) == 0,
             "mip1 bytes match")) {
    return false;
  }
  if (!Check(std::memcmp(res->storage.data() + static_cast<size_t>(mip2.offset_bytes), expected_mip2, sizeof(expected_mip2)) == 0,
             "mip2 bytes match")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  if (!Check(ValidateStream(buf, len), "stream validates")) {
    return false;
  }

  // Host-allocated textures should embed updates via UPLOAD_RESOURCE.
  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_UPLOAD_RESOURCE) >= 1, "GenerateMipSubLevels emits UPLOAD_RESOURCE")) {
    return false;
  }
  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_RESOURCE_DIRTY_RANGE) == 0, "GenerateMipSubLevels does not emit DIRTY_RANGE for host alloc")) {
    return false;
  }

  const uint64_t expected_start = mip1.offset_bytes;
  const uint64_t expected_end = static_cast<uint64_t>(res->size_bytes);

  std::vector<uint8_t> covered(res->size_bytes, 0);
  const size_t stream_len = StreamBytesUsed(buf, len);
  size_t off = sizeof(aerogpu_cmd_stream_header);
  while (off + sizeof(aerogpu_cmd_hdr) <= stream_len) {
    const auto* hdr = reinterpret_cast<const aerogpu_cmd_hdr*>(buf + off);
    if (hdr->opcode == AEROGPU_CMD_UPLOAD_RESOURCE) {
      const auto* cmd = reinterpret_cast<const aerogpu_cmd_upload_resource*>(hdr);
      if (cmd->resource_handle == res->handle) {
        const uint64_t start = cmd->offset_bytes;
        const uint64_t end = start + cmd->size_bytes;
        if (!Check(end <= expected_end, "UPLOAD_RESOURCE range within resource")) {
          return false;
        }
        if (!Check(start >= expected_start, "UPLOAD_RESOURCE does not touch mip0")) {
          return false;
        }

        if (!CheckUploadResourceWithinSingleTextureSubresource(res, start, end)) {
          return false;
        }

        const uint8_t* payload = reinterpret_cast<const uint8_t*>(cmd) + sizeof(*cmd);
        if (!Check(std::memcmp(payload, res->storage.data() + start, static_cast<size_t>(cmd->size_bytes)) == 0,
                   "UPLOAD_RESOURCE payload matches storage bytes")) {
          return false;
        }

        for (uint64_t i = start; i < end && i < static_cast<uint64_t>(covered.size()); ++i) {
          covered[static_cast<size_t>(i)] = 1;
        }
      }
    }
    if (hdr->size_bytes == 0 || hdr->size_bytes > stream_len - off) {
      break;
    }
    off += hdr->size_bytes;
  }

  for (uint64_t i = expected_start; i < expected_end && i < static_cast<uint64_t>(covered.size()); ++i) {
    if (!Check(covered[static_cast<size_t>(i)] != 0, "UPLOAD_RESOURCE covers full generated mip range")) {
      return false;
    }
  }
  return true;
}

bool TestGenerateMipSubLevelsBoxFilter2dBcUniform() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnGenerateMipSubLevels != nullptr, "GenerateMipSubLevels must be available")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  struct Case {
    uint32_t fmt;
    uint32_t block_bytes;
    const char* name;
    std::array<uint8_t, 16> mip0_block;
  };

  const Case cases[] = {
      // D3DFMT_DXT1: 8-byte block. Use a single block encoding an opaque red surface.
      {static_cast<uint32_t>(kD3dFmtDxt1),
       8u,
       "DXT1",
       {0x00, 0xF8, 0x00, 0xF8, 0x00, 0x00, 0x00, 0x00}},
      // D3DFMT_DXT3: 16-byte block (explicit alpha). Alpha=255 for all texels.
      {static_cast<uint32_t>(kD3dFmtDxt3),
       16u,
       "DXT3",
       {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xF8, 0x00, 0xF8, 0x00, 0x00, 0x00, 0x00}},
      // D3DFMT_DXT5: 16-byte block (interpolated alpha). Alpha=255 for all texels.
      {static_cast<uint32_t>(kD3dFmtDxt5),
       16u,
       "DXT5",
       {0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x00, 0xF8, 0x00, 0x00, 0x00, 0x00}},
  };

  for (const Case& c : cases) {
    // Create a 4x4 texture with 3 mip levels (4x4, 2x2, 1x1).
    D3D9DDIARG_CREATERESOURCE create_res{};
    create_res.type = kD3dRTypeTexture;
    create_res.format = c.fmt;
    create_res.width = 4;
    create_res.height = 4;
    create_res.depth = 1;
    create_res.mip_levels = 3;
    create_res.usage = 0;
    create_res.pool = 0;
    create_res.size = 0;
    create_res.hResource.pDrvPrivate = nullptr;
    create_res.pSharedHandle = nullptr;
    create_res.pPrivateDriverData = nullptr;
    create_res.PrivateDriverDataSize = 0;
    create_res.wddm_hAllocation = 0;

    hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
    char create_msg[128] = {};
    std::snprintf(create_msg, sizeof(create_msg), "CreateResource(4x4 %s texture mips)", c.name);
    if (!Check(hr == S_OK, create_msg)) {
      return false;
    }

    auto* res = reinterpret_cast<Resource*>(create_res.hResource.pDrvPrivate);
    if (!Check(res != nullptr, "resource pointer")) {
      return false;
    }
    if (!Check(res->backing_alloc_id == 0, "resource is host-allocated (alloc_id==0)")) {
      return false;
    }
    if (!Check(res->storage.size() >= res->size_bytes, "resource storage sized")) {
      return false;
    }

    // Fill mip0 with a known BC block. Mip generation should produce identical
    // blocks for lower mips because the surface is uniform.
    if (!Check(res->slice_pitch >= c.block_bytes, "mip0 slice_pitch large enough")) {
      return false;
    }
    std::memcpy(res->storage.data(), c.mip0_block.data(), c.block_bytes);

    dev->cmd.reset();
    hr = cleanup.device_funcs.pfnGenerateMipSubLevels(create_dev.hDevice, create_res.hResource);
    if (!Check(hr == S_OK, "GenerateMipSubLevels")) {
      return false;
    }

    Texture2dMipLevelLayout mip1{};
    Texture2dMipLevelLayout mip2{};
    if (!Check(calc_texture2d_mip_level_layout(res->format, res->width, res->height, res->mip_levels, res->depth, 1, &mip1),
               "mip1 layout")) {
      return false;
    }
    if (!Check(calc_texture2d_mip_level_layout(res->format, res->width, res->height, res->mip_levels, res->depth, 2, &mip2),
               "mip2 layout")) {
      return false;
    }
    if (!Check(mip1.width == 2 && mip1.height == 2, "mip1 dims 2x2")) {
      return false;
    }
    if (!Check(mip2.width == 1 && mip2.height == 1, "mip2 dims 1x1")) {
      return false;
    }
    if (!Check(mip1.slice_pitch_bytes == c.block_bytes, "mip1 slice_pitch==1 block")) {
      return false;
    }
    if (!Check(mip2.slice_pitch_bytes == c.block_bytes, "mip2 slice_pitch==1 block")) {
      return false;
    }

    if (!Check(std::memcmp(res->storage.data() + static_cast<size_t>(mip1.offset_bytes), c.mip0_block.data(), c.block_bytes) == 0,
               "mip1 bytes match")) {
      return false;
    }
    if (!Check(std::memcmp(res->storage.data() + static_cast<size_t>(mip2.offset_bytes), c.mip0_block.data(), c.block_bytes) == 0,
               "mip2 bytes match")) {
      return false;
    }

    dev->cmd.finalize();
    const uint8_t* buf = dev->cmd.data();
    const size_t len = dev->cmd.bytes_used();

    if (!Check(ValidateStream(buf, len), "stream validates")) {
      return false;
    }

    // Host-allocated textures should embed updates via UPLOAD_RESOURCE.
    if (!Check(CountOpcode(buf, len, AEROGPU_CMD_UPLOAD_RESOURCE) >= 1, "GenerateMipSubLevels emits UPLOAD_RESOURCE")) {
      return false;
    }
    if (!Check(CountOpcode(buf, len, AEROGPU_CMD_RESOURCE_DIRTY_RANGE) == 0,
               "GenerateMipSubLevels does not emit DIRTY_RANGE for host alloc")) {
      return false;
    }

    const uint64_t expected_start = mip1.offset_bytes;
    const uint64_t expected_end = static_cast<uint64_t>(res->size_bytes);

    std::vector<uint8_t> covered(res->size_bytes, 0);
    const size_t stream_len = StreamBytesUsed(buf, len);
    size_t off = sizeof(aerogpu_cmd_stream_header);
    while (off + sizeof(aerogpu_cmd_hdr) <= stream_len) {
      const auto* hdr = reinterpret_cast<const aerogpu_cmd_hdr*>(buf + off);
      if (hdr->opcode == AEROGPU_CMD_UPLOAD_RESOURCE) {
        const auto* cmd = reinterpret_cast<const aerogpu_cmd_upload_resource*>(hdr);
        if (cmd->resource_handle == res->handle) {
          const uint64_t start = cmd->offset_bytes;
          const uint64_t end = start + cmd->size_bytes;
          if (!Check(end <= expected_end, "UPLOAD_RESOURCE range within resource")) {
            return false;
          }
          if (!Check(start >= expected_start, "UPLOAD_RESOURCE does not touch mip0")) {
            return false;
          }

          if (!CheckUploadResourceWithinSingleTextureSubresource(res, start, end)) {
            return false;
          }

          const uint8_t* payload = reinterpret_cast<const uint8_t*>(cmd) + sizeof(*cmd);
          if (!Check(std::memcmp(payload, res->storage.data() + start, static_cast<size_t>(cmd->size_bytes)) == 0,
                     "UPLOAD_RESOURCE payload matches storage bytes")) {
            return false;
          }

          for (uint64_t i = start; i < end && i < static_cast<uint64_t>(covered.size()); ++i) {
            covered[static_cast<size_t>(i)] = 1;
          }
        }
      }
      if (hdr->size_bytes == 0 || hdr->size_bytes > stream_len - off) {
        break;
      }
      off += hdr->size_bytes;
    }

    for (uint64_t i = expected_start; i < expected_end && i < static_cast<uint64_t>(covered.size()); ++i) {
      if (!Check(covered[static_cast<size_t>(i)] != 0, "UPLOAD_RESOURCE covers full generated mip range")) {
        return false;
      }
    }

    hr = cleanup.device_funcs.pfnDestroyResource(create_dev.hDevice, create_res.hResource);
    char destroy_msg[128] = {};
    std::snprintf(destroy_msg, sizeof(destroy_msg), "DestroyResource(%s)", c.name);
    if (!Check(hr == S_OK, destroy_msg)) {
      return false;
    }
  }

  return true;
}

bool TestGenerateMipSubLevelsAllocBackedEmitsDirtyRange() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hResource{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_resource = false;

    ~Cleanup() {
      if (has_resource && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hResource);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnGenerateMipSubLevels != nullptr, "GenerateMipSubLevels must be available")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  // Simulate a WDDM-enabled device so allocation-list tracking and alloc-backed
  // dirty-range updates are enabled in portable builds.
  hr = device_test_enable_wddm_context(create_dev.hDevice);
  if (!Check(hr == S_OK, "device_test_enable_wddm_context")) {
    return false;
  }
  D3DDDI_ALLOCATIONLIST list[4] = {};
  hr = device_test_rebind_alloc_list_tracker(create_dev.hDevice, list, 4, 0xFFFFu);
  if (!Check(hr == S_OK, "device_test_rebind_alloc_list_tracker")) {
    return false;
  }

  // Create an alloc-backed texture by providing a WDDM allocation handle and a
  // private-driver-data buffer for the alloc_id contract. (Portable builds don't
  // actually map the allocation; the test resizes the CPU shadow storage below.)
  aerogpu_wddm_alloc_priv priv{};
  std::memset(&priv, 0, sizeof(priv));

  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = kD3dRTypeTexture;
  create_res.format = 22u; // D3DFMT_X8R8G8B8
  create_res.width = 4;
  create_res.height = 4;
  create_res.depth = 1;
  create_res.mip_levels = 3;
  create_res.usage = 0;
  create_res.pool = 0;
  create_res.size = 0;
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr;
  create_res.pKmdAllocPrivateData = &priv;
  create_res.KmdAllocPrivateDataSize = sizeof(priv);
  create_res.wddm_hAllocation = 0xABCDu;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == S_OK, "CreateResource(alloc-backed texture)")) {
    return false;
  }
  cleanup.hResource = create_res.hResource;
  cleanup.has_resource = true;

  auto* res = reinterpret_cast<Resource*>(create_res.hResource.pDrvPrivate);
  if (!Check(res != nullptr, "resource pointer")) {
    return false;
  }
  if (!Check(res->backing_alloc_id != 0, "alloc-backed texture backing_alloc_id non-zero")) {
    return false;
  }
  if (!Check(res->wddm_hAllocation == create_res.wddm_hAllocation, "resource preserves WDDM hAllocation")) {
    return false;
  }

  // Portable builds don't have a WDDM lock callback; resize CPU shadow storage so
  // we can write mip bytes and still exercise the alloc-backed DIRTY_RANGE path.
  if (res->storage.size() < res->size_bytes) {
    res->storage.resize(res->size_bytes);
  }

  // Fill mip0 with a known pattern:
  // R = x + y*4, G = 0, B = 0, X (alpha) = 0. Mip gen should force alpha to 0xFF.
  const uint32_t row_pitch = res->row_pitch;
  if (!Check(row_pitch == 16u, "mip0 row_pitch==16")) {
    return false;
  }
  uint8_t* base = res->storage.data();
  for (uint32_t y = 0; y < 4; ++y) {
    for (uint32_t x = 0; x < 4; ++x) {
      const uint8_t r = static_cast<uint8_t>(x + y * 4u);
      const size_t off = static_cast<size_t>(y) * row_pitch + static_cast<size_t>(x) * 4u;
      base[off + 0] = 0; // B
      base[off + 1] = 0; // G
      base[off + 2] = r; // R
      base[off + 3] = 0; // X (ignored)
    }
  }

  // Clear command buffer/allocation list so we only observe visibility packets
  // from mip generation.
  dev->cmd.reset();
  hr = device_test_reset_alloc_list_tracker(create_dev.hDevice);
  if (!Check(hr == S_OK, "device_test_reset_alloc_list_tracker")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnGenerateMipSubLevels(create_dev.hDevice, create_res.hResource);
  if (!Check(hr == S_OK, "GenerateMipSubLevels")) {
    return false;
  }

  Texture2dMipLevelLayout mip1{};
  Texture2dMipLevelLayout mip2{};
  if (!Check(calc_texture2d_mip_level_layout(res->format, res->width, res->height, res->mip_levels, res->depth, 1, &mip1),
             "mip1 layout")) {
    return false;
  }
  if (!Check(calc_texture2d_mip_level_layout(res->format, res->width, res->height, res->mip_levels, res->depth, 2, &mip2),
             "mip2 layout")) {
    return false;
  }

  const uint8_t expected_mip1[16] = {
      0, 0, 3, 0xFF, 0, 0, 5, 0xFF,
      0, 0, 11, 0xFF, 0, 0, 13, 0xFF,
  };
  const uint8_t expected_mip2[4] = {0, 0, 8, 0xFF};
  if (!Check(std::memcmp(res->storage.data() + static_cast<size_t>(mip1.offset_bytes), expected_mip1, sizeof(expected_mip1)) == 0,
             "mip1 bytes match")) {
    return false;
  }
  if (!Check(std::memcmp(res->storage.data() + static_cast<size_t>(mip2.offset_bytes), expected_mip2, sizeof(expected_mip2)) == 0,
             "mip2 bytes match")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();
  if (!Check(ValidateStream(buf, len), "stream validates")) {
    return false;
  }

  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_UPLOAD_RESOURCE) == 0,
             "GenerateMipSubLevels does not emit UPLOAD_RESOURCE for alloc-backed")) {
    return false;
  }
  const CmdLoc dirty = FindLastOpcode(buf, len, AEROGPU_CMD_RESOURCE_DIRTY_RANGE);
  if (!Check(dirty.hdr != nullptr, "GenerateMipSubLevels emits RESOURCE_DIRTY_RANGE")) {
    return false;
  }
  const auto* dirty_cmd = reinterpret_cast<const aerogpu_cmd_resource_dirty_range*>(dirty.hdr);
  if (!Check(dirty_cmd->resource_handle == res->handle, "RESOURCE_DIRTY_RANGE resource_handle matches")) {
    return false;
  }
  if (!Check(dirty_cmd->offset_bytes == mip1.offset_bytes, "RESOURCE_DIRTY_RANGE offset starts at mip1")) {
    return false;
  }
  if (!Check(dirty_cmd->size_bytes == static_cast<uint64_t>(res->size_bytes) - mip1.offset_bytes,
             "RESOURCE_DIRTY_RANGE size covers mips")) {
    return false;
  }

  if (!Check(dev->alloc_list_tracker.list_len() == 1, "allocation list has 1 entry")) {
    return false;
  }
  if (!Check(list[0].hAllocation == create_res.wddm_hAllocation, "allocation list carries hAllocation")) {
    return false;
  }
  if (!Check(list[0].WriteOperation == 0, "allocation list entry is read-only for dirty-range CPU write")) {
    return false;
  }
  return Check(list[0].AllocationListSlotId == 0, "allocation list slot id == 0");
}

bool TestCreateResourceIgnoresStaleAllocPrivDataForNonShared() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hResource{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_resource = false;

    ~Cleanup() {
      if (has_resource && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hResource);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  ScopedDeviceCmdVectorReset cmd_reset(dev);

  std::vector<uint8_t> dma(4096, 0);
  dev->cmd.set_span(dma.data(), dma.size());

  // Simulate stale output-buffer contents: prior to
  // `fix(aerogpu-d3d9): avoid consuming uninitialized alloc privdata` the driver
  // would incorrectly consume these bytes and treat the resource as shared even
  // though the runtime did not request sharing.
  aerogpu_wddm_alloc_priv stale{};
  stale.magic = AEROGPU_WDDM_ALLOC_PRIV_MAGIC;
  stale.version = AEROGPU_WDDM_ALLOC_PRIV_VERSION;
  stale.alloc_id = 0x4242u;
  stale.flags = AEROGPU_WDDM_ALLOC_PRIV_FLAG_IS_SHARED;
  stale.share_token = 0x1122334455667788ull;
  stale.size_bytes = 0x1000u;

  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = kD3dRTypeSurface;
  create_res.format = 22u; // D3DFMT_X8R8G8B8
  create_res.width = 32;
  create_res.height = 32;
  create_res.depth = 1;
  create_res.mip_levels = 1;
  create_res.usage = 0x00000001u; // D3DUSAGE_RENDERTARGET
  create_res.pool = 0;
  create_res.size = 0;
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr; // not a shared resource
  create_res.pKmdAllocPrivateData = &stale;
  create_res.KmdAllocPrivateDataSize = sizeof(stale);
  create_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == S_OK, "CreateResource(non-shared)")) {
    return false;
  }
  cleanup.hResource = create_res.hResource;
  cleanup.has_resource = true;

  auto* res = reinterpret_cast<Resource*>(create_res.hResource.pDrvPrivate);
  if (!Check(res != nullptr, "resource pointer")) {
    return false;
  }
  if (!Check(!res->is_shared, "non-shared CreateResource does not become is_shared via stale privdata")) {
    return false;
  }
  if (!Check(res->share_token == 0, "non-shared CreateResource does not inherit share_token via stale privdata")) {
    return false;
  }

  dev->cmd.finalize();
  if (!Check(ValidateStream(dma.data(), dma.size()), "stream validates")) {
    return false;
  }
  if (!Check(CountOpcode(dma.data(), dma.size(), AEROGPU_CMD_EXPORT_SHARED_SURFACE) == 0,
             "non-shared CreateResource does not emit EXPORT_SHARED_SURFACE")) {
    return false;
  }

  // Make cleanup safe: switch back to vector mode so subsequent destroy calls
  // can't fail due to span-buffer capacity constraints.
  dev->cmd.set_vector();
  return true;
}

bool TestCreateResourceAllowsNullPrivateDataWhenNotAllocBacked() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hResource{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_resource = false;

    ~Cleanup() {
      if (has_resource && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hResource);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  // Simulate WDDM-enabled mode but do NOT supply a WDDM allocation handle. The
  // driver should fall back to host-allocated resources and must not require a
  // runtime private-driver-data buffer in this case.
  hr = device_test_enable_wddm_context(create_dev.hDevice);
  if (!Check(hr == S_OK, "device_test_enable_wddm_context")) {
    return false;
  }
  D3DDDI_ALLOCATIONLIST list[4] = {};
  hr = device_test_rebind_alloc_list_tracker(create_dev.hDevice, list, 4, 0xFFFFu);
  if (!Check(hr == S_OK, "device_test_rebind_alloc_list_tracker")) {
    return false;
  }

  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = kD3dRTypeSurface;
  create_res.format = 22u; // D3DFMT_X8R8G8B8
  create_res.width = 16;
  create_res.height = 16;
  create_res.depth = 1;
  create_res.mip_levels = 1;
  create_res.usage = 0;
  create_res.pool = 0;
  create_res.size = 0;
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr;
  create_res.pPrivateDriverData = nullptr;
  create_res.PrivateDriverDataSize = 0;
  create_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == S_OK, "CreateResource(no privdata, no hAllocation)")) {
    return false;
  }
  if (!Check(create_res.hResource.pDrvPrivate != nullptr, "CreateResource returned resource handle")) {
    return false;
  }
  cleanup.hResource = create_res.hResource;
  cleanup.has_resource = true;

  auto* res = reinterpret_cast<Resource*>(create_res.hResource.pDrvPrivate);
  if (!Check(res != nullptr, "resource pointer")) {
    return false;
  }
  if (!Check(res->wddm_hAllocation == 0, "resource remains non-alloc-backed")) {
    return false;
  }
  return Check(res->backing_alloc_id == 0, "resource remains host-allocated (alloc_id == 0)");
}

bool TestUnlockX1R5G5B5ForcesAlphaBitAndUploadsFixedBytes() {
#if defined(_WIN32)
  return true;
#else
  constexpr uint32_t kD3dFmtX1R5G5B5 = 24u;
  constexpr D3DDDIFORMAT kFmtX1R5G5B5 = static_cast<D3DDDIFORMAT>(kD3dFmtX1R5G5B5);

  // Skip if the format isn't enabled in the build.
  if (aerogpu::d3d9_format_to_aerogpu(kD3dFmtX1R5G5B5) == AEROGPU_FORMAT_INVALID) {
    std::fprintf(stderr, "INFO: skipping X1R5G5B5 unlock fixup test (format not enabled)\n");
    return true;
  }
  if (!Check(aerogpu::bytes_per_pixel(kFmtX1R5G5B5) == 2u, "bytes_per_pixel(X1R5G5B5)==2")) {
    return false;
  }

  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hResource{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_resource = false;

    ~Cleanup() {
      if (has_resource && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hResource);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDestroyResource != nullptr, "DestroyResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnLock != nullptr && cleanup.device_funcs.pfnUnlock != nullptr, "Lock/Unlock must be available")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  std::vector<uint8_t> dma(4096, 0);
  dev->cmd.set_span(dma.data(), dma.size());
  dev->cmd.reset();
  struct CmdModeGuard {
    Device* dev = nullptr;
    ~CmdModeGuard() {
      if (dev) {
        // Cleanup destructors may submit; ensure they don't reference our span buffer.
        dev->cmd.set_vector();
      }
    }
  } cmd_guard{dev};

  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = kD3dRTypeTexture;
  create_res.format = kD3dFmtX1R5G5B5;
  create_res.width = 4;
  create_res.height = 1;
  create_res.depth = 1;
  create_res.mip_levels = 1;
  create_res.usage = 0;
  create_res.pool = 0; // default pool (host-backed in portable build)
  create_res.size = 0;
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr;
  create_res.pPrivateDriverData = nullptr;
  create_res.PrivateDriverDataSize = 0;
  create_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == S_OK, "CreateResource(X1R5G5B5)")) {
    return false;
  }
  if (!Check(create_res.hResource.pDrvPrivate != nullptr, "CreateResource returned resource handle")) {
    return false;
  }
  cleanup.hResource = create_res.hResource;
  cleanup.has_resource = true;

  auto* res = reinterpret_cast<Resource*>(create_res.hResource.pDrvPrivate);
  if (!Check(res != nullptr, "resource pointer")) {
    return false;
  }
  if (!Check(res->handle != 0, "X1R5G5B5 resource has host handle")) {
    return false;
  }
  if (!Check(res->backing_alloc_id == 0, "X1R5G5B5 resource is host-backed in portable build")) {
    return false;
  }
  if (!Check(res->storage.size() >= res->size_bytes && res->size_bytes >= 4u, "resource storage sized")) {
    return false;
  }

  // Reset the command stream so we only capture the Unlock writeback.
  std::memset(dma.data(), 0, dma.size());
  dev->cmd.reset();

  // Initialize storage with zeros so we can verify that Unlock only touches the
  // expected bytes.
  std::memset(res->storage.data(), 0, res->storage.size());

  constexpr uint32_t kOffset = 1; // odd offset to exercise alignment logic
  constexpr uint32_t kSize = 3;   // spans high byte of texel0 and texel1

  D3D9DDIARG_LOCK lock{};
  lock.hResource = create_res.hResource;
  lock.offset_bytes = kOffset;
  lock.size_bytes = kSize;
  lock.flags = 0;
  D3DDDI_LOCKEDBOX box{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(X1R5G5B5)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock returns pData")) {
    return false;
  }

  auto* bytes = static_cast<uint8_t*>(box.pData);
  // bytes[0] and bytes[2] are the high bytes of two texels in X1R5G5B5; Unlock
  // must force their MSBs to 1. bytes[1] is a low byte and must be preserved.
  bytes[0] = 0x12;
  bytes[1] = 0x56;
  bytes[2] = 0x34;

  D3D9DDIARG_UNLOCK unlock{};
  unlock.hResource = create_res.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(X1R5G5B5)")) {
    return false;
  }

  // Verify bytes were fixed in-place before upload.
  const uint8_t expected_fixed[3] = {
      static_cast<uint8_t>(0x12u | 0x80u),
      0x56u,
      static_cast<uint8_t>(0x34u | 0x80u),
  };
  if (!Check(res->storage[kOffset + 0] == expected_fixed[0], "X1R5G5B5 high byte 0 alpha bit set")) {
    return false;
  }
  if (!Check(res->storage[kOffset + 1] == expected_fixed[1], "X1R5G5B5 low byte preserved")) {
    return false;
  }
  if (!Check(res->storage[kOffset + 2] == expected_fixed[2], "X1R5G5B5 high byte 1 alpha bit set")) {
    return false;
  }
  if (!Check(res->storage[0] == 0u && res->storage[4] == 0u, "Unlock does not touch bytes outside range")) {
    return false;
  }

  dev->cmd.finalize();
  if (!Check(ValidateStream(dma.data(), dma.size()), "command stream validation")) {
    return false;
  }

  if (!Check(CountOpcode(dma.data(), dma.size(), AEROGPU_CMD_UPLOAD_RESOURCE) == 1, "Unlock emits one UPLOAD_RESOURCE")) {
    return false;
  }
  const CmdLoc upload = FindLastOpcode(dma.data(), dma.size(), AEROGPU_CMD_UPLOAD_RESOURCE);
  if (!Check(upload.hdr != nullptr, "UPLOAD_RESOURCE location")) {
    return false;
  }
  const auto* upload_cmd = reinterpret_cast<const aerogpu_cmd_upload_resource*>(upload.hdr);
  if (!Check(upload_cmd->resource_handle == res->handle, "UPLOAD_RESOURCE resource_handle")) {
    return false;
  }
  const uint64_t expected_upload_off = 0;
  const uint64_t expected_upload_size = res->row_pitch;
  if (!Check(upload_cmd->offset_bytes == expected_upload_off, "UPLOAD_RESOURCE offset")) {
    return false;
  }
  if (!Check(upload_cmd->size_bytes == expected_upload_size, "UPLOAD_RESOURCE size")) {
    return false;
  }
  const uint8_t* payload = reinterpret_cast<const uint8_t*>(upload_cmd) + sizeof(*upload_cmd);
  return Check(std::memcmp(payload, res->storage.data(), static_cast<size_t>(expected_upload_size)) == 0,
               "UPLOAD_RESOURCE payload contains fixed bytes");
#endif
}

bool TestAllocBackedUnlockEmitsDirtyRange() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hResource{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_resource = false;

    ~Cleanup() {
      if (has_resource && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hResource);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnLock != nullptr && cleanup.device_funcs.pfnUnlock != nullptr, "Lock/Unlock must be available")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  // Simulate a WDDM-enabled device so allocation-list tracking and alloc-backed
  // dirty-range updates are enabled in portable builds.
  hr = device_test_enable_wddm_context(create_dev.hDevice);
  if (!Check(hr == S_OK, "device_test_enable_wddm_context")) {
    return false;
  }
  D3DDDI_ALLOCATIONLIST list[4] = {};
  hr = device_test_rebind_alloc_list_tracker(create_dev.hDevice, list, 4, 0xFFFFu);
  if (!Check(hr == S_OK, "device_test_rebind_alloc_list_tracker")) {
    return false;
  }

  aerogpu_wddm_alloc_priv priv{};
  std::memset(&priv, 0, sizeof(priv));

  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = 6u; // D3DRTYPE_VERTEXBUFFER
  create_res.format = 0;
  create_res.width = 0;
  create_res.height = 0;
  create_res.depth = 1;
  create_res.mip_levels = 1;
  create_res.usage = 0;
  create_res.pool = 0;
  create_res.size = 64;
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr;
  create_res.pKmdAllocPrivateData = &priv;
  create_res.KmdAllocPrivateDataSize = sizeof(priv);
  create_res.wddm_hAllocation = 0xABCDu;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == S_OK, "CreateResource(alloc-backed VB)")) {
    return false;
  }
  if (!Check(create_res.hResource.pDrvPrivate != nullptr, "CreateResource returned resource handle")) {
    return false;
  }
  cleanup.hResource = create_res.hResource;
  cleanup.has_resource = true;

  auto* res = reinterpret_cast<Resource*>(create_res.hResource.pDrvPrivate);
  if (!Check(res != nullptr, "resource pointer")) {
    return false;
  }
  if (!Check(res->backing_alloc_id != 0, "alloc-backed resource backing_alloc_id non-zero")) {
    return false;
  }
  if (!Check(res->wddm_hAllocation == create_res.wddm_hAllocation, "resource preserves WDDM hAllocation")) {
    return false;
  }

  // Portable builds don't have a WDDM lock callback; resize CPU shadow storage
  // so Lock/Unlock can proceed while still exercising the alloc-backed update path.
  if (res->storage.size() < res->size_bytes) {
    res->storage.resize(res->size_bytes);
  }

  constexpr uint32_t kOffset = 4;
  constexpr uint32_t kSize = 16;

  D3D9DDIARG_LOCK lock{};
  lock.hResource = create_res.hResource;
  lock.offset_bytes = kOffset;
  lock.size_bytes = kSize;
  lock.flags = 0;
  D3DDDI_LOCKEDBOX box{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(alloc-backed VB)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock returns pData")) {
    return false;
  }
  std::memset(box.pData, 0xCD, kSize);

  D3D9DDIARG_UNLOCK unlock{};
  unlock.hResource = create_res.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(alloc-backed VB)")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  if (!Check(FindLastOpcode(buf, len, AEROGPU_CMD_CREATE_BUFFER).hdr != nullptr, "CREATE_BUFFER emitted")) {
    return false;
  }
  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_UPLOAD_RESOURCE) == 0,
             "alloc-backed Unlock does not emit UPLOAD_RESOURCE")) {
    return false;
  }

  const CmdLoc dirty = FindLastOpcode(buf, len, AEROGPU_CMD_RESOURCE_DIRTY_RANGE);
  if (!Check(dirty.hdr != nullptr, "RESOURCE_DIRTY_RANGE emitted")) {
    return false;
  }
  const auto* dirty_cmd = reinterpret_cast<const aerogpu_cmd_resource_dirty_range*>(dirty.hdr);
  if (!Check(dirty_cmd->resource_handle == res->handle, "RESOURCE_DIRTY_RANGE resource_handle")) {
    return false;
  }
  if (!Check(dirty_cmd->offset_bytes == kOffset, "RESOURCE_DIRTY_RANGE offset")) {
    return false;
  }
  if (!Check(dirty_cmd->size_bytes == kSize, "RESOURCE_DIRTY_RANGE size")) {
    return false;
  }

  if (!Check(dev->alloc_list_tracker.list_len() == 1, "allocation list has 1 entry")) {
    return false;
  }
  if (!Check(list[0].hAllocation == create_res.wddm_hAllocation, "allocation list carries hAllocation")) {
    return false;
  }
  if (!Check(list[0].WriteOperation == 0, "allocation list entry remains read-only for buffer CPU write")) {
    return false;
  }
  return Check(list[0].AllocationListSlotId == 0, "allocation list slot id == 0");
}

bool TestCopyRectsToHostBackedResourceEmitsUpload() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hSrc{};
    D3DDDI_HRESOURCE hDst{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_src = false;
    bool has_dst = false;

    ~Cleanup() {
      if (has_dst && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hDst);
      }
      if (has_src && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hSrc);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnCopyRects != nullptr, "CopyRects must be available")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  ScopedDeviceCmdVectorReset cmd_reset(dev);

  std::vector<uint8_t> dma(64 * 1024, 0);
  dev->cmd.set_span(dma.data(), dma.size());
  dev->cmd.reset();

  // Create host-backed src/dst surfaces (portable path: backing_alloc_id==0).
  D3D9DDIARG_CREATERESOURCE create_src{};
  create_src.type = kD3dRTypeSurface;
  create_src.format = 22u; // D3DFMT_X8R8G8B8
  create_src.width = 4;
  create_src.height = 4;
  create_src.depth = 1;
  create_src.mip_levels = 1;
  create_src.usage = 0;
  create_src.pool = 0;
  create_src.size = 0;
  create_src.hResource.pDrvPrivate = nullptr;
  create_src.pSharedHandle = nullptr;
  create_src.pPrivateDriverData = nullptr;
  create_src.PrivateDriverDataSize = 0;
  create_src.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_src);
  if (!Check(hr == S_OK, "CreateResource(src surface)")) {
    return false;
  }
  cleanup.hSrc = create_src.hResource;
  cleanup.has_src = true;

  D3D9DDIARG_CREATERESOURCE create_dst = create_src;
  create_dst.hResource.pDrvPrivate = nullptr;
  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_dst);
  if (!Check(hr == S_OK, "CreateResource(dst surface)")) {
    return false;
  }
  cleanup.hDst = create_dst.hResource;
  cleanup.has_dst = true;

  auto* src_res = reinterpret_cast<Resource*>(create_src.hResource.pDrvPrivate);
  auto* dst_res = reinterpret_cast<Resource*>(create_dst.hResource.pDrvPrivate);
  if (!Check(src_res != nullptr && dst_res != nullptr, "resource pointers")) {
    return false;
  }
  if (!Check(src_res->backing_alloc_id == 0 && dst_res->backing_alloc_id == 0, "resources are host-backed")) {
    return false;
  }
  if (!Check(src_res->storage.size() >= src_res->size_bytes, "src storage allocated")) {
    return false;
  }
  if (!Check(dst_res->storage.size() >= dst_res->size_bytes, "dst storage allocated")) {
    return false;
  }

  // Fill src with a deterministic pattern.
  for (size_t i = 0; i < src_res->storage.size(); ++i) {
    src_res->storage[i] = static_cast<uint8_t>(i & 0xFFu);
  }
  std::fill(dst_res->storage.begin(), dst_res->storage.end(), 0x00);

  // Copy a 2x2 rect from (0,0) into dst. Upload packets must be row-aligned, so
  // expect two full-row uploads (16 bytes each) at offsets 0 and row_pitch.
  RECT r{};
  r.left = 0;
  r.top = 0;
  r.right = 2;
  r.bottom = 2;

  D3D9DDIARG_COPYRECTS copy{};
  copy.hSrcResource = create_src.hResource;
  copy.hDstResource = create_dst.hResource;
  copy.pSrcRects = &r;
  copy.rect_count = 1;

  hr = cleanup.device_funcs.pfnCopyRects(create_dev.hDevice, &copy);
  if (!Check(hr == S_OK, "CopyRects")) {
    return false;
  }

  dev->cmd.finalize();
  if (!Check(ValidateStream(dma.data(), dma.size()), "stream validates")) {
    return false;
  }
  if (!Check(CountOpcode(dma.data(), dma.size(), AEROGPU_CMD_UPLOAD_RESOURCE) == 2, "CopyRects emits 2 UPLOAD_RESOURCE")) {
    return false;
  }

  // Validate both row uploads (offsets 0 and row_pitch, size row_pitch bytes each).
  const size_t stream_len = StreamBytesUsed(dma.data(), dma.size());
  size_t offset = sizeof(aerogpu_cmd_stream_header);
  uint32_t upload_idx = 0;
  while (offset + sizeof(aerogpu_cmd_hdr) <= stream_len) {
    const auto* hdr = reinterpret_cast<const aerogpu_cmd_hdr*>(dma.data() + offset);
    if (hdr->opcode == AEROGPU_CMD_UPLOAD_RESOURCE) {
      const auto* cmd = reinterpret_cast<const aerogpu_cmd_upload_resource*>(hdr);
      const uint32_t expected_off = (upload_idx == 0) ? 0u : src_res->row_pitch;
      const uint32_t expected_size = src_res->row_pitch;
      if (!Check(cmd->resource_handle == dst_res->handle, "UPLOAD_RESOURCE dst handle")) {
        return false;
      }
      if (!Check(cmd->offset_bytes == expected_off, "UPLOAD_RESOURCE offset")) {
        return false;
      }
      if (!Check(cmd->size_bytes == expected_size, "UPLOAD_RESOURCE size")) {
        return false;
      }
      const uint8_t* payload = reinterpret_cast<const uint8_t*>(cmd) + sizeof(*cmd);
      // The copy only touches the left half (8 bytes) of each row; the rest of
      // the row should remain zero (dst was initialized to zeros).
      if (!Check(std::memcmp(payload, src_res->storage.data() + expected_off, 8u) == 0, "UPLOAD_RESOURCE payload (copied bytes)")) {
        return false;
      }
      const uint8_t zeros[8] = {};
      if (!Check(std::memcmp(payload + 8u, zeros, sizeof(zeros)) == 0, "UPLOAD_RESOURCE payload (untouched bytes)")) {
        return false;
      }
      upload_idx++;
    }
    if (hdr->size_bytes == 0 || hdr->size_bytes > stream_len - offset) {
      break;
    }
    offset += hdr->size_bytes;
  }
  if (!Check(upload_idx == 2, "saw 2 UPLOAD_RESOURCE packets")) {
    return false;
  }

  // Make cleanup safe: switch back to vector mode so subsequent destroy calls
  // can't fail due to span-buffer capacity constraints.
  dev->cmd.set_vector();
  return true;
}

bool TestCopyRects16BitToHostBackedResourceEmitsUpload() {
  constexpr uint32_t kD3dFmtR5G6B5 = 23u;
  // Skip if the format isn't enabled in the build.
  if (aerogpu::d3d9_format_to_aerogpu(kD3dFmtR5G6B5) == AEROGPU_FORMAT_INVALID) {
    std::fprintf(stderr, "INFO: skipping CopyRects 16-bit test (R5G6B5 not enabled)\n");
    return true;
  }

  const uint32_t bpp = aerogpu::bytes_per_pixel(static_cast<D3DDDIFORMAT>(kD3dFmtR5G6B5));
  if (!Check(bpp == 2u, "bytes_per_pixel(R5G6B5)==2")) {
    return false;
  }

  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hSrc{};
    D3DDDI_HRESOURCE hDst{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_src = false;
    bool has_dst = false;

    ~Cleanup() {
      if (has_dst && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hDst);
      }
      if (has_src && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hSrc);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnCopyRects != nullptr, "CopyRects must be available")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  ScopedDeviceCmdVectorReset cmd_reset(dev);

  std::vector<uint8_t> dma(64 * 1024, 0);
  dev->cmd.set_span(dma.data(), dma.size());
  dev->cmd.reset();

  // Create host-backed src/dst surfaces (portable path: backing_alloc_id==0).
  D3D9DDIARG_CREATERESOURCE create_src{};
  create_src.type = kD3dRTypeSurface;
  create_src.format = kD3dFmtR5G6B5;
  create_src.width = 4;
  create_src.height = 4;
  create_src.depth = 1;
  create_src.mip_levels = 1;
  create_src.usage = 0;
  create_src.pool = 0;
  create_src.size = 0;
  create_src.hResource.pDrvPrivate = nullptr;
  create_src.pSharedHandle = nullptr;
  create_src.pPrivateDriverData = nullptr;
  create_src.PrivateDriverDataSize = 0;
  create_src.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_src);
  if (!Check(hr == S_OK, "CreateResource(src R5G6B5 surface)")) {
    return false;
  }
  cleanup.hSrc = create_src.hResource;
  cleanup.has_src = true;

  D3D9DDIARG_CREATERESOURCE create_dst = create_src;
  create_dst.hResource.pDrvPrivate = nullptr;
  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_dst);
  if (!Check(hr == S_OK, "CreateResource(dst R5G6B5 surface)")) {
    return false;
  }
  cleanup.hDst = create_dst.hResource;
  cleanup.has_dst = true;

  auto* src_res = reinterpret_cast<Resource*>(create_src.hResource.pDrvPrivate);
  auto* dst_res = reinterpret_cast<Resource*>(create_dst.hResource.pDrvPrivate);
  if (!Check(src_res != nullptr && dst_res != nullptr, "resource pointers")) {
    return false;
  }
  if (!Check(src_res->backing_alloc_id == 0 && dst_res->backing_alloc_id == 0, "resources are host-backed")) {
    return false;
  }
  if (!Check(src_res->storage.size() >= src_res->size_bytes, "src storage allocated")) {
    return false;
  }
  if (!Check(dst_res->storage.size() >= dst_res->size_bytes, "dst storage allocated")) {
    return false;
  }

  // Fill src with a deterministic pattern.
  for (size_t i = 0; i < src_res->storage.size(); ++i) {
    src_res->storage[i] = static_cast<uint8_t>(i & 0xFFu);
  }
  std::fill(dst_res->storage.begin(), dst_res->storage.end(), 0x00);

  // Copy a 2x2 rect from (0,0) into dst. Upload packets must be row-aligned, so
  // expect two full-row uploads (8 bytes each) at offsets 0 and row_pitch.
  RECT r{};
  r.left = 0;
  r.top = 0;
  r.right = 2;
  r.bottom = 2;

  D3D9DDIARG_COPYRECTS copy{};
  copy.hSrcResource = create_src.hResource;
  copy.hDstResource = create_dst.hResource;
  copy.pSrcRects = &r;
  copy.rect_count = 1;

  hr = cleanup.device_funcs.pfnCopyRects(create_dev.hDevice, &copy);
  if (!Check(hr == S_OK, "CopyRects(R5G6B5)")) {
    return false;
  }

  dev->cmd.finalize();
  if (!Check(ValidateStream(dma.data(), dma.size()), "stream validates")) {
    return false;
  }
  if (!Check(CountOpcode(dma.data(), dma.size(), AEROGPU_CMD_UPLOAD_RESOURCE) == 2,
             "CopyRects(R5G6B5) emits 2 UPLOAD_RESOURCE")) {
    return false;
  }

  // Validate both row uploads (offsets 0 and row_pitch, size row_pitch bytes each).
  const size_t stream_len = StreamBytesUsed(dma.data(), dma.size());
  size_t offset = sizeof(aerogpu_cmd_stream_header);
  uint32_t upload_idx = 0;
  while (offset + sizeof(aerogpu_cmd_hdr) <= stream_len) {
    const auto* hdr = reinterpret_cast<const aerogpu_cmd_hdr*>(dma.data() + offset);
    if (hdr->opcode == AEROGPU_CMD_UPLOAD_RESOURCE) {
      const auto* cmd = reinterpret_cast<const aerogpu_cmd_upload_resource*>(hdr);
      const uint32_t expected_off = (upload_idx == 0) ? 0u : src_res->row_pitch;
      const uint32_t expected_size = src_res->row_pitch;
      if (!Check(cmd->resource_handle == dst_res->handle, "UPLOAD_RESOURCE dst handle")) {
        return false;
      }
      if (!Check(cmd->offset_bytes == expected_off, "UPLOAD_RESOURCE offset")) {
        return false;
      }
      if (!Check(cmd->size_bytes == expected_size, "UPLOAD_RESOURCE size")) {
        return false;
      }
      const uint8_t* payload = reinterpret_cast<const uint8_t*>(cmd) + sizeof(*cmd);
      // The copy only touches the left half (4 bytes) of each row; the rest of
      // the row should remain zero (dst was initialized to zeros).
      if (!Check(std::memcmp(payload, src_res->storage.data() + expected_off, 4u) == 0,
                 "UPLOAD_RESOURCE payload (copied bytes)")) {
        return false;
      }
      const uint8_t zeros[4] = {};
      if (!Check(std::memcmp(payload + 4u, zeros, sizeof(zeros)) == 0,
                 "UPLOAD_RESOURCE payload (untouched bytes)")) {
        return false;
      }
      upload_idx++;
    }
    if (hdr->size_bytes == 0 || hdr->size_bytes > stream_len - offset) {
      break;
    }
    offset += hdr->size_bytes;
  }
  if (!Check(upload_idx == 2, "saw 2 UPLOAD_RESOURCE packets")) {
    return false;
  }

  // Make cleanup safe: switch back to vector mode so subsequent destroy calls
  // can't fail due to span-buffer capacity constraints.
  dev->cmd.set_vector();
  return true;
}

bool TestCopyRects16BitToGuestBackedResourceEmitsDirtyRange() {
#if defined(_WIN32)
  // Portable tests exercise the non-WDK code paths; skip on Windows where this
  // D3D9 UMD is expected to run against the real WDDM runtime.
  return true;
#else
  constexpr uint32_t kD3dFmtR5G6B5 = 23u;
  constexpr D3DDDIFORMAT kFmtR5G6B5 = static_cast<D3DDDIFORMAT>(kD3dFmtR5G6B5);

  if (aerogpu::d3d9_format_to_aerogpu(kD3dFmtR5G6B5) == AEROGPU_FORMAT_INVALID) {
    std::fprintf(stderr, "INFO: skipping CopyRects guest-backed 16-bit test (R5G6B5 not enabled)\n");
    return true;
  }

  const uint32_t bpp = aerogpu::bytes_per_pixel(kFmtR5G6B5);
  if (!Check(bpp == 2u, "bytes_per_pixel(R5G6B5) must be 2 when enabled")) {
    return false;
  }

  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    std::vector<D3DDDI_HRESOURCE> resources;
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyResource) {
        for (auto& hRes : resources) {
          if (hRes.pDrvPrivate) {
            device_funcs.pfnDestroyResource(hDevice, hRes);
          }
        }
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "pfnCreateResource")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnOpenResource != nullptr, "pfnOpenResource")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnCopyRects != nullptr, "pfnCopyRects")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  D3DDDI_ALLOCATIONLIST alloc_list[8] = {};

  // Create a host-backed source surface.
  D3D9DDIARG_CREATERESOURCE create_src{};
  create_src.type = kD3dRTypeSurface;
  create_src.format = kD3dFmtR5G6B5;
  create_src.width = 4;
  create_src.height = 4;
  create_src.depth = 1;
  create_src.mip_levels = 1;
  create_src.usage = 0;
  create_src.pool = 0;
  create_src.size = 0;
  create_src.hResource.pDrvPrivate = nullptr;
  create_src.pSharedHandle = nullptr;
  create_src.pPrivateDriverData = nullptr;
  create_src.PrivateDriverDataSize = 0;
  create_src.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_src);
  if (!Check(hr == S_OK, "CreateResource(src R5G6B5 surface)")) {
    return false;
  }
  if (!Check(create_src.hResource.pDrvPrivate != nullptr, "CreateResource returned src resource")) {
    return false;
  }
  cleanup.resources.push_back(create_src.hResource);

  auto* src_res = reinterpret_cast<Resource*>(create_src.hResource.pDrvPrivate);
  if (!Check(src_res != nullptr, "src resource pointer")) {
    return false;
  }
  if (!Check(src_res->handle != 0, "src has GPU handle")) {
    return false;
  }
  if (!Check(src_res->backing_alloc_id == 0, "src is host-backed")) {
    return false;
  }
  if (!Check(src_res->storage.size() >= src_res->size_bytes, "src storage allocated")) {
    return false;
  }

  // Create a guest-backed destination surface via OpenResource.
  aerogpu_wddm_alloc_priv priv{};
  priv.magic = AEROGPU_WDDM_ALLOC_PRIV_MAGIC;
  priv.version = AEROGPU_WDDM_ALLOC_PRIV_VERSION;
  priv.alloc_id = 0x7777u;
  priv.flags = AEROGPU_WDDM_ALLOC_PRIV_FLAG_IS_SHARED;
  priv.share_token = 0xAABBCCDDEEFF0011ull;
  priv.size_bytes = 4ull * 4ull * 2ull;
  priv.reserved0 = 0;

  D3D9DDIARG_OPENRESOURCE open_dst{};
  open_dst.pPrivateDriverData = &priv;
  open_dst.private_driver_data_size = sizeof(priv);
  open_dst.type = 0;
  open_dst.format = kD3dFmtR5G6B5;
  open_dst.width = 4;
  open_dst.height = 4;
  open_dst.depth = 1;
  open_dst.mip_levels = 1;
  open_dst.usage = 0;
  open_dst.size = 0;
  open_dst.hResource.pDrvPrivate = nullptr;
  open_dst.wddm_hAllocation = 0x2222u;

  hr = cleanup.device_funcs.pfnOpenResource(create_dev.hDevice, &open_dst);
  if (!Check(hr == S_OK, "OpenResource(guest-backed dst surface)")) {
    return false;
  }
  if (!Check(open_dst.hResource.pDrvPrivate != nullptr, "OpenResource returned dst resource")) {
    return false;
  }
  cleanup.resources.push_back(open_dst.hResource);

  auto* dst_res = reinterpret_cast<Resource*>(open_dst.hResource.pDrvPrivate);
  if (!Check(dst_res != nullptr, "dst resource pointer")) {
    return false;
  }
  if (!Check(dst_res->handle != 0, "dst has GPU handle")) {
    return false;
  }
  if (!Check(dst_res->backing_alloc_id == priv.alloc_id, "dst backing_alloc_id matches")) {
    return false;
  }
  if (!Check(dst_res->storage.size() >= dst_res->size_bytes, "dst storage allocated")) {
    return false;
  }

  // Enable allocation-list tracking (portable tests toggle hContext manually).
  hr = device_test_enable_wddm_context(create_dev.hDevice);
  if (!Check(hr == S_OK, "device_test_enable_wddm_context")) {
    return false;
  }
  hr = device_test_rebind_alloc_list_tracker(create_dev.hDevice, alloc_list, 8, 0xFFFFu);
  if (!Check(hr == S_OK, "device_test_rebind_alloc_list_tracker")) {
    return false;
  }
  hr = device_test_reset_alloc_list_tracker(create_dev.hDevice);
  if (!Check(hr == S_OK, "device_test_reset_alloc_list_tracker")) {
    return false;
  }

  // Fill src with a deterministic non-zero pattern and zero the destination.
  for (size_t i = 0; i < src_res->storage.size(); ++i) {
    src_res->storage[i] = static_cast<uint8_t>((i + 1) & 0xFFu);
  }
  std::fill(dst_res->storage.begin(), dst_res->storage.end(), 0x00);

  // Copy a 2x2 rect at (1,1). This should not emit UPLOAD_RESOURCE for a
  // guest-backed destination, but should emit RESOURCE_DIRTY_RANGE.
  RECT r{};
  r.left = 1;
  r.top = 1;
  r.right = 3;
  r.bottom = 3;

  D3D9DDIARG_COPYRECTS copy{};
  copy.hSrcResource = create_src.hResource;
  copy.hDstResource = open_dst.hResource;
  copy.pSrcRects = &r;
  copy.rect_count = 1;

  hr = cleanup.device_funcs.pfnCopyRects(create_dev.hDevice, &copy);
  if (!Check(hr == S_OK, "CopyRects(R5G6B5 guest-backed dst)")) {
    return false;
  }

  const uint32_t row_pitch = dst_res->row_pitch;
  const uint32_t row_bytes = static_cast<uint32_t>(r.right - r.left) * bpp;
  for (uint32_t y = static_cast<uint32_t>(r.top); y < static_cast<uint32_t>(r.bottom); ++y) {
    const size_t off = static_cast<size_t>(y) * row_pitch + static_cast<size_t>(r.left) * bpp;
    if (!Check(std::memcmp(dst_res->storage.data() + off, src_res->storage.data() + off, row_bytes) == 0,
               "CopyRects updated dst storage bytes")) {
      return false;
    }
  }
  if (!Check(dst_res->storage[0] == 0, "CopyRects did not overwrite dst bytes outside the rect")) {
    return false;
  }
  if (!Check(dst_res->storage.back() == 0, "CopyRects did not overwrite trailing dst bytes outside the rect")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_UPLOAD_RESOURCE) == 0, "guest-backed CopyRects must not emit UPLOAD_RESOURCE")) {
    return false;
  }

  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_RESOURCE_DIRTY_RANGE) == 1,
             "guest-backed CopyRects emits 1 RESOURCE_DIRTY_RANGE")) {
    return false;
  }

  const CmdLoc dirty = FindLastOpcode(buf, len, AEROGPU_CMD_RESOURCE_DIRTY_RANGE);
  if (!Check(dirty.hdr != nullptr, "RESOURCE_DIRTY_RANGE location")) {
    return false;
  }
  const auto* cmd = reinterpret_cast<const aerogpu_cmd_resource_dirty_range*>(dirty.hdr);
  if (!Check(cmd->resource_handle == dst_res->handle, "dirty_range handle matches dst")) {
    return false;
  }

  const uint64_t expected_off =
      static_cast<uint64_t>(r.top) * static_cast<uint64_t>(row_pitch) + static_cast<uint64_t>(r.left) * bpp;
  const uint64_t expected_size =
      static_cast<uint64_t>(r.bottom - r.top - 1) * static_cast<uint64_t>(row_pitch) + static_cast<uint64_t>(row_bytes);
  const uint64_t expected_end = expected_off + expected_size;

  if (!Check(cmd->offset_bytes <= expected_off, "dirty_range offset covers first modified byte")) {
    return false;
  }
  if (!Check(cmd->offset_bytes + cmd->size_bytes >= expected_end, "dirty_range size covers last modified byte")) {
    return false;
  }
  if (!Check(cmd->offset_bytes + cmd->size_bytes <= static_cast<uint64_t>(dst_res->size_bytes),
             "dirty_range stays within dst bounds")) {
    return false;
  }

  if (!Check(dev->alloc_list_tracker.list_len() == 1, "allocation list contains dst mapping")) {
    return false;
  }
  if (!Check(alloc_list[0].hAllocation == open_dst.wddm_hAllocation, "allocation list hAllocation matches")) {
    return false;
  }
  if (!Check(alloc_list[0].WriteOperation == 0, "dirty range tracks allocation as read")) {
    return false;
  }

  return ValidateStream(buf, len);
#endif
}

bool TestCopyRects16BitTransferEmitsCopyTexture2D() {
#if defined(_WIN32)
  // Portable tests exercise the non-WDK code paths; skip on Windows where this
  // D3D9 UMD is expected to run against the real WDDM runtime.
  return true;
#else
  constexpr uint32_t kD3dFmtR5G6B5 = 23u;
  constexpr D3DDDIFORMAT kFmtR5G6B5 = static_cast<D3DDDIFORMAT>(kD3dFmtR5G6B5);

  if (aerogpu::d3d9_format_to_aerogpu(kD3dFmtR5G6B5) == AEROGPU_FORMAT_INVALID) {
    std::fprintf(stderr, "INFO: skipping CopyRects transfer 16-bit test (R5G6B5 not enabled)\n");
    return true;
  }

  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCopyRects != nullptr, "pfnCopyRects")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev && dev->adapter, "device+adapter pointers")) {
    return false;
  }

  // Force the transfer-supported path in portable tests by stubbing the
  // UMDRIVERPRIVATE discovery blob.
  hr = device_test_force_umd_private_features(create_dev.hDevice, AEROGPU_UMDPRIV_FEATURE_TRANSFER);
  if (!Check(hr == S_OK, "device_test_force_umd_private_features(TRANSFER)")) {
    return false;
  }

  // Use a span-backed command buffer so submit()'s rewind preserves the finalized
  // bytes for inspection.
  uint8_t stream_buf[256] = {};
  dev->cmd.set_span(stream_buf, sizeof(stream_buf));
  dev->cmd.reset();
  struct CmdModeGuard {
    Device* dev = nullptr;
    ~CmdModeGuard() {
      if (dev) {
        // Cleanup destructors may submit, so ensure we don't reference the
        // stack-backed command buffer after this test completes.
        dev->cmd.set_vector();
      }
    }
  } cmd_guard{dev};

  const uint32_t bpp = aerogpu::bytes_per_pixel(kFmtR5G6B5);
  if (!Check(bpp == 2u, "bytes_per_pixel(R5G6B5) must be 2 when enabled")) {
    return false;
  }

  constexpr uint32_t kWidth = 4;
  constexpr uint32_t kHeight = 4;
  const uint32_t row_pitch = kWidth * bpp;
  const uint32_t size_bytes = row_pitch * kHeight;

  Resource src{};
  src.kind = ResourceKind::Surface;
  src.handle = 0x3000u;
  src.format = kFmtR5G6B5;
  src.width = kWidth;
  src.height = kHeight;
  src.depth = 1;
  src.mip_levels = 1;
  src.pool = 0;
  src.size_bytes = size_bytes;
  src.row_pitch = row_pitch;
  src.slice_pitch = size_bytes;

  Resource dst{};
  dst.kind = ResourceKind::Surface;
  dst.handle = 0x4000u;
  dst.format = kFmtR5G6B5;
  dst.width = kWidth;
  dst.height = kHeight;
  dst.depth = 1;
  dst.mip_levels = 1;
  dst.pool = 2u; // D3DPOOL_SYSTEMMEM
  dst.size_bytes = size_bytes;
  dst.row_pitch = row_pitch;
  dst.slice_pitch = size_bytes;
  dst.backing_alloc_id = 0x1234u; // required for WRITEBACK_DST
  dst.wddm_hAllocation = 0;

  D3DDDI_HRESOURCE hSrc{};
  hSrc.pDrvPrivate = &src;
  D3DDDI_HRESOURCE hDst{};
  hDst.pDrvPrivate = &dst;

  D3D9DDIARG_COPYRECTS args{};
  args.hSrcResource = hSrc;
  args.hDstResource = hDst;
  args.pSrcRects = nullptr;
  args.rect_count = 0;

  hr = cleanup.device_funcs.pfnCopyRects(create_dev.hDevice, &args);
  if (!Check(hr == S_OK, "CopyRects(R5G6B5 transfer-supported)")) {
    return false;
  }

  if (!Check(ValidateStream(stream_buf, sizeof(stream_buf)), "command stream validation")) {
    return false;
  }

  if (!Check(CountOpcode(stream_buf, sizeof(stream_buf), AEROGPU_CMD_COPY_TEXTURE2D) == 1,
             "CopyRects emits COPY_TEXTURE2D")) {
    return false;
  }
  if (!Check(CountOpcode(stream_buf, sizeof(stream_buf), AEROGPU_CMD_UPLOAD_RESOURCE) == 0,
             "transfer CopyRects must not emit UPLOAD_RESOURCE")) {
    return false;
  }
  if (!Check(CountOpcode(stream_buf, sizeof(stream_buf), AEROGPU_CMD_RESOURCE_DIRTY_RANGE) == 0,
             "transfer CopyRects must not emit RESOURCE_DIRTY_RANGE")) {
    return false;
  }

  const CmdLoc copy = FindLastOpcode(stream_buf, sizeof(stream_buf), AEROGPU_CMD_COPY_TEXTURE2D);
  if (!Check(copy.hdr != nullptr, "COPY_TEXTURE2D location")) {
    return false;
  }
  const auto* cmd = reinterpret_cast<const aerogpu_cmd_copy_texture2d*>(copy.hdr);
  if (!Check(cmd->src_texture == src.handle, "COPY_TEXTURE2D src_texture matches")) {
    return false;
  }
  if (!Check(cmd->dst_texture == dst.handle, "COPY_TEXTURE2D dst_texture matches")) {
    return false;
  }
  if (!Check(cmd->width == kWidth && cmd->height == kHeight, "COPY_TEXTURE2D width/height match surface")) {
    return false;
  }
  if (!Check(cmd->flags == AEROGPU_COPY_FLAG_WRITEBACK_DST, "COPY_TEXTURE2D has WRITEBACK_DST flag")) {
    return false;
  }

  return true;
#endif
}

bool TestSharedResourceCreateAndOpenEmitsExportImport() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hResource{};
    D3DDDI_HRESOURCE hAlias{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_resource = false;
    bool has_alias = false;

    ~Cleanup() {
      if (has_alias && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hAlias);
      }
      if (has_resource && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hResource);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  ScopedDeviceCmdVectorReset cmd_reset(dev);

  // Use a span-backed buffer so we can inspect the exact packets emitted for
  // shared-surface create/open. Note: CreateResource(shared) forces an immediate
  // submission to make the EXPORT visible to other processes; that resets the
  // stream header but leaves the packet bytes intact in the span buffer.
  std::vector<uint8_t> dma(4096, 0);
  dev->cmd.set_span(dma.data(), dma.size());

  aerogpu_wddm_alloc_priv priv{};
  std::memset(&priv, 0, sizeof(priv));
  HANDLE shared_handle = nullptr;

  D3D9DDIARG_CREATERESOURCE create_shared{};
  create_shared.type = kD3dRTypeSurface;
  create_shared.format = 22u; // D3DFMT_X8R8G8B8
  create_shared.width = 32;
  create_shared.height = 32;
  create_shared.depth = 1;
  create_shared.mip_levels = 1;
  create_shared.usage = 0x00000001u; // D3DUSAGE_RENDERTARGET
  create_shared.pool = 0;
  create_shared.size = 0;
  create_shared.hResource.pDrvPrivate = nullptr;
  create_shared.pSharedHandle = &shared_handle;
  create_shared.pKmdAllocPrivateData = &priv;
  create_shared.KmdAllocPrivateDataSize = sizeof(priv);
  create_shared.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_shared);
  if (!Check(hr == S_OK, "CreateResource(shared)")) {
    return false;
  }
  cleanup.hResource = create_shared.hResource;
  cleanup.has_resource = true;

  auto* res = reinterpret_cast<Resource*>(create_shared.hResource.pDrvPrivate);
  if (!Check(res != nullptr, "shared resource pointer")) {
    return false;
  }
  if (!Check(res->is_shared, "resource is_shared")) {
    return false;
  }
  if (!Check(!res->is_shared_alias, "shared create is not an alias")) {
    return false;
  }
  if (!Check(res->share_token != 0, "shared resource share_token non-zero")) {
    return false;
  }
  if (!Check(res->backing_alloc_id != 0, "shared resource backing_alloc_id non-zero")) {
    return false;
  }

  if (!Check(priv.magic == AEROGPU_WDDM_ALLOC_PRIV_MAGIC, "alloc priv magic")) {
    return false;
  }
  if (!Check(priv.version == AEROGPU_WDDM_ALLOC_PRIV_VERSION, "alloc priv version")) {
    return false;
  }
  if (!Check((priv.flags & AEROGPU_WDDM_ALLOC_PRIV_FLAG_IS_SHARED) != 0, "alloc priv shared flag")) {
    return false;
  }
  if (!Check(priv.alloc_id == res->backing_alloc_id, "alloc priv alloc_id matches resource")) {
    return false;
  }
  if (!Check(priv.share_token == res->share_token, "alloc priv share_token matches resource")) {
    return false;
  }
  if (!Check(priv.size_bytes != 0, "alloc priv size_bytes non-zero")) {
    return false;
  }
  if (!Check(AEROGPU_WDDM_ALLOC_PRIV_DESC_PRESENT(priv.reserved0), "alloc priv desc present")) {
    return false;
  }
  if (!Check(AEROGPU_WDDM_ALLOC_PRIV_DESC_FORMAT(priv.reserved0) == create_shared.format, "alloc priv desc format")) {
    return false;
  }
  if (!Check(AEROGPU_WDDM_ALLOC_PRIV_DESC_WIDTH(priv.reserved0) == create_shared.width, "alloc priv desc width")) {
    return false;
  }
  if (!Check(AEROGPU_WDDM_ALLOC_PRIV_DESC_HEIGHT(priv.reserved0) == create_shared.height, "alloc priv desc height")) {
    return false;
  }

  // The shared create path should emit CREATE_TEXTURE2D + EXPORT_SHARED_SURFACE.
  if (!Check(CountOpcode(dma.data(), dma.size(), AEROGPU_CMD_CREATE_TEXTURE2D) == 1, "CREATE_TEXTURE2D emitted")) {
    return false;
  }
  if (!Check(CountOpcode(dma.data(), dma.size(), AEROGPU_CMD_EXPORT_SHARED_SURFACE) == 1, "EXPORT_SHARED_SURFACE emitted")) {
    return false;
  }
  const CmdLoc export_loc = FindLastOpcode(dma.data(), dma.size(), AEROGPU_CMD_EXPORT_SHARED_SURFACE);
  if (!Check(export_loc.hdr != nullptr, "EXPORT_SHARED_SURFACE packet present")) {
    return false;
  }
  const auto* export_cmd = reinterpret_cast<const aerogpu_cmd_export_shared_surface*>(export_loc.hdr);
  if (!Check(export_cmd->resource_handle == res->handle, "EXPORT_SHARED_SURFACE resource_handle matches")) {
    return false;
  }
  if (!Check(export_cmd->share_token == res->share_token, "EXPORT_SHARED_SURFACE share_token matches")) {
    return false;
  }

  // Now simulate opening the shared resource in another process: caller passes a
  // non-null shared handle value plus the preserved allocation private data blob.
  std::memset(dma.data(), 0, dma.size());
  dev->cmd.set_span(dma.data(), dma.size());

  // Accept both v1 and v2 allocation private data blobs (the KMD may return v2
  // when the caller provided a large-enough buffer).
  aerogpu_wddm_alloc_priv_v2 priv_open{};
  std::memset(&priv_open, 0, sizeof(priv_open));
  std::memcpy(&priv_open, &priv, sizeof(priv));
  priv_open.version = AEROGPU_WDDM_ALLOC_PRIV_VERSION_2;
  HANDLE open_handle = reinterpret_cast<HANDLE>(static_cast<uintptr_t>(0x1));

  D3D9DDIARG_CREATERESOURCE open_shared{};
  open_shared.type = create_shared.type;
  open_shared.format = create_shared.format;
  open_shared.width = create_shared.width;
  open_shared.height = create_shared.height;
  open_shared.depth = create_shared.depth;
  open_shared.mip_levels = create_shared.mip_levels;
  open_shared.usage = create_shared.usage;
  open_shared.pool = create_shared.pool;
  open_shared.size = 0;
  open_shared.hResource.pDrvPrivate = nullptr;
  open_shared.pSharedHandle = &open_handle;
  open_shared.pKmdAllocPrivateData = &priv_open;
  open_shared.KmdAllocPrivateDataSize = sizeof(priv_open);
  open_shared.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &open_shared);
  if (!Check(hr == S_OK, "CreateResource(open shared)")) {
    return false;
  }
  cleanup.hAlias = open_shared.hResource;
  cleanup.has_alias = true;

  auto* alias = reinterpret_cast<Resource*>(open_shared.hResource.pDrvPrivate);
  if (!Check(alias != nullptr, "alias resource pointer")) {
    return false;
  }
  if (!Check(alias->is_shared, "alias is_shared")) {
    return false;
  }
  if (!Check(alias->is_shared_alias, "alias is_shared_alias")) {
    return false;
  }
  if (!Check(alias->share_token == res->share_token, "alias share_token matches original")) {
    return false;
  }
  if (!Check(alias->backing_alloc_id == res->backing_alloc_id, "alias backing_alloc_id matches original")) {
    return false;
  }

  dev->cmd.finalize();
  if (!Check(ValidateStream(dma.data(), dma.size()), "import stream validates")) {
    return false;
  }
  if (!Check(CountOpcode(dma.data(), dma.size(), AEROGPU_CMD_IMPORT_SHARED_SURFACE) == 1, "IMPORT_SHARED_SURFACE emitted")) {
    return false;
  }
  if (!Check(CountOpcode(dma.data(), dma.size(), AEROGPU_CMD_CREATE_TEXTURE2D) == 0, "open shared does not CREATE_TEXTURE2D")) {
    return false;
  }

  const CmdLoc import_loc = FindLastOpcode(dma.data(), dma.size(), AEROGPU_CMD_IMPORT_SHARED_SURFACE);
  if (!Check(import_loc.hdr != nullptr, "IMPORT_SHARED_SURFACE packet present")) {
    return false;
  }
  const auto* import_cmd = reinterpret_cast<const aerogpu_cmd_import_shared_surface*>(import_loc.hdr);
  if (!Check(import_cmd->out_resource_handle == alias->handle, "IMPORT_SHARED_SURFACE out_resource_handle matches")) {
    return false;
  }
  if (!Check(import_cmd->share_token == alias->share_token, "IMPORT_SHARED_SURFACE share_token matches")) {
    return false;
  }

  const aerogpu_handle_t original_handle = res->handle;
  const aerogpu_handle_t alias_handle = alias->handle;

  // Validate that DestroyResource emits DESTROY_RESOURCE even for shared surfaces.
  auto check_destroy_stream = [&](aerogpu_handle_t expected_handle, const char* which) -> bool {
    dev->cmd.finalize();
    if (!Check(ValidateStream(dma.data(), dma.size()), which)) {
      return false;
    }
    if (!Check(CountOpcode(dma.data(), dma.size(), AEROGPU_CMD_DESTROY_RESOURCE) >= 1, which)) {
      return false;
    }
    const auto* stream = reinterpret_cast<const aerogpu_cmd_stream_header*>(dma.data());
    size_t offset = sizeof(aerogpu_cmd_stream_header);
    while (offset + sizeof(aerogpu_cmd_hdr) <= stream->size_bytes) {
      const auto* hdr = reinterpret_cast<const aerogpu_cmd_hdr*>(dma.data() + offset);
      if (hdr->opcode == AEROGPU_CMD_DESTROY_RESOURCE) {
        const auto* cmd = reinterpret_cast<const aerogpu_cmd_destroy_resource*>(hdr);
        if (cmd->resource_handle == expected_handle) {
          return true;
        }
      }
      if (hdr->size_bytes == 0 || hdr->size_bytes > stream->size_bytes - offset) {
        break;
      }
      offset += hdr->size_bytes;
    }
    std::fprintf(stderr, "FAIL: %s missing expected handle %u\n", which, static_cast<unsigned>(expected_handle));
    return false;
  };

  std::memset(dma.data(), 0, dma.size());
  dev->cmd.set_span(dma.data(), dma.size());
  if (cleanup.device_funcs.pfnDestroyResource) {
    cleanup.device_funcs.pfnDestroyResource(create_dev.hDevice, cleanup.hAlias);
    cleanup.has_alias = false;
  }
  if (!check_destroy_stream(alias_handle, "DestroyResource(alias) emits DESTROY_RESOURCE")) {
    dev->cmd.set_vector();
    return false;
  }

  std::memset(dma.data(), 0, dma.size());
  dev->cmd.set_span(dma.data(), dma.size());
  if (cleanup.device_funcs.pfnDestroyResource) {
    cleanup.device_funcs.pfnDestroyResource(create_dev.hDevice, cleanup.hResource);
    cleanup.has_resource = false;
  }
  if (!check_destroy_stream(original_handle, "DestroyResource(original) emits DESTROY_RESOURCE")) {
    dev->cmd.set_vector();
    return false;
  }

  // Make cleanup safe: switch back to vector mode so subsequent destroy calls
  // can't fail due to span-buffer capacity constraints.
  dev->cmd.set_vector();
  return true;
}

bool TestPresentStatsAndFrameLatency() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnPresentEx != nullptr, "PresentEx must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnGetPresentStats != nullptr, "GetPresentStats must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnGetLastPresentCount != nullptr, "GetLastPresentCount must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetMaximumFrameLatency != nullptr, "SetMaximumFrameLatency must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnGetMaximumFrameLatency != nullptr, "GetMaximumFrameLatency must be available")) {
    return false;
  }

  D3D9DDI_PRESENTSTATS stats{};
  hr = cleanup.device_funcs.pfnGetPresentStats(create_dev.hDevice, &stats);
  if (!Check(hr == S_OK, "GetPresentStats initial")) {
    return false;
  }
  if (!Check(stats.PresentCount == 0, "PresentCount initial == 0")) {
    return false;
  }

  uint32_t last_present = 123;
  hr = cleanup.device_funcs.pfnGetLastPresentCount(create_dev.hDevice, &last_present);
  if (!Check(hr == S_OK, "GetLastPresentCount initial")) {
    return false;
  }
  if (!Check(last_present == 0, "LastPresentCount initial == 0")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnSetMaximumFrameLatency(create_dev.hDevice, 0);
  if (!Check(hr == E_INVALIDARG, "SetMaximumFrameLatency rejects 0")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnSetMaximumFrameLatency(create_dev.hDevice, 1);
  if (!Check(hr == S_OK, "SetMaximumFrameLatency(1)")) {
    return false;
  }

  uint32_t max_latency = 0;
  hr = cleanup.device_funcs.pfnGetMaximumFrameLatency(create_dev.hDevice, &max_latency);
  if (!Check(hr == S_OK, "GetMaximumFrameLatency")) {
    return false;
  }
  if (!Check(max_latency == 1, "GetMaximumFrameLatency returns 1")) {
    return false;
  }

  D3D9DDIARG_PRESENTEX present{};
  present.hSrc.pDrvPrivate = nullptr;
  present.hWnd = nullptr;
  present.sync_interval = 1;
  present.d3d9_present_flags = 0;
  hr = cleanup.device_funcs.pfnPresentEx(create_dev.hDevice, &present);
  if (!Check(hr == S_OK, "PresentEx first")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnGetPresentStats(create_dev.hDevice, &stats);
  if (!Check(hr == S_OK, "GetPresentStats after PresentEx")) {
    return false;
  }
  if (!Check(stats.PresentCount == 1, "PresentCount == 1 after PresentEx")) {
    return false;
  }
  if (!Check(stats.PresentRefreshCount == 1, "PresentRefreshCount == 1 after PresentEx")) {
    return false;
  }
  if (!Check(stats.SyncRefreshCount == 1, "SyncRefreshCount == 1 after PresentEx")) {
    return false;
  }
  if (!Check(stats.SyncQPCTime != 0, "SyncQPCTime non-zero after PresentEx")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnGetLastPresentCount(create_dev.hDevice, &last_present);
  if (!Check(hr == S_OK, "GetLastPresentCount after PresentEx")) {
    return false;
  }
  if (!Check(last_present == 1, "LastPresentCount == 1 after PresentEx")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  auto* adapter = reinterpret_cast<Adapter*>(open.hAdapter.pDrvPrivate);
  if (!Check(dev != nullptr && adapter != nullptr, "device/adapter pointers")) {
    return false;
  }

  uint64_t first_present_fence = 0;
  {
    std::lock_guard<std::mutex> lock(dev->mutex);
    if (!Check(dev->inflight_present_fences.size() == 1, "inflight_present_fences contains one fence")) {
      return false;
    }
    first_present_fence = dev->inflight_present_fences.front();
  }
  if (!Check(first_present_fence != 0, "present fence value")) {
    return false;
  }

  // Force the present fence into the "not completed" state so we can validate
  // D3DPRESENT_DONOTWAIT throttling.
  hr = adapter_test_set_completed_fence(open.hAdapter, 0);
  if (!Check(hr == S_OK, "adapter_test_set_completed_fence (present not completed)")) {
    return false;
  }

  present.d3d9_present_flags = 0x1u; // D3DPRESENT_DONOTWAIT
  hr = cleanup.device_funcs.pfnPresentEx(create_dev.hDevice, &present);
  if (!Check(hr == D3DERR_WASSTILLDRAWING, "PresentEx DONOTWAIT returns WASSTILLDRAWING when throttled")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnGetLastPresentCount(create_dev.hDevice, &last_present);
  if (!Check(hr == S_OK, "GetLastPresentCount after throttled PresentEx")) {
    return false;
  }
  if (!Check(last_present == 1, "LastPresentCount unchanged after throttled PresentEx")) {
    return false;
  }

  // Mark the fence complete and confirm presents proceed again.
  hr = adapter_test_set_completed_fence(open.hAdapter, first_present_fence);
  if (!Check(hr == S_OK, "adapter_test_set_completed_fence (present completed)")) {
    return false;
  }

  present.d3d9_present_flags = 0;
  hr = cleanup.device_funcs.pfnPresentEx(create_dev.hDevice, &present);
  if (!Check(hr == S_OK, "PresentEx after fence completion")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnGetPresentStats(create_dev.hDevice, &stats);
  if (!Check(hr == S_OK, "GetPresentStats after second PresentEx")) {
    return false;
  }
  if (!Check(stats.PresentCount == 2, "PresentCount == 2 after second PresentEx")) {
    return false;
  }
  return true;
}

bool TestPresentExSubmitsOnceWhenNoPendingRenderWork() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnPresentEx != nullptr, "PresentEx must be available")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  auto* adapter = reinterpret_cast<Adapter*>(open.hAdapter.pDrvPrivate);
  if (!Check(dev != nullptr && adapter != nullptr, "device/adapter pointers")) {
    return false;
  }

  uint64_t base_fence = 0;
  uint64_t base_render_submits = 0;
  uint64_t base_present_submits = 0;
  {
    std::lock_guard<std::mutex> lock(adapter->fence_mutex);
    base_fence = adapter->last_submitted_fence;
    base_render_submits = adapter->render_submit_count;
    base_present_submits = adapter->present_submit_count;
  }

  D3D9DDIARG_PRESENTEX present{};
  present.hSrc.pDrvPrivate = nullptr;
  present.hWnd = nullptr;
  present.sync_interval = 1;
  present.d3d9_present_flags = 0;
  hr = cleanup.device_funcs.pfnPresentEx(create_dev.hDevice, &present);
  if (!Check(hr == S_OK, "PresentEx")) {
    return false;
  }

  uint64_t final_fence = 0;
  uint64_t final_render_submits = 0;
  uint64_t final_present_submits = 0;
  {
    std::lock_guard<std::mutex> lock(adapter->fence_mutex);
    final_fence = adapter->last_submitted_fence;
    final_render_submits = adapter->render_submit_count;
    final_present_submits = adapter->present_submit_count;
  }
  if (!Check(final_fence == base_fence + 1, "PresentEx submits exactly once when no render work is pending")) {
    return false;
  }
  if (!Check(final_render_submits == base_render_submits, "PresentEx (idle) does not issue a render submit")) {
    return false;
  }
  if (!Check(final_present_submits == base_present_submits + 1, "PresentEx (idle) issues exactly one present submit")) {
    return false;
  }

  uint64_t present_fence = 0;
  {
    std::lock_guard<std::mutex> lock(dev->mutex);
    if (!Check(dev->inflight_present_fences.size() == 1, "inflight_present_fences contains one fence")) {
      return false;
    }
    present_fence = dev->inflight_present_fences.front();
  }
  return Check(present_fence == base_fence + 1, "present fence matches single submission");
}

bool TestPresentSubmitsOnceWhenNoPendingRenderWork() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnPresent != nullptr, "Present must be available")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  auto* adapter = reinterpret_cast<Adapter*>(open.hAdapter.pDrvPrivate);
  if (!Check(dev != nullptr && adapter != nullptr, "device/adapter pointers")) {
    return false;
  }

  uint64_t base_fence = 0;
  uint64_t base_render_submits = 0;
  uint64_t base_present_submits = 0;
  {
    std::lock_guard<std::mutex> lock(adapter->fence_mutex);
    base_fence = adapter->last_submitted_fence;
    base_render_submits = adapter->render_submit_count;
    base_present_submits = adapter->present_submit_count;
  }

  D3D9DDIARG_PRESENT present{};
  present.hSrc.pDrvPrivate = nullptr;
  present.hSwapChain.pDrvPrivate = nullptr;
  present.hWnd = nullptr;
  present.sync_interval = 1;
  present.flags = 0;
  hr = cleanup.device_funcs.pfnPresent(create_dev.hDevice, &present);
  if (!Check(hr == S_OK, "Present")) {
    return false;
  }

  uint64_t final_fence = 0;
  uint64_t final_render_submits = 0;
  uint64_t final_present_submits = 0;
  {
    std::lock_guard<std::mutex> lock(adapter->fence_mutex);
    final_fence = adapter->last_submitted_fence;
    final_render_submits = adapter->render_submit_count;
    final_present_submits = adapter->present_submit_count;
  }
  if (!Check(final_fence == base_fence + 1, "Present submits exactly once when no render work is pending")) {
    return false;
  }
  if (!Check(final_render_submits == base_render_submits, "Present (idle) does not issue a render submit")) {
    return false;
  }
  if (!Check(final_present_submits == base_present_submits + 1, "Present (idle) issues exactly one present submit")) {
    return false;
  }

  uint64_t present_fence = 0;
  {
    std::lock_guard<std::mutex> lock(dev->mutex);
    if (!Check(dev->inflight_present_fences.size() == 1, "inflight_present_fences contains one fence")) {
      return false;
    }
    present_fence = dev->inflight_present_fences.front();
  }
  return Check(present_fence == base_fence + 1, "present fence matches single submission");
}

bool TestPresentExSplitsRenderAndPresentSubmissions() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnClear != nullptr, "Clear must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnPresentEx != nullptr, "PresentEx must be available")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  auto* adapter = reinterpret_cast<Adapter*>(open.hAdapter.pDrvPrivate);
  if (!Check(dev != nullptr && adapter != nullptr, "device/adapter pointers")) {
    return false;
  }

  uint64_t base_fence = 0;
  uint64_t base_render_submits = 0;
  uint64_t base_present_submits = 0;
  {
    std::lock_guard<std::mutex> lock(adapter->fence_mutex);
    base_fence = adapter->last_submitted_fence;
    base_render_submits = adapter->render_submit_count;
    base_present_submits = adapter->present_submit_count;
  }

  // Emit a render command so PresentEx must flush it via a Render submission
  // before issuing the Present submission.
  hr = cleanup.device_funcs.pfnClear(create_dev.hDevice,
                                     /*flags=*/0,
                                     /*color_rgba8=*/0,
                                     /*depth=*/1.0f,
                                     /*stencil=*/0);
  if (!Check(hr == S_OK, "Clear")) {
    return false;
  }

  bool has_pending_render = false;
  {
    std::lock_guard<std::mutex> lock(dev->mutex);
    has_pending_render = !dev->cmd.empty();
  }
  if (!Check(has_pending_render, "Clear emits pending render work")) {
    return false;
  }

  D3D9DDIARG_PRESENTEX present{};
  present.hSrc.pDrvPrivate = nullptr;
  present.hWnd = nullptr;
  present.sync_interval = 1;
  present.d3d9_present_flags = 0;
  hr = cleanup.device_funcs.pfnPresentEx(create_dev.hDevice, &present);
  if (!Check(hr == S_OK, "PresentEx")) {
    return false;
  }

  uint64_t final_fence = 0;
  uint64_t final_render_submits = 0;
  uint64_t final_present_submits = 0;
  {
    std::lock_guard<std::mutex> lock(adapter->fence_mutex);
    final_fence = adapter->last_submitted_fence;
    final_render_submits = adapter->render_submit_count;
    final_present_submits = adapter->present_submit_count;
  }

  if (!Check(final_fence == base_fence + 2,
             "PresentEx flushes render work then presents (two submissions)")) {
    return false;
  }
  if (!Check(final_render_submits == base_render_submits + 1, "PresentEx flush issues exactly one render submit")) {
    return false;
  }
  if (!Check(final_present_submits == base_present_submits + 1, "PresentEx issues exactly one present submit")) {
    return false;
  }

  uint64_t present_fence = 0;
  {
    std::lock_guard<std::mutex> lock(dev->mutex);
    if (!Check(dev->inflight_present_fences.size() == 1, "inflight_present_fences contains one fence")) {
      return false;
    }
    present_fence = dev->inflight_present_fences.front();
  }
  return Check(present_fence == base_fence + 2, "present fence corresponds to second submission");
}

bool TestConcurrentPresentExReturnsDistinctFences() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs1{};
    D3D9DDI_DEVICEFUNCS device_funcs2{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice1{};
    D3DDDI_HDEVICE hDevice2{};
    bool has_adapter = false;
    bool has_device1 = false;
    bool has_device2 = false;
 
    ~Cleanup() {
      if (has_device1 && device_funcs1.pfnDestroyDevice) {
        device_funcs1.pfnDestroyDevice(hDevice1);
      }
      if (has_device2 && device_funcs2.pfnDestroyDevice) {
        device_funcs2.pfnDestroyDevice(hDevice2);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;
 
  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;
 
  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;
 
  D3D9DDIARG_CREATEDEVICE create_dev1{};
  create_dev1.hAdapter = open.hAdapter;
  create_dev1.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev1, &cleanup.device_funcs1);
  if (!Check(hr == S_OK, "CreateDevice(device1)")) {
    return false;
  }
  cleanup.hDevice1 = create_dev1.hDevice;
  cleanup.has_device1 = true;
 
  D3D9DDIARG_CREATEDEVICE create_dev2{};
  create_dev2.hAdapter = open.hAdapter;
  create_dev2.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev2, &cleanup.device_funcs2);
  if (!Check(hr == S_OK, "CreateDevice(device2)")) {
    return false;
  }
  cleanup.hDevice2 = create_dev2.hDevice;
  cleanup.has_device2 = true;
 
  if (!Check(cleanup.device_funcs1.pfnPresentEx != nullptr, "PresentEx must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs2.pfnPresentEx != nullptr, "PresentEx must be available (device2)")) {
    return false;
  }
 
  auto* dev1 = reinterpret_cast<Device*>(create_dev1.hDevice.pDrvPrivate);
  auto* dev2 = reinterpret_cast<Device*>(create_dev2.hDevice.pDrvPrivate);
  auto* adapter = reinterpret_cast<Adapter*>(open.hAdapter.pDrvPrivate);
  if (!Check(dev1 != nullptr && dev2 != nullptr && adapter != nullptr, "device/adapter pointers")) {
    return false;
  }
 
  uint64_t base_fence = 0;
  {
    std::lock_guard<std::mutex> lock(adapter->fence_mutex);
    base_fence = adapter->last_submitted_fence;
  }
 
  struct Gate {
    std::mutex mutex;
    std::condition_variable cv;
    int ready = 0;
    bool go = false;
  } gate;
 
  uint64_t fence1 = 0;
  uint64_t fence2 = 0;
  HRESULT hr1 = E_FAIL;
  HRESULT hr2 = E_FAIL;
 
  auto run_present = [&](D3DDDI_HDEVICE hDevice, Device* dev, D3D9DDI_DEVICEFUNCS* funcs, uint64_t* out_fence,
                         HRESULT* out_hr) {
    {
      std::unique_lock<std::mutex> lock(gate.mutex);
      gate.ready++;
      gate.cv.notify_all();
      gate.cv.wait(lock, [&] { return gate.go; });
    }
 
    D3D9DDIARG_PRESENTEX present{};
    present.hSrc.pDrvPrivate = nullptr;
    present.hWnd = nullptr;
    present.sync_interval = 1;
    present.d3d9_present_flags = 0;
    const HRESULT local_hr = funcs->pfnPresentEx(hDevice, &present);
 
    uint64_t local_fence = 0;
    {
      std::lock_guard<std::mutex> lock(dev->mutex);
      local_fence = dev->last_submission_fence;
    }
 
    if (out_fence) {
      *out_fence = local_fence;
    }
    if (out_hr) {
      *out_hr = local_hr;
    }
  };
 
  std::thread t1(run_present, create_dev1.hDevice, dev1, &cleanup.device_funcs1, &fence1, &hr1);
  std::thread t2(run_present, create_dev2.hDevice, dev2, &cleanup.device_funcs2, &fence2, &hr2);
 
  {
    std::unique_lock<std::mutex> lock(gate.mutex);
    if (!gate.cv.wait_for(lock, std::chrono::milliseconds(500), [&] { return gate.ready == 2; })) {
      gate.go = true;
      gate.cv.notify_all();
      lock.unlock();
      t1.join();
      t2.join();
      return Check(false, "PresentEx threads failed to start");
    }
    gate.go = true;
    gate.cv.notify_all();
  }
 
  t1.join();
  t2.join();
 
  if (!Check(hr1 == S_OK, "PresentEx(device1)")) {
    return false;
  }
  if (!Check(hr2 == S_OK, "PresentEx(device2)")) {
    return false;
  }
  if (!Check(fence1 != 0 && fence2 != 0, "PresentEx returns non-zero fences")) {
    return false;
  }
  if (!Check(fence1 != fence2, "Concurrent PresentEx submissions return distinct fences")) {
    return false;
  }
  if (!Check(fence1 > base_fence && fence2 > base_fence, "Concurrent PresentEx fences advance")) {
    return false;
  }
 
  const uint64_t max_fence = std::max(fence1, fence2);
  {
    std::lock_guard<std::mutex> lock(adapter->fence_mutex);
    if (!Check(adapter->last_submitted_fence >= max_fence, "adapter last_submitted_fence >= max PresentEx fence")) {
      return false;
    }
  }
  return true;
}

bool TestPresentSplitsRenderAndPresentSubmissions() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnClear != nullptr, "Clear must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnPresent != nullptr, "Present must be available")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  auto* adapter = reinterpret_cast<Adapter*>(open.hAdapter.pDrvPrivate);
  if (!Check(dev != nullptr && adapter != nullptr, "device/adapter pointers")) {
    return false;
  }

  uint64_t base_fence = 0;
  uint64_t base_render_submits = 0;
  uint64_t base_present_submits = 0;
  {
    std::lock_guard<std::mutex> lock(adapter->fence_mutex);
    base_fence = adapter->last_submitted_fence;
    base_render_submits = adapter->render_submit_count;
    base_present_submits = adapter->present_submit_count;
  }

  // Emit a render command so Present must flush it via a Render submission before
  // issuing the Present submission.
  hr = cleanup.device_funcs.pfnClear(create_dev.hDevice,
                                     /*flags=*/0,
                                     /*color_rgba8=*/0,
                                     /*depth=*/1.0f,
                                     /*stencil=*/0);
  if (!Check(hr == S_OK, "Clear")) {
    return false;
  }

  bool has_pending_render = false;
  {
    std::lock_guard<std::mutex> lock(dev->mutex);
    has_pending_render = !dev->cmd.empty();
  }
  if (!Check(has_pending_render, "Clear emits pending render work")) {
    return false;
  }

  D3D9DDIARG_PRESENT present{};
  present.hSrc.pDrvPrivate = nullptr;
  present.hSwapChain.pDrvPrivate = nullptr;
  present.hWnd = nullptr;
  present.sync_interval = 1;
  present.flags = 0;
  hr = cleanup.device_funcs.pfnPresent(create_dev.hDevice, &present);
  if (!Check(hr == S_OK, "Present")) {
    return false;
  }

  uint64_t final_fence = 0;
  uint64_t final_render_submits = 0;
  uint64_t final_present_submits = 0;
  {
    std::lock_guard<std::mutex> lock(adapter->fence_mutex);
    final_fence = adapter->last_submitted_fence;
    final_render_submits = adapter->render_submit_count;
    final_present_submits = adapter->present_submit_count;
  }

  if (!Check(final_fence == base_fence + 2,
             "Present flushes render work then presents (two submissions)")) {
    return false;
  }
  if (!Check(final_render_submits == base_render_submits + 1, "Present flush issues exactly one render submit")) {
    return false;
  }
  if (!Check(final_present_submits == base_present_submits + 1, "Present issues exactly one present submit")) {
    return false;
  }

  uint64_t present_fence = 0;
  {
    std::lock_guard<std::mutex> lock(dev->mutex);
    if (!Check(dev->inflight_present_fences.size() == 1, "inflight_present_fences contains one fence")) {
      return false;
    }
    present_fence = dev->inflight_present_fences.front();
  }
  return Check(present_fence == base_fence + 2, "present fence corresponds to second submission");
}

bool TestFlushNoopsOnEmptyCommandBuffer() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnFlush != nullptr, "Flush must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnClear != nullptr, "Clear must be available")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  auto* adapter = reinterpret_cast<Adapter*>(open.hAdapter.pDrvPrivate);
  if (!Check(dev != nullptr && adapter != nullptr, "device/adapter pointers")) {
    return false;
  }

  uint64_t base_fence = 0;
  uint64_t base_render_submits = 0;
  uint64_t base_present_submits = 0;
  {
    std::lock_guard<std::mutex> lock(adapter->fence_mutex);
    base_fence = adapter->last_submitted_fence;
    base_render_submits = adapter->render_submit_count;
    base_present_submits = adapter->present_submit_count;
  }

  hr = cleanup.device_funcs.pfnFlush(create_dev.hDevice);
  if (!Check(hr == S_OK, "Flush(empty)")) {
    return false;
  }

  uint64_t after_empty_flush = 0;
  uint64_t after_empty_render_submits = 0;
  uint64_t after_empty_present_submits = 0;
  {
    std::lock_guard<std::mutex> lock(adapter->fence_mutex);
    after_empty_flush = adapter->last_submitted_fence;
    after_empty_render_submits = adapter->render_submit_count;
    after_empty_present_submits = adapter->present_submit_count;
  }
  if (!Check(after_empty_flush == base_fence, "Flush(empty) does not submit")) {
    return false;
  }
  if (!Check(after_empty_render_submits == base_render_submits, "Flush(empty) does not issue render submits")) {
    return false;
  }
  if (!Check(after_empty_present_submits == base_present_submits, "Flush(empty) does not issue present submits")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnClear(create_dev.hDevice,
                                     /*flags=*/0,
                                     /*color_rgba8=*/0,
                                     /*depth=*/1.0f,
                                     /*stencil=*/0);
  if (!Check(hr == S_OK, "Clear")) {
    return false;
  }

  bool has_pending_render = false;
  {
    std::lock_guard<std::mutex> lock(dev->mutex);
    has_pending_render = !dev->cmd.empty();
  }
  if (!Check(has_pending_render, "Clear emits pending render work")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnFlush(create_dev.hDevice);
  if (!Check(hr == S_OK, "Flush(non-empty)")) {
    return false;
  }

  uint64_t after_flush = 0;
  uint64_t after_render_submits = 0;
  uint64_t after_present_submits = 0;
  {
    std::lock_guard<std::mutex> lock(adapter->fence_mutex);
    after_flush = adapter->last_submitted_fence;
    after_render_submits = adapter->render_submit_count;
    after_present_submits = adapter->present_submit_count;
  }
  if (!Check(after_flush == base_fence + 1, "Flush submits once when command buffer is non-empty")) {
    return false;
  }
  if (!Check(after_render_submits == base_render_submits + 1, "Flush(non-empty) issues exactly one render submit")) {
    return false;
  }
  return Check(after_present_submits == base_present_submits, "Flush(non-empty) does not issue present submits");
}

bool TestGetDisplayModeExReturnsPrimaryMode() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnGetDisplayModeEx != nullptr, "GetDisplayModeEx must be available")) {
    return false;
  }

  D3DDDI_DISPLAYMODEEX mode{};
  D3DDDI_ROTATION rotation = D3DDDI_ROTATION_IDENTITY;
  D3D9DDIARG_GETDISPLAYMODEEX args{};
  args.swapchain = 0;
  args.pMode = &mode;
  args.pRotation = &rotation;

  hr = cleanup.device_funcs.pfnGetDisplayModeEx(create_dev.hDevice, &args);
  if (!Check(hr == S_OK, "GetDisplayModeEx")) {
    return false;
  }
  if (!Check(mode.Size == sizeof(D3DDDI_DISPLAYMODEEX), "display mode size field")) {
    return false;
  }
  if (!Check(mode.Width != 0 && mode.Height != 0, "display mode dimensions non-zero")) {
    return false;
  }
  if (!Check(mode.RefreshRate != 0, "display mode refresh non-zero")) {
    return false;
  }
  if (!Check(mode.Format == 22u, "display mode format is X8R8G8B8")) {
    return false;
  }
  if (!Check(mode.ScanLineOrdering == 1u, "display mode scanline progressive")) {
    return false;
  }
  return Check(rotation == D3DDDI_ROTATION_IDENTITY, "display rotation identity");
}

bool TestCheckDeviceStateNullHwndReturnsOk() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCheckDeviceState != nullptr, "CheckDeviceState must be available")) {
    return false;
  }

  // Some D3D9Ex clients (including DWM) call CheckDeviceState without a HWND.
  hr = cleanup.device_funcs.pfnCheckDeviceState(create_dev.hDevice, nullptr);
  return Check(hr == S_OK, "CheckDeviceState(NULL)");
}

bool TestDeviceMiscExApisSucceed() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCheckDeviceState != nullptr, "CheckDeviceState must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnWaitForVBlank != nullptr, "WaitForVBlank must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetGPUThreadPriority != nullptr, "SetGPUThreadPriority must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnGetGPUThreadPriority != nullptr, "GetGPUThreadPriority must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnCheckResourceResidency != nullptr, "CheckResourceResidency must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnQueryResourceResidency != nullptr, "QueryResourceResidency must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnComposeRects != nullptr, "ComposeRects must be available")) {
    return false;
  }

  // DWM frequently probes device state without a window handle in some paths.
  hr = cleanup.device_funcs.pfnCheckDeviceState(create_dev.hDevice, nullptr);
  if (!Check(hr == S_OK, "CheckDeviceState(NULL)")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnSetGPUThreadPriority(create_dev.hDevice, 100);
  if (!Check(hr == S_OK, "SetGPUThreadPriority(100)")) {
    return false;
  }
  int32_t priority = 0;
  hr = cleanup.device_funcs.pfnGetGPUThreadPriority(create_dev.hDevice, &priority);
  if (!Check(hr == S_OK, "GetGPUThreadPriority")) {
    return false;
  }
  if (!Check(priority == 7, "GPU thread priority clamps to +7")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnSetGPUThreadPriority(create_dev.hDevice, -100);
  if (!Check(hr == S_OK, "SetGPUThreadPriority(-100)")) {
    return false;
  }
  priority = 0;
  hr = cleanup.device_funcs.pfnGetGPUThreadPriority(create_dev.hDevice, &priority);
  if (!Check(hr == S_OK, "GetGPUThreadPriority after clamp")) {
    return false;
  }
  if (!Check(priority == -7, "GPU thread priority clamps to -7")) {
    return false;
  }

  // Residency queries should succeed and report resident in the system-memory
  // model.
  uint32_t residency[2] = {0, 0};
  D3D9DDIARG_QUERYRESOURCERESIDENCY query{};
  query.pResources = nullptr;
  query.resource_count = 2;
  query.pResidencyStatus = residency;
  hr = cleanup.device_funcs.pfnQueryResourceResidency(create_dev.hDevice, &query);
  if (!Check(hr == S_OK, "QueryResourceResidency")) {
    return false;
  }
  if (!Check(residency[0] == 1 && residency[1] == 1, "QueryResourceResidency reports resident")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnCheckResourceResidency(create_dev.hDevice, nullptr, 0);
  if (!Check(hr == S_OK, "CheckResourceResidency(0)")) {
    return false;
  }

  // ComposeRects is a D3D9Ex compositor helper; our bring-up path treats it as a
  // no-op but must still succeed.
  D3D9DDIARG_COMPOSERECTS compose{};
  compose.reserved0 = 0;
  compose.reserved1 = 0;
  hr = cleanup.device_funcs.pfnComposeRects(create_dev.hDevice, &compose);
  if (!Check(hr == S_OK, "ComposeRects")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnWaitForVBlank(create_dev.hDevice, 0);
  return Check(hr == S_OK, "WaitForVBlank");
}

bool TestAllocationListSplitResetsOnEmptySubmit() {
  // Repro for a subtle WDDM-only failure mode:
  //
  // Allocation list tracking may request a "flush/split" before we've emitted any
  // command packets in the new submission (e.g. because state-setting packets are
  // elided due to caching). In that situation submit() must still reset the
  // submission-local allocation tracking state even though it should not issue an
  // empty DMA submission.
  Adapter adapter;
  Device dev(&adapter);
  D3DDDI_HDEVICE hDevice{};
  hDevice.pDrvPrivate = &dev;
  HRESULT hr = device_test_enable_wddm_context(hDevice);
  if (!Check(hr == S_OK, "device_test_enable_wddm_context")) {
    return false;
  }

  D3DDDI_ALLOCATIONLIST list[1] = {};
  hr = device_test_rebind_alloc_list_tracker(hDevice, list, 1, 0xFFFFu);
  if (!Check(hr == S_OK, "device_test_rebind_alloc_list_tracker")) {
    return false;
  }

  const auto r0 = device_test_track_buffer_read(hDevice, /*hAllocation=*/1, /*alloc_id=*/1, /*share_token=*/0);
  if (!Check(r0.status == AllocRefStatus::kOk, "track_buffer_read first")) {
    return false;
  }
  if (!Check(dev.cmd.empty(), "command stream still empty after tracking")) {
    return false;
  }
  if (!Check(dev.alloc_list_tracker.list_len() == 1, "allocation list full")) {
    return false;
  }

  // submit() should not issue an empty DMA submission, but it must still reset
  // submission-local allocation tracking state so we can continue tracking in a
  // new submission.
  {
    std::lock_guard<std::mutex> lock(dev.mutex);
    (void)submit_locked(&dev);
  }

  if (!Check(dev.alloc_list_tracker.list_len() == 0, "allocation list reset after empty submit")) {
    return false;
  }
  const auto r1 = device_test_track_buffer_read(hDevice, /*hAllocation=*/2, /*alloc_id=*/2, /*share_token=*/0);
  if (!Check(r1.status == AllocRefStatus::kOk, "track_buffer_read after empty submit")) {
    return false;
  }
  if (!Check(dev.alloc_list_tracker.list_len() == 1, "allocation list len after re-track")) {
    return false;
  }
  if (!Check(list[0].hAllocation == 2, "allocation list entry points at second allocation")) {
    return false;
  }
  return true;
}

bool TestDrawStateTrackingPreSplitRetainsAllocs() {
  // Repro for a subtle WDDM-only failure mode:
  //
  // If the current submission's allocation list already contains entries from
  // earlier commands, draw-state tracking can exhaust the remaining capacity and
  // trigger a split mid-tracking. If that happens, we must ensure the new
  // submission re-tracks *all* draw allocations (not just those encountered
  // after the split) so host-side alloc-table lookups remain valid.
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hDummy{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_dummy = false;

    ~Cleanup() {
      if (has_dummy && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hDummy);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetRenderTarget != nullptr, "SetRenderTarget must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetTexture != nullptr, "SetTexture must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  // Enable allocation-list tracking in a portable build and constrain capacity so
  // draw-state tracking must pre-split if there is an outstanding tracked alloc.
  hr = device_test_enable_wddm_context(create_dev.hDevice);
  if (!Check(hr == S_OK, "device_test_enable_wddm_context")) {
    return false;
  }
  D3DDDI_ALLOCATIONLIST alloc_list[2] = {};
  hr = device_test_rebind_alloc_list_tracker(create_dev.hDevice, alloc_list, 2, 0xFFFFu);
  if (!Check(hr == S_OK, "device_test_rebind_alloc_list_tracker")) {
    return false;
  }
  hr = device_test_reset_alloc_list_tracker(create_dev.hDevice);
  if (!Check(hr == S_OK, "device_test_reset_alloc_list_tracker")) {
    return false;
  }

  aerogpu_wddm_alloc_priv priv{};
  std::memset(&priv, 0, sizeof(priv));

  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = 6u; // D3DRTYPE_VERTEXBUFFER
  create_res.format = 0;
  create_res.width = 0;
  create_res.height = 0;
  create_res.depth = 1;
  create_res.mip_levels = 1;
  create_res.usage = 0;
  create_res.pool = 0;
  create_res.size = 64;
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr;
  create_res.pKmdAllocPrivateData = &priv;
  create_res.KmdAllocPrivateDataSize = sizeof(priv);
  create_res.wddm_hAllocation = 0x1111u;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == S_OK, "CreateResource(dummy alloc-backed VB)")) {
    return false;
  }
  if (!Check(create_res.hResource.pDrvPrivate != nullptr, "CreateResource returned resource handle")) {
    return false;
  }
  cleanup.hDummy = create_res.hResource;
  cleanup.has_dummy = true;

  // Ensure the dummy resource consumed one allocation-list entry.
  {
    std::lock_guard<std::mutex> lock(dev->mutex);
    if (!Check(dev->alloc_list_tracker.list_len() == 1, "allocation list has 1 entry after CreateResource")) {
      return false;
    }
  }
  if (!Check(alloc_list[0].hAllocation == create_res.wddm_hAllocation, "allocation list contains dummy hAllocation")) {
    return false;
  }

  // Bind two distinct alloc-backed resources in draw state. (We don't need to
  // emit SetRenderTarget/SetTexture packets; we only need the pointers for
  // allocation tracking.) Use the DDIs to avoid poking internal Device caches
  // directly.
  Resource rt{};
  rt.kind = ResourceKind::Texture2D;
  rt.handle = 0x2000u;
  rt.backing_alloc_id = 1;
  rt.share_token = 0;
  rt.wddm_hAllocation = 0x2000u;

  Resource tex{};
  tex.kind = ResourceKind::Texture2D;
  tex.handle = 0x3000u;
  tex.backing_alloc_id = 2;
  tex.share_token = 0;
  tex.wddm_hAllocation = 0x3000u;

  D3DDDI_HRESOURCE hRt{};
  hRt.pDrvPrivate = &rt;
  hr = cleanup.device_funcs.pfnSetRenderTarget(create_dev.hDevice, /*slot=*/0, hRt);
  if (!Check(hr == S_OK, "SetRenderTarget(state tracking RT0)")) {
    return false;
  }
  D3DDDI_HRESOURCE hTex{};
  hTex.pDrvPrivate = &tex;
  hr = cleanup.device_funcs.pfnSetTexture(create_dev.hDevice, /*stage=*/0, hTex);
  if (!Check(hr == S_OK, "SetTexture(state tracking TEX0)")) {
    return false;
  }

  D3DDDIVIEWPORTINFO vp{};
  vp.X = 0.0f;
  vp.Y = 0.0f;
  vp.Width = 256.0f;
  vp.Height = 256.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }

  // D3DFVF_XYZRHW (0x4) | D3DFVF_DIFFUSE (0x40).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x44u);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|DIFFUSE)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    float rhw;
    uint32_t color;
  };

  constexpr uint32_t kGreen = 0xFF00FF00u;
  Vertex verts[3]{};
  verts[0] = {256.0f * 0.25f, 256.0f * 0.25f, 0.5f, 1.0f, kGreen};
  verts[1] = {256.0f * 0.75f, 256.0f * 0.25f, 0.5f, 1.0f, kGreen};
  verts[2] = {256.0f * 0.50f, 256.0f * 0.75f, 0.5f, 1.0f, kGreen};

  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 1, verts, sizeof(Vertex));
  if (!Check(hr == S_OK, "DrawPrimitiveUP")) {
    return false;
  }

  // After the draw, the allocation list should contain *all* draw dependencies.
  {
    std::lock_guard<std::mutex> lock(dev->mutex);
    if (!Check(dev->alloc_list_tracker.list_len() == 2, "allocation list contains draw deps after split")) {
      return false;
    }
  }
  if (!Check(alloc_list[0].hAllocation == rt.wddm_hAllocation, "allocation list contains draw RT mapping")) {
    return false;
  }
  if (!Check(alloc_list[0].WriteOperation == 1, "allocation list marks draw RT as write")) {
    return false;
  }
  if (!Check(alloc_list[1].hAllocation == tex.wddm_hAllocation, "allocation list contains draw texture mapping")) {
    return false;
  }
  return Check(alloc_list[1].WriteOperation == 0, "allocation list marks draw texture as read");
}

bool TestBlitStateTrackingPreSplitRetainsAllocs() {
  // Same class of failure as TestDrawStateTrackingPreSplitRetainsAllocs, but for
  // the D3D9 blit helper path (used by cursor overlay and other compositor
  // operations).
  //
  // If the current submission's allocation list already contains tracked entries
  // from earlier commands, blit draw-state tracking must pre-split so the final
  // submission re-tracks *all* required allocations.
  Adapter adapter{};
  Device dev(&adapter);

  D3DDDI_HDEVICE hDevice{};
  hDevice.pDrvPrivate = &dev;
  HRESULT enable_hr = device_test_enable_wddm_context(hDevice);
  if (!Check(enable_hr == S_OK, "device_test_enable_wddm_context")) {
    return false;
  }
  D3DDDI_ALLOCATIONLIST alloc_list[2] = {};
  HRESULT hr = device_test_rebind_alloc_list_tracker(hDevice, alloc_list, 2, 0xFFFFu);
  if (!Check(hr == S_OK, "device_test_rebind_alloc_list_tracker")) {
    return false;
  }
  hr = device_test_reset_alloc_list_tracker(hDevice);
  if (!Check(hr == S_OK, "device_test_reset_alloc_list_tracker")) {
    return false;
  }

  // Seed with a dummy allocation so the blit must split to fit dst+src.
  const auto dummy = device_test_track_buffer_read(hDevice, /*hAllocation=*/0x1111u, /*alloc_id=*/99, /*share_token=*/0);
  if (!Check(dummy.status == AllocRefStatus::kOk, "track_buffer_read dummy")) {
    return false;
  }
  if (!Check(dev.alloc_list_tracker.list_len() == 1, "allocation list has dummy entry")) {
    return false;
  }

  Resource dst{};
  dst.handle = 0x2000u;
  dst.kind = ResourceKind::Texture2D;
  dst.format = static_cast<D3DDDIFORMAT>(21u); // D3DFMT_A8R8G8B8
  dst.width = 64;
  dst.height = 64;
  dst.backing_alloc_id = 1;
  dst.share_token = 0;
  dst.wddm_hAllocation = 0x2000u;

  Resource src{};
  src.handle = 0x3000u;
  src.kind = ResourceKind::Texture2D;
  src.format = static_cast<D3DDDIFORMAT>(21u); // D3DFMT_A8R8G8B8
  src.width = 32;
  src.height = 32;
  src.backing_alloc_id = 2;
  src.share_token = 0;
  src.wddm_hAllocation = 0x3000u;

  RECT dst_rect{0, 0, 32, 32};
  RECT src_rect{0, 0, 32, 32};

  hr = S_OK;
  {
    std::lock_guard<std::mutex> lock(dev.mutex);
    hr = blit_alpha_locked(&dev, &dst, &dst_rect, &src, &src_rect, /*filter=*/1u);
  }
  if (!Check(hr == S_OK, "blit_alpha_locked")) {
    return false;
  }

  if (!Check(dev.alloc_list_tracker.list_len() == 2, "allocation list contains blit deps after split")) {
    return false;
  }
  if (!Check(alloc_list[0].hAllocation == dst.wddm_hAllocation, "allocation list contains blit dst mapping")) {
    return false;
  }
  if (!Check(alloc_list[0].WriteOperation == 1, "allocation list marks blit dst as write")) {
    return false;
  }
  if (!Check(alloc_list[1].hAllocation == src.wddm_hAllocation, "allocation list contains blit src mapping")) {
    return false;
  }
  return Check(alloc_list[1].WriteOperation == 0, "allocation list marks blit src as read");
}

bool TestRenderTargetTrackingPreSplitRetainsAllocs() {
  // Similar to TestDrawStateTrackingPreSplitRetainsAllocs, but for Clear(): the
  // render-target tracking helper must not drop earlier tracked render targets
  // if allocation-list tracking needs to split.
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hDummy{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_dummy = false;

    ~Cleanup() {
      if (has_dummy && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hDummy);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetRenderTarget != nullptr, "SetRenderTarget must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetDepthStencil != nullptr, "SetDepthStencil must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnClear != nullptr, "Clear must be available")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  hr = device_test_enable_wddm_context(create_dev.hDevice);
  if (!Check(hr == S_OK, "device_test_enable_wddm_context")) {
    return false;
  }
  D3DDDI_ALLOCATIONLIST alloc_list[2] = {};
  hr = device_test_rebind_alloc_list_tracker(create_dev.hDevice, alloc_list, 2, 0xFFFFu);
  if (!Check(hr == S_OK, "device_test_rebind_alloc_list_tracker")) {
    return false;
  }
  hr = device_test_reset_alloc_list_tracker(create_dev.hDevice);
  if (!Check(hr == S_OK, "device_test_reset_alloc_list_tracker")) {
    return false;
  }

  aerogpu_wddm_alloc_priv priv{};
  std::memset(&priv, 0, sizeof(priv));

  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = 6u; // D3DRTYPE_VERTEXBUFFER
  create_res.format = 0;
  create_res.width = 0;
  create_res.height = 0;
  create_res.depth = 1;
  create_res.mip_levels = 1;
  create_res.usage = 0;
  create_res.pool = 0;
  create_res.size = 64;
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr;
  create_res.pKmdAllocPrivateData = &priv;
  create_res.KmdAllocPrivateDataSize = sizeof(priv);
  create_res.wddm_hAllocation = 0x1111u;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == S_OK, "CreateResource(dummy alloc-backed VB)")) {
    return false;
  }
  if (!Check(create_res.hResource.pDrvPrivate != nullptr, "CreateResource returned resource handle")) {
    return false;
  }
  cleanup.hDummy = create_res.hResource;
  cleanup.has_dummy = true;

  {
    std::lock_guard<std::mutex> lock(dev->mutex);
    if (!Check(dev->alloc_list_tracker.list_len() == 1, "allocation list has 1 entry after CreateResource")) {
      return false;
    }
  }

  Resource rt0{};
  rt0.kind = ResourceKind::Texture2D;
  rt0.handle = 0x2000u;
  rt0.backing_alloc_id = 1;
  rt0.share_token = 0;
  rt0.wddm_hAllocation = 0x2000u;

  Resource rt1{};
  rt1.kind = ResourceKind::Texture2D;
  rt1.handle = 0x2001u;
  rt1.backing_alloc_id = 2;
  rt1.share_token = 0;
  rt1.wddm_hAllocation = 0x2001u;

  D3DDDI_HRESOURCE hRt0{};
  hRt0.pDrvPrivate = &rt0;
  hr = cleanup.device_funcs.pfnSetRenderTarget(create_dev.hDevice, /*slot=*/0, hRt0);
  if (!Check(hr == S_OK, "SetRenderTarget(RT0)")) {
    return false;
  }
  D3DDDI_HRESOURCE hRt1{};
  hRt1.pDrvPrivate = &rt1;
  hr = cleanup.device_funcs.pfnSetRenderTarget(create_dev.hDevice, /*slot=*/1, hRt1);
  if (!Check(hr == S_OK, "SetRenderTarget(RT1)")) {
    return false;
  }
  D3DDDI_HRESOURCE null_res{};
  hr = cleanup.device_funcs.pfnSetRenderTarget(create_dev.hDevice, /*slot=*/2, null_res);
  if (!Check(hr == S_OK, "SetRenderTarget(RT2=null)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetDepthStencil(create_dev.hDevice, null_res);
  if (!Check(hr == S_OK, "SetDepthStencil(null)")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnClear(create_dev.hDevice,
                                     /*flags=*/0x1u,
                                     /*color_rgba8=*/0xFF0000FFu,
                                     /*depth=*/1.0f,
                                     /*stencil=*/0);
  if (!Check(hr == S_OK, "Clear")) {
    return false;
  }

  {
    std::lock_guard<std::mutex> lock(dev->mutex);
    if (!Check(dev->alloc_list_tracker.list_len() == 2, "allocation list contains MRT deps after split")) {
      return false;
    }
  }
  if (!Check(alloc_list[0].hAllocation == rt0.wddm_hAllocation, "allocation list contains RT0 mapping")) {
    return false;
  }
  if (!Check(alloc_list[0].WriteOperation == 1, "allocation list marks RT0 as write")) {
    return false;
  }
  if (!Check(alloc_list[1].hAllocation == rt1.wddm_hAllocation, "allocation list contains RT1 mapping")) {
    return false;
  }
  return Check(alloc_list[1].WriteOperation == 1, "allocation list marks RT1 as write");
}

bool TestDrawStateTrackingDedupsSharedAllocIds() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  // When the same shared allocation is opened multiple times, the D3D9 runtime
  // can hand us distinct WDDM allocation handles that alias the same alloc_id.
  // The allocation list (and host-side alloc table) is keyed by alloc_id, so a
  // draw referencing both handles should still only consume a single allocation
  // list entry.
  hr = device_test_enable_wddm_context(create_dev.hDevice);
  if (!Check(hr == S_OK, "device_test_enable_wddm_context")) {
    return false;
  }
  D3DDDI_ALLOCATIONLIST alloc_list[1] = {};
  hr = device_test_rebind_alloc_list_tracker(create_dev.hDevice, alloc_list, 1, 0xFFFFu);
  if (!Check(hr == S_OK, "device_test_rebind_alloc_list_tracker")) {
    return false;
  }

  Resource rt{};
  rt.kind = ResourceKind::Texture2D;
  rt.handle = 1;
  rt.backing_alloc_id = 1;
  rt.share_token = 0x1122334455667788ull;
  rt.wddm_hAllocation = 100;

  Resource tex{};
  tex.kind = ResourceKind::Texture2D;
  tex.handle = 2;
  tex.backing_alloc_id = 1;
  tex.share_token = 0x1122334455667788ull;
  tex.wddm_hAllocation = 200;

  D3DDDI_HRESOURCE hRt{};
  hRt.pDrvPrivate = &rt;
  hr = cleanup.device_funcs.pfnSetRenderTarget(create_dev.hDevice, /*slot=*/0, hRt);
  if (!Check(hr == S_OK, "SetRenderTarget(dedup RT0)")) {
    return false;
  }
  D3DDDI_HRESOURCE hTex{};
  hTex.pDrvPrivate = &tex;
  hr = cleanup.device_funcs.pfnSetTexture(create_dev.hDevice, /*stage=*/0, hTex);
  if (!Check(hr == S_OK, "SetTexture(dedup TEX0)")) {
    return false;
  }

  D3DDDIVIEWPORTINFO vp{};
  vp.X = 0.0f;
  vp.Y = 0.0f;
  vp.Width = 256.0f;
  vp.Height = 256.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }

  // D3DFVF_XYZRHW (0x4) | D3DFVF_DIFFUSE (0x40).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x44u);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|DIFFUSE)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    float rhw;
    uint32_t color;
  };

  constexpr uint32_t kGreen = 0xFF00FF00u;
  Vertex verts[3]{};
  verts[0] = {256.0f * 0.25f, 256.0f * 0.25f, 0.5f, 1.0f, kGreen};
  verts[1] = {256.0f * 0.75f, 256.0f * 0.25f, 0.5f, 1.0f, kGreen};
  verts[2] = {256.0f * 0.50f, 256.0f * 0.75f, 0.5f, 1.0f, kGreen};

  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 1, verts, sizeof(Vertex));
  if (!Check(hr == S_OK, "DrawPrimitiveUP")) {
    return false;
  }

  {
    std::lock_guard<std::mutex> lock(dev->mutex);
    if (!Check(dev->alloc_list_tracker.list_len() == 1, "draw tracking dedups shared alloc_id")) {
      return false;
    }
  }

  if (!Check(alloc_list[0].hAllocation == rt.wddm_hAllocation, "allocation list uses first tracked handle")) {
    return false;
  }
  return Check(alloc_list[0].WriteOperation == 1, "render-target write upgrades allocation list entry");
}

bool TestRotateResourceIdentitiesTrackingPreSplitRetainsAllocs() {
  // RotateResourceIdentities may need to emit multiple rebinding packets (RTs +
  // rotated textures/streams/index). Allocation tracking can split the submission
  // when the list is full; ensure we pre-split so earlier tracked allocations are
  // not dropped.
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnRotateResourceIdentities != nullptr, "RotateResourceIdentities entrypoint")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetRenderTarget != nullptr, "SetRenderTarget must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetDepthStencil != nullptr, "SetDepthStencil must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetTexture != nullptr, "SetTexture must be available")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  hr = device_test_enable_wddm_context(create_dev.hDevice);
  if (!Check(hr == S_OK, "device_test_enable_wddm_context")) {
    return false;
  }
  D3DDDI_ALLOCATIONLIST alloc_list[2] = {};
  hr = device_test_rebind_alloc_list_tracker(create_dev.hDevice, alloc_list, 2, 0xFFFFu);
  if (!Check(hr == S_OK, "device_test_rebind_alloc_list_tracker")) {
    return false;
  }
  hr = device_test_reset_alloc_list_tracker(create_dev.hDevice);
  if (!Check(hr == S_OK, "device_test_reset_alloc_list_tracker")) {
    return false;
  }

  // Pre-fill the allocation list to simulate other work already tracked in the
  // submission. This should force RotateResourceIdentities to split before it
  // begins tracking its own dependencies.
  const AllocRef dummy_ref =
      device_test_track_buffer_read(create_dev.hDevice, /*hAllocation=*/0x9999u, /*alloc_id=*/0x999u, /*share_token=*/0);
  if (!Check(dummy_ref.status == AllocRefStatus::kOk, "dummy allocation tracked")) {
    return false;
  }
  if (!Check(dev->alloc_list_tracker.list_len() == 1, "allocation list has 1 pre-filled entry")) {
    return false;
  }

  Resource rt{};
  rt.kind = ResourceKind::Texture2D;
  rt.handle = 0x2000u;
  rt.backing_alloc_id = 1;
  rt.share_token = 0;
  rt.wddm_hAllocation = 0x2000u;

  Resource tex0{};
  tex0.kind = ResourceKind::Texture2D;
  tex0.type = 0;
  tex0.format = 22u; // D3DFMT_X8R8G8B8
  tex0.width = 16;
  tex0.height = 16;
  tex0.depth = 1;
  tex0.mip_levels = 1;
  tex0.usage = 0;
  tex0.pool = 0;
  tex0.size_bytes = 16u * 16u * 4u;
  tex0.row_pitch = 16u * 4u;
  tex0.slice_pitch = tex0.size_bytes;
  tex0.handle = 0x3000u;
  tex0.backing_alloc_id = 2;
  tex0.share_token = 0;
  tex0.wddm_hAllocation = 0x3000u;

  Resource tex1 = tex0;
  tex1.handle = 0x3001u;
  tex1.backing_alloc_id = 3;
  tex1.wddm_hAllocation = 0x3001u;

  {
    std::lock_guard<std::mutex> lock(dev->mutex);
    dev->cmd.reset();
  }
  D3DDDI_HRESOURCE hRt{};
  hRt.pDrvPrivate = &rt;
  hr = cleanup.device_funcs.pfnSetRenderTarget(create_dev.hDevice, /*slot=*/0, hRt);
  if (!Check(hr == S_OK, "Rotate: SetRenderTarget(RT0)")) {
    return false;
  }
  D3DDDI_HRESOURCE null_res{};
  hr = cleanup.device_funcs.pfnSetRenderTarget(create_dev.hDevice, /*slot=*/1, null_res);
  if (!Check(hr == S_OK, "Rotate: SetRenderTarget(RT1=null)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetDepthStencil(create_dev.hDevice, null_res);
  if (!Check(hr == S_OK, "Rotate: SetDepthStencil(null)")) {
    return false;
  }
  D3DDDI_HRESOURCE hTex0{};
  hTex0.pDrvPrivate = &tex0;
  hr = cleanup.device_funcs.pfnSetTexture(create_dev.hDevice, /*stage=*/0, hTex0);
  if (!Check(hr == S_OK, "Rotate: SetTexture(stage0)")) {
    return false;
  }
  // Keep the command stream empty: RotateResourceIdentities may pre-split the
  // submission based on allocation-list capacity, so avoid submitting unrelated
  // state-setting packets in this unit test.
  {
    std::lock_guard<std::mutex> lock(dev->mutex);
    dev->cmd.reset();
  }

  D3DDDI_HRESOURCE rotate[2]{};
  rotate[0].pDrvPrivate = &tex0;
  rotate[1].pDrvPrivate = &tex1;

  hr = cleanup.device_funcs.pfnRotateResourceIdentities(create_dev.hDevice, rotate, 2);
  if (!Check(hr == S_OK, "RotateResourceIdentities")) {
    return false;
  }

  // The allocation list should contain both the RT and the rotated texture (now
  // bound to stage 0), with the render target marked as WriteOperation.
  {
    std::lock_guard<std::mutex> lock(dev->mutex);
    if (!Check(dev->alloc_list_tracker.list_len() == 2, "allocation list contains rotate rebind deps after split")) {
      return false;
    }
  }
  if (!Check(alloc_list[0].hAllocation == rt.wddm_hAllocation, "allocation list contains RT mapping")) {
    return false;
  }
  if (!Check(alloc_list[0].WriteOperation == 1, "allocation list marks RT as write")) {
    return false;
  }
  if (!Check(alloc_list[1].hAllocation == tex0.wddm_hAllocation, "allocation list contains rotated texture mapping")) {
    return false;
  }
  return Check(alloc_list[1].WriteOperation == 0, "allocation list marks rotated texture as read");
}

bool TestOpenResourceCapturesWddmAllocationForTracking() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hResource{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_resource = false;

    ~Cleanup() {
      if (has_resource && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hResource);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  // Enable allocation-list tracking in a portable build.
  hr = device_test_enable_wddm_context(create_dev.hDevice);
  if (!Check(hr == S_OK, "device_test_enable_wddm_context")) {
    return false;
  }
  D3DDDI_ALLOCATIONLIST alloc_list[4] = {};
  hr = device_test_rebind_alloc_list_tracker(create_dev.hDevice, alloc_list, 4, 0xFFFFu);
  if (!Check(hr == S_OK, "device_test_rebind_alloc_list_tracker")) {
    return false;
  }
  hr = device_test_reset_alloc_list_tracker(create_dev.hDevice);
  if (!Check(hr == S_OK, "device_test_reset_alloc_list_tracker")) {
    return false;
  }

  aerogpu_wddm_alloc_priv priv{};
  priv.magic = AEROGPU_WDDM_ALLOC_PRIV_MAGIC;
  priv.version = AEROGPU_WDDM_ALLOC_PRIV_VERSION;
  priv.alloc_id = 1;
  priv.flags = AEROGPU_WDDM_ALLOC_PRIV_FLAG_IS_SHARED;
  priv.share_token = 0x1122334455667788ull;
  priv.size_bytes = 16ull * 16ull * 4ull;
  priv.reserved0 = 0;

  D3D9DDIARG_OPENRESOURCE open_res{};
  open_res.pPrivateDriverData = &priv;
  open_res.private_driver_data_size = sizeof(priv);
  open_res.type = 0;
  open_res.format = 22u; // D3DFMT_X8R8G8B8
  open_res.width = 16;
  open_res.height = 16;
  open_res.depth = 1;
  open_res.mip_levels = 1;
  open_res.usage = 0;
  open_res.size = 0;
  open_res.hResource.pDrvPrivate = nullptr;
  open_res.wddm_hAllocation = 0x1234u;

  if (!Check(cleanup.device_funcs.pfnOpenResource != nullptr, "OpenResource entrypoint")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnOpenResource(create_dev.hDevice, &open_res);
  if (!Check(hr == S_OK, "OpenResource")) {
    return false;
  }
  if (!Check(open_res.hResource.pDrvPrivate != nullptr, "OpenResource returned resource")) {
    return false;
  }
  cleanup.hResource = open_res.hResource;
  cleanup.has_resource = true;

  auto* res = reinterpret_cast<Resource*>(open_res.hResource.pDrvPrivate);
  if (!Check(res->backing_alloc_id == priv.alloc_id, "OpenResource captures alloc_id")) {
    return false;
  }
  if (!Check(res->wddm_hAllocation == open_res.wddm_hAllocation, "OpenResource captures wddm_hAllocation")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnSetRenderTarget(create_dev.hDevice, 0, open_res.hResource);
  if (!Check(hr == S_OK, "SetRenderTarget")) {
    return false;
  }

  // Clear forces render-target allocation tracking; this should succeed when
  // OpenResource supplies wddm_hAllocation.
  hr = cleanup.device_funcs.pfnClear(create_dev.hDevice,
                                     /*flags=*/0x1u,
                                     /*color_rgba8=*/0xFFFFFFFFu,
                                     /*depth=*/1.0f,
                                     /*stencil=*/0);
  if (!Check(hr == S_OK, "Clear")) {
    return false;
  }

  if (!Check(dev->alloc_list_tracker.list_len() == 1, "allocation list includes imported RT")) {
    return false;
  }
  if (!Check(alloc_list[0].hAllocation == open_res.wddm_hAllocation, "tracked allocation handle matches")) {
    return false;
  }
  if (!Check(alloc_list[0].WriteOperation == 1, "tracked allocation is marked WriteOperation")) {
    return false;
  }
  return true;
}

bool TestOpenResourceRejectsUnsupportedNon2dType() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  ScopedDeviceCmdVectorReset cmd_reset(dev);

  // Bind a span-backed command buffer so we can assert that no IMPORT_SHARED_SURFACE
  // packets are emitted when OpenResource fails validation.
  std::vector<uint8_t> dma(4096, 0);
  dev->cmd.set_span(dma.data(), dma.size());
  dev->cmd.reset();

  aerogpu_wddm_alloc_priv priv{};
  priv.magic = AEROGPU_WDDM_ALLOC_PRIV_MAGIC;
  priv.version = AEROGPU_WDDM_ALLOC_PRIV_VERSION;
  priv.alloc_id = 1;
  priv.flags = AEROGPU_WDDM_ALLOC_PRIV_FLAG_IS_SHARED;
  priv.share_token = 0x1122334455667788ull;
  priv.size_bytes = 0;
  priv.reserved0 = 0;

  D3D9DDIARG_OPENRESOURCE open_res{};
  open_res.pPrivateDriverData = &priv;
  open_res.private_driver_data_size = sizeof(priv);
  // D3DRESOURCETYPE::D3DRTYPE_VOLUME == 2.
  open_res.type = 2u;
  open_res.format = 22u; // D3DFMT_X8R8G8B8
  open_res.width = 16;
  open_res.height = 16;
  open_res.depth = 2;
  open_res.mip_levels = 1;
  open_res.usage = 0;
  open_res.size = 0;
  open_res.hResource.pDrvPrivate = nullptr;
  open_res.wddm_hAllocation = 0;

  if (!Check(cleanup.device_funcs.pfnOpenResource != nullptr, "OpenResource entrypoint")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnOpenResource(create_dev.hDevice, &open_res);
  if (!Check(hr == D3DERR_INVALIDCALL, "OpenResource rejects unsupported non-2D resource types")) {
    return false;
  }
  if (!Check(open_res.hResource.pDrvPrivate == nullptr, "OpenResource failure does not return a handle")) {
    return false;
  }

  dev->cmd.finalize();
  if (!Check(ValidateStream(dma.data(), dma.size()), "stream validates after failed OpenResource")) {
    return false;
  }
  return Check(CountOpcode(dma.data(), dma.size(), AEROGPU_CMD_IMPORT_SHARED_SURFACE) == 0,
               "failed OpenResource must not emit IMPORT_SHARED_SURFACE");
}

bool TestOpenResourceRejectsNonSquareCubeTexture() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  ScopedDeviceCmdVectorReset cmd_reset(dev);

  // Bind a span-backed command buffer so we can assert that no IMPORT_SHARED_SURFACE
  // packets are emitted when OpenResource fails validation.
  std::vector<uint8_t> dma(4096, 0);
  dev->cmd.set_span(dma.data(), dma.size());
  dev->cmd.reset();

  aerogpu_wddm_alloc_priv priv{};
  priv.magic = AEROGPU_WDDM_ALLOC_PRIV_MAGIC;
  priv.version = AEROGPU_WDDM_ALLOC_PRIV_VERSION;
  priv.alloc_id = 1;
  priv.flags = AEROGPU_WDDM_ALLOC_PRIV_FLAG_IS_SHARED;
  priv.share_token = 0x1122334455667788ull;
  priv.size_bytes = 0;
  priv.reserved0 = 0;

  // Depth==6 is interpreted by the host as a cube texture; cube textures must be square.
  D3D9DDIARG_OPENRESOURCE open_res{};
  open_res.pPrivateDriverData = &priv;
  open_res.private_driver_data_size = sizeof(priv);
  // D3DRESOURCETYPE::D3DRTYPE_TEXTURE == 3.
  open_res.type = 3u;
  open_res.format = 22u; // D3DFMT_X8R8G8B8
  open_res.width = 16;
  open_res.height = 8; // non-square
  open_res.depth = 6;
  open_res.mip_levels = 1;
  open_res.usage = 0;
  open_res.size = 0;
  open_res.hResource.pDrvPrivate = nullptr;
  open_res.wddm_hAllocation = 0;

  if (!Check(cleanup.device_funcs.pfnOpenResource != nullptr, "OpenResource entrypoint")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnOpenResource(create_dev.hDevice, &open_res);
  if (!Check(hr == D3DERR_INVALIDCALL, "OpenResource rejects non-square cube textures")) {
    return false;
  }
  if (!Check(open_res.hResource.pDrvPrivate == nullptr, "OpenResource failure does not return a handle")) {
    return false;
  }

  dev->cmd.finalize();
  if (!Check(ValidateStream(dma.data(), dma.size()), "stream validates after failed OpenResource")) {
    return false;
  }
  return Check(CountOpcode(dma.data(), dma.size(), AEROGPU_CMD_IMPORT_SHARED_SURFACE) == 0,
               "failed OpenResource must not emit IMPORT_SHARED_SURFACE");
}

bool TestOpenResourceArrayTextureEmitsArrayLayers() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hResource{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_resource = false;

    ~Cleanup() {
      if (has_resource && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hResource);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  ScopedDeviceCmdVectorReset cmd_reset(dev);

  // Bind a span-backed command buffer so we can validate IMPORT_SHARED_SURFACE output.
  std::vector<uint8_t> dma(4096, 0);
  dev->cmd.set_span(dma.data(), dma.size());
  dev->cmd.reset();
  struct CmdStreamRestore {
    Device* dev = nullptr;
    ~CmdStreamRestore() {
      if (dev) {
        // Cleanup destructors may destroy resources/devices and emit additional
        // packets; ensure they do not reference the span-backed buffer.
        dev->cmd.set_vector();
      }
    }
  } cmd_restore{dev};

  aerogpu_wddm_alloc_priv priv{};
  priv.magic = AEROGPU_WDDM_ALLOC_PRIV_MAGIC;
  priv.version = AEROGPU_WDDM_ALLOC_PRIV_VERSION;
  priv.alloc_id = 1;
  priv.flags = AEROGPU_WDDM_ALLOC_PRIV_FLAG_IS_SHARED;
  priv.share_token = 0x1122334455667788ull;
  priv.size_bytes = 0;
  priv.reserved0 = 0;

  // D3DRESOURCETYPE::D3DRTYPE_TEXTURE == 3.
  constexpr uint32_t kD3dRTypeTexture = 3u;

  D3D9DDIARG_OPENRESOURCE open_res{};
  open_res.pPrivateDriverData = &priv;
  open_res.private_driver_data_size = sizeof(priv);
  open_res.type = kD3dRTypeTexture;
  open_res.format = 22u; // D3DFMT_X8R8G8B8
  open_res.width = 64;
  open_res.height = 64;
  open_res.depth = 6;
  open_res.mip_levels = 1;
  open_res.usage = 0;
  open_res.size = 0;
  open_res.hResource.pDrvPrivate = nullptr;
  open_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnOpenResource(create_dev.hDevice, &open_res);
  if (!Check(hr == S_OK, "OpenResource(array texture)")) {
    return false;
  }
  if (!Check(open_res.hResource.pDrvPrivate != nullptr, "OpenResource returned resource handle")) {
    return false;
  }
  cleanup.hResource = open_res.hResource;
  cleanup.has_resource = true;

  auto* res = reinterpret_cast<Resource*>(open_res.hResource.pDrvPrivate);
  if (!Check(res != nullptr, "resource pointer")) {
    return false;
  }
  if (!Check(res->kind == ResourceKind::Texture2D, "OpenResource array texture kind==Texture2D")) {
    return false;
  }
  if (!Check(res->depth == 6u, "OpenResource preserves depth==6 (array layers)")) {
    return false;
  }
  if (!Check(res->size_bytes == res->slice_pitch * res->depth, "OpenResource size_bytes includes array layers")) {
    return false;
  }

  dev->cmd.finalize();
  if (!Check(ValidateStream(dma.data(), dma.size()), "stream validates")) {
    return false;
  }
  if (!Check(CountOpcode(dma.data(), dma.size(), AEROGPU_CMD_IMPORT_SHARED_SURFACE) == 1, "IMPORT_SHARED_SURFACE emitted")) {
    return false;
  }
  if (!Check(CountOpcode(dma.data(), dma.size(), AEROGPU_CMD_CREATE_TEXTURE2D) == 0, "OpenResource does not CREATE_TEXTURE2D")) {
    return false;
  }
  const CmdLoc import_loc = FindLastOpcode(dma.data(), dma.size(), AEROGPU_CMD_IMPORT_SHARED_SURFACE);
  if (!Check(import_loc.hdr != nullptr, "IMPORT_SHARED_SURFACE packet present")) {
    return false;
  }
  const auto* import_cmd = reinterpret_cast<const aerogpu_cmd_import_shared_surface*>(import_loc.hdr);
  if (!Check(import_cmd->out_resource_handle == res->handle, "IMPORT_SHARED_SURFACE out_resource_handle matches")) {
    return false;
  }
  return Check(import_cmd->share_token == priv.share_token, "IMPORT_SHARED_SURFACE share_token matches");
}

bool TestOpenResourceCubeTextureTypeNormalizesDepthTo6() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hResource{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_resource = false;

    ~Cleanup() {
      if (has_resource && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hResource);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  ScopedDeviceCmdVectorReset cmd_reset(dev);

  // Bind a span-backed command buffer so we can validate IMPORT_SHARED_SURFACE output.
  std::vector<uint8_t> dma(4096, 0);
  dev->cmd.set_span(dma.data(), dma.size());
  dev->cmd.reset();
  struct CmdStreamRestore {
    Device* dev = nullptr;
    ~CmdStreamRestore() {
      if (dev) {
        // Cleanup destructors may destroy resources/devices and emit additional
        // packets; ensure they do not reference the span-backed buffer.
        dev->cmd.set_vector();
      }
    }
  } cmd_restore{dev};

  aerogpu_wddm_alloc_priv priv{};
  priv.magic = AEROGPU_WDDM_ALLOC_PRIV_MAGIC;
  priv.version = AEROGPU_WDDM_ALLOC_PRIV_VERSION;
  priv.alloc_id = 1;
  priv.flags = AEROGPU_WDDM_ALLOC_PRIV_FLAG_IS_SHARED;
  priv.share_token = 0x1122334455667788ull;
  priv.size_bytes = 0;
  priv.reserved0 = 0;

  // D3DRESOURCETYPE::D3DRTYPE_CUBETEXTURE == 5.
  constexpr uint32_t kD3dRTypeCubeTexture = 5u;

  D3D9DDIARG_OPENRESOURCE open_res{};
  open_res.pPrivateDriverData = &priv;
  open_res.private_driver_data_size = sizeof(priv);
  open_res.type = kD3dRTypeCubeTexture;
  open_res.format = 22u; // D3DFMT_X8R8G8B8
  open_res.width = 64;
  open_res.height = 64;
  // Some D3D9 runtimes do not populate Depth meaningfully for cube textures. The
  // UMD normalizes them to Depth==6 (array layers).
  open_res.depth = 1;
  open_res.mip_levels = 1;
  open_res.usage = 0;
  open_res.size = 0;
  open_res.hResource.pDrvPrivate = nullptr;
  open_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnOpenResource(create_dev.hDevice, &open_res);
  if (!Check(hr == S_OK, "OpenResource(cube texture type)")) {
    return false;
  }
  if (!Check(open_res.hResource.pDrvPrivate != nullptr, "OpenResource returned resource handle")) {
    return false;
  }
  cleanup.hResource = open_res.hResource;
  cleanup.has_resource = true;

  auto* res = reinterpret_cast<Resource*>(open_res.hResource.pDrvPrivate);
  if (!Check(res != nullptr, "resource pointer")) {
    return false;
  }
  if (!Check(res->type == kD3dRTypeCubeTexture, "OpenResource stores type==CUBETEXTURE")) {
    return false;
  }
  if (!Check(res->kind == ResourceKind::Texture2D, "OpenResource cube kind==Texture2D")) {
    return false;
  }
  if (!Check(res->depth == 6u, "OpenResource normalizes cube depth to 6")) {
    return false;
  }
  if (!Check(res->size_bytes == res->slice_pitch * res->depth, "OpenResource cube size_bytes includes array layers")) {
    return false;
  }

  dev->cmd.finalize();
  if (!Check(ValidateStream(dma.data(), dma.size()), "stream validates")) {
    return false;
  }
  if (!Check(CountOpcode(dma.data(), dma.size(), AEROGPU_CMD_IMPORT_SHARED_SURFACE) == 1, "IMPORT_SHARED_SURFACE emitted")) {
    return false;
  }
  if (!Check(CountOpcode(dma.data(), dma.size(), AEROGPU_CMD_CREATE_TEXTURE2D) == 0, "OpenResource does not CREATE_TEXTURE2D")) {
    return false;
  }
  return true;
}

bool TestOpenResourceCubeTextureRequiresSquare() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  ScopedDeviceCmdVectorReset cmd_reset(dev);

  // Bind a span-backed command buffer so we can validate that no IMPORT_SHARED_SURFACE
  // is emitted on failure.
  std::vector<uint8_t> dma(4096, 0);
  dev->cmd.set_span(dma.data(), dma.size());
  dev->cmd.reset();

  aerogpu_wddm_alloc_priv priv{};
  priv.magic = AEROGPU_WDDM_ALLOC_PRIV_MAGIC;
  priv.version = AEROGPU_WDDM_ALLOC_PRIV_VERSION;
  priv.alloc_id = 1;
  priv.flags = AEROGPU_WDDM_ALLOC_PRIV_FLAG_IS_SHARED;
  priv.share_token = 0x1122334455667788ull;
  priv.size_bytes = 0;
  priv.reserved0 = 0;

  // D3DRESOURCETYPE::D3DRTYPE_CUBETEXTURE == 5.
  constexpr uint32_t kD3dRTypeCubeTexture = 5u;

  // Cube textures must be square. Use non-square dimensions and an unhelpful Depth value (1).
  D3D9DDIARG_OPENRESOURCE open_res{};
  open_res.pPrivateDriverData = &priv;
  open_res.private_driver_data_size = sizeof(priv);
  open_res.type = kD3dRTypeCubeTexture;
  open_res.format = 22u; // D3DFMT_X8R8G8B8
  open_res.width = 8;
  open_res.height = 4; // non-square
  open_res.depth = 1;
  open_res.mip_levels = 1;
  open_res.usage = 0;
  open_res.size = 0;
  open_res.hResource.pDrvPrivate = nullptr;
  open_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnOpenResource(create_dev.hDevice, &open_res);
  if (!Check(hr == D3DERR_INVALIDCALL, "OpenResource(cube, non-square) rejects")) {
    return false;
  }
  if (!Check(open_res.hResource.pDrvPrivate == nullptr, "OpenResource failure does not return a handle")) {
    return false;
  }

  dev->cmd.finalize();
  if (!Check(ValidateStream(dma.data(), dma.size()), "stream validates after failed OpenResource")) {
    return false;
  }
  return Check(CountOpcode(dma.data(), dma.size(), AEROGPU_CMD_IMPORT_SHARED_SURFACE) == 0,
               "failed OpenResource must not emit IMPORT_SHARED_SURFACE");
}

bool TestInvalidPayloadArgs() {
  uint8_t buf[256] = {};

  SpanCmdStreamWriter w(buf, sizeof(buf));
  w.reset();

  auto* cmd =
      w.append_with_payload<aerogpu_cmd_create_shader_dxbc>(AEROGPU_CMD_CREATE_SHADER_DXBC, nullptr, 4);
  if (!Check(cmd == nullptr, "append_with_payload rejects null payload")) {
    return false;
  }
  if (!Check(w.error() == CmdStreamError::kInvalidArgument, "null payload sets kInvalidArgument")) {
    return false;
  }

  w.reset();
  const size_t too_large = std::numeric_limits<size_t>::max();
  cmd = w.append_with_payload<aerogpu_cmd_create_shader_dxbc>(AEROGPU_CMD_CREATE_SHADER_DXBC, buf, too_large);
  if (!Check(cmd == nullptr, "append_with_payload rejects oversized payload")) {
    return false;
  }
  if (!Check(w.error() == CmdStreamError::kSizeTooLarge, "oversized payload sets kSizeTooLarge")) {
    return false;
  }

  // Cover the edge case where `payload_size` would not overflow the
  // `payload_size + sizeof(HeaderT)` check, but would overflow padding/alignment
  // when rounding up to 4 bytes.
  w.reset();
  const size_t near_max = std::numeric_limits<size_t>::max() - sizeof(aerogpu_cmd_create_shader_dxbc);
  cmd = w.append_with_payload<aerogpu_cmd_create_shader_dxbc>(AEROGPU_CMD_CREATE_SHADER_DXBC, buf, near_max);
  if (!Check(cmd == nullptr, "append_with_payload rejects near-max payload")) {
    return false;
  }
  if (!Check(w.error() == CmdStreamError::kSizeTooLarge, "near-max payload sets kSizeTooLarge")) {
    return false;
  }

  VectorCmdStreamWriter vec;
  vec.reset();
  cmd = vec.append_with_payload<aerogpu_cmd_create_shader_dxbc>(AEROGPU_CMD_CREATE_SHADER_DXBC, buf, near_max);
  if (!Check(cmd == nullptr, "VectorCmdStreamWriter rejects near-max payload")) {
    return false;
  }
  return Check(vec.error() == CmdStreamError::kSizeTooLarge, "VectorCmdStreamWriter near-max payload sets kSizeTooLarge");
}

template <typename DeviceFuncsT>
bool TestSetShaderConstIBEmitsCommandsImpl() {
  if constexpr (!HasPfnSetShaderConstI<DeviceFuncsT>::value ||
                !HasPfnSetShaderConstB<DeviceFuncsT>::value) {
    // Some D3D9 DDI header variants do not expose the I/B constant entrypoints in the device
    // function table. In those builds we cannot exercise the DDI surface area; treat the test as a
    // no-op.
    return true;
  } else {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    DeviceFuncsT device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  if (!Check(create_dev.hDevice.pDrvPrivate != nullptr, "CreateDevice returned device handle")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  std::vector<uint8_t> dma(4096, 0);
  dev->cmd.set_span(dma.data(), dma.size());
  dev->cmd.reset();
  // Ensure the device's CmdWriter is reset back to vector-backed storage before `dma` is freed
  // (DeviceDestroy flushes any pending command buffer via submit()).
  ScopedDeviceCmdVectorReset cmd_reset(dev);

  // Set 2 int4 registers: i5..i6.
  const uint32_t int_start = 5;
  const uint32_t int_count = 2;
  const int32_t ints[int_count * 4] = {1, 2, 3, 4, 5, 6, 7, 8};
  hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice,
                                              kD3d9ShaderStagePs,
                                              int_start,
                                              ints,
                                              int_count);
  if (!Check(hr == S_OK, "SetShaderConstI")) {
    return false;
  }

  // Set 2 bool registers: b7..b8.
  const uint32_t bool_start = 7;
  const uint32_t bool_count = 2;
  const BOOL bools[bool_count] = {static_cast<BOOL>(1), static_cast<BOOL>(0)};
  hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice,
                                               kD3d9ShaderStagePs,
                                               bool_start,
                                               bools,
                                              bool_count);
  if (!Check(hr == S_OK, "SetShaderConstB")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dma.data();
  const size_t len = dev->cmd.bytes_used();
  if (!Check(ValidateStream(buf, dma.size()), "command stream validates")) {
    return false;
  }

  const CmdLoc i_loc = FindLastOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_I);
  if (!Check(i_loc.hdr != nullptr, "SET_SHADER_CONSTANTS_I emitted")) {
    return false;
  }
  const auto* i_cmd = reinterpret_cast<const aerogpu_cmd_set_shader_constants_i*>(i_loc.hdr);
  if (!Check(i_cmd->stage == AEROGPU_SHADER_STAGE_PIXEL, "I stage")) {
    return false;
  }
  if (!Check(i_cmd->start_register == int_start, "I start_register")) {
    return false;
  }
  if (!Check(i_cmd->vec4_count == int_count, "I vec4_count")) {
    return false;
  }
  const auto* i_payload = reinterpret_cast<const int32_t*>(
      reinterpret_cast<const uint8_t*>(i_cmd) + sizeof(*i_cmd));
  if (!Check(std::memcmp(i_payload, ints, sizeof(ints)) == 0, "I payload matches")) {
    return false;
  }

  const CmdLoc b_loc = FindLastOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_B);
  if (!Check(b_loc.hdr != nullptr, "SET_SHADER_CONSTANTS_B emitted")) {
    return false;
  }
  const auto* b_cmd = reinterpret_cast<const aerogpu_cmd_set_shader_constants_b*>(b_loc.hdr);
  if (!Check(b_cmd->stage == AEROGPU_SHADER_STAGE_PIXEL, "B stage")) {
    return false;
  }
  if (!Check(b_cmd->start_register == bool_start, "B start_register")) {
    return false;
  }
  if (!Check(b_cmd->bool_count == bool_count, "B bool_count")) {
    return false;
  }
  const auto* b_payload = reinterpret_cast<const uint32_t*>(
      reinterpret_cast<const uint8_t*>(b_cmd) + sizeof(*b_cmd));
  // Payload uses a single u32 per bool register (0 or 1).
  const uint32_t expected_b[bool_count] = {1u, 0u};
  return Check(std::memcmp(b_payload, expected_b, sizeof(expected_b)) == 0, "B payload matches");
  }
}

bool TestSetShaderConstIBEmitsCommands() {
  return TestSetShaderConstIBEmitsCommandsImpl<D3D9DDI_DEVICEFUNCS>();
}

template <typename DeviceFuncsT>
bool TestSetShaderConstIBNormalizesStageImpl() {
  if constexpr (!HasPfnSetShaderConstI<DeviceFuncsT>::value ||
                !HasPfnSetShaderConstB<DeviceFuncsT>::value) {
    // Some D3D9 DDI header variants do not expose the I/B constant entrypoints in the device
    // function table. In those builds we cannot exercise the DDI surface area; treat the test as a
    // no-op.
    return true;
  } else {
    struct Cleanup {
      D3D9DDI_ADAPTERFUNCS adapter_funcs{};
      DeviceFuncsT device_funcs{};
      D3DDDI_HADAPTER hAdapter{};
      D3DDDI_HDEVICE hDevice{};
      bool has_adapter = false;
      bool has_device = false;

      ~Cleanup() {
        if (has_device && device_funcs.pfnDestroyDevice) {
          device_funcs.pfnDestroyDevice(hDevice);
        }
        if (has_adapter && adapter_funcs.pfnCloseAdapter) {
          adapter_funcs.pfnCloseAdapter(hAdapter);
        }
      }
    } cleanup;

    D3DDDIARG_OPENADAPTER2 open{};
    open.Interface = 1;
    open.Version = 1;
    D3DDDI_ADAPTERCALLBACKS callbacks{};
    D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
    open.pAdapterCallbacks = &callbacks;
    open.pAdapterCallbacks2 = &callbacks2;
    open.pAdapterFuncs = &cleanup.adapter_funcs;

    HRESULT hr = ::OpenAdapter2(&open);
    if (!Check(hr == S_OK, "OpenAdapter2")) {
      return false;
    }
    cleanup.hAdapter = open.hAdapter;
    cleanup.has_adapter = true;

    D3D9DDIARG_CREATEDEVICE create_dev{};
    create_dev.hAdapter = open.hAdapter;
    create_dev.Flags = 0;
    hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
    if (!Check(hr == S_OK, "CreateDevice")) {
      return false;
    }
    cleanup.hDevice = create_dev.hDevice;
    cleanup.has_device = true;

    auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
    if (!Check(dev != nullptr, "device pointer")) {
      return false;
    }

    std::vector<uint8_t> dma(4096, 0);
    dev->cmd.set_span(dma.data(), dma.size());
    dev->cmd.reset();
    ScopedDeviceCmdVectorReset cmd_reset(dev);

    // Use a non-{0,1} stage encoding; the driver should normalize it to PS.
    constexpr uint32_t kWeirdStage = 42u;

    const uint32_t int_start = 5;
    const uint32_t int_count = 1;
    const int32_t ints[int_count * 4] = {1, 2, 3, 4};
    hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, kWeirdStage, int_start, ints, int_count);
    if (!Check(hr == S_OK, "SetShaderConstI(weird stage)")) {
      return false;
    }

    const uint32_t bool_start = 7;
    const uint32_t bool_count = 1;
    const BOOL bools[bool_count] = {static_cast<BOOL>(1)};
    hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, kWeirdStage, bool_start, bools, bool_count);
    if (!Check(hr == S_OK, "SetShaderConstB(weird stage)")) {
      return false;
    }

    dev->cmd.finalize();
    const uint8_t* buf = dma.data();
    const size_t len = dev->cmd.bytes_used();
    if (!Check(ValidateStream(buf, dma.size()), "command stream validates")) {
      return false;
    }

    const CmdLoc i_loc = FindLastOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_I);
    if (!Check(i_loc.hdr != nullptr, "SET_SHADER_CONSTANTS_I emitted")) {
      return false;
    }
    const auto* i_cmd = reinterpret_cast<const aerogpu_cmd_set_shader_constants_i*>(i_loc.hdr);
    if (!Check(i_cmd->stage == AEROGPU_SHADER_STAGE_PIXEL, "I stage normalized to PS")) {
      return false;
    }
    if (!Check(i_cmd->start_register == int_start, "I start_register")) {
      return false;
    }
    if (!Check(i_cmd->vec4_count == int_count, "I vec4_count")) {
      return false;
    }
    const auto* i_payload = reinterpret_cast<const int32_t*>(
        reinterpret_cast<const uint8_t*>(i_cmd) + sizeof(*i_cmd));
    if (!Check(std::memcmp(i_payload, ints, sizeof(ints)) == 0, "I payload matches")) {
      return false;
    }

    const CmdLoc b_loc = FindLastOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_B);
    if (!Check(b_loc.hdr != nullptr, "SET_SHADER_CONSTANTS_B emitted")) {
      return false;
    }
    const auto* b_cmd = reinterpret_cast<const aerogpu_cmd_set_shader_constants_b*>(b_loc.hdr);
    if (!Check(b_cmd->stage == AEROGPU_SHADER_STAGE_PIXEL, "B stage normalized to PS")) {
      return false;
    }
    if (!Check(b_cmd->start_register == bool_start, "B start_register")) {
      return false;
    }
    if (!Check(b_cmd->bool_count == bool_count, "B bool_count")) {
      return false;
    }
    const auto* b_payload = reinterpret_cast<const uint32_t*>(
        reinterpret_cast<const uint8_t*>(b_cmd) + sizeof(*b_cmd));
    // Payload uses a single u32 per bool register (0 or 1).
    const uint32_t expected_b[bool_count] = {1u};
    return Check(std::memcmp(b_payload, expected_b, sizeof(expected_b)) == 0, "B payload matches");
  }
}

bool TestSetShaderConstIBNormalizesStage() {
  return TestSetShaderConstIBNormalizesStageImpl<D3D9DDI_DEVICEFUNCS>();
}

template <typename DeviceFuncsT>
bool TestSetShaderConstIBSkipsRedundantCommandsImpl() {
  if constexpr (!HasPfnSetShaderConstI<DeviceFuncsT>::value ||
                !HasPfnSetShaderConstB<DeviceFuncsT>::value) {
    return true;
  } else {
    struct Cleanup {
      D3D9DDI_ADAPTERFUNCS adapter_funcs{};
      DeviceFuncsT device_funcs{};
      D3DDDI_HADAPTER hAdapter{};
      D3DDDI_HDEVICE hDevice{};
      D3D9DDI_HSTATEBLOCK hStateBlock{};
      bool has_adapter = false;
      bool has_device = false;
      bool has_stateblock = false;

      ~Cleanup() {
        if (has_stateblock && device_funcs.pfnDeleteStateBlock) {
          device_funcs.pfnDeleteStateBlock(hDevice, hStateBlock);
        }
        if (has_device && device_funcs.pfnDestroyDevice) {
          device_funcs.pfnDestroyDevice(hDevice);
        }
        if (has_adapter && adapter_funcs.pfnCloseAdapter) {
          adapter_funcs.pfnCloseAdapter(hAdapter);
        }
      }
    } cleanup;

    D3DDDIARG_OPENADAPTER2 open{};
    open.Interface = 1;
    open.Version = 1;
    D3DDDI_ADAPTERCALLBACKS callbacks{};
    D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
    open.pAdapterCallbacks = &callbacks;
    open.pAdapterCallbacks2 = &callbacks2;
    open.pAdapterFuncs = &cleanup.adapter_funcs;

    HRESULT hr = ::OpenAdapter2(&open);
    if (!Check(hr == S_OK, "OpenAdapter2")) {
      return false;
    }
    cleanup.hAdapter = open.hAdapter;
    cleanup.has_adapter = true;

    D3D9DDIARG_CREATEDEVICE create_dev{};
    create_dev.hAdapter = open.hAdapter;
    create_dev.Flags = 0;
    hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
    if (!Check(hr == S_OK, "CreateDevice")) {
      return false;
    }
    cleanup.hDevice = create_dev.hDevice;
    cleanup.has_device = true;

    if (!Check(cleanup.device_funcs.pfnSetShaderConstI != nullptr, "SetShaderConstI must be available")) {
      return false;
    }
    if (!Check(cleanup.device_funcs.pfnSetShaderConstB != nullptr, "SetShaderConstB must be available")) {
      return false;
    }
    if (!cleanup.device_funcs.pfnBeginStateBlock ||
        !cleanup.device_funcs.pfnEndStateBlock ||
        !cleanup.device_funcs.pfnApplyStateBlock ||
        !cleanup.device_funcs.pfnDeleteStateBlock) {
      // Some build configurations may omit state-block entrypoints.
      return true;
    }

    auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
    if (!Check(dev != nullptr, "device pointer")) {
      return false;
    }

    std::vector<uint8_t> dma(4096, 0);
    dev->cmd.set_span(dma.data(), dma.size());
    dev->cmd.reset();
    ScopedDeviceCmdVectorReset cmd_reset(dev);

    const uint32_t int_start = 5;
    const uint32_t int_count = 2;
    const int32_t ints_a[int_count * 4] = {1, 2, 3, 4, 5, 6, 7, 8};
    hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, kD3d9ShaderStagePs, int_start, ints_a, int_count);
    if (!Check(hr == S_OK, "SetShaderConstI (A)")) {
      return false;
    }

    const uint32_t bool_start = 7;
    const uint32_t bool_count = 2;
    const BOOL bools_a[bool_count] = {static_cast<BOOL>(1), static_cast<BOOL>(0)};
    hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, kD3d9ShaderStagePs, bool_start, bools_a, bool_count);
    if (!Check(hr == S_OK, "SetShaderConstB (A)")) {
      return false;
    }

    // Re-applying the exact same constants should not emit redundant command stream packets.
    dev->cmd.reset();
    hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, kD3d9ShaderStagePs, int_start, ints_a, int_count);
    if (!Check(hr == S_OK, "SetShaderConstI (A redundant)")) {
      return false;
    }
    hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, kD3d9ShaderStagePs, bool_start, bools_a, bool_count);
    if (!Check(hr == S_OK, "SetShaderConstB (A redundant)")) {
      return false;
    }
    dev->cmd.finalize();
    const uint8_t* buf = dma.data();
    const size_t len = dev->cmd.bytes_used();
    if (!Check(ValidateStream(buf, dma.size()), "command stream validates")) {
      return false;
    }
    if (!Check(CountOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_I) == 0,
               "Redundant SetShaderConstI does not emit SET_SHADER_CONSTANTS_I")) {
      return false;
    }
    if (!Check(CountOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_B) == 0,
               "Redundant SetShaderConstB does not emit SET_SHADER_CONSTANTS_B")) {
      return false;
    }

    // Redundant sets must still be captured in Begin/End-recorded state blocks.
    hr = cleanup.device_funcs.pfnBeginStateBlock(create_dev.hDevice);
    if (!Check(hr == S_OK, "BeginStateBlock")) {
      return false;
    }
    hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, kD3d9ShaderStagePs, int_start, ints_a, int_count);
    if (!Check(hr == S_OK, "SetShaderConstI (A record)")) {
      return false;
    }
    hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, kD3d9ShaderStagePs, bool_start, bools_a, bool_count);
    if (!Check(hr == S_OK, "SetShaderConstB (A record)")) {
      return false;
    }
    hr = cleanup.device_funcs.pfnEndStateBlock(create_dev.hDevice, &cleanup.hStateBlock);
    if (!Check(hr == S_OK, "EndStateBlock")) {
      return false;
    }
    if (!Check(cleanup.hStateBlock.pDrvPrivate != nullptr, "EndStateBlock returns a stateblock handle")) {
      return false;
    }
    cleanup.has_stateblock = true;

    const int32_t ints_b[int_count * 4] = {-1, -2, -3, -4, -5, -6, -7, -8};
    hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, kD3d9ShaderStagePs, int_start, ints_b, int_count);
    if (!Check(hr == S_OK, "SetShaderConstI (B)")) {
      return false;
    }
    const BOOL bools_b[bool_count] = {static_cast<BOOL>(0), static_cast<BOOL>(1)};
    hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, kD3d9ShaderStagePs, bool_start, bools_b, bool_count);
    if (!Check(hr == S_OK, "SetShaderConstB (B)")) {
      return false;
    }

    dev->cmd.reset();
    hr = cleanup.device_funcs.pfnApplyStateBlock(create_dev.hDevice, cleanup.hStateBlock);
    if (!Check(hr == S_OK, "ApplyStateBlock")) {
      return false;
    }
    dev->cmd.finalize();
    buf = dma.data();
    const size_t apply_len = dev->cmd.bytes_used();
    if (!Check(ValidateStream(buf, dma.size()), "command stream validates (apply)")) {
      return false;
    }

    if (!Check(CountOpcode(buf, apply_len, AEROGPU_CMD_SET_SHADER_CONSTANTS_I) == 1,
               "ApplyStateBlock emits SET_SHADER_CONSTANTS_I")) {
      return false;
    }
    if (!Check(CountOpcode(buf, apply_len, AEROGPU_CMD_SET_SHADER_CONSTANTS_B) == 1,
               "ApplyStateBlock emits SET_SHADER_CONSTANTS_B")) {
      return false;
    }

    const CmdLoc i_loc = FindLastOpcode(buf, apply_len, AEROGPU_CMD_SET_SHADER_CONSTANTS_I);
    if (!Check(i_loc.hdr != nullptr, "Apply emitted SET_SHADER_CONSTANTS_I")) {
      return false;
    }
    const auto* i_cmd = reinterpret_cast<const aerogpu_cmd_set_shader_constants_i*>(i_loc.hdr);
    if (!Check(i_cmd->stage == AEROGPU_SHADER_STAGE_PIXEL, "I stage")) {
      return false;
    }
    if (!Check(i_cmd->start_register == int_start, "I start_register")) {
      return false;
    }
    if (!Check(i_cmd->vec4_count == int_count, "I vec4_count")) {
      return false;
    }
    const auto* i_payload =
        reinterpret_cast<const int32_t*>(reinterpret_cast<const uint8_t*>(i_cmd) + sizeof(*i_cmd));
    if (!Check(std::memcmp(i_payload, ints_a, sizeof(ints_a)) == 0, "I payload restores A")) {
      return false;
    }

    const CmdLoc b_loc = FindLastOpcode(buf, apply_len, AEROGPU_CMD_SET_SHADER_CONSTANTS_B);
    if (!Check(b_loc.hdr != nullptr, "Apply emitted SET_SHADER_CONSTANTS_B")) {
      return false;
    }
    const auto* b_cmd = reinterpret_cast<const aerogpu_cmd_set_shader_constants_b*>(b_loc.hdr);
    if (!Check(b_cmd->stage == AEROGPU_SHADER_STAGE_PIXEL, "B stage")) {
      return false;
    }
    if (!Check(b_cmd->start_register == bool_start, "B start_register")) {
      return false;
    }
    if (!Check(b_cmd->bool_count == bool_count, "B bool_count")) {
      return false;
    }
    const auto* b_payload =
        reinterpret_cast<const uint32_t*>(reinterpret_cast<const uint8_t*>(b_cmd) + sizeof(*b_cmd));
    const uint32_t expected_b[bool_count] = {1u, 0u};
    return Check(std::memcmp(b_payload, expected_b, sizeof(expected_b)) == 0, "B payload restores A");
  }
}

bool TestSetShaderConstIBSkipsRedundantCommands() {
  return TestSetShaderConstIBSkipsRedundantCommandsImpl<D3D9DDI_DEVICEFUNCS>();
}

template <typename DeviceFuncsT>
bool TestSetShaderConstIBInvalidRangeNoopsImpl() {
  if constexpr (!HasPfnSetShaderConstI<DeviceFuncsT>::value ||
                !HasPfnSetShaderConstB<DeviceFuncsT>::value) {
    return true;
  } else {
    struct Cleanup {
      D3D9DDI_ADAPTERFUNCS adapter_funcs{};
      DeviceFuncsT device_funcs{};
      D3DDDI_HADAPTER hAdapter{};
      D3DDDI_HDEVICE hDevice{};
      bool has_adapter = false;
      bool has_device = false;

      ~Cleanup() {
        if (has_device && device_funcs.pfnDestroyDevice) {
          device_funcs.pfnDestroyDevice(hDevice);
        }
        if (has_adapter && adapter_funcs.pfnCloseAdapter) {
          adapter_funcs.pfnCloseAdapter(hAdapter);
        }
      }
    } cleanup;

    D3DDDIARG_OPENADAPTER2 open{};
    open.Interface = 1;
    open.Version = 1;
    D3DDDI_ADAPTERCALLBACKS callbacks{};
    D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
    open.pAdapterCallbacks = &callbacks;
    open.pAdapterCallbacks2 = &callbacks2;
    open.pAdapterFuncs = &cleanup.adapter_funcs;

    HRESULT hr = ::OpenAdapter2(&open);
    if (!Check(hr == S_OK, "OpenAdapter2")) {
      return false;
    }
    cleanup.hAdapter = open.hAdapter;
    cleanup.has_adapter = true;

    D3D9DDIARG_CREATEDEVICE create_dev{};
    create_dev.hAdapter = open.hAdapter;
    create_dev.Flags = 0;
    hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
    if (!Check(hr == S_OK, "CreateDevice")) {
      return false;
    }
    cleanup.hDevice = create_dev.hDevice;
    cleanup.has_device = true;

    if (!Check(cleanup.device_funcs.pfnSetShaderConstI != nullptr, "SetShaderConstI must be available")) {
      return false;
    }
    if (!Check(cleanup.device_funcs.pfnSetShaderConstB != nullptr, "SetShaderConstB must be available")) {
      return false;
    }

    auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
    if (!Check(dev != nullptr, "device pointer")) {
      return false;
    }

    std::vector<uint8_t> dma(4096, 0);
    dev->cmd.set_span(dma.data(), dma.size());
    dev->cmd.reset();
    ScopedDeviceCmdVectorReset cmd_reset(dev);

    // Seed register 255 with known values so invalid ranges cannot "clamp" and partially write it.
    const uint32_t last_reg = 255;
    const int32_t i255_a[4] = {1, 2, 3, 4};
    hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, kD3d9ShaderStagePs, last_reg, i255_a, 1);
    if (!Check(hr == S_OK, "SetShaderConstI(PS, i255)")) {
      return false;
    }
    const BOOL b255_a[1] = {static_cast<BOOL>(1)};
    hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, kD3d9ShaderStagePs, last_reg, b255_a, 1);
    if (!Check(hr == S_OK, "SetShaderConstB(PS, b255)")) {
      return false;
    }

    const size_t base = static_cast<size_t>(last_reg) * 4;
    int32_t i_snapshot[4]{};
    std::memcpy(i_snapshot, dev->ps_consts_i + base, sizeof(i_snapshot));
    const uint8_t b_snapshot = dev->ps_consts_b[last_reg];

    // Invalid range: start=255, count=2.
    dev->cmd.reset();
    const int32_t i_invalid[8] = {-1, -2, -3, -4, -5, -6, -7, -8};
    hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, kD3d9ShaderStagePs, last_reg, i_invalid, 2);
    if (!Check(hr == kD3DErrInvalidCall, "SetShaderConstI invalid range returns INVALIDCALL")) {
      return false;
    }
    const BOOL b_invalid[2] = {static_cast<BOOL>(0), static_cast<BOOL>(0)};
    hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, kD3d9ShaderStagePs, last_reg, b_invalid, 2);
    if (!Check(hr == kD3DErrInvalidCall, "SetShaderConstB invalid range returns INVALIDCALL")) {
      return false;
    }
    dev->cmd.finalize();

    if (!Check(CountOpcode(dma.data(), dev->cmd.bytes_used(), AEROGPU_CMD_SET_SHADER_CONSTANTS_I) == 0,
               "invalid SetShaderConstI emits no SET_SHADER_CONSTANTS_I")) {
      return false;
    }
    if (!Check(CountOpcode(dma.data(), dev->cmd.bytes_used(), AEROGPU_CMD_SET_SHADER_CONSTANTS_B) == 0,
               "invalid SetShaderConstB emits no SET_SHADER_CONSTANTS_B")) {
      return false;
    }

    if (!Check(std::memcmp(dev->ps_consts_i + base, i_snapshot, sizeof(i_snapshot)) == 0,
               "invalid SetShaderConstI does not modify cached i255")) {
      return false;
    }
    return Check(dev->ps_consts_b[last_reg] == b_snapshot, "invalid SetShaderConstB does not modify cached b255");
  }
}

bool TestSetShaderConstIBInvalidRangeNoops() {
  return TestSetShaderConstIBInvalidRangeNoopsImpl<D3D9DDI_DEVICEFUNCS>();
}

template <typename DeviceFuncsT>
bool TestGetShaderConstIBRoundTripImpl() {
  if constexpr (!HasPfnSetShaderConstI<DeviceFuncsT>::value ||
                !HasPfnSetShaderConstB<DeviceFuncsT>::value ||
                !HasPfnGetShaderConstI<DeviceFuncsT>::value ||
                !HasPfnGetShaderConstB<DeviceFuncsT>::value) {
    return true;
  } else {
    struct Cleanup {
      D3D9DDI_ADAPTERFUNCS adapter_funcs{};
      DeviceFuncsT device_funcs{};
      D3DDDI_HADAPTER hAdapter{};
      D3DDDI_HDEVICE hDevice{};
      bool has_adapter = false;
      bool has_device = false;

      ~Cleanup() {
        if (has_device && device_funcs.pfnDestroyDevice) {
          device_funcs.pfnDestroyDevice(hDevice);
        }
        if (has_adapter && adapter_funcs.pfnCloseAdapter) {
          adapter_funcs.pfnCloseAdapter(hAdapter);
        }
      }
    } cleanup;

    D3DDDIARG_OPENADAPTER2 open{};
    open.Interface = 1;
    open.Version = 1;
    D3DDDI_ADAPTERCALLBACKS callbacks{};
    D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
    open.pAdapterCallbacks = &callbacks;
    open.pAdapterCallbacks2 = &callbacks2;
    open.pAdapterFuncs = &cleanup.adapter_funcs;

    HRESULT hr = ::OpenAdapter2(&open);
    if (!Check(hr == S_OK, "OpenAdapter2")) {
      return false;
    }
    cleanup.hAdapter = open.hAdapter;
    cleanup.has_adapter = true;

    D3D9DDIARG_CREATEDEVICE create_dev{};
    create_dev.hAdapter = open.hAdapter;
    create_dev.Flags = 0;
    hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
    if (!Check(hr == S_OK, "CreateDevice")) {
      return false;
    }
    cleanup.hDevice = create_dev.hDevice;
    cleanup.has_device = true;

    if (!Check(cleanup.device_funcs.pfnSetShaderConstI != nullptr, "SetShaderConstI must be available")) {
      return false;
    }
    if (!Check(cleanup.device_funcs.pfnSetShaderConstB != nullptr, "SetShaderConstB must be available")) {
      return false;
    }
    if (!Check(cleanup.device_funcs.pfnGetShaderConstI != nullptr, "GetShaderConstI must be available")) {
      return false;
    }
    if (!Check(cleanup.device_funcs.pfnGetShaderConstB != nullptr, "GetShaderConstB must be available")) {
      return false;
    }

    auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
    if (!Check(dev != nullptr, "device pointer")) {
      return false;
    }

    std::vector<uint8_t> dma(4096, 0);
    dev->cmd.set_span(dma.data(), dma.size());
    dev->cmd.reset();
    ScopedDeviceCmdVectorReset cmd_reset(dev);

    // Round-trip VS/PS int constants: ensure the stages are independent.
    const uint32_t i_start = 5;
    const int32_t vs_i5[4] = {100, 101, 102, 103};
    hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, kD3d9ShaderStageVs, i_start, vs_i5, 1);
    if (!Check(hr == S_OK, "SetShaderConstI(VS, i5)")) {
      return false;
    }

    const uint32_t ps_i_count = 2;
    const int32_t ps_i5_i6[ps_i_count * 4] = {1, 2, 3, 4, 5, 6, 7, 8};
    hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, kD3d9ShaderStagePs, i_start, ps_i5_i6, ps_i_count);
    if (!Check(hr == S_OK, "SetShaderConstI(PS, i5..i6)")) {
      return false;
    }

    using PfnGetI = decltype(cleanup.device_funcs.pfnGetShaderConstI);
    using GetIStageT = typename FnTraits<PfnGetI>::template Arg<1>;
    using GetIStartT = typename FnTraits<PfnGetI>::template Arg<2>;
    using GetIDataPtrT = typename FnTraits<PfnGetI>::template Arg<3>;
    using GetIDataT = std::remove_pointer_t<GetIDataPtrT>;
    using GetICountT = typename FnTraits<PfnGetI>::template Arg<4>;

    std::array<GetIDataT, 4> out_vs_i{};
    hr = cleanup.device_funcs.pfnGetShaderConstI(create_dev.hDevice,
                                                 static_cast<GetIStageT>(kD3d9ShaderStageVs),
                                                 static_cast<GetIStartT>(i_start),
                                                 out_vs_i.data(),
                                                 static_cast<GetICountT>(1));
    if (!Check(hr == S_OK, "GetShaderConstI(VS, i5)")) {
      return false;
    }
    for (size_t i = 0; i < out_vs_i.size(); ++i) {
      if (!Check(static_cast<int32_t>(out_vs_i[i]) == vs_i5[i], "GetShaderConstI(VS) returns set values")) {
        return false;
      }
    }

    std::array<GetIDataT, ps_i_count * 4> out_ps_i{};
    hr = cleanup.device_funcs.pfnGetShaderConstI(create_dev.hDevice,
                                                 static_cast<GetIStageT>(kD3d9ShaderStagePs),
                                                 static_cast<GetIStartT>(i_start),
                                                 out_ps_i.data(),
                                                 static_cast<GetICountT>(ps_i_count));
    if (!Check(hr == S_OK, "GetShaderConstI(PS, i5..i6)")) {
      return false;
    }
    for (size_t i = 0; i < out_ps_i.size(); ++i) {
      if (!Check(static_cast<int32_t>(out_ps_i[i]) == ps_i5_i6[i], "GetShaderConstI(PS) returns set values")) {
        return false;
      }
    }

    // Round-trip PS bool constants: setters normalize non-zero inputs to 1.
    const uint32_t b_start = 7;
    const uint32_t b_count = 3;
    const BOOL b_in[b_count] = {0, static_cast<BOOL>(0xFFFF'FFFFu), 0};
    hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, kD3d9ShaderStagePs, b_start, b_in, b_count);
    if (!Check(hr == S_OK, "SetShaderConstB(PS, b7..b9)")) {
      return false;
    }

    using PfnGetB = decltype(cleanup.device_funcs.pfnGetShaderConstB);
    using GetBStageT = typename FnTraits<PfnGetB>::template Arg<1>;
    using GetBStartT = typename FnTraits<PfnGetB>::template Arg<2>;
    using GetBDataPtrT = typename FnTraits<PfnGetB>::template Arg<3>;
    using GetBDataT = std::remove_pointer_t<GetBDataPtrT>;
    using GetBCountT = typename FnTraits<PfnGetB>::template Arg<4>;

    std::array<GetBDataT, b_count> out_b{};
    hr = cleanup.device_funcs.pfnGetShaderConstB(create_dev.hDevice,
                                                 static_cast<GetBStageT>(kD3d9ShaderStagePs),
                                                 static_cast<GetBStartT>(b_start),
                                                 out_b.data(),
                                                 static_cast<GetBCountT>(b_count));
    if (!Check(hr == S_OK, "GetShaderConstB(PS, b7..b9)")) {
      return false;
    }
    const uint32_t expected_b[b_count] = {0u, 1u, 0u};
    for (size_t i = 0; i < out_b.size(); ++i) {
      if (!Check(static_cast<uint32_t>(out_b[i]) == expected_b[i], "GetShaderConstB returns normalized values")) {
        return false;
      }
    }

    // Stage normalization on the getter path: any non-VS stage should behave like PS.
    constexpr uint32_t kWeirdStage = 42u;

    std::array<GetIDataT, ps_i_count * 4> out_ps_i_norm{};
    hr = cleanup.device_funcs.pfnGetShaderConstI(create_dev.hDevice,
                                                 static_cast<GetIStageT>(kWeirdStage),
                                                 static_cast<GetIStartT>(i_start),
                                                 out_ps_i_norm.data(),
                                                 static_cast<GetICountT>(ps_i_count));
    if (!Check(hr == S_OK, "GetShaderConstI(weird stage, i5..i6)")) {
      return false;
    }
    for (size_t i = 0; i < out_ps_i_norm.size(); ++i) {
      if (!Check(static_cast<int32_t>(out_ps_i_norm[i]) == ps_i5_i6[i], "GetShaderConstI weird stage reads PS values")) {
        return false;
      }
    }

    std::array<GetBDataT, b_count> out_b_norm_stage{};
    hr = cleanup.device_funcs.pfnGetShaderConstB(create_dev.hDevice,
                                                 static_cast<GetBStageT>(kWeirdStage),
                                                 static_cast<GetBStartT>(b_start),
                                                 out_b_norm_stage.data(),
                                                 static_cast<GetBCountT>(b_count));
    if (!Check(hr == S_OK, "GetShaderConstB(weird stage, b7..b9)")) {
      return false;
    }
    for (size_t i = 0; i < out_b_norm_stage.size(); ++i) {
      if (!Check(static_cast<uint32_t>(out_b_norm_stage[i]) == expected_b[i], "GetShaderConstB weird stage reads PS values")) {
        return false;
      }
    }

    // Stage normalization: any non-VS stage should behave like PS.
    const uint32_t i_norm_start = 10;
    const int32_t i_norm[4] = {-9, -8, -7, -6};
    hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, kWeirdStage, i_norm_start, i_norm, 1);
    if (!Check(hr == S_OK, "SetShaderConstI(weird stage)")) {
      return false;
    }
    std::array<GetIDataT, 4> out_i_norm{};
    hr = cleanup.device_funcs.pfnGetShaderConstI(create_dev.hDevice,
                                                 static_cast<GetIStageT>(kD3d9ShaderStagePs),
                                                 static_cast<GetIStartT>(i_norm_start),
                                                 out_i_norm.data(),
                                                 static_cast<GetICountT>(1));
    if (!Check(hr == S_OK, "GetShaderConstI(PS, normalized)")) {
      return false;
    }
    for (size_t i = 0; i < out_i_norm.size(); ++i) {
      if (!Check(static_cast<int32_t>(out_i_norm[i]) == i_norm[i], "GetShaderConstI reads normalized stage values")) {
        return false;
      }
    }

    const uint32_t b_norm_start = 20;
    const BOOL b_norm[1] = {static_cast<BOOL>(1)};
    hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, kWeirdStage, b_norm_start, b_norm, 1);
    if (!Check(hr == S_OK, "SetShaderConstB(weird stage)")) {
      return false;
    }
    std::array<GetBDataT, 1> out_b_norm{};
    hr = cleanup.device_funcs.pfnGetShaderConstB(create_dev.hDevice,
                                                 static_cast<GetBStageT>(kD3d9ShaderStagePs),
                                                 static_cast<GetBStartT>(b_norm_start),
                                                 out_b_norm.data(),
                                                 static_cast<GetBCountT>(1));
    if (!Check(hr == S_OK, "GetShaderConstB(PS, normalized)")) {
      return false;
    }
    if (!Check(static_cast<uint32_t>(out_b_norm[0]) == 1u, "GetShaderConstB reads normalized stage values")) {
      return false;
    }

    // Invalid arg/range handling: ensure outputs are zeroed before returning an error so callers
    // can't accidentally consume uninitialized memory.
    std::array<GetIDataT, 8> invalid_i{};
    for (auto& v : invalid_i) {
      v = static_cast<GetIDataT>(0x7F);
    }
    hr = cleanup.device_funcs.pfnGetShaderConstI(create_dev.hDevice,
                                                 static_cast<GetIStageT>(kD3d9ShaderStagePs),
                                                 static_cast<GetIStartT>(255u),
                                                 invalid_i.data(),
                                                 static_cast<GetICountT>(2));
    if (!Check(hr == kD3DErrInvalidCall, "GetShaderConstI invalid range returns INVALIDCALL")) {
      return false;
    }
    for (const auto& v : invalid_i) {
      if (!Check(static_cast<uint64_t>(v) == 0u, "GetShaderConstI invalid range zeroes output")) {
        return false;
      }
    }

    std::array<GetBDataT, 2> invalid_b{};
    for (auto& v : invalid_b) {
      v = static_cast<GetBDataT>(0x7F);
    }
    hr = cleanup.device_funcs.pfnGetShaderConstB(create_dev.hDevice,
                                                 static_cast<GetBStageT>(kD3d9ShaderStagePs),
                                                 static_cast<GetBStartT>(255u),
                                                 invalid_b.data(),
                                                 static_cast<GetBCountT>(2));
    if (!Check(hr == kD3DErrInvalidCall, "GetShaderConstB invalid range returns INVALIDCALL")) {
      return false;
    }
    for (const auto& v : invalid_b) {
      if (!Check(static_cast<uint64_t>(v) == 0u, "GetShaderConstB invalid range zeroes output")) {
        return false;
      }
    }

    return true;
  }
}

bool TestGetShaderConstIBRoundTrip() {
  return TestGetShaderConstIBRoundTripImpl<D3D9DDI_DEVICEFUNCS>();
}

template <typename DeviceFuncsT, uint32_t D3dStage>
bool TestApplyStateBlockSkipsRedundantShaderConstFImpl() {
  if constexpr (!HasPfnSetShaderConstF<DeviceFuncsT>::value) {
    // Some D3D9 DDI header variants may not expose SetShaderConstF in the device function table.
    return true;
  } else {
    struct Cleanup {
      D3D9DDI_ADAPTERFUNCS adapter_funcs{};
      DeviceFuncsT device_funcs{};
      D3DDDI_HADAPTER hAdapter{};
      D3DDDI_HDEVICE hDevice{};
      D3D9DDI_HSTATEBLOCK hStateBlock{};
      bool has_adapter = false;
      bool has_device = false;
      bool has_stateblock = false;

      ~Cleanup() {
        if (has_stateblock && device_funcs.pfnDeleteStateBlock) {
          device_funcs.pfnDeleteStateBlock(hDevice, hStateBlock);
        }
        if (has_device && device_funcs.pfnDestroyDevice) {
          device_funcs.pfnDestroyDevice(hDevice);
        }
        if (has_adapter && adapter_funcs.pfnCloseAdapter) {
          adapter_funcs.pfnCloseAdapter(hAdapter);
        }
      }
    } cleanup;

    D3DDDIARG_OPENADAPTER2 open{};
    open.Interface = 1;
    open.Version = 1;
    D3DDDI_ADAPTERCALLBACKS callbacks{};
    D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
    open.pAdapterCallbacks = &callbacks;
    open.pAdapterCallbacks2 = &callbacks2;
    open.pAdapterFuncs = &cleanup.adapter_funcs;

    HRESULT hr = ::OpenAdapter2(&open);
    if (!Check(hr == S_OK, "OpenAdapter2")) {
      return false;
    }
    cleanup.hAdapter = open.hAdapter;
    cleanup.has_adapter = true;

    D3D9DDIARG_CREATEDEVICE create_dev{};
    create_dev.hAdapter = open.hAdapter;
    create_dev.Flags = 0;
    hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
    if (!Check(hr == S_OK, "CreateDevice")) {
      return false;
    }
    cleanup.hDevice = create_dev.hDevice;
    cleanup.has_device = true;

    if (!cleanup.device_funcs.pfnBeginStateBlock ||
        !cleanup.device_funcs.pfnEndStateBlock ||
        !cleanup.device_funcs.pfnApplyStateBlock ||
        !cleanup.device_funcs.pfnDeleteStateBlock) {
      // Some build configurations may omit state-block entrypoints.
      return true;
    }
    if (!Check(cleanup.device_funcs.pfnSetShaderConstF != nullptr, "SetShaderConstF must be available")) {
      return false;
    }

    auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
    if (!Check(dev != nullptr, "device pointer")) {
      return false;
    }

    std::vector<uint8_t> dma(4096, 0);
    dev->cmd.set_span(dma.data(), dma.size());
    dev->cmd.reset();
    ScopedDeviceCmdVectorReset cmd_reset(dev);

    // Record a state block that sets float shader constants.
    hr = cleanup.device_funcs.pfnBeginStateBlock(create_dev.hDevice);
    if (!Check(hr == S_OK, "BeginStateBlock")) {
      return false;
    }
    const uint32_t start_reg = 5;
    const uint32_t vec4_count = 2;
    const float data[vec4_count * 4] = {
        1.0f, 2.0f, 3.0f, 4.0f,
        5.0f, 6.0f, 7.0f, 8.0f,
    };
    hr = cleanup.device_funcs.pfnSetShaderConstF(create_dev.hDevice, D3dStage, start_reg, data, vec4_count);
    if (!Check(hr == S_OK, "SetShaderConstF(record)")) {
      return false;
    }
    hr = cleanup.device_funcs.pfnEndStateBlock(create_dev.hDevice, &cleanup.hStateBlock);
    if (!Check(hr == S_OK, "EndStateBlock")) {
      return false;
    }
    if (!Check(cleanup.hStateBlock.pDrvPrivate != nullptr, "EndStateBlock returns a stateblock handle")) {
      return false;
    }
    cleanup.has_stateblock = true;

    // Applying the state block immediately (without changing device state) should not emit redundant constant uploads.
    dev->cmd.reset();
    hr = cleanup.device_funcs.pfnApplyStateBlock(create_dev.hDevice, cleanup.hStateBlock);
    if (!Check(hr == S_OK, "ApplyStateBlock")) {
      return false;
    }
    dev->cmd.finalize();
    const uint8_t* buf = dma.data();
    const size_t len = dev->cmd.bytes_used();
    if (!Check(ValidateStream(buf, dma.size()), "command stream validates")) {
      return false;
    }
    return Check(CountOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_F) == 0,
                 "Redundant ApplyStateBlock does not emit SET_SHADER_CONSTANTS_F");
  }
}

bool TestApplyStateBlockSkipsRedundantShaderConstF() {
  return TestApplyStateBlockSkipsRedundantShaderConstFImpl<D3D9DDI_DEVICEFUNCS, kD3d9ShaderStagePs>();
}

bool TestApplyStateBlockSkipsRedundantShaderConstFVs() {
  return TestApplyStateBlockSkipsRedundantShaderConstFImpl<D3D9DDI_DEVICEFUNCS, kD3d9ShaderStageVs>();
}

template <typename DeviceFuncsT, uint32_t D3dStage, uint32_t ExpectedStage>
bool TestApplyStateBlockEmitsShaderConstIBImpl() {
  if constexpr (!HasPfnSetShaderConstI<DeviceFuncsT>::value ||
                !HasPfnSetShaderConstB<DeviceFuncsT>::value) {
    // Some D3D9 DDI header variants do not expose the I/B constant entrypoints in the device
    // function table. In those builds we cannot exercise the DDI surface area; treat the test as a
    // no-op.
    return true;
  } else {
    struct Cleanup {
      D3D9DDI_ADAPTERFUNCS adapter_funcs{};
      DeviceFuncsT device_funcs{};
      D3DDDI_HADAPTER hAdapter{};
      D3DDDI_HDEVICE hDevice{};
      D3D9DDI_HSTATEBLOCK hStateBlock{};
      bool has_adapter = false;
      bool has_device = false;
      bool has_stateblock = false;

      ~Cleanup() {
        if (has_stateblock && device_funcs.pfnDeleteStateBlock) {
          device_funcs.pfnDeleteStateBlock(hDevice, hStateBlock);
        }
        if (has_device && device_funcs.pfnDestroyDevice) {
          device_funcs.pfnDestroyDevice(hDevice);
        }
        if (has_adapter && adapter_funcs.pfnCloseAdapter) {
          adapter_funcs.pfnCloseAdapter(hAdapter);
        }
      }
    } cleanup;

    D3DDDIARG_OPENADAPTER2 open{};
    open.Interface = 1;
    open.Version = 1;
    D3DDDI_ADAPTERCALLBACKS callbacks{};
    D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
    open.pAdapterCallbacks = &callbacks;
    open.pAdapterCallbacks2 = &callbacks2;
    open.pAdapterFuncs = &cleanup.adapter_funcs;

    HRESULT hr = ::OpenAdapter2(&open);
    if (!Check(hr == S_OK, "OpenAdapter2")) {
      return false;
    }
    if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
      return false;
    }
    cleanup.hAdapter = open.hAdapter;
    cleanup.has_adapter = true;

    D3D9DDIARG_CREATEDEVICE create_dev{};
    create_dev.hAdapter = open.hAdapter;
    create_dev.Flags = 0;

    hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
    if (!Check(hr == S_OK, "CreateDevice")) {
      return false;
    }
    if (!Check(create_dev.hDevice.pDrvPrivate != nullptr, "CreateDevice returned device handle")) {
      return false;
    }
    cleanup.hDevice = create_dev.hDevice;
    cleanup.has_device = true;

    if (!Check(cleanup.device_funcs.pfnBeginStateBlock != nullptr, "BeginStateBlock must be available")) {
      return false;
    }
    if (!Check(cleanup.device_funcs.pfnEndStateBlock != nullptr, "EndStateBlock must be available")) {
      return false;
    }
    if (!Check(cleanup.device_funcs.pfnApplyStateBlock != nullptr, "ApplyStateBlock must be available")) {
      return false;
    }
    if (!Check(cleanup.device_funcs.pfnDeleteStateBlock != nullptr, "DeleteStateBlock must be available")) {
      return false;
    }

    auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
    if (!Check(dev != nullptr, "device pointer")) {
      return false;
    }

    std::vector<uint8_t> dma(4096, 0);
    dev->cmd.set_span(dma.data(), dma.size());
    dev->cmd.reset();
    ScopedDeviceCmdVectorReset cmd_reset(dev);

    // Record a state block that sets int/bool constants.
    hr = cleanup.device_funcs.pfnBeginStateBlock(create_dev.hDevice);
    if (!Check(hr == S_OK, "BeginStateBlock")) {
      return false;
    }

    // Set 2 int4 registers: i5..i6.
    const uint32_t int_start = 5;
    const uint32_t int_count = 2;
    const int32_t ints_a[int_count * 4] = {1, 2, 3, 4, 5, 6, 7, 8};
    hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice,
                                                 D3dStage,
                                                 int_start,
                                                 ints_a,
                                                 int_count);
    if (!Check(hr == S_OK, "SetShaderConstI (recorded)")) {
      return false;
    }

    // Set 2 bool registers: b7..b8.
    const uint32_t bool_start = 7;
    const uint32_t bool_count = 2;
    const BOOL bools_a[bool_count] = {static_cast<BOOL>(1), static_cast<BOOL>(0)};
    hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice,
                                                 D3dStage,
                                                 bool_start,
                                                 bools_a,
                                                 bool_count);
    if (!Check(hr == S_OK, "SetShaderConstB (recorded)")) {
      return false;
    }

    hr = cleanup.device_funcs.pfnEndStateBlock(create_dev.hDevice, &cleanup.hStateBlock);
    if (!Check(hr == S_OK, "EndStateBlock")) {
      return false;
    }
    if (!Check(cleanup.hStateBlock.pDrvPrivate != nullptr, "EndStateBlock returns stateblock handle")) {
      return false;
    }
    cleanup.has_stateblock = true;

    // Change the constants to different values so ApplyStateBlock must re-upload.
    const int32_t ints_b[int_count * 4] = {-1, -2, -3, -4, -5, -6, -7, -8};
    hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice,
                                                 D3dStage,
                                                 int_start,
                                                 ints_b,
                                                 int_count);
    if (!Check(hr == S_OK, "SetShaderConstI change-to-B")) {
      return false;
    }

    const BOOL bools_b[bool_count] = {static_cast<BOOL>(0), static_cast<BOOL>(1)};
    hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice,
                                                 D3dStage,
                                                 bool_start,
                                                 bools_b,
                                                 bool_count);
    if (!Check(hr == S_OK, "SetShaderConstB change-to-B")) {
      return false;
    }

    dev->cmd.reset();
    hr = cleanup.device_funcs.pfnApplyStateBlock(create_dev.hDevice, cleanup.hStateBlock);
    if (!Check(hr == S_OK, "ApplyStateBlock")) {
      return false;
    }

    dev->cmd.finalize();
    const uint8_t* buf = dma.data();
    const size_t len = dev->cmd.bytes_used();
    if (!Check(ValidateStream(buf, dma.size()), "command stream validates")) {
      return false;
    }

    const CmdLoc i_loc = FindLastOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_I);
    if (!Check(i_loc.hdr != nullptr, "ApplyStateBlock emits SET_SHADER_CONSTANTS_I")) {
      return false;
    }
    const auto* i_cmd = reinterpret_cast<const aerogpu_cmd_set_shader_constants_i*>(i_loc.hdr);
    if (!Check(i_cmd->stage == ExpectedStage, "ApplyStateBlock I stage")) {
      return false;
    }
    if (!Check(i_cmd->start_register == int_start, "ApplyStateBlock I start_register")) {
      return false;
    }
    if (!Check(i_cmd->vec4_count == int_count, "ApplyStateBlock I vec4_count")) {
      return false;
    }
    const auto* i_payload = reinterpret_cast<const int32_t*>(
        reinterpret_cast<const uint8_t*>(i_cmd) + sizeof(*i_cmd));
    if (!Check(std::memcmp(i_payload, ints_a, sizeof(ints_a)) == 0, "ApplyStateBlock I payload matches")) {
      return false;
    }

    const CmdLoc b_loc = FindLastOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_B);
    if (!Check(b_loc.hdr != nullptr, "ApplyStateBlock emits SET_SHADER_CONSTANTS_B")) {
      return false;
    }
    const auto* b_cmd = reinterpret_cast<const aerogpu_cmd_set_shader_constants_b*>(b_loc.hdr);
    if (!Check(b_cmd->stage == ExpectedStage, "ApplyStateBlock B stage")) {
      return false;
    }
    if (!Check(b_cmd->start_register == bool_start, "ApplyStateBlock B start_register")) {
      return false;
    }
    if (!Check(b_cmd->bool_count == bool_count, "ApplyStateBlock B bool_count")) {
      return false;
    }
    const auto* b_payload = reinterpret_cast<const uint32_t*>(
        reinterpret_cast<const uint8_t*>(b_cmd) + sizeof(*b_cmd));
    const uint32_t expected_b[bool_count] = {1u, 0u};
    return Check(std::memcmp(b_payload, expected_b, sizeof(expected_b)) == 0, "B payload matches");
  }
}

bool TestApplyStateBlockEmitsShaderConstIB() {
  return TestApplyStateBlockEmitsShaderConstIBImpl<
      D3D9DDI_DEVICEFUNCS,
      kD3d9ShaderStagePs,
      static_cast<uint32_t>(AEROGPU_SHADER_STAGE_PIXEL)>();
}

bool TestApplyStateBlockEmitsShaderConstIBVs() {
  return TestApplyStateBlockEmitsShaderConstIBImpl<
      D3D9DDI_DEVICEFUNCS,
      kD3d9ShaderStageVs,
      static_cast<uint32_t>(AEROGPU_SHADER_STAGE_VERTEX)>();
}

template <typename DeviceFuncsT, uint32_t D3dStage, uint32_t ExpectedStage>
bool TestApplyStateBlockSplitsShaderConstIBImpl() {
  if constexpr (!HasPfnSetShaderConstI<DeviceFuncsT>::value ||
                !HasPfnSetShaderConstB<DeviceFuncsT>::value) {
    // Some D3D9 DDI header variants do not expose the I/B constant entrypoints in the device
    // function table. In those builds we cannot exercise the DDI surface area; treat the test as a
    // no-op.
    return true;
  } else {
    struct Cleanup {
      D3D9DDI_ADAPTERFUNCS adapter_funcs{};
      DeviceFuncsT device_funcs{};
      D3DDDI_HADAPTER hAdapter{};
      D3DDDI_HDEVICE hDevice{};
      D3D9DDI_HSTATEBLOCK hStateBlock{};
      bool has_adapter = false;
      bool has_device = false;
      bool has_stateblock = false;
      ~Cleanup() {
        if (has_stateblock && device_funcs.pfnDeleteStateBlock) {
          device_funcs.pfnDeleteStateBlock(hDevice, hStateBlock);
        }
        if (has_device && device_funcs.pfnDestroyDevice) {
          device_funcs.pfnDestroyDevice(hDevice);
        }
        if (has_adapter && adapter_funcs.pfnCloseAdapter) {
          adapter_funcs.pfnCloseAdapter(hAdapter);
        }
      }
    } cleanup;

    D3DDDIARG_OPENADAPTER2 open{};
    open.Interface = 1;
    open.Version = 1;
    D3DDDI_ADAPTERCALLBACKS callbacks{};
    D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
    open.pAdapterCallbacks = &callbacks;
    open.pAdapterCallbacks2 = &callbacks2;
    open.pAdapterFuncs = &cleanup.adapter_funcs;

    HRESULT hr = ::OpenAdapter2(&open);
    if (!Check(hr == S_OK, "OpenAdapter2")) {
      return false;
    }
    cleanup.hAdapter = open.hAdapter;
    cleanup.has_adapter = true;

    D3D9DDIARG_CREATEDEVICE create_dev{};
    create_dev.hAdapter = open.hAdapter;
    create_dev.Flags = 0;
    hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
    if (!Check(hr == S_OK, "CreateDevice")) {
      return false;
    }
    cleanup.hDevice = create_dev.hDevice;
    cleanup.has_device = true;

    auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
    if (!Check(dev != nullptr, "device pointer")) {
      return false;
    }

    std::vector<uint8_t> dma(4096, 0);
    dev->cmd.set_span(dma.data(), dma.size());
    dev->cmd.reset();
    ScopedDeviceCmdVectorReset cmd_reset(dev);

    hr = cleanup.device_funcs.pfnBeginStateBlock(create_dev.hDevice);
    if (!Check(hr == S_OK, "BeginStateBlock")) {
      return false;
    }

    // Record non-contiguous int constants: i5 and i7.
    const uint32_t i0 = 5;
    const uint32_t i1 = 7;
    const int32_t i5[4] = {1, 2, 3, 4};
    const int32_t i7[4] = {9, 10, 11, 12};
    hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, D3dStage, i0, i5, 1);
    if (!Check(hr == S_OK, "SetShaderConstI(i5)")) {
      return false;
    }
    hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, D3dStage, i1, i7, 1);
    if (!Check(hr == S_OK, "SetShaderConstI(i7)")) {
      return false;
    }

    // Record non-contiguous bool constants: b7 and b9.
    const uint32_t b0 = 7;
    const uint32_t b1 = 9;
    const BOOL b7_val[1] = {static_cast<BOOL>(1)};
    const BOOL b9_val[1] = {static_cast<BOOL>(0)};
    hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, D3dStage, b0, b7_val, 1);
    if (!Check(hr == S_OK, "SetShaderConstB(b7)")) {
      return false;
    }
    hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, D3dStage, b1, b9_val, 1);
    if (!Check(hr == S_OK, "SetShaderConstB(b9)")) {
      return false;
    }

    hr = cleanup.device_funcs.pfnEndStateBlock(create_dev.hDevice, &cleanup.hStateBlock);
    if (!Check(hr == S_OK, "EndStateBlock")) {
      return false;
    }
    cleanup.has_stateblock = true;

    // Change values so ApplyStateBlock must restore the original non-contiguous segments.
    const int32_t i5_b[4] = {-1, -2, -3, -4};
    const int32_t i7_b[4] = {-9, -10, -11, -12};
    hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, D3dStage, i0, i5_b, 1);
    if (!Check(hr == S_OK, "SetShaderConstI(i5 B)")) {
      return false;
    }
    hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, D3dStage, i1, i7_b, 1);
    if (!Check(hr == S_OK, "SetShaderConstI(i7 B)")) {
      return false;
    }

    const BOOL b7_b[1] = {static_cast<BOOL>(0)};
    const BOOL b9_b[1] = {static_cast<BOOL>(1)};
    hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, D3dStage, b0, b7_b, 1);
    if (!Check(hr == S_OK, "SetShaderConstB(b7 B)")) {
      return false;
    }
    hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, D3dStage, b1, b9_b, 1);
    if (!Check(hr == S_OK, "SetShaderConstB(b9 B)")) {
      return false;
    }

    dev->cmd.reset();
    hr = cleanup.device_funcs.pfnApplyStateBlock(create_dev.hDevice, cleanup.hStateBlock);
    if (!Check(hr == S_OK, "ApplyStateBlock")) {
      return false;
    }
    dev->cmd.finalize();
    const uint8_t* buf = dma.data();
    const size_t len = dev->cmd.bytes_used();
    if (!Check(ValidateStream(buf, dma.size()), "command stream validates")) {
      return false;
    }

    if (!Check(CountOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_I) == 2,
               "ApplyStateBlock splits SET_SHADER_CONSTANTS_I")) {
      return false;
    }
    if (!Check(CountOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_B) == 2,
               "ApplyStateBlock splits SET_SHADER_CONSTANTS_B")) {
      return false;
    }

    // Validate int packets: first i5, then i7.
    const CmdLoc i7_loc = FindLastOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_I);
    if (!Check(i7_loc.hdr != nullptr, "I packet present")) {
      return false;
    }
    const auto* i7_cmd = reinterpret_cast<const aerogpu_cmd_set_shader_constants_i*>(i7_loc.hdr);
    if (!Check(i7_cmd->stage == ExpectedStage, "I stage")) {
      return false;
    }
    if (!Check(i7_cmd->start_register == i1, "I7 start_register")) {
      return false;
    }
    if (!Check(i7_cmd->vec4_count == 1, "I7 vec4_count")) {
      return false;
    }
    const auto* i7_payload =
        reinterpret_cast<const int32_t*>(reinterpret_cast<const uint8_t*>(i7_cmd) + sizeof(*i7_cmd));
    if (!Check(std::memcmp(i7_payload, i7, sizeof(i7)) == 0, "I7 payload matches")) {
      return false;
    }

    const CmdLoc i5_loc = FindLastOpcodeBefore(buf, len, i7_loc.offset, AEROGPU_CMD_SET_SHADER_CONSTANTS_I);
    if (!Check(i5_loc.hdr != nullptr, "I5 packet present")) {
      return false;
    }
    const auto* i5_cmd = reinterpret_cast<const aerogpu_cmd_set_shader_constants_i*>(i5_loc.hdr);
    if (!Check(i5_cmd->stage == ExpectedStage, "I5 stage")) {
      return false;
    }
    if (!Check(i5_cmd->start_register == i0, "I5 start_register")) {
      return false;
    }
    if (!Check(i5_cmd->vec4_count == 1, "I5 vec4_count")) {
      return false;
    }
    const auto* i5_payload =
        reinterpret_cast<const int32_t*>(reinterpret_cast<const uint8_t*>(i5_cmd) + sizeof(*i5_cmd));
    if (!Check(std::memcmp(i5_payload, i5, sizeof(i5)) == 0, "I5 payload matches")) {
      return false;
    }

    // Validate bool packets: first b7=true, then b9=false.
    const CmdLoc b9_loc = FindLastOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_B);
    if (!Check(b9_loc.hdr != nullptr, "B packet present")) {
      return false;
    }
    const auto* b9_cmd = reinterpret_cast<const aerogpu_cmd_set_shader_constants_b*>(b9_loc.hdr);
    if (!Check(b9_cmd->stage == ExpectedStage, "B stage")) {
      return false;
    }
    if (!Check(b9_cmd->start_register == b1, "B9 start_register")) {
      return false;
    }
    if (!Check(b9_cmd->bool_count == 1, "B9 bool_count")) {
      return false;
    }
    const auto* b9_payload =
        reinterpret_cast<const uint32_t*>(reinterpret_cast<const uint8_t*>(b9_cmd) + sizeof(*b9_cmd));
    // Payload uses a single u32 per bool register (0 or 1).
    const uint32_t expected_b9[1] = {0u};
    if (!Check(std::memcmp(b9_payload, expected_b9, sizeof(expected_b9)) == 0, "B9 payload matches")) {
      return false;
    }

    const CmdLoc b7_loc = FindLastOpcodeBefore(buf, len, b9_loc.offset, AEROGPU_CMD_SET_SHADER_CONSTANTS_B);
    if (!Check(b7_loc.hdr != nullptr, "B7 packet present")) {
      return false;
    }
    const auto* b7_cmd = reinterpret_cast<const aerogpu_cmd_set_shader_constants_b*>(b7_loc.hdr);
    if (!Check(b7_cmd->stage == ExpectedStage, "B7 stage")) {
      return false;
    }
    if (!Check(b7_cmd->start_register == b0, "B7 start_register")) {
      return false;
    }
    if (!Check(b7_cmd->bool_count == 1, "B7 bool_count")) {
      return false;
    }
    const auto* b7_payload =
        reinterpret_cast<const uint32_t*>(reinterpret_cast<const uint8_t*>(b7_cmd) + sizeof(*b7_cmd));
    const uint32_t expected_b7[1] = {1u};
    return Check(std::memcmp(b7_payload, expected_b7, sizeof(expected_b7)) == 0, "B7 payload matches");
  }
}

bool TestApplyStateBlockSplitsShaderConstIB() {
  return TestApplyStateBlockSplitsShaderConstIBImpl<
      D3D9DDI_DEVICEFUNCS,
      kD3d9ShaderStagePs,
      static_cast<uint32_t>(AEROGPU_SHADER_STAGE_PIXEL)>();
}

bool TestApplyStateBlockSplitsShaderConstIBVs() {
  return TestApplyStateBlockSplitsShaderConstIBImpl<
      D3D9DDI_DEVICEFUNCS,
      kD3d9ShaderStageVs,
      static_cast<uint32_t>(AEROGPU_SHADER_STAGE_VERTEX)>();
}

template <typename DeviceFuncsT, uint32_t D3dStage>
bool TestApplyStateBlockSkipsRedundantShaderConstIBImpl() {
  if constexpr (!HasPfnSetShaderConstI<DeviceFuncsT>::value ||
                !HasPfnSetShaderConstB<DeviceFuncsT>::value) {
    // Some D3D9 DDI header variants do not expose the I/B constant entrypoints in the device
    // function table. In those builds we cannot exercise the DDI surface area; treat the test as a
    // no-op.
    return true;
  } else {
    struct Cleanup {
      D3D9DDI_ADAPTERFUNCS adapter_funcs{};
      DeviceFuncsT device_funcs{};
      D3DDDI_HADAPTER hAdapter{};
      D3DDDI_HDEVICE hDevice{};
      D3D9DDI_HSTATEBLOCK hStateBlock{};
      bool has_adapter = false;
      bool has_device = false;
      bool has_stateblock = false;
      ~Cleanup() {
        if (has_stateblock && device_funcs.pfnDeleteStateBlock) {
          device_funcs.pfnDeleteStateBlock(hDevice, hStateBlock);
        }
        if (has_device && device_funcs.pfnDestroyDevice) {
          device_funcs.pfnDestroyDevice(hDevice);
        }
        if (has_adapter && adapter_funcs.pfnCloseAdapter) {
          adapter_funcs.pfnCloseAdapter(hAdapter);
        }
      }
    } cleanup;

    D3DDDIARG_OPENADAPTER2 open{};
    open.Interface = 1;
    open.Version = 1;
    D3DDDI_ADAPTERCALLBACKS callbacks{};
    D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
    open.pAdapterCallbacks = &callbacks;
    open.pAdapterCallbacks2 = &callbacks2;
    open.pAdapterFuncs = &cleanup.adapter_funcs;

    HRESULT hr = ::OpenAdapter2(&open);
    if (!Check(hr == S_OK, "OpenAdapter2")) {
      return false;
    }
    cleanup.hAdapter = open.hAdapter;
    cleanup.has_adapter = true;

    D3D9DDIARG_CREATEDEVICE create_dev{};
    create_dev.hAdapter = open.hAdapter;
    create_dev.Flags = 0;
    hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
    if (!Check(hr == S_OK, "CreateDevice")) {
      return false;
    }
    cleanup.hDevice = create_dev.hDevice;
    cleanup.has_device = true;

    if (!cleanup.device_funcs.pfnBeginStateBlock ||
        !cleanup.device_funcs.pfnEndStateBlock ||
        !cleanup.device_funcs.pfnApplyStateBlock ||
        !cleanup.device_funcs.pfnDeleteStateBlock) {
      // Some build configurations may omit state-block entrypoints.
      return true;
    }

    auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
    if (!Check(dev != nullptr, "device pointer")) {
      return false;
    }

    std::vector<uint8_t> dma(4096, 0);
    dev->cmd.set_span(dma.data(), dma.size());
    dev->cmd.reset();
    ScopedDeviceCmdVectorReset cmd_reset(dev);

    hr = cleanup.device_funcs.pfnBeginStateBlock(create_dev.hDevice);
    if (!Check(hr == S_OK, "BeginStateBlock")) {
      return false;
    }

    const uint32_t int_start = 5;
    const uint32_t int_count = 2;
    const int32_t ints[int_count * 4] = {1, 2, 3, 4, 5, 6, 7, 8};
    hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, D3dStage, int_start, ints, int_count);
    if (!Check(hr == S_OK, "SetShaderConstI (record)")) {
      return false;
    }

    const uint32_t bool_start = 7;
    const uint32_t bool_count = 2;
    const BOOL bools[bool_count] = {static_cast<BOOL>(1), static_cast<BOOL>(0)};
    hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, D3dStage, bool_start, bools, bool_count);
    if (!Check(hr == S_OK, "SetShaderConstB (record)")) {
      return false;
    }

    hr = cleanup.device_funcs.pfnEndStateBlock(create_dev.hDevice, &cleanup.hStateBlock);
    if (!Check(hr == S_OK, "EndStateBlock")) {
      return false;
    }
    cleanup.has_stateblock = true;

    // Applying the state block immediately (without changing device state) should be a no-op for
    // shader I/B constants.
    dev->cmd.reset();
    hr = cleanup.device_funcs.pfnApplyStateBlock(create_dev.hDevice, cleanup.hStateBlock);
    if (!Check(hr == S_OK, "ApplyStateBlock")) {
      return false;
    }
    dev->cmd.finalize();
    const uint8_t* buf = dma.data();
    const size_t len = dev->cmd.bytes_used();
    if (!Check(ValidateStream(buf, dma.size()), "command stream validates")) {
      return false;
    }

    if (!Check(CountOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_I) == 0,
               "Redundant ApplyStateBlock does not emit SET_SHADER_CONSTANTS_I")) {
      return false;
    }
    return Check(CountOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_B) == 0,
                 "Redundant ApplyStateBlock does not emit SET_SHADER_CONSTANTS_B");
  }
}

bool TestApplyStateBlockSkipsRedundantShaderConstIB() {
  return TestApplyStateBlockSkipsRedundantShaderConstIBImpl<D3D9DDI_DEVICEFUNCS, kD3d9ShaderStagePs>();
}

bool TestApplyStateBlockSkipsRedundantShaderConstIBVs() {
  return TestApplyStateBlockSkipsRedundantShaderConstIBImpl<D3D9DDI_DEVICEFUNCS, kD3d9ShaderStageVs>();
}

bool TestApplyStateBlockNormalizesShaderConstIBStage() {
  if constexpr (!HasPfnSetShaderConstI<D3D9DDI_DEVICEFUNCS>::value ||
                !HasPfnSetShaderConstB<D3D9DDI_DEVICEFUNCS>::value) {
    // Some D3D9 DDI header variants do not expose the I/B constant entrypoints in the device
    // function table. In those builds we cannot exercise the DDI surface area; treat the test as a
    // no-op.
    return true;
  } else {
    struct Cleanup {
      D3D9DDI_ADAPTERFUNCS adapter_funcs{};
      D3D9DDI_DEVICEFUNCS device_funcs{};
      D3DDDI_HADAPTER hAdapter{};
      D3DDDI_HDEVICE hDevice{};
      D3D9DDI_HSTATEBLOCK hStateBlock{};
      bool has_adapter = false;
      bool has_device = false;
      bool has_stateblock = false;
      ~Cleanup() {
        if (has_stateblock && device_funcs.pfnDeleteStateBlock) {
          device_funcs.pfnDeleteStateBlock(hDevice, hStateBlock);
        }
        if (has_device && device_funcs.pfnDestroyDevice) {
          device_funcs.pfnDestroyDevice(hDevice);
        }
        if (has_adapter && adapter_funcs.pfnCloseAdapter) {
          adapter_funcs.pfnCloseAdapter(hAdapter);
        }
      }
    } cleanup;

    D3DDDIARG_OPENADAPTER2 open{};
    open.Interface = 1;
    open.Version = 1;
    D3DDDI_ADAPTERCALLBACKS callbacks{};
    D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
    open.pAdapterCallbacks = &callbacks;
    open.pAdapterCallbacks2 = &callbacks2;
    open.pAdapterFuncs = &cleanup.adapter_funcs;

    HRESULT hr = ::OpenAdapter2(&open);
    if (!Check(hr == S_OK, "OpenAdapter2")) {
      return false;
    }
    cleanup.hAdapter = open.hAdapter;
    cleanup.has_adapter = true;

    D3D9DDIARG_CREATEDEVICE create_dev{};
    create_dev.hAdapter = open.hAdapter;
    create_dev.Flags = 0;
    hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
    if (!Check(hr == S_OK, "CreateDevice")) {
      return false;
    }
    cleanup.hDevice = create_dev.hDevice;
    cleanup.has_device = true;

    if (!Check(cleanup.device_funcs.pfnBeginStateBlock != nullptr, "BeginStateBlock must be available")) {
      return false;
    }
    if (!Check(cleanup.device_funcs.pfnEndStateBlock != nullptr, "EndStateBlock must be available")) {
      return false;
    }
    if (!Check(cleanup.device_funcs.pfnApplyStateBlock != nullptr, "ApplyStateBlock must be available")) {
      return false;
    }
    if (!Check(cleanup.device_funcs.pfnDeleteStateBlock != nullptr, "DeleteStateBlock must be available")) {
      return false;
    }

    auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
    if (!Check(dev != nullptr, "device pointer")) {
      return false;
    }

    std::vector<uint8_t> dma(4096, 0);
    dev->cmd.set_span(dma.data(), dma.size());
    dev->cmd.reset();
    ScopedDeviceCmdVectorReset cmd_reset(dev);

    // Record constants into a state block using a non-{0,1} stage value. The UMD should treat any
    // non-VS stage as PS (matching its shader binding path).
    constexpr uint32_t kWeirdStage = 42u;
    hr = cleanup.device_funcs.pfnBeginStateBlock(create_dev.hDevice);
    if (!Check(hr == S_OK, "BeginStateBlock")) {
      return false;
    }

    const uint32_t int_start = 5;
    const uint32_t int_count = 1;
    const int32_t ints_a[4] = {1, 2, 3, 4};
    hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, kWeirdStage, int_start, ints_a, int_count);
    if (!Check(hr == S_OK, "SetShaderConstI(weird stage, recorded)")) {
      return false;
    }

    const uint32_t bool_start = 7;
    const uint32_t bool_count = 1;
    const BOOL bools_a[1] = {static_cast<BOOL>(1)};
    hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, kWeirdStage, bool_start, bools_a, bool_count);
    if (!Check(hr == S_OK, "SetShaderConstB(weird stage, recorded)")) {
      return false;
    }

    hr = cleanup.device_funcs.pfnEndStateBlock(create_dev.hDevice, &cleanup.hStateBlock);
    if (!Check(hr == S_OK, "EndStateBlock")) {
      return false;
    }
    if (!Check(cleanup.hStateBlock.pDrvPrivate != nullptr, "EndStateBlock returns stateblock handle")) {
      return false;
    }
    cleanup.has_stateblock = true;

    // Change PS constants so ApplyStateBlock must restore.
    const int32_t ints_b[4] = {-1, -2, -3, -4};
    hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, kD3d9ShaderStagePs, int_start, ints_b, int_count);
    if (!Check(hr == S_OK, "SetShaderConstI(PS, B)")) {
      return false;
    }

    const BOOL bools_b[1] = {static_cast<BOOL>(0)};
    hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, kD3d9ShaderStagePs, bool_start, bools_b, bool_count);
    if (!Check(hr == S_OK, "SetShaderConstB(PS, B)")) {
      return false;
    }

    dev->cmd.reset();
    hr = cleanup.device_funcs.pfnApplyStateBlock(create_dev.hDevice, cleanup.hStateBlock);
    if (!Check(hr == S_OK, "ApplyStateBlock")) {
      return false;
    }

    dev->cmd.finalize();
    const uint8_t* buf = dma.data();
    const size_t len = dev->cmd.bytes_used();
    if (!Check(ValidateStream(buf, dma.size()), "command stream validates")) {
      return false;
    }

    if (!Check(CountOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_I) == 1,
               "ApplyStateBlock emits one SET_SHADER_CONSTANTS_I")) {
      return false;
    }
    if (!Check(CountOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_B) == 1,
               "ApplyStateBlock emits one SET_SHADER_CONSTANTS_B")) {
      return false;
    }

    const CmdLoc i_loc = FindLastOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_I);
    if (!Check(i_loc.hdr != nullptr, "SET_SHADER_CONSTANTS_I emitted")) {
      return false;
    }
    const auto* i_cmd = reinterpret_cast<const aerogpu_cmd_set_shader_constants_i*>(i_loc.hdr);
    if (!Check(i_cmd->stage == AEROGPU_SHADER_STAGE_PIXEL, "I stage normalized to PS")) {
      return false;
    }
    if (!Check(i_cmd->start_register == int_start, "I start_register")) {
      return false;
    }
    if (!Check(i_cmd->vec4_count == int_count, "I vec4_count")) {
      return false;
    }
    const auto* i_payload = reinterpret_cast<const int32_t*>(
        reinterpret_cast<const uint8_t*>(i_cmd) + sizeof(*i_cmd));
    if (!Check(std::memcmp(i_payload, ints_a, sizeof(ints_a)) == 0, "I payload matches recorded")) {
      return false;
    }

    const CmdLoc b_loc = FindLastOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_B);
    if (!Check(b_loc.hdr != nullptr, "SET_SHADER_CONSTANTS_B emitted")) {
      return false;
    }
    const auto* b_cmd = reinterpret_cast<const aerogpu_cmd_set_shader_constants_b*>(b_loc.hdr);
    if (!Check(b_cmd->stage == AEROGPU_SHADER_STAGE_PIXEL, "B stage normalized to PS")) {
      return false;
    }
    if (!Check(b_cmd->start_register == bool_start, "B start_register")) {
      return false;
    }
    if (!Check(b_cmd->bool_count == bool_count, "B bool_count")) {
      return false;
    }
    const auto* b_payload = reinterpret_cast<const uint32_t*>(
        reinterpret_cast<const uint8_t*>(b_cmd) + sizeof(*b_cmd));
    const uint32_t expected_b[bool_count] = {1u};
    return Check(std::memcmp(b_payload, expected_b, sizeof(expected_b)) == 0, "B payload matches recorded");
  }
}

template <typename DeviceFuncsT, uint32_t D3dStage, uint32_t ExpectedStage>
bool TestApplyStateBlockRecordsShaderConstIBImpl() {
  if constexpr (!HasPfnSetShaderConstI<DeviceFuncsT>::value ||
                !HasPfnSetShaderConstB<DeviceFuncsT>::value) {
    // Some D3D9 DDI header variants do not expose the I/B constant entrypoints in the device
    // function table. In those builds we cannot exercise the DDI surface area; treat the test as a
    // no-op.
    return true;
  } else {
    struct Cleanup {
      D3D9DDI_ADAPTERFUNCS adapter_funcs{};
      DeviceFuncsT device_funcs{};
      D3DDDI_HADAPTER hAdapter{};
      D3DDDI_HDEVICE hDevice{};
      D3D9DDI_HSTATEBLOCK sb_src{};
      D3D9DDI_HSTATEBLOCK sb_dst{};
      bool has_adapter = false;
      bool has_device = false;
      bool has_sb_src = false;
      bool has_sb_dst = false;
      ~Cleanup() {
        if (has_sb_dst && device_funcs.pfnDeleteStateBlock) {
          device_funcs.pfnDeleteStateBlock(hDevice, sb_dst);
        }
        if (has_sb_src && device_funcs.pfnDeleteStateBlock) {
          device_funcs.pfnDeleteStateBlock(hDevice, sb_src);
        }
        if (has_device && device_funcs.pfnDestroyDevice) {
          device_funcs.pfnDestroyDevice(hDevice);
        }
        if (has_adapter && adapter_funcs.pfnCloseAdapter) {
          adapter_funcs.pfnCloseAdapter(hAdapter);
        }
      }
    } cleanup;

    D3DDDIARG_OPENADAPTER2 open{};
    open.Interface = 1;
    open.Version = 1;
    D3DDDI_ADAPTERCALLBACKS callbacks{};
    D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
    open.pAdapterCallbacks = &callbacks;
    open.pAdapterCallbacks2 = &callbacks2;
    open.pAdapterFuncs = &cleanup.adapter_funcs;

    HRESULT hr = ::OpenAdapter2(&open);
    if (!Check(hr == S_OK, "OpenAdapter2")) {
      return false;
    }
    cleanup.hAdapter = open.hAdapter;
    cleanup.has_adapter = true;

    D3D9DDIARG_CREATEDEVICE create_dev{};
    create_dev.hAdapter = open.hAdapter;
    create_dev.Flags = 0;
    hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
    if (!Check(hr == S_OK, "CreateDevice")) {
      return false;
    }
    cleanup.hDevice = create_dev.hDevice;
    cleanup.has_device = true;

    if (!Check(cleanup.device_funcs.pfnBeginStateBlock != nullptr, "BeginStateBlock must be available")) {
      return false;
    }
    if (!Check(cleanup.device_funcs.pfnEndStateBlock != nullptr, "EndStateBlock must be available")) {
      return false;
    }
    if (!Check(cleanup.device_funcs.pfnApplyStateBlock != nullptr, "ApplyStateBlock must be available")) {
      return false;
    }
    if (!Check(cleanup.device_funcs.pfnDeleteStateBlock != nullptr, "DeleteStateBlock must be available")) {
      return false;
    }

    auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
    if (!Check(dev != nullptr, "device pointer")) {
      return false;
    }

    std::vector<uint8_t> dma(4096, 0);
    dev->cmd.set_span(dma.data(), dma.size());
    dev->cmd.reset();
    ScopedDeviceCmdVectorReset cmd_reset(dev);

    // Record a source state block with sparse I/B constants.
    hr = cleanup.device_funcs.pfnBeginStateBlock(create_dev.hDevice);
    if (!Check(hr == S_OK, "BeginStateBlock(src)")) {
      return false;
    }

    const uint32_t i0 = 5;
    const uint32_t i1 = 7;
    const int32_t i5_a[4] = {1, 2, 3, 4};
    const int32_t i7_a[4] = {9, 10, 11, 12};
    hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, D3dStage, i0, i5_a, 1);
    if (!Check(hr == S_OK, "SetShaderConstI(i5 A)")) {
      return false;
    }
    hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, D3dStage, i1, i7_a, 1);
    if (!Check(hr == S_OK, "SetShaderConstI(i7 A)")) {
      return false;
    }

    const uint32_t b0 = 7;
    const uint32_t b1 = 9;
    const BOOL b7_a[1] = {static_cast<BOOL>(1)};
    const BOOL b9_a[1] = {static_cast<BOOL>(0)};
    hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, D3dStage, b0, b7_a, 1);
    if (!Check(hr == S_OK, "SetShaderConstB(b7 A)")) {
      return false;
    }
    hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, D3dStage, b1, b9_a, 1);
    if (!Check(hr == S_OK, "SetShaderConstB(b9 A)")) {
      return false;
    }

    hr = cleanup.device_funcs.pfnEndStateBlock(create_dev.hDevice, &cleanup.sb_src);
    if (!Check(hr == S_OK, "EndStateBlock(src)")) {
      return false;
    }
    if (!Check(cleanup.sb_src.pDrvPrivate != nullptr, "EndStateBlock(src) returns handle")) {
      return false;
    }
    cleanup.has_sb_src = true;

    // Record a destination state block while calling ApplyStateBlock(src). The driver must record
    // the applied I/B constants into the active recording block.
    hr = cleanup.device_funcs.pfnBeginStateBlock(create_dev.hDevice);
    if (!Check(hr == S_OK, "BeginStateBlock(dst)")) {
      return false;
    }
    hr = cleanup.device_funcs.pfnApplyStateBlock(create_dev.hDevice, cleanup.sb_src);
    if (!Check(hr == S_OK, "ApplyStateBlock(src while recording dst)")) {
      return false;
    }
    hr = cleanup.device_funcs.pfnEndStateBlock(create_dev.hDevice, &cleanup.sb_dst);
    if (!Check(hr == S_OK, "EndStateBlock(dst)")) {
      return false;
    }
    if (!Check(cleanup.sb_dst.pDrvPrivate != nullptr, "EndStateBlock(dst) returns handle")) {
      return false;
    }
    cleanup.has_sb_dst = true;

    // Overwrite device constants to B so ApplyStateBlock(dst) must restore A values.
    const int32_t i5_b[4] = {-1, -2, -3, -4};
    const int32_t i7_b[4] = {-9, -10, -11, -12};
    hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, D3dStage, i0, i5_b, 1);
    if (!Check(hr == S_OK, "SetShaderConstI(i5 B)")) {
      return false;
    }
    hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, D3dStage, i1, i7_b, 1);
    if (!Check(hr == S_OK, "SetShaderConstI(i7 B)")) {
      return false;
    }

    const BOOL b7_b[1] = {static_cast<BOOL>(0)};
    const BOOL b9_b[1] = {static_cast<BOOL>(1)};
    hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, D3dStage, b0, b7_b, 1);
    if (!Check(hr == S_OK, "SetShaderConstB(b7 B)")) {
      return false;
    }
    hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, D3dStage, b1, b9_b, 1);
    if (!Check(hr == S_OK, "SetShaderConstB(b9 B)")) {
      return false;
    }

    dev->cmd.reset();
    hr = cleanup.device_funcs.pfnApplyStateBlock(create_dev.hDevice, cleanup.sb_dst);
    if (!Check(hr == S_OK, "ApplyStateBlock(dst)")) {
      return false;
    }
    dev->cmd.finalize();
    const uint8_t* buf = dma.data();
    const size_t len = dev->cmd.bytes_used();
    if (!Check(ValidateStream(buf, dma.size()), "command stream validates")) {
      return false;
    }

    if (!Check(CountOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_I) == 2,
               "ApplyStateBlock(dst) splits SET_SHADER_CONSTANTS_I")) {
      return false;
    }
    if (!Check(CountOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_B) == 2,
               "ApplyStateBlock(dst) splits SET_SHADER_CONSTANTS_B")) {
      return false;
    }

    // Validate int packets: i5 then i7.
    const CmdLoc i7_loc = FindLastOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_I);
    if (!Check(i7_loc.hdr != nullptr, "I packet present")) {
      return false;
    }
    const auto* i7_cmd = reinterpret_cast<const aerogpu_cmd_set_shader_constants_i*>(i7_loc.hdr);
    if (!Check(i7_cmd->stage == ExpectedStage, "I stage")) {
      return false;
    }
    if (!Check(i7_cmd->start_register == i1, "I7 start_register")) {
      return false;
    }
    if (!Check(i7_cmd->vec4_count == 1, "I7 vec4_count")) {
      return false;
    }
    const auto* i7_payload =
        reinterpret_cast<const int32_t*>(reinterpret_cast<const uint8_t*>(i7_cmd) + sizeof(*i7_cmd));
    if (!Check(std::memcmp(i7_payload, i7_a, sizeof(i7_a)) == 0, "I7 payload matches A")) {
      return false;
    }

    const CmdLoc i5_loc = FindLastOpcodeBefore(buf, len, i7_loc.offset, AEROGPU_CMD_SET_SHADER_CONSTANTS_I);
    if (!Check(i5_loc.hdr != nullptr, "I5 packet present")) {
      return false;
    }
    const auto* i5_cmd = reinterpret_cast<const aerogpu_cmd_set_shader_constants_i*>(i5_loc.hdr);
    if (!Check(i5_cmd->stage == ExpectedStage, "I5 stage")) {
      return false;
    }
    if (!Check(i5_cmd->start_register == i0, "I5 start_register")) {
      return false;
    }
    if (!Check(i5_cmd->vec4_count == 1, "I5 vec4_count")) {
      return false;
    }
    const auto* i5_payload =
        reinterpret_cast<const int32_t*>(reinterpret_cast<const uint8_t*>(i5_cmd) + sizeof(*i5_cmd));
    if (!Check(std::memcmp(i5_payload, i5_a, sizeof(i5_a)) == 0, "I5 payload matches A")) {
      return false;
    }

    // Validate bool packets: b7=true then b9=false.
    const CmdLoc b9_loc = FindLastOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_B);
    if (!Check(b9_loc.hdr != nullptr, "B packet present")) {
      return false;
    }
    const auto* b9_cmd = reinterpret_cast<const aerogpu_cmd_set_shader_constants_b*>(b9_loc.hdr);
    if (!Check(b9_cmd->stage == ExpectedStage, "B stage")) {
      return false;
    }
    if (!Check(b9_cmd->start_register == b1, "B9 start_register")) {
      return false;
    }
    if (!Check(b9_cmd->bool_count == 1, "B9 bool_count")) {
      return false;
    }
    const auto* b9_payload =
        reinterpret_cast<const uint32_t*>(reinterpret_cast<const uint8_t*>(b9_cmd) + sizeof(*b9_cmd));
    const uint32_t expected_b9[1] = {0u};
    if (!Check(std::memcmp(b9_payload, expected_b9, sizeof(expected_b9)) == 0, "B9 payload matches A")) {
      return false;
    }

    const CmdLoc b7_loc = FindLastOpcodeBefore(buf, len, b9_loc.offset, AEROGPU_CMD_SET_SHADER_CONSTANTS_B);
    if (!Check(b7_loc.hdr != nullptr, "B7 packet present")) {
      return false;
    }
    const auto* b7_cmd = reinterpret_cast<const aerogpu_cmd_set_shader_constants_b*>(b7_loc.hdr);
    if (!Check(b7_cmd->stage == ExpectedStage, "B7 stage")) {
      return false;
    }
    if (!Check(b7_cmd->start_register == b0, "B7 start_register")) {
      return false;
    }
    if (!Check(b7_cmd->bool_count == 1, "B7 bool_count")) {
      return false;
    }
    const auto* b7_payload =
        reinterpret_cast<const uint32_t*>(reinterpret_cast<const uint8_t*>(b7_cmd) + sizeof(*b7_cmd));
    const uint32_t expected_b7[1] = {1u};
    return Check(std::memcmp(b7_payload, expected_b7, sizeof(expected_b7)) == 0, "B7 payload matches A");
  }
}

bool TestApplyStateBlockRecordsShaderConstIB() {
  return TestApplyStateBlockRecordsShaderConstIBImpl<
      D3D9DDI_DEVICEFUNCS,
      kD3d9ShaderStagePs,
      static_cast<uint32_t>(AEROGPU_SHADER_STAGE_PIXEL)>();
}

bool TestApplyStateBlockRecordsShaderConstIBVs() {
  return TestApplyStateBlockRecordsShaderConstIBImpl<
      D3D9DDI_DEVICEFUNCS,
      kD3d9ShaderStageVs,
      static_cast<uint32_t>(AEROGPU_SHADER_STAGE_VERTEX)>();
}

template <typename DeviceFuncsT, uint32_t CreateType, uint32_t D3dStage, uint32_t ExpectedStage>
bool TestCaptureStateBlockUpdatesCreateStateBlockShaderConstIBImpl() {
  if constexpr (!HasPfnSetShaderConstI<DeviceFuncsT>::value ||
                !HasPfnSetShaderConstB<DeviceFuncsT>::value ||
                !HasPfnCreateStateBlock<DeviceFuncsT>::value ||
                !HasPfnCaptureStateBlock<DeviceFuncsT>::value) {
    // Some D3D9 DDI header variants do not expose the I/B constant entrypoints (or Create/CaptureStateBlock)
    // in the device function table. In those builds we cannot exercise the DDI surface area; treat
    // the test as a no-op.
    return true;
  } else {
    struct Cleanup {
      D3D9DDI_ADAPTERFUNCS adapter_funcs{};
      DeviceFuncsT device_funcs{};
      D3DDDI_HADAPTER hAdapter{};
      D3DDDI_HDEVICE hDevice{};
      D3D9DDI_HSTATEBLOCK hStateBlock{};
      bool has_adapter = false;
      bool has_device = false;
      bool has_stateblock = false;
      ~Cleanup() {
        if (has_stateblock && device_funcs.pfnDeleteStateBlock) {
          device_funcs.pfnDeleteStateBlock(hDevice, hStateBlock);
        }
        if (has_device && device_funcs.pfnDestroyDevice) {
          device_funcs.pfnDestroyDevice(hDevice);
        }
        if (has_adapter && adapter_funcs.pfnCloseAdapter) {
          adapter_funcs.pfnCloseAdapter(hAdapter);
        }
      }
    } cleanup;

    D3DDDIARG_OPENADAPTER2 open{};
    open.Interface = 1;
    open.Version = 1;
    D3DDDI_ADAPTERCALLBACKS callbacks{};
    D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
    open.pAdapterCallbacks = &callbacks;
    open.pAdapterCallbacks2 = &callbacks2;
    open.pAdapterFuncs = &cleanup.adapter_funcs;

    HRESULT hr = ::OpenAdapter2(&open);
    if (!Check(hr == S_OK, "OpenAdapter2")) {
      return false;
    }
    cleanup.hAdapter = open.hAdapter;
    cleanup.has_adapter = true;

    D3D9DDIARG_CREATEDEVICE create_dev{};
    create_dev.hAdapter = open.hAdapter;
    create_dev.Flags = 0;
    hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
    if (!Check(hr == S_OK, "CreateDevice")) {
      return false;
    }
    cleanup.hDevice = create_dev.hDevice;
    cleanup.has_device = true;

    if (!Check(cleanup.device_funcs.pfnCreateStateBlock != nullptr, "CreateStateBlock must be available")) {
      return false;
    }
    if (!Check(cleanup.device_funcs.pfnCaptureStateBlock != nullptr, "CaptureStateBlock must be available")) {
      return false;
    }
    if (!Check(cleanup.device_funcs.pfnApplyStateBlock != nullptr, "ApplyStateBlock must be available")) {
      return false;
    }
    if (!Check(cleanup.device_funcs.pfnDeleteStateBlock != nullptr, "DeleteStateBlock must be available")) {
      return false;
    }

    auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
    if (!Check(dev != nullptr, "device pointer")) {
      return false;
    }

    std::vector<uint8_t> dma(128 * 1024, 0);
    dev->cmd.set_span(dma.data(), dma.size());
    dev->cmd.reset();
    ScopedDeviceCmdVectorReset cmd_reset(dev);

    // Set constants to A and create a typed state block.
    const uint32_t int_start = 5;
    const uint32_t int_count = 2;
    const int32_t ints_a[int_count * 4] = {1, 2, 3, 4, 5, 6, 7, 8};
    hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, D3dStage, int_start, ints_a, int_count);
    if (!Check(hr == S_OK, "SetShaderConstI (A)")) {
      return false;
    }

    const uint32_t bool_start = 7;
    const uint32_t bool_count = 2;
    const BOOL bools_a[bool_count] = {static_cast<BOOL>(1), static_cast<BOOL>(0)};
    hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, D3dStage, bool_start, bools_a, bool_count);
    if (!Check(hr == S_OK, "SetShaderConstB (A)")) {
      return false;
    }

    hr = CallCreateStateBlock(&cleanup.device_funcs, create_dev.hDevice, CreateType, &cleanup.hStateBlock);
    if (!Check(hr == S_OK, "CreateStateBlock")) {
      return false;
    }
    if (!Check(cleanup.hStateBlock.pDrvPrivate != nullptr, "CreateStateBlock returns stateblock handle")) {
      return false;
    }
    cleanup.has_stateblock = true;

    // Modify device constants to B and capture into the state block so it stores B.
    const int32_t ints_b[int_count * 4] = {-1, -2, -3, -4, -5, -6, -7, -8};
    hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, D3dStage, int_start, ints_b, int_count);
    if (!Check(hr == S_OK, "SetShaderConstI (B)")) {
      return false;
    }
    const BOOL bools_b[bool_count] = {static_cast<BOOL>(0), static_cast<BOOL>(1)};
    hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, D3dStage, bool_start, bools_b, bool_count);
    if (!Check(hr == S_OK, "SetShaderConstB (B)")) {
      return false;
    }

    hr = cleanup.device_funcs.pfnCaptureStateBlock(create_dev.hDevice, cleanup.hStateBlock);
    if (!Check(hr == S_OK, "CaptureStateBlock")) {
      return false;
    }

    // Overwrite device constants to C so ApplyStateBlock must restore the captured B values.
    const int32_t ints_c[int_count * 4] = {9, 10, 11, 12, 13, 14, 15, 16};
    hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, D3dStage, int_start, ints_c, int_count);
    if (!Check(hr == S_OK, "SetShaderConstI (C)")) {
      return false;
    }
    const BOOL bools_c[bool_count] = {static_cast<BOOL>(1), static_cast<BOOL>(1)};
    hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, D3dStage, bool_start, bools_c, bool_count);
    if (!Check(hr == S_OK, "SetShaderConstB (C)")) {
      return false;
    }

    dev->cmd.reset();
    hr = cleanup.device_funcs.pfnApplyStateBlock(create_dev.hDevice, cleanup.hStateBlock);
    if (!Check(hr == S_OK, "ApplyStateBlock")) {
      return false;
    }
    dev->cmd.finalize();
    const uint8_t* buf = dma.data();
    const size_t len = dev->cmd.bytes_used();
    if (!Check(ValidateStream(buf, dma.size()), "command stream validates")) {
      return false;
    }

    if (!Check(CountOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_I) == 1,
               "Capture(CreateStateBlock)+Apply emits one SET_SHADER_CONSTANTS_I")) {
      return false;
    }
    if (!Check(CountOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_B) == 1,
               "Capture(CreateStateBlock)+Apply emits one SET_SHADER_CONSTANTS_B")) {
      return false;
    }

    const CmdLoc i_loc = FindLastOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_I);
    if (!Check(i_loc.hdr != nullptr, "SET_SHADER_CONSTANTS_I emitted")) {
      return false;
    }
    const auto* i_cmd = reinterpret_cast<const aerogpu_cmd_set_shader_constants_i*>(i_loc.hdr);
    if (!Check(i_cmd->stage == ExpectedStage, "I stage")) {
      return false;
    }
    if (!Check(i_cmd->start_register == 0, "I start_register == 0 (full file)")) {
      return false;
    }
    if (!Check(i_cmd->vec4_count == 256, "I vec4_count == 256 (full file)")) {
      return false;
    }
    if (!Check(i_cmd->hdr.size_bytes >= sizeof(*i_cmd) + (256u * 4u * sizeof(int32_t)), "I payload present")) {
      return false;
    }
    const auto* i_payload =
        reinterpret_cast<const int32_t*>(reinterpret_cast<const uint8_t*>(i_cmd) + sizeof(*i_cmd));
    const size_t i_base = static_cast<size_t>(int_start) * 4;
    if (!Check(std::memcmp(i_payload + i_base, ints_b, sizeof(ints_b)) == 0, "I payload matches captured B")) {
      return false;
    }

    const CmdLoc b_loc = FindLastOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_B);
    if (!Check(b_loc.hdr != nullptr, "SET_SHADER_CONSTANTS_B emitted")) {
      return false;
    }
    const auto* b_cmd = reinterpret_cast<const aerogpu_cmd_set_shader_constants_b*>(b_loc.hdr);
    if (!Check(b_cmd->stage == ExpectedStage, "B stage")) {
      return false;
    }
    if (!Check(b_cmd->start_register == 0, "B start_register == 0 (full file)")) {
      return false;
    }
    if (!Check(b_cmd->bool_count == 256, "B bool_count == 256 (full file)")) {
      return false;
    }
    if (!Check(b_cmd->hdr.size_bytes >= sizeof(*b_cmd) + (256u * sizeof(uint32_t)), "B payload present")) {
      return false;
    }
    const auto* b_payload =
        reinterpret_cast<const uint32_t*>(reinterpret_cast<const uint8_t*>(b_cmd) + sizeof(*b_cmd));
    const size_t b_base = static_cast<size_t>(bool_start);
    const uint32_t expected_b[bool_count] = {0u, 1u};
    return Check(std::memcmp(b_payload + b_base, expected_b, sizeof(expected_b)) == 0, "B payload matches captured B");
  }
}

bool TestCaptureStateBlockUpdatesCreateStateBlockShaderConstIB() {
  constexpr uint32_t kD3dSbtPixelState = 2u; // D3DSBT_PIXELSTATE
  return TestCaptureStateBlockUpdatesCreateStateBlockShaderConstIBImpl<
      D3D9DDI_DEVICEFUNCS,
      kD3dSbtPixelState,
      kD3d9ShaderStagePs,
      static_cast<uint32_t>(AEROGPU_SHADER_STAGE_PIXEL)>();
}

bool TestCaptureStateBlockUpdatesCreateStateBlockShaderConstIBVs() {
  constexpr uint32_t kD3dSbtVertexState = 3u; // D3DSBT_VERTEXSTATE
  return TestCaptureStateBlockUpdatesCreateStateBlockShaderConstIBImpl<
      D3D9DDI_DEVICEFUNCS,
      kD3dSbtVertexState,
      kD3d9ShaderStageVs,
      static_cast<uint32_t>(AEROGPU_SHADER_STAGE_VERTEX)>();
}

template <typename DeviceFuncsT>
bool TestCaptureStateBlockUpdatesCreateStateBlockAllShaderConstIBImpl() {
  if constexpr (!HasPfnSetShaderConstI<DeviceFuncsT>::value ||
                !HasPfnSetShaderConstB<DeviceFuncsT>::value ||
                !HasPfnCreateStateBlock<DeviceFuncsT>::value ||
                !HasPfnCaptureStateBlock<DeviceFuncsT>::value) {
    return true;
  } else {
    struct Cleanup {
      D3D9DDI_ADAPTERFUNCS adapter_funcs{};
      DeviceFuncsT device_funcs{};
      D3DDDI_HADAPTER hAdapter{};
      D3DDDI_HDEVICE hDevice{};
      D3D9DDI_HSTATEBLOCK hStateBlock{};
      bool has_adapter = false;
      bool has_device = false;
      bool has_stateblock = false;
      ~Cleanup() {
        if (has_stateblock && device_funcs.pfnDeleteStateBlock) {
          device_funcs.pfnDeleteStateBlock(hDevice, hStateBlock);
        }
        if (has_device && device_funcs.pfnDestroyDevice) {
          device_funcs.pfnDestroyDevice(hDevice);
        }
        if (has_adapter && adapter_funcs.pfnCloseAdapter) {
          adapter_funcs.pfnCloseAdapter(hAdapter);
        }
      }
    } cleanup;

    D3DDDIARG_OPENADAPTER2 open{};
    open.Interface = 1;
    open.Version = 1;
    D3DDDI_ADAPTERCALLBACKS callbacks{};
    D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
    open.pAdapterCallbacks = &callbacks;
    open.pAdapterCallbacks2 = &callbacks2;
    open.pAdapterFuncs = &cleanup.adapter_funcs;

    HRESULT hr = ::OpenAdapter2(&open);
    if (!Check(hr == S_OK, "OpenAdapter2")) {
      return false;
    }
    cleanup.hAdapter = open.hAdapter;
    cleanup.has_adapter = true;

    D3D9DDIARG_CREATEDEVICE create_dev{};
    create_dev.hAdapter = open.hAdapter;
    create_dev.Flags = 0;
    hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
    if (!Check(hr == S_OK, "CreateDevice")) {
      return false;
    }
    cleanup.hDevice = create_dev.hDevice;
    cleanup.has_device = true;

    if (!Check(cleanup.device_funcs.pfnCreateStateBlock != nullptr, "CreateStateBlock must be available")) {
      return false;
    }
    if (!Check(cleanup.device_funcs.pfnCaptureStateBlock != nullptr, "CaptureStateBlock must be available")) {
      return false;
    }
    if (!Check(cleanup.device_funcs.pfnApplyStateBlock != nullptr, "ApplyStateBlock must be available")) {
      return false;
    }
    if (!Check(cleanup.device_funcs.pfnDeleteStateBlock != nullptr, "DeleteStateBlock must be available")) {
      return false;
    }

    auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
    if (!Check(dev != nullptr, "device pointer")) {
      return false;
    }

    std::vector<uint8_t> dma(128 * 1024, 0);
    dev->cmd.set_span(dma.data(), dma.size());
    dev->cmd.reset();
    ScopedDeviceCmdVectorReset cmd_reset(dev);

    const uint32_t int_start = 5;
    const uint32_t int_count = 2;
    const uint32_t bool_start = 7;
    const uint32_t bool_count = 2;

    // Set per-stage constants to A and create D3DSBT_ALL stateblock.
    const int32_t vs_ints_a[int_count * 4] = {1, 2, 3, 4, 5, 6, 7, 8};
    const int32_t ps_ints_a[int_count * 4] = {11, 12, 13, 14, 15, 16, 17, 18};
    const BOOL vs_bools_a[bool_count] = {static_cast<BOOL>(1), static_cast<BOOL>(0)};
    const BOOL ps_bools_a[bool_count] = {static_cast<BOOL>(0), static_cast<BOOL>(1)};

    hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, kD3d9ShaderStageVs, int_start, vs_ints_a, int_count);
    if (!Check(hr == S_OK, "SetShaderConstI(VS, A)")) {
      return false;
    }
    hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, kD3d9ShaderStagePs, int_start, ps_ints_a, int_count);
    if (!Check(hr == S_OK, "SetShaderConstI(PS, A)")) {
      return false;
    }
    hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, kD3d9ShaderStageVs, bool_start, vs_bools_a, bool_count);
    if (!Check(hr == S_OK, "SetShaderConstB(VS, A)")) {
      return false;
    }
    hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, kD3d9ShaderStagePs, bool_start, ps_bools_a, bool_count);
    if (!Check(hr == S_OK, "SetShaderConstB(PS, A)")) {
      return false;
    }

    constexpr uint32_t kD3dSbtAll = 1u; // D3DSBT_ALL
    hr = CallCreateStateBlock(&cleanup.device_funcs, create_dev.hDevice, kD3dSbtAll, &cleanup.hStateBlock);
    if (!Check(hr == S_OK, "CreateStateBlock(ALL)")) {
      return false;
    }
    if (!Check(cleanup.hStateBlock.pDrvPrivate != nullptr, "CreateStateBlock returns stateblock handle")) {
      return false;
    }
    cleanup.has_stateblock = true;

    // Update device constants to B and capture.
    const int32_t vs_ints_b[int_count * 4] = {-1, -2, -3, -4, -5, -6, -7, -8};
    const int32_t ps_ints_b[int_count * 4] = {-11, -12, -13, -14, -15, -16, -17, -18};
    const BOOL vs_bools_b[bool_count] = {static_cast<BOOL>(0), static_cast<BOOL>(1)};
    const BOOL ps_bools_b[bool_count] = {static_cast<BOOL>(1), static_cast<BOOL>(0)};

    hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, kD3d9ShaderStageVs, int_start, vs_ints_b, int_count);
    if (!Check(hr == S_OK, "SetShaderConstI(VS, B)")) {
      return false;
    }
    hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, kD3d9ShaderStagePs, int_start, ps_ints_b, int_count);
    if (!Check(hr == S_OK, "SetShaderConstI(PS, B)")) {
      return false;
    }
    hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, kD3d9ShaderStageVs, bool_start, vs_bools_b, bool_count);
    if (!Check(hr == S_OK, "SetShaderConstB(VS, B)")) {
      return false;
    }
    hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, kD3d9ShaderStagePs, bool_start, ps_bools_b, bool_count);
    if (!Check(hr == S_OK, "SetShaderConstB(PS, B)")) {
      return false;
    }

    hr = cleanup.device_funcs.pfnCaptureStateBlock(create_dev.hDevice, cleanup.hStateBlock);
    if (!Check(hr == S_OK, "CaptureStateBlock(ALL)")) {
      return false;
    }

    // Overwrite device constants to C so apply must restore captured B values.
    const int32_t vs_ints_c[int_count * 4] = {101, 102, 103, 104, 105, 106, 107, 108};
    const int32_t ps_ints_c[int_count * 4] = {201, 202, 203, 204, 205, 206, 207, 208};
    const BOOL vs_bools_c[bool_count] = {static_cast<BOOL>(1), static_cast<BOOL>(1)};
    const BOOL ps_bools_c[bool_count] = {static_cast<BOOL>(1), static_cast<BOOL>(1)};

    hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, kD3d9ShaderStageVs, int_start, vs_ints_c, int_count);
    if (!Check(hr == S_OK, "SetShaderConstI(VS, C)")) {
      return false;
    }
    hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, kD3d9ShaderStagePs, int_start, ps_ints_c, int_count);
    if (!Check(hr == S_OK, "SetShaderConstI(PS, C)")) {
      return false;
    }
    hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, kD3d9ShaderStageVs, bool_start, vs_bools_c, bool_count);
    if (!Check(hr == S_OK, "SetShaderConstB(VS, C)")) {
      return false;
    }
    hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, kD3d9ShaderStagePs, bool_start, ps_bools_c, bool_count);
    if (!Check(hr == S_OK, "SetShaderConstB(PS, C)")) {
      return false;
    }

    dev->cmd.reset();
    hr = cleanup.device_funcs.pfnApplyStateBlock(create_dev.hDevice, cleanup.hStateBlock);
    if (!Check(hr == S_OK, "ApplyStateBlock(ALL)")) {
      return false;
    }
    dev->cmd.finalize();
    const uint8_t* buf = dma.data();
    const size_t len = dev->cmd.bytes_used();
    if (!Check(ValidateStream(buf, dma.size()), "command stream validates")) {
      return false;
    }

    if (!Check(CountOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_I) == 2,
               "Capture(CreateStateBlock ALL)+Apply emits two SET_SHADER_CONSTANTS_I")) {
      return false;
    }
    if (!Check(CountOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_B) == 2,
               "Capture(CreateStateBlock ALL)+Apply emits two SET_SHADER_CONSTANTS_B")) {
      return false;
    }

    // Validate int packets: VS then PS (both full-file, but subrange matches captured B).
    const CmdLoc ps_i_loc = FindLastOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_I);
    if (!Check(ps_i_loc.hdr != nullptr, "PS I packet present")) {
      return false;
    }
    const auto* ps_i_cmd = reinterpret_cast<const aerogpu_cmd_set_shader_constants_i*>(ps_i_loc.hdr);
    if (!Check(ps_i_cmd->stage == static_cast<uint32_t>(AEROGPU_SHADER_STAGE_PIXEL), "PS I stage")) {
      return false;
    }
    if (!Check(ps_i_cmd->start_register == 0 && ps_i_cmd->vec4_count == 256, "PS I covers full file")) {
      return false;
    }
    const auto* ps_i_payload =
        reinterpret_cast<const int32_t*>(reinterpret_cast<const uint8_t*>(ps_i_cmd) + sizeof(*ps_i_cmd));
    const size_t i_base = static_cast<size_t>(int_start) * 4;
    if (!Check(std::memcmp(ps_i_payload + i_base, ps_ints_b, sizeof(ps_ints_b)) == 0, "PS I payload matches captured B")) {
      return false;
    }

    const CmdLoc vs_i_loc = FindLastOpcodeBefore(buf, len, ps_i_loc.offset, AEROGPU_CMD_SET_SHADER_CONSTANTS_I);
    if (!Check(vs_i_loc.hdr != nullptr, "VS I packet present")) {
      return false;
    }
    const auto* vs_i_cmd = reinterpret_cast<const aerogpu_cmd_set_shader_constants_i*>(vs_i_loc.hdr);
    if (!Check(vs_i_cmd->stage == static_cast<uint32_t>(AEROGPU_SHADER_STAGE_VERTEX), "VS I stage")) {
      return false;
    }
    if (!Check(vs_i_cmd->start_register == 0 && vs_i_cmd->vec4_count == 256, "VS I covers full file")) {
      return false;
    }
    const auto* vs_i_payload =
        reinterpret_cast<const int32_t*>(reinterpret_cast<const uint8_t*>(vs_i_cmd) + sizeof(*vs_i_cmd));
    if (!Check(std::memcmp(vs_i_payload + i_base, vs_ints_b, sizeof(vs_ints_b)) == 0, "VS I payload matches captured B")) {
      return false;
    }

    // Validate bool packets: VS then PS.
    const CmdLoc ps_b_loc = FindLastOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_B);
    if (!Check(ps_b_loc.hdr != nullptr, "PS B packet present")) {
      return false;
    }
    const auto* ps_b_cmd = reinterpret_cast<const aerogpu_cmd_set_shader_constants_b*>(ps_b_loc.hdr);
    if (!Check(ps_b_cmd->stage == static_cast<uint32_t>(AEROGPU_SHADER_STAGE_PIXEL), "PS B stage")) {
      return false;
    }
    if (!Check(ps_b_cmd->start_register == 0 && ps_b_cmd->bool_count == 256, "PS B covers full file")) {
      return false;
    }
    const auto* ps_b_payload =
        reinterpret_cast<const uint32_t*>(reinterpret_cast<const uint8_t*>(ps_b_cmd) + sizeof(*ps_b_cmd));
    const size_t b_base = static_cast<size_t>(bool_start);
    const uint32_t expected_ps_b[bool_count] = {1u, 0u};
    if (!Check(std::memcmp(ps_b_payload + b_base, expected_ps_b, sizeof(expected_ps_b)) == 0, "PS B payload matches captured B")) {
      return false;
    }

    const CmdLoc vs_b_loc = FindLastOpcodeBefore(buf, len, ps_b_loc.offset, AEROGPU_CMD_SET_SHADER_CONSTANTS_B);
    if (!Check(vs_b_loc.hdr != nullptr, "VS B packet present")) {
      return false;
    }
    const auto* vs_b_cmd = reinterpret_cast<const aerogpu_cmd_set_shader_constants_b*>(vs_b_loc.hdr);
    if (!Check(vs_b_cmd->stage == static_cast<uint32_t>(AEROGPU_SHADER_STAGE_VERTEX), "VS B stage")) {
      return false;
    }
    if (!Check(vs_b_cmd->start_register == 0 && vs_b_cmd->bool_count == 256, "VS B covers full file")) {
      return false;
    }
    const auto* vs_b_payload =
        reinterpret_cast<const uint32_t*>(reinterpret_cast<const uint8_t*>(vs_b_cmd) + sizeof(*vs_b_cmd));
    const uint32_t expected_vs_b[bool_count] = {0u, 1u};
    return Check(std::memcmp(vs_b_payload + b_base, expected_vs_b, sizeof(expected_vs_b)) == 0, "VS B payload matches captured B");
  }
}

bool TestCaptureStateBlockUpdatesCreateStateBlockAllShaderConstIB() {
  return TestCaptureStateBlockUpdatesCreateStateBlockAllShaderConstIBImpl<D3D9DDI_DEVICEFUNCS>();
}

bool TestCreateStateBlockUnknownTypeTreatsAsAllShaderConstIB() {
  if constexpr (!HasPfnSetShaderConstI<D3D9DDI_DEVICEFUNCS>::value ||
                !HasPfnSetShaderConstB<D3D9DDI_DEVICEFUNCS>::value ||
                !HasPfnCreateStateBlock<D3D9DDI_DEVICEFUNCS>::value) {
    // Some D3D9 DDI header variants do not expose the I/B constant entrypoints (or CreateStateBlock)
    // in the device function table. In those builds we cannot exercise the DDI surface area; treat
    // the test as a no-op.
    return true;
  } else {
    struct Cleanup {
      D3D9DDI_ADAPTERFUNCS adapter_funcs{};
      D3D9DDI_DEVICEFUNCS device_funcs{};
      D3DDDI_HADAPTER hAdapter{};
      D3DDDI_HDEVICE hDevice{};
      bool has_adapter = false;
      bool has_device = false;
      ~Cleanup() {
        if (has_device && device_funcs.pfnDestroyDevice) {
          device_funcs.pfnDestroyDevice(hDevice);
        }
        if (has_adapter && adapter_funcs.pfnCloseAdapter) {
          adapter_funcs.pfnCloseAdapter(hAdapter);
        }
      }
    } cleanup;

    D3DDDIARG_OPENADAPTER2 open{};
    open.Interface = 1;
    open.Version = 1;
    D3DDDI_ADAPTERCALLBACKS callbacks{};
    D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
    open.pAdapterCallbacks = &callbacks;
    open.pAdapterCallbacks2 = &callbacks2;
    open.pAdapterFuncs = &cleanup.adapter_funcs;

    HRESULT hr = ::OpenAdapter2(&open);
    if (!Check(hr == S_OK, "OpenAdapter2")) {
      return false;
    }
    cleanup.hAdapter = open.hAdapter;
    cleanup.has_adapter = true;

    D3D9DDIARG_CREATEDEVICE create_dev{};
    create_dev.hAdapter = open.hAdapter;
    create_dev.Flags = 0;
    hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
    if (!Check(hr == S_OK, "CreateDevice")) {
      return false;
    }
    cleanup.hDevice = create_dev.hDevice;
    cleanup.has_device = true;

    if (!Check(cleanup.device_funcs.pfnCreateStateBlock != nullptr, "CreateStateBlock must be available")) {
      return false;
    }
    if (!Check(cleanup.device_funcs.pfnApplyStateBlock != nullptr, "ApplyStateBlock must be available")) {
      return false;
    }
    if (!Check(cleanup.device_funcs.pfnDeleteStateBlock != nullptr, "DeleteStateBlock must be available")) {
      return false;
    }

    auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
    if (!Check(dev != nullptr, "device pointer")) {
      return false;
    }

    std::vector<uint8_t> dma(128 * 1024, 0);
    dev->cmd.set_span(dma.data(), dma.size());
    dev->cmd.reset();
    ScopedDeviceCmdVectorReset cmd_reset(dev);

    const uint32_t int_start = 5;
    const uint32_t int_count = 2;
    const uint32_t bool_start = 7;
    const uint32_t bool_count = 2;

    // Use distinct VS vs PS constants so stage mixups are caught.
    const int32_t vs_ints_a[int_count * 4] = {1, 2, 3, 4, 5, 6, 7, 8};
    const int32_t ps_ints_a[int_count * 4] = {11, 12, 13, 14, 15, 16, 17, 18};
    const BOOL vs_bools_a[bool_count] = {static_cast<BOOL>(1), static_cast<BOOL>(0)};
    const BOOL ps_bools_a[bool_count] = {static_cast<BOOL>(0), static_cast<BOOL>(1)};

    const int32_t vs_ints_b[int_count * 4] = {-1, -2, -3, -4, -5, -6, -7, -8};
    const int32_t ps_ints_b[int_count * 4] = {-11, -12, -13, -14, -15, -16, -17, -18};
    const BOOL vs_bools_b[bool_count] = {static_cast<BOOL>(0), static_cast<BOOL>(1)};
    const BOOL ps_bools_b[bool_count] = {static_cast<BOOL>(1), static_cast<BOOL>(0)};

    const uint32_t create_types[] = {0u, 0xFFFFFFFFu};
    for (uint32_t create_type : create_types) {
      // Set constants to A, then create the state block with an unusual type value that should be treated as ALL.
      hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, kD3d9ShaderStageVs, int_start, vs_ints_a, int_count);
      if (!Check(hr == S_OK, "SetShaderConstI(VS, A)")) {
        return false;
      }
      hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, kD3d9ShaderStagePs, int_start, ps_ints_a, int_count);
      if (!Check(hr == S_OK, "SetShaderConstI(PS, A)")) {
        return false;
      }
      hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, kD3d9ShaderStageVs, bool_start, vs_bools_a, bool_count);
      if (!Check(hr == S_OK, "SetShaderConstB(VS, A)")) {
        return false;
      }
      hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, kD3d9ShaderStagePs, bool_start, ps_bools_a, bool_count);
      if (!Check(hr == S_OK, "SetShaderConstB(PS, A)")) {
        return false;
      }

      D3D9DDI_HSTATEBLOCK sb{};
      hr = CallCreateStateBlock(&cleanup.device_funcs, create_dev.hDevice, create_type, &sb);
      if (!Check(hr == S_OK, "CreateStateBlock(unusual type)")) {
        return false;
      }
      if (!Check(sb.pDrvPrivate != nullptr, "CreateStateBlock returned stateblock handle")) {
        cleanup.device_funcs.pfnDeleteStateBlock(create_dev.hDevice, sb);
        return false;
      }

      // Change constants to B so ApplyStateBlock must restore A from the snapshot.
      hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, kD3d9ShaderStageVs, int_start, vs_ints_b, int_count);
      if (!Check(hr == S_OK, "SetShaderConstI(VS, B)")) {
        cleanup.device_funcs.pfnDeleteStateBlock(create_dev.hDevice, sb);
        return false;
      }
      hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, kD3d9ShaderStagePs, int_start, ps_ints_b, int_count);
      if (!Check(hr == S_OK, "SetShaderConstI(PS, B)")) {
        cleanup.device_funcs.pfnDeleteStateBlock(create_dev.hDevice, sb);
        return false;
      }
      hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, kD3d9ShaderStageVs, bool_start, vs_bools_b, bool_count);
      if (!Check(hr == S_OK, "SetShaderConstB(VS, B)")) {
        cleanup.device_funcs.pfnDeleteStateBlock(create_dev.hDevice, sb);
        return false;
      }
      hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, kD3d9ShaderStagePs, bool_start, ps_bools_b, bool_count);
      if (!Check(hr == S_OK, "SetShaderConstB(PS, B)")) {
        cleanup.device_funcs.pfnDeleteStateBlock(create_dev.hDevice, sb);
        return false;
      }

      dev->cmd.reset();
      hr = cleanup.device_funcs.pfnApplyStateBlock(create_dev.hDevice, sb);
      if (!Check(hr == S_OK, "ApplyStateBlock")) {
        cleanup.device_funcs.pfnDeleteStateBlock(create_dev.hDevice, sb);
        return false;
      }
      dev->cmd.finalize();
      const uint8_t* buf = dma.data();
      const size_t len = dev->cmd.bytes_used();
      if (!Check(ValidateStream(buf, dma.size()), "command stream validates")) {
        cleanup.device_funcs.pfnDeleteStateBlock(create_dev.hDevice, sb);
        return false;
      }

      if (!Check(CountOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_I) == 2,
                 "CreateStateBlock(unusual type) treated as ALL: emits two SET_SHADER_CONSTANTS_I")) {
        cleanup.device_funcs.pfnDeleteStateBlock(create_dev.hDevice, sb);
        return false;
      }
      if (!Check(CountOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_B) == 2,
                 "CreateStateBlock(unusual type) treated as ALL: emits two SET_SHADER_CONSTANTS_B")) {
        cleanup.device_funcs.pfnDeleteStateBlock(create_dev.hDevice, sb);
        return false;
      }

      // Validate int packets: VS then PS.
      const CmdLoc ps_i_loc = FindLastOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_I);
      if (!Check(ps_i_loc.hdr != nullptr, "PS I packet present")) {
        cleanup.device_funcs.pfnDeleteStateBlock(create_dev.hDevice, sb);
        return false;
      }
      const auto* ps_i_cmd = reinterpret_cast<const aerogpu_cmd_set_shader_constants_i*>(ps_i_loc.hdr);
      if (!Check(ps_i_cmd->stage == static_cast<uint32_t>(AEROGPU_SHADER_STAGE_PIXEL), "PS I stage")) {
        cleanup.device_funcs.pfnDeleteStateBlock(create_dev.hDevice, sb);
        return false;
      }
      const auto* ps_i_payload =
          reinterpret_cast<const int32_t*>(reinterpret_cast<const uint8_t*>(ps_i_cmd) + sizeof(*ps_i_cmd));
      const size_t i_base = static_cast<size_t>(int_start) * 4;
      if (!Check(std::memcmp(ps_i_payload + i_base, ps_ints_a, sizeof(ps_ints_a)) == 0, "PS I payload restores A")) {
        cleanup.device_funcs.pfnDeleteStateBlock(create_dev.hDevice, sb);
        return false;
      }

      const CmdLoc vs_i_loc = FindLastOpcodeBefore(buf, len, ps_i_loc.offset, AEROGPU_CMD_SET_SHADER_CONSTANTS_I);
      if (!Check(vs_i_loc.hdr != nullptr, "VS I packet present")) {
        cleanup.device_funcs.pfnDeleteStateBlock(create_dev.hDevice, sb);
        return false;
      }
      const auto* vs_i_cmd = reinterpret_cast<const aerogpu_cmd_set_shader_constants_i*>(vs_i_loc.hdr);
      if (!Check(vs_i_cmd->stage == static_cast<uint32_t>(AEROGPU_SHADER_STAGE_VERTEX), "VS I stage")) {
        cleanup.device_funcs.pfnDeleteStateBlock(create_dev.hDevice, sb);
        return false;
      }
      const auto* vs_i_payload =
          reinterpret_cast<const int32_t*>(reinterpret_cast<const uint8_t*>(vs_i_cmd) + sizeof(*vs_i_cmd));
      if (!Check(std::memcmp(vs_i_payload + i_base, vs_ints_a, sizeof(vs_ints_a)) == 0, "VS I payload restores A")) {
        cleanup.device_funcs.pfnDeleteStateBlock(create_dev.hDevice, sb);
        return false;
      }

      // Validate bool packets: VS then PS.
      const CmdLoc ps_b_loc = FindLastOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_B);
      if (!Check(ps_b_loc.hdr != nullptr, "PS B packet present")) {
        cleanup.device_funcs.pfnDeleteStateBlock(create_dev.hDevice, sb);
        return false;
      }
      const auto* ps_b_cmd = reinterpret_cast<const aerogpu_cmd_set_shader_constants_b*>(ps_b_loc.hdr);
      if (!Check(ps_b_cmd->stage == static_cast<uint32_t>(AEROGPU_SHADER_STAGE_PIXEL), "PS B stage")) {
        cleanup.device_funcs.pfnDeleteStateBlock(create_dev.hDevice, sb);
        return false;
      }
      const auto* ps_b_payload =
          reinterpret_cast<const uint32_t*>(reinterpret_cast<const uint8_t*>(ps_b_cmd) + sizeof(*ps_b_cmd));
      const size_t b_base = static_cast<size_t>(bool_start);
      const uint32_t expected_ps_b[bool_count] = {0u, 1u};
      if (!Check(std::memcmp(ps_b_payload + b_base, expected_ps_b, sizeof(expected_ps_b)) == 0, "PS B payload restores A")) {
        cleanup.device_funcs.pfnDeleteStateBlock(create_dev.hDevice, sb);
        return false;
      }

      const CmdLoc vs_b_loc = FindLastOpcodeBefore(buf, len, ps_b_loc.offset, AEROGPU_CMD_SET_SHADER_CONSTANTS_B);
      if (!Check(vs_b_loc.hdr != nullptr, "VS B packet present")) {
        cleanup.device_funcs.pfnDeleteStateBlock(create_dev.hDevice, sb);
        return false;
      }
      const auto* vs_b_cmd = reinterpret_cast<const aerogpu_cmd_set_shader_constants_b*>(vs_b_loc.hdr);
      if (!Check(vs_b_cmd->stage == static_cast<uint32_t>(AEROGPU_SHADER_STAGE_VERTEX), "VS B stage")) {
        cleanup.device_funcs.pfnDeleteStateBlock(create_dev.hDevice, sb);
        return false;
      }
      const auto* vs_b_payload =
          reinterpret_cast<const uint32_t*>(reinterpret_cast<const uint8_t*>(vs_b_cmd) + sizeof(*vs_b_cmd));
      const uint32_t expected_vs_b[bool_count] = {1u, 0u};
      const bool ok = (std::memcmp(vs_b_payload + b_base, expected_vs_b, sizeof(expected_vs_b)) == 0);

      cleanup.device_funcs.pfnDeleteStateBlock(create_dev.hDevice, sb);
      if (!Check(ok, "VS B payload restores A")) {
        return false;
      }
    }

    return true;
  }
}

template <typename DeviceFuncsT, uint32_t D3dStage, uint32_t ExpectedStage>
bool TestCaptureStateBlockUpdatesShaderConstIBImpl() {
  if constexpr (!HasPfnSetShaderConstI<DeviceFuncsT>::value ||
                !HasPfnSetShaderConstB<DeviceFuncsT>::value ||
                !HasPfnCaptureStateBlock<DeviceFuncsT>::value) {
    // Some D3D9 DDI header variants do not expose the I/B constant entrypoints (or CaptureStateBlock)
    // in the device function table. In those builds we cannot exercise the DDI surface area; treat
    // the test as a no-op.
    return true;
  } else {
    struct Cleanup {
      D3D9DDI_ADAPTERFUNCS adapter_funcs{};
      DeviceFuncsT device_funcs{};
      D3DDDI_HADAPTER hAdapter{};
      D3DDDI_HDEVICE hDevice{};
      D3D9DDI_HSTATEBLOCK hStateBlock{};
      bool has_adapter = false;
      bool has_device = false;
      bool has_stateblock = false;
      ~Cleanup() {
        if (has_stateblock && device_funcs.pfnDeleteStateBlock) {
          device_funcs.pfnDeleteStateBlock(hDevice, hStateBlock);
        }
        if (has_device && device_funcs.pfnDestroyDevice) {
          device_funcs.pfnDestroyDevice(hDevice);
        }
        if (has_adapter && adapter_funcs.pfnCloseAdapter) {
          adapter_funcs.pfnCloseAdapter(hAdapter);
        }
      }
    } cleanup;

    D3DDDIARG_OPENADAPTER2 open{};
    open.Interface = 1;
    open.Version = 1;
    D3DDDI_ADAPTERCALLBACKS callbacks{};
    D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
    open.pAdapterCallbacks = &callbacks;
    open.pAdapterCallbacks2 = &callbacks2;
    open.pAdapterFuncs = &cleanup.adapter_funcs;

    HRESULT hr = ::OpenAdapter2(&open);
    if (!Check(hr == S_OK, "OpenAdapter2")) {
      return false;
    }
    cleanup.hAdapter = open.hAdapter;
    cleanup.has_adapter = true;

    D3D9DDIARG_CREATEDEVICE create_dev{};
    create_dev.hAdapter = open.hAdapter;
    create_dev.Flags = 0;
    hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
    if (!Check(hr == S_OK, "CreateDevice")) {
      return false;
    }
    cleanup.hDevice = create_dev.hDevice;
    cleanup.has_device = true;

    if (!Check(cleanup.device_funcs.pfnBeginStateBlock != nullptr, "BeginStateBlock must be available")) {
      return false;
    }
    if (!Check(cleanup.device_funcs.pfnEndStateBlock != nullptr, "EndStateBlock must be available")) {
      return false;
    }
    if (!Check(cleanup.device_funcs.pfnCaptureStateBlock != nullptr, "CaptureStateBlock must be available")) {
      return false;
    }
    if (!Check(cleanup.device_funcs.pfnApplyStateBlock != nullptr, "ApplyStateBlock must be available")) {
      return false;
    }
    if (!Check(cleanup.device_funcs.pfnDeleteStateBlock != nullptr, "DeleteStateBlock must be available")) {
      return false;
    }

    auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
    if (!Check(dev != nullptr, "device pointer")) {
      return false;
    }

    std::vector<uint8_t> dma(4096, 0);
    dev->cmd.set_span(dma.data(), dma.size());
    dev->cmd.reset();
    ScopedDeviceCmdVectorReset cmd_reset(dev);

    // Record a state block that sets int/bool constants to A.
    hr = cleanup.device_funcs.pfnBeginStateBlock(create_dev.hDevice);
    if (!Check(hr == S_OK, "BeginStateBlock")) {
      return false;
    }

    const uint32_t int_start = 5;
    const uint32_t int_count = 2;
    const int32_t ints_a[int_count * 4] = {1, 2, 3, 4, 5, 6, 7, 8};
    hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, D3dStage, int_start, ints_a, int_count);
    if (!Check(hr == S_OK, "SetShaderConstI (recorded A)")) {
      return false;
    }

    const uint32_t bool_start = 7;
    const uint32_t bool_count = 2;
    const BOOL bools_a[bool_count] = {static_cast<BOOL>(1), static_cast<BOOL>(0)};
    hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, D3dStage, bool_start, bools_a, bool_count);
    if (!Check(hr == S_OK, "SetShaderConstB (recorded A)")) {
      return false;
    }

    hr = cleanup.device_funcs.pfnEndStateBlock(create_dev.hDevice, &cleanup.hStateBlock);
    if (!Check(hr == S_OK, "EndStateBlock")) {
      return false;
    }
    cleanup.has_stateblock = true;

    // Change device constants to B, then capture the state block so it stores B (not A).
    const int32_t ints_b[int_count * 4] = {-1, -2, -3, -4, -5, -6, -7, -8};
    hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, D3dStage, int_start, ints_b, int_count);
    if (!Check(hr == S_OK, "SetShaderConstI (B)")) {
      return false;
    }
    const BOOL bools_b[bool_count] = {static_cast<BOOL>(0), static_cast<BOOL>(1)};
    hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, D3dStage, bool_start, bools_b, bool_count);
    if (!Check(hr == S_OK, "SetShaderConstB (B)")) {
      return false;
    }

    hr = cleanup.device_funcs.pfnCaptureStateBlock(create_dev.hDevice, cleanup.hStateBlock);
    if (!Check(hr == S_OK, "CaptureStateBlock")) {
      return false;
    }

    // Overwrite device constants to C so ApplyStateBlock must restore captured B values.
    const int32_t ints_c[int_count * 4] = {9, 10, 11, 12, 13, 14, 15, 16};
    hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, D3dStage, int_start, ints_c, int_count);
    if (!Check(hr == S_OK, "SetShaderConstI (C)")) {
      return false;
    }
    const BOOL bools_c[bool_count] = {static_cast<BOOL>(1), static_cast<BOOL>(1)};
    hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, D3dStage, bool_start, bools_c, bool_count);
    if (!Check(hr == S_OK, "SetShaderConstB (C)")) {
      return false;
    }

    dev->cmd.reset();
    hr = cleanup.device_funcs.pfnApplyStateBlock(create_dev.hDevice, cleanup.hStateBlock);
    if (!Check(hr == S_OK, "ApplyStateBlock")) {
      return false;
    }
    dev->cmd.finalize();
    const uint8_t* buf = dma.data();
    const size_t len = dev->cmd.bytes_used();
    if (!Check(ValidateStream(buf, dma.size()), "command stream validates")) {
      return false;
    }

    if (!Check(CountOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_I) == 1,
               "Capture+Apply emits one SET_SHADER_CONSTANTS_I")) {
      return false;
    }
    if (!Check(CountOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_B) == 1,
               "Capture+Apply emits one SET_SHADER_CONSTANTS_B")) {
      return false;
    }

    const CmdLoc i_loc = FindLastOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_I);
    if (!Check(i_loc.hdr != nullptr, "SET_SHADER_CONSTANTS_I emitted")) {
      return false;
    }
    const auto* i_cmd = reinterpret_cast<const aerogpu_cmd_set_shader_constants_i*>(i_loc.hdr);
    if (!Check(i_cmd->stage == ExpectedStage, "I stage")) {
      return false;
    }
    if (!Check(i_cmd->start_register == int_start, "I start_register")) {
      return false;
    }
    if (!Check(i_cmd->vec4_count == int_count, "I vec4_count")) {
      return false;
    }
    const auto* i_payload = reinterpret_cast<const int32_t*>(
        reinterpret_cast<const uint8_t*>(i_cmd) + sizeof(*i_cmd));
    if (!Check(std::memcmp(i_payload, ints_b, sizeof(ints_b)) == 0, "I payload matches captured B")) {
      return false;
    }

    const CmdLoc b_loc = FindLastOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_B);
    if (!Check(b_loc.hdr != nullptr, "SET_SHADER_CONSTANTS_B emitted")) {
      return false;
    }
    const auto* b_cmd = reinterpret_cast<const aerogpu_cmd_set_shader_constants_b*>(b_loc.hdr);
    if (!Check(b_cmd->stage == ExpectedStage, "B stage")) {
      return false;
    }
    if (!Check(b_cmd->start_register == bool_start, "B start_register")) {
      return false;
    }
    if (!Check(b_cmd->bool_count == bool_count, "B bool_count")) {
      return false;
    }
    const auto* b_payload = reinterpret_cast<const uint32_t*>(
        reinterpret_cast<const uint8_t*>(b_cmd) + sizeof(*b_cmd));
    const uint32_t expected_b[bool_count] = {0u, 1u};
    return Check(std::memcmp(b_payload, expected_b, sizeof(expected_b)) == 0, "B payload matches captured B");
  }
}

bool TestCaptureStateBlockUpdatesShaderConstIB() {
  return TestCaptureStateBlockUpdatesShaderConstIBImpl<
      D3D9DDI_DEVICEFUNCS,
      kD3d9ShaderStagePs,
      static_cast<uint32_t>(AEROGPU_SHADER_STAGE_PIXEL)>();
}

bool TestCaptureStateBlockUpdatesShaderConstIBVs() {
  return TestCaptureStateBlockUpdatesShaderConstIBImpl<
      D3D9DDI_DEVICEFUNCS,
      kD3d9ShaderStageVs,
      static_cast<uint32_t>(AEROGPU_SHADER_STAGE_VERTEX)>();
}

template <typename DeviceFuncsT, uint32_t D3dStage, uint32_t ExpectedStage>
bool TestCaptureStateBlockSplitsShaderConstIBImpl() {
  if constexpr (!HasPfnSetShaderConstI<DeviceFuncsT>::value ||
                !HasPfnSetShaderConstB<DeviceFuncsT>::value ||
                !HasPfnCaptureStateBlock<DeviceFuncsT>::value) {
    // Some D3D9 DDI header variants do not expose the I/B constant entrypoints (or CaptureStateBlock)
    // in the device function table. In those builds we cannot exercise the DDI surface area; treat
    // the test as a no-op.
    return true;
  } else {
    struct Cleanup {
      D3D9DDI_ADAPTERFUNCS adapter_funcs{};
      DeviceFuncsT device_funcs{};
      D3DDDI_HADAPTER hAdapter{};
      D3DDDI_HDEVICE hDevice{};
      D3D9DDI_HSTATEBLOCK hStateBlock{};
      bool has_adapter = false;
      bool has_device = false;
      bool has_stateblock = false;
      ~Cleanup() {
        if (has_stateblock && device_funcs.pfnDeleteStateBlock) {
          device_funcs.pfnDeleteStateBlock(hDevice, hStateBlock);
        }
        if (has_device && device_funcs.pfnDestroyDevice) {
          device_funcs.pfnDestroyDevice(hDevice);
        }
        if (has_adapter && adapter_funcs.pfnCloseAdapter) {
          adapter_funcs.pfnCloseAdapter(hAdapter);
        }
      }
    } cleanup;

    D3DDDIARG_OPENADAPTER2 open{};
    open.Interface = 1;
    open.Version = 1;
    D3DDDI_ADAPTERCALLBACKS callbacks{};
    D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
    open.pAdapterCallbacks = &callbacks;
    open.pAdapterCallbacks2 = &callbacks2;
    open.pAdapterFuncs = &cleanup.adapter_funcs;

    HRESULT hr = ::OpenAdapter2(&open);
    if (!Check(hr == S_OK, "OpenAdapter2")) {
      return false;
    }
    cleanup.hAdapter = open.hAdapter;
    cleanup.has_adapter = true;

    D3D9DDIARG_CREATEDEVICE create_dev{};
    create_dev.hAdapter = open.hAdapter;
    create_dev.Flags = 0;
    hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
    if (!Check(hr == S_OK, "CreateDevice")) {
      return false;
    }
    cleanup.hDevice = create_dev.hDevice;
    cleanup.has_device = true;

    if (!Check(cleanup.device_funcs.pfnBeginStateBlock != nullptr, "BeginStateBlock must be available")) {
      return false;
    }
    if (!Check(cleanup.device_funcs.pfnEndStateBlock != nullptr, "EndStateBlock must be available")) {
      return false;
    }
    if (!Check(cleanup.device_funcs.pfnCaptureStateBlock != nullptr, "CaptureStateBlock must be available")) {
      return false;
    }
    if (!Check(cleanup.device_funcs.pfnApplyStateBlock != nullptr, "ApplyStateBlock must be available")) {
      return false;
    }
    if (!Check(cleanup.device_funcs.pfnDeleteStateBlock != nullptr, "DeleteStateBlock must be available")) {
      return false;
    }

    auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
    if (!Check(dev != nullptr, "device pointer")) {
      return false;
    }

    std::vector<uint8_t> dma(4096, 0);
    dev->cmd.set_span(dma.data(), dma.size());
    dev->cmd.reset();
    ScopedDeviceCmdVectorReset cmd_reset(dev);

    // Record non-contiguous int/bool constants into the state block (A).
    hr = cleanup.device_funcs.pfnBeginStateBlock(create_dev.hDevice);
    if (!Check(hr == S_OK, "BeginStateBlock")) {
      return false;
    }

    const uint32_t i0 = 5;
    const uint32_t i1 = 7;
    const int32_t i5_a[4] = {1, 2, 3, 4};
    const int32_t i7_a[4] = {9, 10, 11, 12};
    hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, D3dStage, i0, i5_a, 1);
    if (!Check(hr == S_OK, "SetShaderConstI(i5 A)")) {
      return false;
    }
    hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, D3dStage, i1, i7_a, 1);
    if (!Check(hr == S_OK, "SetShaderConstI(i7 A)")) {
      return false;
    }

    const uint32_t b0 = 7;
    const uint32_t b1 = 9;
    const BOOL b7_a[1] = {static_cast<BOOL>(1)};
    const BOOL b9_a[1] = {static_cast<BOOL>(0)};
    hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, D3dStage, b0, b7_a, 1);
    if (!Check(hr == S_OK, "SetShaderConstB(b7 A)")) {
      return false;
    }
    hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, D3dStage, b1, b9_a, 1);
    if (!Check(hr == S_OK, "SetShaderConstB(b9 A)")) {
      return false;
    }

    hr = cleanup.device_funcs.pfnEndStateBlock(create_dev.hDevice, &cleanup.hStateBlock);
    if (!Check(hr == S_OK, "EndStateBlock")) {
      return false;
    }
    cleanup.has_stateblock = true;

    // Update device constants to B, then capture so the state block stores B.
    const int32_t i5_b[4] = {-1, -2, -3, -4};
    const int32_t i7_b[4] = {-9, -10, -11, -12};
    hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, D3dStage, i0, i5_b, 1);
    if (!Check(hr == S_OK, "SetShaderConstI(i5 B)")) {
      return false;
    }
    hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, D3dStage, i1, i7_b, 1);
    if (!Check(hr == S_OK, "SetShaderConstI(i7 B)")) {
      return false;
    }

    const BOOL b7_b[1] = {static_cast<BOOL>(0)};
    const BOOL b9_b[1] = {static_cast<BOOL>(1)};
    hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, D3dStage, b0, b7_b, 1);
    if (!Check(hr == S_OK, "SetShaderConstB(b7 B)")) {
      return false;
    }
    hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, D3dStage, b1, b9_b, 1);
    if (!Check(hr == S_OK, "SetShaderConstB(b9 B)")) {
      return false;
    }

    hr = cleanup.device_funcs.pfnCaptureStateBlock(create_dev.hDevice, cleanup.hStateBlock);
    if (!Check(hr == S_OK, "CaptureStateBlock")) {
      return false;
    }

    // Change constants again so ApplyStateBlock must restore the captured B values.
    const int32_t i5_c[4] = {100, 101, 102, 103};
    const int32_t i7_c[4] = {200, 201, 202, 203};
    hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, D3dStage, i0, i5_c, 1);
    if (!Check(hr == S_OK, "SetShaderConstI(i5 C)")) {
      return false;
    }
    hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, D3dStage, i1, i7_c, 1);
    if (!Check(hr == S_OK, "SetShaderConstI(i7 C)")) {
      return false;
    }
    const BOOL b7_c[1] = {static_cast<BOOL>(1)};
    // Ensure ApplyStateBlock must update *both* bool ranges so the split behavior
    // is exercised even when the UMD skips redundant constant uploads.
    const BOOL b9_c[1] = {static_cast<BOOL>(0)};
    hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, D3dStage, b0, b7_c, 1);
    if (!Check(hr == S_OK, "SetShaderConstB(b7 C)")) {
      return false;
    }
    hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, D3dStage, b1, b9_c, 1);
    if (!Check(hr == S_OK, "SetShaderConstB(b9 C)")) {
      return false;
    }

    dev->cmd.reset();
    hr = cleanup.device_funcs.pfnApplyStateBlock(create_dev.hDevice, cleanup.hStateBlock);
    if (!Check(hr == S_OK, "ApplyStateBlock")) {
      return false;
    }
    dev->cmd.finalize();
    const uint8_t* buf = dma.data();
    const size_t len = dev->cmd.bytes_used();
    if (!Check(ValidateStream(buf, dma.size()), "command stream validates")) {
      return false;
    }

    if (!Check(CountOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_I) == 2,
               "Capture+Apply splits SET_SHADER_CONSTANTS_I")) {
      return false;
    }
    if (!Check(CountOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_B) == 2,
               "Capture+Apply splits SET_SHADER_CONSTANTS_B")) {
      return false;
    }

    // Validate int packets: i5 then i7 (both captured B values).
    const CmdLoc i7_loc = FindLastOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_I);
    if (!Check(i7_loc.hdr != nullptr, "I packet present")) {
      return false;
    }
    const auto* i7_cmd = reinterpret_cast<const aerogpu_cmd_set_shader_constants_i*>(i7_loc.hdr);
    if (!Check(i7_cmd->stage == ExpectedStage, "I stage")) {
      return false;
    }
    if (!Check(i7_cmd->start_register == i1, "I7 start_register")) {
      return false;
    }
    if (!Check(i7_cmd->vec4_count == 1, "I7 vec4_count")) {
      return false;
    }
    const auto* i7_payload =
        reinterpret_cast<const int32_t*>(reinterpret_cast<const uint8_t*>(i7_cmd) + sizeof(*i7_cmd));
    if (!Check(std::memcmp(i7_payload, i7_b, sizeof(i7_b)) == 0, "I7 payload matches captured B")) {
      return false;
    }

    const CmdLoc i5_loc = FindLastOpcodeBefore(buf, len, i7_loc.offset, AEROGPU_CMD_SET_SHADER_CONSTANTS_I);
    if (!Check(i5_loc.hdr != nullptr, "I5 packet present")) {
      return false;
    }
    const auto* i5_cmd = reinterpret_cast<const aerogpu_cmd_set_shader_constants_i*>(i5_loc.hdr);
    if (!Check(i5_cmd->stage == ExpectedStage, "I5 stage")) {
      return false;
    }
    if (!Check(i5_cmd->start_register == i0, "I5 start_register")) {
      return false;
    }
    if (!Check(i5_cmd->vec4_count == 1, "I5 vec4_count")) {
      return false;
    }
    const auto* i5_payload =
        reinterpret_cast<const int32_t*>(reinterpret_cast<const uint8_t*>(i5_cmd) + sizeof(*i5_cmd));
    if (!Check(std::memcmp(i5_payload, i5_b, sizeof(i5_b)) == 0, "I5 payload matches captured B")) {
      return false;
    }

    // Validate bool packets: b7=false then b9=true (captured B values).
    const CmdLoc b9_loc = FindLastOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_B);
    if (!Check(b9_loc.hdr != nullptr, "B packet present")) {
      return false;
    }
    const auto* b9_cmd = reinterpret_cast<const aerogpu_cmd_set_shader_constants_b*>(b9_loc.hdr);
    if (!Check(b9_cmd->stage == ExpectedStage, "B stage")) {
      return false;
    }
    if (!Check(b9_cmd->start_register == b1, "B9 start_register")) {
      return false;
    }
    if (!Check(b9_cmd->bool_count == 1, "B9 bool_count")) {
      return false;
    }
    const auto* b9_payload =
        reinterpret_cast<const uint32_t*>(reinterpret_cast<const uint8_t*>(b9_cmd) + sizeof(*b9_cmd));
    const uint32_t expected_b9[1] = {1u};
    if (!Check(std::memcmp(b9_payload, expected_b9, sizeof(expected_b9)) == 0, "B9 payload matches captured B")) {
      return false;
    }

    const CmdLoc b7_loc = FindLastOpcodeBefore(buf, len, b9_loc.offset, AEROGPU_CMD_SET_SHADER_CONSTANTS_B);
    if (!Check(b7_loc.hdr != nullptr, "B7 packet present")) {
      return false;
    }
    const auto* b7_cmd = reinterpret_cast<const aerogpu_cmd_set_shader_constants_b*>(b7_loc.hdr);
    if (!Check(b7_cmd->stage == ExpectedStage, "B7 stage")) {
      return false;
    }
    if (!Check(b7_cmd->start_register == b0, "B7 start_register")) {
      return false;
    }
    if (!Check(b7_cmd->bool_count == 1, "B7 bool_count")) {
      return false;
    }
    const auto* b7_payload =
        reinterpret_cast<const uint32_t*>(reinterpret_cast<const uint8_t*>(b7_cmd) + sizeof(*b7_cmd));
    const uint32_t expected_b7[1] = {0u};
    return Check(std::memcmp(b7_payload, expected_b7, sizeof(expected_b7)) == 0, "B7 payload matches captured B");
  }
}

bool TestCaptureStateBlockSplitsShaderConstIB() {
  return TestCaptureStateBlockSplitsShaderConstIBImpl<
      D3D9DDI_DEVICEFUNCS,
      kD3d9ShaderStagePs,
      static_cast<uint32_t>(AEROGPU_SHADER_STAGE_PIXEL)>();
}

bool TestCaptureStateBlockSplitsShaderConstIBVs() {
  return TestCaptureStateBlockSplitsShaderConstIBImpl<
      D3D9DDI_DEVICEFUNCS,
      kD3d9ShaderStageVs,
      static_cast<uint32_t>(AEROGPU_SHADER_STAGE_VERTEX)>();
}

template <typename DeviceFuncsT, uint32_t CreateType, uint32_t D3dStage, uint32_t ExpectedStage>
bool TestCreateStateBlockRestoresShaderConstIBImpl() {
  if constexpr (!HasPfnSetShaderConstI<DeviceFuncsT>::value ||
                !HasPfnSetShaderConstB<DeviceFuncsT>::value ||
                !HasPfnCreateStateBlock<DeviceFuncsT>::value) {
    // Some D3D9 DDI header variants do not expose the I/B constant entrypoints (or CreateStateBlock)
    // in the device function table. In those builds we cannot exercise the DDI surface area; treat
    // the test as a no-op.
    return true;
  } else {
    struct Cleanup {
      D3D9DDI_ADAPTERFUNCS adapter_funcs{};
      DeviceFuncsT device_funcs{};
      D3DDDI_HADAPTER hAdapter{};
      D3DDDI_HDEVICE hDevice{};
      D3D9DDI_HSTATEBLOCK hStateBlock{};
      bool has_adapter = false;
      bool has_device = false;
      bool has_stateblock = false;
      ~Cleanup() {
        if (has_stateblock && device_funcs.pfnDeleteStateBlock) {
          device_funcs.pfnDeleteStateBlock(hDevice, hStateBlock);
        }
        if (has_device && device_funcs.pfnDestroyDevice) {
          device_funcs.pfnDestroyDevice(hDevice);
        }
        if (has_adapter && adapter_funcs.pfnCloseAdapter) {
          adapter_funcs.pfnCloseAdapter(hAdapter);
        }
      }
    } cleanup;

    D3DDDIARG_OPENADAPTER2 open{};
    open.Interface = 1;
    open.Version = 1;
    D3DDDI_ADAPTERCALLBACKS callbacks{};
    D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
    open.pAdapterCallbacks = &callbacks;
    open.pAdapterCallbacks2 = &callbacks2;
    open.pAdapterFuncs = &cleanup.adapter_funcs;

    HRESULT hr = ::OpenAdapter2(&open);
    if (!Check(hr == S_OK, "OpenAdapter2")) {
      return false;
    }
    cleanup.hAdapter = open.hAdapter;
    cleanup.has_adapter = true;

    D3D9DDIARG_CREATEDEVICE create_dev{};
    create_dev.hAdapter = open.hAdapter;
    create_dev.Flags = 0;
    hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
    if (!Check(hr == S_OK, "CreateDevice")) {
      return false;
    }
    cleanup.hDevice = create_dev.hDevice;
    cleanup.has_device = true;

    if (!Check(cleanup.device_funcs.pfnCreateStateBlock != nullptr, "CreateStateBlock must be available")) {
      return false;
    }
    if (!Check(cleanup.device_funcs.pfnApplyStateBlock != nullptr, "ApplyStateBlock must be available")) {
      return false;
    }
    if (!Check(cleanup.device_funcs.pfnDeleteStateBlock != nullptr, "DeleteStateBlock must be available")) {
      return false;
    }

    auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
    if (!Check(dev != nullptr, "device pointer")) {
      return false;
    }

    std::vector<uint8_t> dma(128 * 1024, 0);
    dev->cmd.set_span(dma.data(), dma.size());
    dev->cmd.reset();
    ScopedDeviceCmdVectorReset cmd_reset(dev);

    // Set int/bool constants to A and create a typed state block (PIXELSTATE or VERTEXSTATE).
    const uint32_t int_start = 5;
    const uint32_t int_count = 2;
    const int32_t ints_a[int_count * 4] = {1, 2, 3, 4, 5, 6, 7, 8};
    hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, D3dStage, int_start, ints_a, int_count);
    if (!Check(hr == S_OK, "SetShaderConstI (A)")) {
      return false;
    }

    const uint32_t bool_start = 7;
    const uint32_t bool_count = 2;
    const BOOL bools_a[bool_count] = {static_cast<BOOL>(1), static_cast<BOOL>(0)};
    hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, D3dStage, bool_start, bools_a, bool_count);
    if (!Check(hr == S_OK, "SetShaderConstB (A)")) {
      return false;
    }

    hr = CallCreateStateBlock(&cleanup.device_funcs, create_dev.hDevice, CreateType, &cleanup.hStateBlock);
    if (!Check(hr == S_OK, "CreateStateBlock")) {
      return false;
    }
    if (!Check(cleanup.hStateBlock.pDrvPrivate != nullptr, "CreateStateBlock returns stateblock handle")) {
      return false;
    }
    cleanup.has_stateblock = true;

    // Change device constants to B so ApplyStateBlock must restore captured A.
    const int32_t ints_b[int_count * 4] = {-1, -2, -3, -4, -5, -6, -7, -8};
    hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, D3dStage, int_start, ints_b, int_count);
    if (!Check(hr == S_OK, "SetShaderConstI (B)")) {
      return false;
    }
    const BOOL bools_b[bool_count] = {static_cast<BOOL>(0), static_cast<BOOL>(1)};
    hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, D3dStage, bool_start, bools_b, bool_count);
    if (!Check(hr == S_OK, "SetShaderConstB (B)")) {
      return false;
    }

    dev->cmd.reset();
    hr = cleanup.device_funcs.pfnApplyStateBlock(create_dev.hDevice, cleanup.hStateBlock);
    if (!Check(hr == S_OK, "ApplyStateBlock")) {
      return false;
    }
    dev->cmd.finalize();

    const uint8_t* buf = dma.data();
    const size_t len = dev->cmd.bytes_used();
    if (!Check(ValidateStream(buf, dma.size()), "command stream validates")) {
      return false;
    }

    // Typed state blocks capture the whole constant file for their stage, so we should see one
    // contiguous upload for each constant type.
    if (!Check(CountOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_I) == 1,
               "CreateStateBlock+Apply emits one SET_SHADER_CONSTANTS_I")) {
      return false;
    }
    if (!Check(CountOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_B) == 1,
               "CreateStateBlock+Apply emits one SET_SHADER_CONSTANTS_B")) {
      return false;
    }

    const CmdLoc i_loc = FindLastOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_I);
    if (!Check(i_loc.hdr != nullptr, "SET_SHADER_CONSTANTS_I emitted")) {
      return false;
    }
    const auto* i_cmd = reinterpret_cast<const aerogpu_cmd_set_shader_constants_i*>(i_loc.hdr);
    if (!Check(i_cmd->stage == ExpectedStage, "I stage")) {
      return false;
    }
    if (!Check(i_cmd->start_register == 0, "I start_register == 0 (full file)")) {
      return false;
    }
    if (!Check(i_cmd->vec4_count == 256, "I vec4_count == 256 (full file)")) {
      return false;
    }
    if (!Check(i_cmd->hdr.size_bytes >= sizeof(*i_cmd) + (256u * 4u * sizeof(int32_t)), "I payload present")) {
      return false;
    }
    const auto* i_payload = reinterpret_cast<const int32_t*>(reinterpret_cast<const uint8_t*>(i_cmd) + sizeof(*i_cmd));
    const size_t i_base = static_cast<size_t>(int_start) * 4;
    if (!Check(std::memcmp(i_payload + i_base, ints_a, sizeof(ints_a)) == 0, "I payload restores captured A")) {
      return false;
    }

    const CmdLoc b_loc = FindLastOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_B);
    if (!Check(b_loc.hdr != nullptr, "SET_SHADER_CONSTANTS_B emitted")) {
      return false;
    }
    const auto* b_cmd = reinterpret_cast<const aerogpu_cmd_set_shader_constants_b*>(b_loc.hdr);
    if (!Check(b_cmd->stage == ExpectedStage, "B stage")) {
      return false;
    }
    if (!Check(b_cmd->start_register == 0, "B start_register == 0 (full file)")) {
      return false;
    }
    if (!Check(b_cmd->bool_count == 256, "B bool_count == 256 (full file)")) {
      return false;
    }
    if (!Check(b_cmd->hdr.size_bytes >= sizeof(*b_cmd) + (256u * sizeof(uint32_t)), "B payload present")) {
      return false;
    }
    const auto* b_payload = reinterpret_cast<const uint32_t*>(reinterpret_cast<const uint8_t*>(b_cmd) + sizeof(*b_cmd));
    const size_t b_base = static_cast<size_t>(bool_start);
    const uint32_t expected_b[bool_count] = {1u, 0u};
    return Check(std::memcmp(b_payload + b_base, expected_b, sizeof(expected_b)) == 0, "B payload restores captured A");
  }
}

bool TestCreateStateBlockRestoresShaderConstIB() {
  constexpr uint32_t kD3dSbtPixelState = 2u; // D3DSBT_PIXELSTATE
  return TestCreateStateBlockRestoresShaderConstIBImpl<
      D3D9DDI_DEVICEFUNCS,
      kD3dSbtPixelState,
      kD3d9ShaderStagePs,
      static_cast<uint32_t>(AEROGPU_SHADER_STAGE_PIXEL)>();
}

bool TestCreateStateBlockRestoresShaderConstIBVs() {
  constexpr uint32_t kD3dSbtVertexState = 3u; // D3DSBT_VERTEXSTATE
  return TestCreateStateBlockRestoresShaderConstIBImpl<
      D3D9DDI_DEVICEFUNCS,
      kD3dSbtVertexState,
      kD3d9ShaderStageVs,
      static_cast<uint32_t>(AEROGPU_SHADER_STAGE_VERTEX)>();
}

template <typename DeviceFuncsT>
bool TestCreateStateBlockAllRestoresShaderConstIBImpl() {
  if constexpr (!HasPfnSetShaderConstI<DeviceFuncsT>::value ||
                !HasPfnSetShaderConstB<DeviceFuncsT>::value ||
                !HasPfnCreateStateBlock<DeviceFuncsT>::value) {
    return true;
  } else {
    struct Cleanup {
      D3D9DDI_ADAPTERFUNCS adapter_funcs{};
      DeviceFuncsT device_funcs{};
      D3DDDI_HADAPTER hAdapter{};
      D3DDDI_HDEVICE hDevice{};
      D3D9DDI_HSTATEBLOCK hStateBlock{};
      bool has_adapter = false;
      bool has_device = false;
      bool has_stateblock = false;
      ~Cleanup() {
        if (has_stateblock && device_funcs.pfnDeleteStateBlock) {
          device_funcs.pfnDeleteStateBlock(hDevice, hStateBlock);
        }
        if (has_device && device_funcs.pfnDestroyDevice) {
          device_funcs.pfnDestroyDevice(hDevice);
        }
        if (has_adapter && adapter_funcs.pfnCloseAdapter) {
          adapter_funcs.pfnCloseAdapter(hAdapter);
        }
      }
    } cleanup;

    D3DDDIARG_OPENADAPTER2 open{};
    open.Interface = 1;
    open.Version = 1;
    D3DDDI_ADAPTERCALLBACKS callbacks{};
    D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
    open.pAdapterCallbacks = &callbacks;
    open.pAdapterCallbacks2 = &callbacks2;
    open.pAdapterFuncs = &cleanup.adapter_funcs;

    HRESULT hr = ::OpenAdapter2(&open);
    if (!Check(hr == S_OK, "OpenAdapter2")) {
      return false;
    }
    cleanup.hAdapter = open.hAdapter;
    cleanup.has_adapter = true;

    D3D9DDIARG_CREATEDEVICE create_dev{};
    create_dev.hAdapter = open.hAdapter;
    create_dev.Flags = 0;
    hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
    if (!Check(hr == S_OK, "CreateDevice")) {
      return false;
    }
    cleanup.hDevice = create_dev.hDevice;
    cleanup.has_device = true;

    if (!Check(cleanup.device_funcs.pfnCreateStateBlock != nullptr, "CreateStateBlock must be available")) {
      return false;
    }
    if (!Check(cleanup.device_funcs.pfnApplyStateBlock != nullptr, "ApplyStateBlock must be available")) {
      return false;
    }
    if (!Check(cleanup.device_funcs.pfnDeleteStateBlock != nullptr, "DeleteStateBlock must be available")) {
      return false;
    }

    auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
    if (!Check(dev != nullptr, "device pointer")) {
      return false;
    }

    std::vector<uint8_t> dma(128 * 1024, 0);
    dev->cmd.set_span(dma.data(), dma.size());
    dev->cmd.reset();
    ScopedDeviceCmdVectorReset cmd_reset(dev);

    const uint32_t int_start = 5;
    const uint32_t int_count = 2;
    const uint32_t bool_start = 7;
    const uint32_t bool_count = 2;

    // Set per-stage constants to distinct values so stage mixups are caught.
    const int32_t vs_ints_a[int_count * 4] = {1, 2, 3, 4, 5, 6, 7, 8};
    const int32_t ps_ints_a[int_count * 4] = {11, 12, 13, 14, 15, 16, 17, 18};
    const BOOL vs_bools_a[bool_count] = {static_cast<BOOL>(1), static_cast<BOOL>(0)};
    const BOOL ps_bools_a[bool_count] = {static_cast<BOOL>(0), static_cast<BOOL>(1)};

    hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, kD3d9ShaderStageVs, int_start, vs_ints_a, int_count);
    if (!Check(hr == S_OK, "SetShaderConstI(VS, A)")) {
      return false;
    }
    hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, kD3d9ShaderStagePs, int_start, ps_ints_a, int_count);
    if (!Check(hr == S_OK, "SetShaderConstI(PS, A)")) {
      return false;
    }

    hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, kD3d9ShaderStageVs, bool_start, vs_bools_a, bool_count);
    if (!Check(hr == S_OK, "SetShaderConstB(VS, A)")) {
      return false;
    }
    hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, kD3d9ShaderStagePs, bool_start, ps_bools_a, bool_count);
    if (!Check(hr == S_OK, "SetShaderConstB(PS, A)")) {
      return false;
    }

    constexpr uint32_t kD3dSbtAll = 1u; // D3DSBT_ALL
    hr = CallCreateStateBlock(&cleanup.device_funcs, create_dev.hDevice, kD3dSbtAll, &cleanup.hStateBlock);
    if (!Check(hr == S_OK, "CreateStateBlock(ALL)")) {
      return false;
    }
    if (!Check(cleanup.hStateBlock.pDrvPrivate != nullptr, "CreateStateBlock returns stateblock handle")) {
      return false;
    }
    cleanup.has_stateblock = true;

    // Change both stages to B so apply must restore A.
    const int32_t vs_ints_b[int_count * 4] = {-1, -2, -3, -4, -5, -6, -7, -8};
    const int32_t ps_ints_b[int_count * 4] = {-11, -12, -13, -14, -15, -16, -17, -18};
    const BOOL vs_bools_b[bool_count] = {static_cast<BOOL>(0), static_cast<BOOL>(1)};
    const BOOL ps_bools_b[bool_count] = {static_cast<BOOL>(1), static_cast<BOOL>(0)};

    hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, kD3d9ShaderStageVs, int_start, vs_ints_b, int_count);
    if (!Check(hr == S_OK, "SetShaderConstI(VS, B)")) {
      return false;
    }
    hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, kD3d9ShaderStagePs, int_start, ps_ints_b, int_count);
    if (!Check(hr == S_OK, "SetShaderConstI(PS, B)")) {
      return false;
    }
    hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, kD3d9ShaderStageVs, bool_start, vs_bools_b, bool_count);
    if (!Check(hr == S_OK, "SetShaderConstB(VS, B)")) {
      return false;
    }
    hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, kD3d9ShaderStagePs, bool_start, ps_bools_b, bool_count);
    if (!Check(hr == S_OK, "SetShaderConstB(PS, B)")) {
      return false;
    }

    dev->cmd.reset();
    hr = cleanup.device_funcs.pfnApplyStateBlock(create_dev.hDevice, cleanup.hStateBlock);
    if (!Check(hr == S_OK, "ApplyStateBlock")) {
      return false;
    }
    dev->cmd.finalize();
    const uint8_t* buf = dma.data();
    const size_t len = dev->cmd.bytes_used();
    if (!Check(ValidateStream(buf, dma.size()), "command stream validates")) {
      return false;
    }

    if (!Check(CountOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_I) == 2,
               "CreateStateBlock(ALL)+Apply emits two SET_SHADER_CONSTANTS_I")) {
      return false;
    }
    if (!Check(CountOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_B) == 2,
               "CreateStateBlock(ALL)+Apply emits two SET_SHADER_CONSTANTS_B")) {
      return false;
    }

    // Int constants: VS then PS.
    const CmdLoc ps_i_loc = FindLastOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_I);
    if (!Check(ps_i_loc.hdr != nullptr, "PS I packet present")) {
      return false;
    }
    const auto* ps_i_cmd = reinterpret_cast<const aerogpu_cmd_set_shader_constants_i*>(ps_i_loc.hdr);
    if (!Check(ps_i_cmd->stage == static_cast<uint32_t>(AEROGPU_SHADER_STAGE_PIXEL), "PS I stage")) {
      return false;
    }
    if (!Check(ps_i_cmd->start_register == 0 && ps_i_cmd->vec4_count == 256, "PS I covers full file")) {
      return false;
    }
    const auto* ps_i_payload =
        reinterpret_cast<const int32_t*>(reinterpret_cast<const uint8_t*>(ps_i_cmd) + sizeof(*ps_i_cmd));
    const size_t i_base = static_cast<size_t>(int_start) * 4;
    if (!Check(std::memcmp(ps_i_payload + i_base, ps_ints_a, sizeof(ps_ints_a)) == 0, "PS I restores A")) {
      return false;
    }

    const CmdLoc vs_i_loc = FindLastOpcodeBefore(buf, len, ps_i_loc.offset, AEROGPU_CMD_SET_SHADER_CONSTANTS_I);
    if (!Check(vs_i_loc.hdr != nullptr, "VS I packet present")) {
      return false;
    }
    const auto* vs_i_cmd = reinterpret_cast<const aerogpu_cmd_set_shader_constants_i*>(vs_i_loc.hdr);
    if (!Check(vs_i_cmd->stage == static_cast<uint32_t>(AEROGPU_SHADER_STAGE_VERTEX), "VS I stage")) {
      return false;
    }
    if (!Check(vs_i_cmd->start_register == 0 && vs_i_cmd->vec4_count == 256, "VS I covers full file")) {
      return false;
    }
    const auto* vs_i_payload =
        reinterpret_cast<const int32_t*>(reinterpret_cast<const uint8_t*>(vs_i_cmd) + sizeof(*vs_i_cmd));
    if (!Check(std::memcmp(vs_i_payload + i_base, vs_ints_a, sizeof(vs_ints_a)) == 0, "VS I restores A")) {
      return false;
    }

    // Bool constants: VS then PS.
    const CmdLoc ps_b_loc = FindLastOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_B);
    if (!Check(ps_b_loc.hdr != nullptr, "PS B packet present")) {
      return false;
    }
    const auto* ps_b_cmd = reinterpret_cast<const aerogpu_cmd_set_shader_constants_b*>(ps_b_loc.hdr);
    if (!Check(ps_b_cmd->stage == static_cast<uint32_t>(AEROGPU_SHADER_STAGE_PIXEL), "PS B stage")) {
      return false;
    }
    if (!Check(ps_b_cmd->start_register == 0 && ps_b_cmd->bool_count == 256, "PS B covers full file")) {
      return false;
    }
    const auto* ps_b_payload =
        reinterpret_cast<const uint32_t*>(reinterpret_cast<const uint8_t*>(ps_b_cmd) + sizeof(*ps_b_cmd));
    const size_t b_base = static_cast<size_t>(bool_start);
    const uint32_t ps_expected_b[bool_count] = {0u, 1u};
    if (!Check(std::memcmp(ps_b_payload + b_base, ps_expected_b, sizeof(ps_expected_b)) == 0, "PS B restores A")) {
      return false;
    }

    const CmdLoc vs_b_loc = FindLastOpcodeBefore(buf, len, ps_b_loc.offset, AEROGPU_CMD_SET_SHADER_CONSTANTS_B);
    if (!Check(vs_b_loc.hdr != nullptr, "VS B packet present")) {
      return false;
    }
    const auto* vs_b_cmd = reinterpret_cast<const aerogpu_cmd_set_shader_constants_b*>(vs_b_loc.hdr);
    if (!Check(vs_b_cmd->stage == static_cast<uint32_t>(AEROGPU_SHADER_STAGE_VERTEX), "VS B stage")) {
      return false;
    }
    if (!Check(vs_b_cmd->start_register == 0 && vs_b_cmd->bool_count == 256, "VS B covers full file")) {
      return false;
    }
    const auto* vs_b_payload =
        reinterpret_cast<const uint32_t*>(reinterpret_cast<const uint8_t*>(vs_b_cmd) + sizeof(*vs_b_cmd));
    const uint32_t vs_expected_b[bool_count] = {1u, 0u};
    return Check(std::memcmp(vs_b_payload + b_base, vs_expected_b, sizeof(vs_expected_b)) == 0, "VS B restores A");
  }
}

bool TestCreateStateBlockAllRestoresShaderConstIB() {
  return TestCreateStateBlockAllRestoresShaderConstIBImpl<D3D9DDI_DEVICEFUNCS>();
}

bool TestDestroyBoundShaderUnbinds() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3D9DDI_HSHADER hShader{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_shader = false;

    ~Cleanup() {
      if (has_shader && device_funcs.pfnDestroyShader) {
        device_funcs.pfnDestroyShader(hDevice, hShader);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  if (!Check(create_dev.hDevice.pDrvPrivate != nullptr, "CreateDevice returned device handle")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  const uint8_t dxbc[] = {0x44, 0x58, 0x42, 0x43, 0x00, 0x01, 0x02, 0x03};
  D3D9DDI_HSHADER hShader{};
  hr = cleanup.device_funcs.pfnCreateShader(create_dev.hDevice,
                                            kD3d9ShaderStageVs,
                                            dxbc,
                                            static_cast<uint32_t>(sizeof(dxbc)),
                                            &hShader);
  if (!Check(hr == S_OK, "CreateShader(VS)")) {
    return false;
  }
  if (!Check(hShader.pDrvPrivate != nullptr, "CreateShader returned shader handle")) {
    return false;
  }
  cleanup.hShader = hShader;
  cleanup.has_shader = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  auto* sh = reinterpret_cast<Shader*>(hShader.pDrvPrivate);
  const aerogpu_handle_t destroyed_handle = sh ? sh->handle : 0;

  hr = cleanup.device_funcs.pfnSetShader(create_dev.hDevice, kD3d9ShaderStageVs, hShader);
  if (!Check(hr == S_OK, "SetShader(VS)")) {
    return false;
  }
  if (!Check(dev->vs == sh, "SetShader updates cached vs pointer")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnDestroyShader(create_dev.hDevice, hShader);
  if (!Check(hr == S_OK, "DestroyShader")) {
    return false;
  }
  cleanup.has_shader = false;

  // The host rejects null shader binds; destroying a bound shader must rebind a
  // replacement (fixed-function or internal fallback) before emitting DESTROY_SHADER.
  if (!Check(dev->vs != nullptr && dev->vs->handle != destroyed_handle, "DestroyShader rebinds a non-null VS")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  const CmdLoc bind = FindLastOpcode(buf, len, AEROGPU_CMD_BIND_SHADERS);
  if (!Check(bind.hdr != nullptr, "bind_shaders emitted")) {
    return false;
  }

  const auto* bind_cmd = reinterpret_cast<const aerogpu_cmd_bind_shaders*>(bind.hdr);
  if (!Check(bind_cmd->vs != 0 && bind_cmd->ps != 0, "bind_shaders binds non-null shaders")) {
    return false;
  }
  if (!Check(bind_cmd->vs != destroyed_handle && bind_cmd->ps != destroyed_handle, "bind_shaders unbinds destroyed handle")) {
    return false;
  }

  const CmdLoc destroy = FindLastOpcode(buf, len, AEROGPU_CMD_DESTROY_SHADER);
  if (!Check(destroy.hdr != nullptr, "destroy_shader emitted")) {
    return false;
  }
  return Check(bind.offset < destroy.offset, "unbind occurs before destroy");
}

bool TestPartialShaderStageBindingVsOnlyBindsFixedfuncPsAndDraws() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3D9DDI_HSHADER hVs{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_vs = false;

    ~Cleanup() {
      if (has_vs && device_funcs.pfnDestroyShader) {
        device_funcs.pfnDestroyShader(hDevice, hVs);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  if (!Check(create_dev.hDevice.pDrvPrivate != nullptr, "CreateDevice returned device handle")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  const uint8_t dxbc[] = {0x44, 0x58, 0x42, 0x43, 0x00, 0x01, 0x02, 0x03};
  D3D9DDI_HSHADER hVs{};
  hr = cleanup.device_funcs.pfnCreateShader(create_dev.hDevice,
                                            kD3d9ShaderStageVs,
                                            dxbc,
                                            static_cast<uint32_t>(sizeof(dxbc)),
                                            &hVs);
  if (!Check(hr == S_OK, "CreateShader(VS)")) {
    return false;
  }
  if (!Check(hVs.pDrvPrivate != nullptr, "CreateShader returned handle")) {
    return false;
  }
  cleanup.hVs = hVs;
  cleanup.has_vs = true;

  hr = cleanup.device_funcs.pfnSetShader(create_dev.hDevice, kD3d9ShaderStageVs, hVs);
  if (!Check(hr == S_OK, "SetShader(VS)")) {
    return false;
  }

  // Explicitly clear PS (NULL stage); draw should still succeed by binding an
  // internal fixed-function PS fallback.
  D3D9DDI_HSHADER null_shader{};
  hr = cleanup.device_funcs.pfnSetShader(create_dev.hDevice, kD3d9ShaderStagePs, null_shader);
  if (!Check(hr == S_OK, "SetShader(PS=NULL)")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnDrawPrimitive(create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 0, 1);
  if (!Check(hr == S_OK, "DrawPrimitive(VS-only)")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  const CmdLoc draw = FindLastOpcode(buf, len, AEROGPU_CMD_DRAW);
  if (!Check(draw.hdr != nullptr, "DRAW emitted")) {
    return false;
  }

  // Draw-time interop may temporarily bind an internal fixed-function shader and
  // restore the original (NULL) stage after the draw. Ensure the bind used for
  // the draw occurs before the draw packet, rather than relying on the last bind
  // in the stream.
  const CmdLoc bind = FindLastOpcodeBefore(buf, len, draw.offset, AEROGPU_CMD_BIND_SHADERS);
  if (!Check(bind.hdr != nullptr, "BIND_SHADERS emitted")) {
    return false;
  }
  if (!Check(bind.offset < draw.offset, "BIND_SHADERS occurs before DRAW")) {
    return false;
  }

  const auto* bind_cmd = reinterpret_cast<const aerogpu_cmd_bind_shaders*>(bind.hdr);
  if (!Check(bind_cmd->vs != 0, "BIND_SHADERS has non-zero VS")) {
    return false;
  }
  if (!Check(bind_cmd->ps != 0, "BIND_SHADERS has non-zero PS fallback")) {
    return false;
  }
  return ValidateStream(buf, len);
}

bool TestPartialShaderStageBindingPsOnlyBindsFixedfuncVsAndDraws() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3D9DDI_HSHADER hPs{};
    D3DDDI_HRESOURCE hVb{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_ps = false;
    bool has_vb = false;

    ~Cleanup() {
      if (has_vb && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hVb);
      }
      if (has_ps && device_funcs.pfnDestroyShader) {
        device_funcs.pfnDestroyShader(hDevice, hPs);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  if (!Check(create_dev.hDevice.pDrvPrivate != nullptr, "CreateDevice returned device handle")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  // Configure a supported fixed-function FVF so the driver can synthesize an
  // internal VS for PS-only draws.
  constexpr uint32_t kD3dFvfXyzRhw = 0x00000004u;
  constexpr uint32_t kD3dFvfDiffuse = 0x00000040u;
  const uint32_t fvf = kD3dFvfXyzRhw | kD3dFvfDiffuse;
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, fvf);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|DIFFUSE)")) {
    return false;
  }

  const uint8_t dxbc[] = {0x44, 0x58, 0x42, 0x43, 0xAA, 0xBB, 0xCC, 0xDD};
  D3D9DDI_HSHADER hPs{};
  hr = cleanup.device_funcs.pfnCreateShader(create_dev.hDevice,
                                            kD3d9ShaderStagePs,
                                            dxbc,
                                            static_cast<uint32_t>(sizeof(dxbc)),
                                            &hPs);
  if (!Check(hr == S_OK, "CreateShader(PS)")) {
    return false;
  }
  if (!Check(hPs.pDrvPrivate != nullptr, "CreateShader returned handle")) {
    return false;
  }
  cleanup.hPs = hPs;
  cleanup.has_ps = true;

  hr = cleanup.device_funcs.pfnSetShader(create_dev.hDevice, kD3d9ShaderStagePs, hPs);
  if (!Check(hr == S_OK, "SetShader(PS)")) {
    return false;
  }

  // Explicitly clear VS (NULL stage); draw should still succeed by binding an
  // internal fixed-function VS fallback.
  D3D9DDI_HSHADER null_shader{};
  hr = cleanup.device_funcs.pfnSetShader(create_dev.hDevice, kD3d9ShaderStageVs, null_shader);
  if (!Check(hr == S_OK, "SetShader(VS=NULL)")) {
    return false;
  }

  // Provide a small vertex stream so the fixed-function XYZRHW emulation path
  // can read and convert vertices for the fallback VS.
  struct VertexXyzrhwDiffuse {
    float x;
    float y;
    float z;
    float rhw;
    uint32_t color;
  };
  const VertexXyzrhwDiffuse verts[3] = {
      {0.0f, 0.0f, 0.5f, 1.0f, 0xFFFFFFFFu},
      {1.0f, 0.0f, 0.5f, 1.0f, 0xFFFFFFFFu},
      {0.0f, 1.0f, 0.5f, 1.0f, 0xFFFFFFFFu},
  };

  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = 0;
  create_res.format = 0;
  create_res.width = 0;
  create_res.height = 0;
  create_res.depth = 0;
  create_res.mip_levels = 1;
  create_res.usage = 0;
  create_res.pool = 0;
  create_res.size = sizeof(verts);
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr;
  create_res.pKmdAllocPrivateData = nullptr;
  create_res.KmdAllocPrivateDataSize = 0;
  create_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == S_OK, "CreateResource(vertex buffer)")) {
    return false;
  }
  cleanup.hVb = create_res.hResource;
  cleanup.has_vb = true;

  D3D9DDIARG_LOCK lock{};
  lock.hResource = create_res.hResource;
  lock.offset_bytes = 0;
  lock.size_bytes = 0;
  lock.flags = 0;
  D3DDDI_LOCKEDBOX box{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(vertex buffer)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock returns pData")) {
    return false;
  }
  std::memcpy(box.pData, verts, sizeof(verts));

  D3D9DDIARG_UNLOCK unlock{};
  unlock.hResource = create_res.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(vertex buffer)")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnSetStreamSource(create_dev.hDevice, 0, create_res.hResource, 0, sizeof(VertexXyzrhwDiffuse));
  if (!Check(hr == S_OK, "SetStreamSource")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnDrawPrimitive(create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 0, 1);
  if (!Check(hr == S_OK, "DrawPrimitive(PS-only)")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  const CmdLoc draw = FindLastOpcode(buf, len, AEROGPU_CMD_DRAW);
  if (!Check(draw.hdr != nullptr, "DRAW emitted")) {
    return false;
  }

  // Draw-time interop may restore the original (NULL) stage after drawing, so
  // the final BIND_SHADERS packet might occur after DRAW. Find the most recent
  // bind before the draw packet.
  const CmdLoc bind = FindLastOpcodeBefore(buf, len, draw.offset, AEROGPU_CMD_BIND_SHADERS);
  if (!Check(bind.hdr != nullptr, "BIND_SHADERS emitted")) {
    return false;
  }
  if (!Check(bind.offset < draw.offset, "BIND_SHADERS occurs before DRAW")) {
    return false;
  }

  const auto* bind_cmd = reinterpret_cast<const aerogpu_cmd_bind_shaders*>(bind.hdr);
  if (!Check(bind_cmd->vs != 0, "BIND_SHADERS has non-zero VS fallback")) {
    return false;
  }
  if (!Check(bind_cmd->ps != 0, "BIND_SHADERS has non-zero PS")) {
    return false;
  }
  return ValidateStream(buf, len);
}

bool TestPartialShaderStageBindingPsOnlyXyzDiffuseUploadsWvpConstants() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3D9DDI_HSHADER hPs{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_ps = false;

    ~Cleanup() {
      if (has_ps && device_funcs.pfnDestroyShader) {
        device_funcs.pfnDestroyShader(hDevice, hPs);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  if (!Check(create_dev.hDevice.pDrvPrivate != nullptr, "CreateDevice returned device handle")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnCreateShader != nullptr, "CreateShader must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetShader != nullptr, "SetShader must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  // Set non-identity transforms: WORLD0 * VIEW * PROJECTION.
  float world[16] = {};
  float view[16] = {};
  float proj[16] = {};
  auto set_identity = [](float m[16]) {
    std::memset(m, 0, sizeof(float) * 16);
    m[0] = 1.0f;
    m[5] = 1.0f;
    m[10] = 1.0f;
    m[15] = 1.0f;
  };
  set_identity(world);
  set_identity(view);
  set_identity(proj);
  // Scale + translate.
  world[0] = 2.0f;
  world[5] = 3.0f;
  world[10] = 4.0f;
  world[12] = 5.0f;
  world[13] = 6.0f;
  world[14] = 7.0f;

  if (!Check(cleanup.device_funcs.pfnSetTransform != nullptr, "SetTransform must be available")) {
    return false;
  }
  D3DMATRIX world_m{};
  D3DMATRIX view_m{};
  D3DMATRIX proj_m{};
  std::memcpy(world_m.m, world, sizeof(world));
  std::memcpy(view_m.m, view, sizeof(view));
  std::memcpy(proj_m.m, proj, sizeof(proj));
  hr = cleanup.device_funcs.pfnSetTransform(create_dev.hDevice, D3DTS_WORLD, &world_m);
  if (!Check(hr == S_OK, "SetTransform(WORLD)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTransform(create_dev.hDevice, D3DTS_VIEW, &view_m);
  if (!Check(hr == S_OK, "SetTransform(VIEW)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTransform(create_dev.hDevice, D3DTS_PROJECTION, &proj_m);
  if (!Check(hr == S_OK, "SetTransform(PROJECTION)")) {
    return false;
  }

  // D3DFVF_XYZ (0x2) | D3DFVF_DIFFUSE (0x40).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x42u);
  if (!Check(hr == S_OK, "SetFVF(XYZ|DIFFUSE)")) {
    return false;
  }

  // Bind a user pixel shader, leave VS NULL (shader stage interop PS-only).
  const uint8_t dxbc[] = {0x44, 0x58, 0x42, 0x43, 0xAA, 0xBB, 0xCC, 0xDD};
  D3D9DDI_HSHADER hPs{};
  hr = cleanup.device_funcs.pfnCreateShader(create_dev.hDevice,
                                            kD3d9ShaderStagePs,
                                            dxbc,
                                            static_cast<uint32_t>(sizeof(dxbc)),
                                            &hPs);
  if (!Check(hr == S_OK, "CreateShader(PS)")) {
    return false;
  }
  if (!Check(hPs.pDrvPrivate != nullptr, "CreateShader returned handle")) {
    return false;
  }
  cleanup.hPs = hPs;
  cleanup.has_ps = true;

  hr = cleanup.device_funcs.pfnSetShader(create_dev.hDevice, kD3d9ShaderStagePs, hPs);
  if (!Check(hr == S_OK, "SetShader(PS)")) {
    return false;
  }
  D3D9DDI_HSHADER null_shader{};
  hr = cleanup.device_funcs.pfnSetShader(create_dev.hDevice, kD3d9ShaderStageVs, null_shader);
  if (!Check(hr == S_OK, "SetShader(VS=NULL)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    uint32_t color;
  };
  constexpr uint32_t kWhite = 0xFFFFFFFFu;
  Vertex tri[3]{};
  tri[0] = {-1.0f, -1.0f, 0.0f, kWhite};
  tri[1] = {1.0f, -1.0f, 0.0f, kWhite};
  tri[2] = {0.0f, 1.0f, 0.0f, kWhite};

  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(
      create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 1, tri, sizeof(Vertex));
  if (!Check(hr == S_OK, "DrawPrimitiveUP(PS-only, XYZ|DIFFUSE)")) {
    return false;
  }

  if (!Check(dev->up_vertex_buffer != nullptr, "up_vertex_buffer allocated")) {
    return false;
  }
  const aerogpu_handle_t up_vb_handle = dev->up_vertex_buffer->handle;
  if (!Check(up_vb_handle != 0, "up_vertex_buffer handle non-zero")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  // Expected WVP columns (transpose of row-major WVP) uploaded to c240..c243.
  float wv[16];
  float wvp[16];
  MulMat4RowMajor(world, view, wv);
  MulMat4RowMajor(wv, proj, wvp);
  float expected_cols[16] = {};
  for (int c = 0; c < 4; ++c) {
    expected_cols[c * 4 + 0] = wvp[0 * 4 + c];
    expected_cols[c * 4 + 1] = wvp[1 * 4 + c];
    expected_cols[c * 4 + 2] = wvp[2 * 4 + c];
    expected_cols[c * 4 + 3] = wvp[3 * 4 + c];
  }

  const CmdLoc upload = FindLastUploadForHandle(buf, len, up_vb_handle);
  if (!Check(upload.hdr != nullptr, "upload_resource(up_vertex_buffer) emitted")) {
    return false;
  }
  const auto* upload_cmd = reinterpret_cast<const aerogpu_cmd_upload_resource*>(upload.hdr);
  if (!Check(upload_cmd->offset_bytes == 0, "upload_resource VB offset is 0")) {
    return false;
  }
  if (!Check(upload_cmd->size_bytes == sizeof(tri), "upload_resource VB size matches original vertex data")) {
    return false;
  }

  const uint8_t* payload = reinterpret_cast<const uint8_t*>(upload_cmd) + sizeof(*upload_cmd);
  float x0 = 0.0f;
  float y0 = 0.0f;
  float z0 = 0.0f;
  uint32_t c0 = 0;
  std::memcpy(&x0, payload + 0, sizeof(float));
  std::memcpy(&y0, payload + 4, sizeof(float));
  std::memcpy(&z0, payload + 8, sizeof(float));
  std::memcpy(&c0, payload + 12, sizeof(uint32_t));

  if (!Check(std::fabs(x0 - tri[0].x) < 1e-6f, "PS-only XYZ UP: x0 preserved (no CPU conversion)")) {
    return false;
  }
  if (!Check(std::fabs(y0 - tri[0].y) < 1e-6f, "PS-only XYZ UP: y0 preserved (no CPU conversion)")) {
    return false;
  }
  if (!Check(std::fabs(z0 - tri[0].z) < 1e-6f, "PS-only XYZ UP: z0 preserved")) {
    return false;
  }
  if (!Check(c0 == kWhite, "PS-only XYZ UP: diffuse color preserved")) {
    return false;
  }

  const CmdLoc wvp_consts = FindLastVsWvpConstants(buf, len);
  if (!Check(wvp_consts.hdr != nullptr, "SET_SHADER_CONSTANTS_F uploads WVP constants")) {
    return false;
  }
  const auto* sc = reinterpret_cast<const aerogpu_cmd_set_shader_constants_f*>(wvp_consts.hdr);
  if (!Check(wvp_consts.hdr->size_bytes >= sizeof(*sc) + sizeof(expected_cols), "WVP constants payload size")) {
    return false;
  }
  const float* cols = reinterpret_cast<const float*>(reinterpret_cast<const uint8_t*>(sc) + sizeof(*sc));
  if (!Check(std::memcmp(cols, expected_cols, sizeof(expected_cols)) == 0, "WVP constants payload matches expected columns")) {
    return false;
  }

  const CmdLoc draw = FindLastOpcode(buf, len, AEROGPU_CMD_DRAW);
  if (!Check(draw.hdr != nullptr, "DRAW emitted")) {
    return false;
  }

  const CmdLoc bind = FindLastOpcodeBefore(buf, len, draw.offset, AEROGPU_CMD_BIND_SHADERS);
  if (!Check(bind.hdr != nullptr, "BIND_SHADERS emitted")) {
    return false;
  }
  if (!Check(bind.offset < draw.offset, "BIND_SHADERS occurs before DRAW")) {
    return false;
  }
  const auto* bind_cmd = reinterpret_cast<const aerogpu_cmd_bind_shaders*>(bind.hdr);
  if (!Check(bind_cmd->vs != 0, "BIND_SHADERS binds non-zero VS fallback")) {
    return false;
  }
  const auto* ps = reinterpret_cast<const Shader*>(hPs.pDrvPrivate);
  const uint32_t expected_ps_handle = ps ? ps->handle : 0;
  if (!Check(bind_cmd->ps == expected_ps_handle, "BIND_SHADERS binds user PS handle")) {
    return false;
  }

  const auto* create_vs = FindCreateShaderByHandle(buf, len, bind_cmd->vs);
  if (!Check(create_vs != nullptr, "CREATE_SHADER_DXBC for VS fallback is present")) {
    return false;
  }
  if (!Check(create_vs->stage == AEROGPU_SHADER_STAGE_VERTEX, "VS fallback stage is VERTEX")) {
    return false;
  }
  if (!Check(create_vs->dxbc_size_bytes == sizeof(fixedfunc::kVsWvpPosColor), "VS fallback bytecode size matches")) {
    return false;
  }
  {
    const uint8_t* vs_payload = reinterpret_cast<const uint8_t*>(create_vs) + sizeof(*create_vs);
    if (!Check(std::memcmp(vs_payload, fixedfunc::kVsWvpPosColor, sizeof(fixedfunc::kVsWvpPosColor)) == 0,
               "VS fallback bytecode matches fixedfunc WVP shader")) {
      return false;
    }
  }

  if (!CheckWvpConstantsUploadedBeforeDraw(buf, len, draw.offset, wvp, "PS-only XYZ: WVP constants uploaded")) {
    return false;
  }

  return ValidateStream(buf, len);
}

bool TestDestroyBoundVertexDeclUnbinds() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3D9DDI_HVERTEXDECL hDecl{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_decl = false;

    ~Cleanup() {
      if (has_decl && device_funcs.pfnDestroyVertexDecl) {
        device_funcs.pfnDestroyVertexDecl(hDevice, hDecl);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  if (!Check(create_dev.hDevice.pDrvPrivate != nullptr, "CreateDevice returned device handle")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  const uint8_t blob[] = {0x01, 0x02, 0x03, 0x04};
  D3D9DDI_HVERTEXDECL hDecl{};
  hr = cleanup.device_funcs.pfnCreateVertexDecl(create_dev.hDevice,
                                                blob,
                                                static_cast<uint32_t>(sizeof(blob)),
                                                &hDecl);
  if (!Check(hr == S_OK, "CreateVertexDecl")) {
    return false;
  }
  if (!Check(hDecl.pDrvPrivate != nullptr, "CreateVertexDecl returned handle")) {
    return false;
  }
  cleanup.hDecl = hDecl;
  cleanup.has_decl = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  auto* decl = reinterpret_cast<VertexDecl*>(hDecl.pDrvPrivate);

  hr = cleanup.device_funcs.pfnSetVertexDecl(create_dev.hDevice, hDecl);
  if (!Check(hr == S_OK, "SetVertexDecl")) {
    return false;
  }
  if (!Check(dev->vertex_decl == decl, "SetVertexDecl updates cached decl pointer")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnDestroyVertexDecl(create_dev.hDevice, hDecl);
  if (!Check(hr == S_OK, "DestroyVertexDecl")) {
    return false;
  }
  cleanup.has_decl = false;

  if (!Check(dev->vertex_decl == nullptr, "DestroyVertexDecl clears cached decl pointer")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  const CmdLoc set_layout = FindLastOpcode(buf, len, AEROGPU_CMD_SET_INPUT_LAYOUT);
  if (!Check(set_layout.hdr != nullptr, "set_input_layout emitted")) {
    return false;
  }
  const auto* set_cmd = reinterpret_cast<const aerogpu_cmd_set_input_layout*>(set_layout.hdr);
  if (!Check(set_cmd->input_layout_handle == 0, "set_input_layout clears handle")) {
    return false;
  }

  const CmdLoc destroy = FindLastOpcode(buf, len, AEROGPU_CMD_DESTROY_INPUT_LAYOUT);
  if (!Check(destroy.hdr != nullptr, "destroy_input_layout emitted")) {
    return false;
  }
  return Check(set_layout.offset < destroy.offset, "unbind occurs before destroy");
}

bool TestSetVertexDeclDerivesFixedFunctionFvf() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  if (!Check(create_dev.hDevice.pDrvPrivate != nullptr, "CreateDevice returned device handle")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateVertexDecl != nullptr, "CreateVertexDecl must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetVertexDecl != nullptr, "SetVertexDecl must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDestroyVertexDecl != nullptr, "DestroyVertexDecl must be available")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  auto run_case = [&](const D3DVERTEXELEMENT9_COMPAT* elems,
                      size_t elem_count,
                      uint32_t expected_fvf,
                      const char* name) -> bool {
    D3D9DDI_HVERTEXDECL hDecl{};
    const uint32_t decl_size = static_cast<uint32_t>(elem_count * sizeof(D3DVERTEXELEMENT9_COMPAT));
    HRESULT hr = cleanup.device_funcs.pfnCreateVertexDecl(create_dev.hDevice, elems, decl_size, &hDecl);
    if (!Check(hr == S_OK, name)) {
      return false;
    }
    if (!Check(hDecl.pDrvPrivate != nullptr, "CreateVertexDecl returned handle")) {
      return false;
    }

    hr = cleanup.device_funcs.pfnSetVertexDecl(create_dev.hDevice, hDecl);
    if (!Check(hr == S_OK, "SetVertexDecl")) {
      cleanup.device_funcs.pfnDestroyVertexDecl(create_dev.hDevice, hDecl);
      return false;
    }
    if (!Check(dev->fvf == expected_fvf, "derived dev->fvf matches expected")) {
      cleanup.device_funcs.pfnDestroyVertexDecl(create_dev.hDevice, hDecl);
      return false;
    }

    hr = cleanup.device_funcs.pfnDestroyVertexDecl(create_dev.hDevice, hDecl);
    if (!Check(hr == S_OK, "DestroyVertexDecl")) {
      return false;
    }
    return true;
  };

  // Existing bring-up path: XYZRHW|DIFFUSE (POSITIONT float4 + COLOR0 D3DCOLOR).
  const D3DVERTEXELEMENT9_COMPAT decl_xyzrhw_diffuse[] = {
      {0, 0, kD3dDeclTypeFloat4, kD3dDeclMethodDefault, /*Usage=*/0, 0},
      {0, 16, kD3dDeclTypeD3dColor, kD3dDeclMethodDefault, kD3dDeclUsageColor, 0},
      {0xFF, 0, kD3dDeclTypeUnused, 0, 0, 0}, // D3DDECL_END
  };

  // XYZRHW|DIFFUSE|TEX1: + TEXCOORD0 float2 at offset 20.
  const D3DVERTEXELEMENT9_COMPAT decl_xyzrhw_diffuse_tex1[] = {
      {0, 0, kD3dDeclTypeFloat4, kD3dDeclMethodDefault, kD3dDeclUsagePositionT, 0},
      {0, 16, kD3dDeclTypeD3dColor, kD3dDeclMethodDefault, kD3dDeclUsageColor, 0},
      {0, 20, kD3dDeclTypeFloat2, kD3dDeclMethodDefault, kD3dDeclUsageTexcoord, 0},
      {0xFF, 0, kD3dDeclTypeUnused, 0, 0, 0}, // D3DDECL_END
  };

  // Same as above but with TEXCOORD0 encoded as Usage=0 (some runtimes appear to
  // leave Usage as 0 when synthesizing fixed-function decls).
  const D3DVERTEXELEMENT9_COMPAT decl_xyzrhw_diffuse_tex1_usage0[] = {
      {0, 0, kD3dDeclTypeFloat4, kD3dDeclMethodDefault, kD3dDeclUsagePositionT, 0},
      {0, 16, kD3dDeclTypeD3dColor, kD3dDeclMethodDefault, kD3dDeclUsageColor, 0},
      {0, 20, kD3dDeclTypeFloat2, kD3dDeclMethodDefault, /*Usage=*/0, 0},
      {0xFF, 0, kD3dDeclTypeUnused, 0, 0, 0}, // D3DDECL_END
  };

  // XYZ|DIFFUSE: POSITION float3 + COLOR0 D3DCOLOR.
  const D3DVERTEXELEMENT9_COMPAT decl_xyz_diffuse[] = {
      {0, 0, kD3dDeclTypeFloat3, kD3dDeclMethodDefault, /*Usage=*/0, 0},
      {0, 12, kD3dDeclTypeD3dColor, kD3dDeclMethodDefault, kD3dDeclUsageColor, 0},
      {0xFF, 0, kD3dDeclTypeUnused, 0, 0, 0}, // D3DDECL_END
  };

  // XYZ|DIFFUSE|TEX1: + TEXCOORD0 float2 at offset 16.
  const D3DVERTEXELEMENT9_COMPAT decl_xyz_diffuse_tex1[] = {
      {0, 0, kD3dDeclTypeFloat3, kD3dDeclMethodDefault, /*Usage=*/0, 0},
      {0, 12, kD3dDeclTypeD3dColor, kD3dDeclMethodDefault, kD3dDeclUsageColor, 0},
      {0, 16, kD3dDeclTypeFloat2, kD3dDeclMethodDefault, kD3dDeclUsageTexcoord, 0},
      {0xFF, 0, kD3dDeclTypeUnused, 0, 0, 0}, // D3DDECL_END
  };

  const D3DVERTEXELEMENT9_COMPAT decl_xyz_diffuse_tex1_usage0[] = {
      {0, 0, kD3dDeclTypeFloat3, kD3dDeclMethodDefault, /*Usage=*/0, 0},
      {0, 12, kD3dDeclTypeD3dColor, kD3dDeclMethodDefault, kD3dDeclUsageColor, 0},
      {0, 16, kD3dDeclTypeFloat2, kD3dDeclMethodDefault, /*Usage=*/0, 0},
      {0xFF, 0, kD3dDeclTypeUnused, 0, 0, 0}, // D3DDECL_END
  };

  // Some runtimes include additional bytes/elements beyond the first D3DDECL_END.
  // The fixed-function decl detector should ignore this trailing padding.
  const D3DVERTEXELEMENT9_COMPAT decl_xyzrhw_diffuse_trailing[] = {
      {0, 0, kD3dDeclTypeFloat4, kD3dDeclMethodDefault, /*Usage=*/0, 0},
      {0, 16, kD3dDeclTypeD3dColor, kD3dDeclMethodDefault, kD3dDeclUsageColor, 0},
      {0xFF, 0, kD3dDeclTypeUnused, 0, 0, 0}, // D3DDECL_END
      {},                                     // ignored padding
  };

  const D3DVERTEXELEMENT9_COMPAT decl_xyzrhw_diffuse_tex1_trailing[] = {
      {0, 0, kD3dDeclTypeFloat4, kD3dDeclMethodDefault, kD3dDeclUsagePositionT, 0},
      {0, 16, kD3dDeclTypeD3dColor, kD3dDeclMethodDefault, kD3dDeclUsageColor, 0},
      {0, 20, kD3dDeclTypeFloat2, kD3dDeclMethodDefault, kD3dDeclUsageTexcoord, 0},
      {0xFF, 0, kD3dDeclTypeUnused, 0, 0, 0}, // D3DDECL_END
      {},                                     // ignored padding
  };

  const D3DVERTEXELEMENT9_COMPAT decl_xyz_diffuse_trailing[] = {
      {0, 0, kD3dDeclTypeFloat3, kD3dDeclMethodDefault, /*Usage=*/0, 0},
      {0, 12, kD3dDeclTypeD3dColor, kD3dDeclMethodDefault, kD3dDeclUsageColor, 0},
      {0xFF, 0, kD3dDeclTypeUnused, 0, 0, 0}, // D3DDECL_END
      {},                                     // ignored padding
  };

  const D3DVERTEXELEMENT9_COMPAT decl_xyz_diffuse_tex1_trailing[] = {
      {0, 0, kD3dDeclTypeFloat3, kD3dDeclMethodDefault, /*Usage=*/0, 0},
      {0, 12, kD3dDeclTypeD3dColor, kD3dDeclMethodDefault, kD3dDeclUsageColor, 0},
      {0, 16, kD3dDeclTypeFloat2, kD3dDeclMethodDefault, kD3dDeclUsageTexcoord, 0},
      {0xFF, 0, kD3dDeclTypeUnused, 0, 0, 0}, // D3DDECL_END
      {},                                     // ignored padding
  };

  // Plain position-only decls (no DIFFUSE/TEX).
  const D3DVERTEXELEMENT9_COMPAT decl_xyzrhw[] = {
      {0, 0, kD3dDeclTypeFloat4, kD3dDeclMethodDefault, kD3dDeclUsagePositionT, 0},
      {0xFF, 0, kD3dDeclTypeUnused, 0, 0, 0}, // D3DDECL_END
  };

  const D3DVERTEXELEMENT9_COMPAT decl_xyz[] = {
      {0, 0, kD3dDeclTypeFloat3, kD3dDeclMethodDefault, /*Usage=*/0, 0},
      {0xFF, 0, kD3dDeclTypeUnused, 0, 0, 0}, // D3DDECL_END
  };

  // TEXCOORD0 float3 variant: infer D3DFVF_TEXCOORDSIZE3(0) (bits 16..17 == 1).
  const D3DVERTEXELEMENT9_COMPAT decl_xyz_tex1_f3[] = {
      {0, 0, kD3dDeclTypeFloat3, kD3dDeclMethodDefault, /*Usage=*/0, 0},
      {0, 12, kD3dDeclTypeFloat3, kD3dDeclMethodDefault, kD3dDeclUsageTexcoord, 0},
      {0xFF, 0, kD3dDeclTypeUnused, 0, 0, 0}, // D3DDECL_END
  };

  const D3DVERTEXELEMENT9_COMPAT decl_xyzrhw_diffuse_tex1_f3[] = {
      {0, 0, kD3dDeclTypeFloat4, kD3dDeclMethodDefault, kD3dDeclUsagePositionT, 0},
      {0, 16, kD3dDeclTypeD3dColor, kD3dDeclMethodDefault, kD3dDeclUsageColor, 0},
      {0, 20, kD3dDeclTypeFloat3, kD3dDeclMethodDefault, kD3dDeclUsageTexcoord, 0},
      {0xFF, 0, kD3dDeclTypeUnused, 0, 0, 0}, // D3DDECL_END
  };

  if (!run_case(decl_xyzrhw_diffuse,
                sizeof(decl_xyzrhw_diffuse) / sizeof(decl_xyzrhw_diffuse[0]),
                kD3dFvfXyzRhw | kD3dFvfDiffuse,
                "CreateVertexDecl(XYZRHW|DIFFUSE)")) {
    return false;
  }
  if (!run_case(decl_xyzrhw,
                sizeof(decl_xyzrhw) / sizeof(decl_xyzrhw[0]),
                kD3dFvfXyzRhw,
                "CreateVertexDecl(XYZRHW)")) {
    return false;
  }
  if (!run_case(decl_xyzrhw_diffuse_tex1,
                sizeof(decl_xyzrhw_diffuse_tex1) / sizeof(decl_xyzrhw_diffuse_tex1[0]),
                kD3dFvfXyzRhw | kD3dFvfDiffuse | kD3dFvfTex1,
                "CreateVertexDecl(XYZRHW|DIFFUSE|TEX1)")) {
    return false;
  }
  if (!run_case(decl_xyzrhw_diffuse_tex1_usage0,
                sizeof(decl_xyzrhw_diffuse_tex1_usage0) / sizeof(decl_xyzrhw_diffuse_tex1_usage0[0]),
                kD3dFvfXyzRhw | kD3dFvfDiffuse | kD3dFvfTex1,
                "CreateVertexDecl(XYZRHW|DIFFUSE|TEX1, tex Usage=0)")) {
    return false;
  }
  if (!run_case(decl_xyz_diffuse,
                sizeof(decl_xyz_diffuse) / sizeof(decl_xyz_diffuse[0]),
                kD3dFvfXyz | kD3dFvfDiffuse,
                "CreateVertexDecl(XYZ|DIFFUSE)")) {
    return false;
  }
  if (!run_case(decl_xyz,
                sizeof(decl_xyz) / sizeof(decl_xyz[0]),
                kD3dFvfXyz,
                "CreateVertexDecl(XYZ)")) {
    return false;
  }
  if (!run_case(decl_xyz_diffuse_tex1,
                sizeof(decl_xyz_diffuse_tex1) / sizeof(decl_xyz_diffuse_tex1[0]),
                kD3dFvfXyz | kD3dFvfDiffuse | kD3dFvfTex1,
                "CreateVertexDecl(XYZ|DIFFUSE|TEX1)")) {
    return false;
  }
  if (!run_case(decl_xyz_tex1_f3,
                sizeof(decl_xyz_tex1_f3) / sizeof(decl_xyz_tex1_f3[0]),
                kD3dFvfXyz | kD3dFvfTex1 | (1u << 16),
                "CreateVertexDecl(XYZ|TEX1, TEX0=float3)")) {
    return false;
  }
  if (!run_case(decl_xyzrhw_diffuse_tex1_f3,
                sizeof(decl_xyzrhw_diffuse_tex1_f3) / sizeof(decl_xyzrhw_diffuse_tex1_f3[0]),
                kD3dFvfXyzRhw | kD3dFvfDiffuse | kD3dFvfTex1 | (1u << 16),
                "CreateVertexDecl(XYZRHW|DIFFUSE|TEX1, TEX0=float3)")) {
    return false;
  }
  if (!run_case(decl_xyz_diffuse_tex1_usage0,
                sizeof(decl_xyz_diffuse_tex1_usage0) / sizeof(decl_xyz_diffuse_tex1_usage0[0]),
                kD3dFvfXyz | kD3dFvfDiffuse | kD3dFvfTex1,
                "CreateVertexDecl(XYZ|DIFFUSE|TEX1, tex Usage=0)")) {
    return false;
  }

  if (!run_case(decl_xyzrhw_diffuse_trailing,
                sizeof(decl_xyzrhw_diffuse_trailing) / sizeof(decl_xyzrhw_diffuse_trailing[0]),
                kD3dFvfXyzRhw | kD3dFvfDiffuse,
                "CreateVertexDecl(XYZRHW|DIFFUSE, trailing padding)")) {
    return false;
  }
  if (!run_case(decl_xyzrhw_diffuse_tex1_trailing,
                sizeof(decl_xyzrhw_diffuse_tex1_trailing) / sizeof(decl_xyzrhw_diffuse_tex1_trailing[0]),
                kD3dFvfXyzRhw | kD3dFvfDiffuse | kD3dFvfTex1,
                "CreateVertexDecl(XYZRHW|DIFFUSE|TEX1, trailing padding)")) {
    return false;
  }
  if (!run_case(decl_xyz_diffuse_trailing,
                sizeof(decl_xyz_diffuse_trailing) / sizeof(decl_xyz_diffuse_trailing[0]),
                kD3dFvfXyz | kD3dFvfDiffuse,
                "CreateVertexDecl(XYZ|DIFFUSE, trailing padding)")) {
    return false;
  }
  return run_case(decl_xyz_diffuse_tex1_trailing,
                  sizeof(decl_xyz_diffuse_tex1_trailing) / sizeof(decl_xyz_diffuse_tex1_trailing[0]),
                  kD3dFvfXyz | kD3dFvfDiffuse | kD3dFvfTex1,
                  "CreateVertexDecl(XYZ|DIFFUSE|TEX1, trailing padding)");
}

bool TestFvfXyzrhwDiffuseDrawPrimitiveUpEmitsFixedfuncCommands() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }

  D3DDDIVIEWPORTINFO vp{};
  vp.X = 0.0f;
  vp.Y = 0.0f;
  vp.Width = 256.0f;
  vp.Height = 256.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }

  // D3DFVF_XYZRHW (0x4) | D3DFVF_DIFFUSE (0x40).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x44u);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|DIFFUSE)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    float rhw;
    uint32_t color;
  };

  constexpr uint32_t kGreen = 0xFF00FF00u;
  Vertex verts[3]{};
  verts[0] = {256.0f * 0.25f, 256.0f * 0.25f, 0.5f, 1.0f, kGreen};
  verts[1] = {256.0f * 0.75f, 256.0f * 0.25f, 0.5f, 1.0f, kGreen};
  verts[2] = {256.0f * 0.50f, 256.0f * 0.75f, 0.5f, 1.0f, kGreen};

  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(
      create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 1, verts, sizeof(Vertex));
  if (!Check(hr == S_OK, "DrawPrimitiveUP")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_CREATE_SHADER_DXBC) >= 2,
             "fixed-function fallback creates shaders")) {
    return false;
  }

  const CmdLoc bind = FindLastOpcode(buf, len, AEROGPU_CMD_BIND_SHADERS);
  if (!Check(bind.hdr != nullptr, "bind_shaders emitted")) {
    return false;
  }
  const auto* bind_cmd = reinterpret_cast<const aerogpu_cmd_bind_shaders*>(bind.hdr);
  if (!Check(bind_cmd->vs != 0 && bind_cmd->ps != 0, "bind_shaders uses non-zero VS/PS handles")) {
    return false;
  }

  const CmdLoc upload = FindLastOpcode(buf, len, AEROGPU_CMD_UPLOAD_RESOURCE);
  if (!Check(upload.hdr != nullptr, "upload_resource emitted")) {
    return false;
  }
  const auto* upload_cmd = reinterpret_cast<const aerogpu_cmd_upload_resource*>(upload.hdr);
  if (!Check(upload_cmd->offset_bytes == 0, "upload_resource offset is 0")) {
    return false;
  }
  if (!Check(upload_cmd->size_bytes == sizeof(verts), "upload_resource size matches vertex data")) {
    return false;
  }

  const uint8_t* payload = reinterpret_cast<const uint8_t*>(upload_cmd) + sizeof(*upload_cmd);
  float x0 = 0.0f;
  float y0 = 0.0f;
  float z0 = 0.0f;
  float w0 = 0.0f;
  uint32_t c0 = 0;
  std::memcpy(&x0, payload + 0, sizeof(float));
  std::memcpy(&y0, payload + 4, sizeof(float));
  std::memcpy(&z0, payload + 8, sizeof(float));
  std::memcpy(&w0, payload + 12, sizeof(float));
  std::memcpy(&c0, payload + 16, sizeof(uint32_t));

  const float expected_x0 = ((verts[0].x + 0.5f - vp.X) / vp.Width) * 2.0f - 1.0f;
  const float expected_y0 = 1.0f - ((verts[0].y + 0.5f - vp.Y) / vp.Height) * 2.0f;
  if (!Check(std::fabs(x0 - expected_x0) < 1e-6f, "XYZRHW->clip: x0 matches half-pixel convention")) {
    return false;
  }
  if (!Check(std::fabs(y0 - expected_y0) < 1e-6f, "XYZRHW->clip: y0 matches half-pixel convention")) {
    return false;
  }
  if (!Check(std::fabs(z0 - verts[0].z) < 1e-6f, "XYZRHW->clip: z preserved")) {
    return false;
  }
  if (!Check(std::fabs(w0 - 1.0f) < 1e-6f, "XYZRHW->clip: w preserved")) {
    return false;
  }
  return Check(c0 == kGreen, "XYZRHW->clip: diffuse color preserved");
}

bool TestFvfXyzrhwDiffuseTex1DrawPrimitiveUpEmitsFixedfuncCommands() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hTex{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_tex = false;

    ~Cleanup() {
      if (has_tex && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hTex);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetTexture != nullptr, "SetTexture must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  // Reset so the stream only contains commands relevant to this test.
  dev->cmd.reset();

  D3DDDIVIEWPORTINFO vp{};
  vp.X = 0.0f;
  vp.Y = 0.0f;
  vp.Width = 256.0f;
  vp.Height = 256.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }

  // Create a tiny host-backed texture so stage0 can select a texture-sampling
  // fixed-function pixel shader.
  D3D9DDIARG_CREATERESOURCE create_tex{};
  create_tex.type = kD3dRTypeTexture;
  create_tex.format = 22u; // D3DFMT_X8R8G8B8
  create_tex.width = 2;
  create_tex.height = 2;
  create_tex.depth = 1;
  create_tex.mip_levels = 1;
  create_tex.usage = 0;
  create_tex.pool = 0;
  create_tex.size = 0;
  create_tex.hResource.pDrvPrivate = nullptr;
  create_tex.pSharedHandle = nullptr;
  create_tex.pPrivateDriverData = nullptr;
  create_tex.PrivateDriverDataSize = 0;
  create_tex.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_tex);
  if (!CheckHr(hr, S_OK, "CreateResource(texture)")) {
    return false;
  }
  if (!Check(create_tex.hResource.pDrvPrivate != nullptr, "CreateResource returned texture handle")) {
    return false;
  }
  cleanup.hTex = create_tex.hResource;
  cleanup.has_tex = true;

  hr = cleanup.device_funcs.pfnSetTexture(create_dev.hDevice, 0, create_tex.hResource);
  if (!Check(hr == S_OK, "SetTexture(0)")) {
    return false;
  }

  // D3DFVF_XYZRHW (0x4) | D3DFVF_DIFFUSE (0x40) | D3DFVF_TEX1 (0x100).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x144u);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|DIFFUSE|TEX1)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    float rhw;
    uint32_t color;
    float u;
    float v;
  };

  constexpr uint32_t kGreen = 0xFF00FF00u;
  Vertex verts[3]{};
  verts[0] = {256.0f * 0.25f, 256.0f * 0.25f, 0.5f, 1.0f, kGreen, 0.0f, 0.0f};
  verts[1] = {256.0f * 0.75f, 256.0f * 0.25f, 0.5f, 1.0f, kGreen, 1.0f, 0.0f};
  verts[2] = {256.0f * 0.50f, 256.0f * 0.75f, 0.5f, 1.0f, kGreen, 0.5f, 1.0f};

  // Draw twice to ensure fixed-function internal objects are cached.
  for (int i = 0; i < 2; ++i) {
    hr = cleanup.device_funcs.pfnDrawPrimitiveUP(
        create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 1, verts, sizeof(Vertex));
    if (!Check(hr == S_OK, "DrawPrimitiveUP")) {
      return false;
    }
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  const FixedFuncVariant variant = fixedfunc_variant_from_fvf(0x144u);
  if (!Check(variant != FixedFuncVariant::NONE, "fixed-function variant recognized")) {
    return false;
  }
  const auto& pipe = dev->fixedfunc_pipelines[static_cast<size_t>(variant)];

  if (!Check(pipe.vertex_decl != nullptr, "internal FVF vertex decl created")) {
    return false;
  }
  if (!Check(pipe.vs != nullptr && pipe.ps != nullptr,
             "internal fixed-function shaders created")) {
    return false;
  }

  const aerogpu_handle_t decl_handle = pipe.vertex_decl->handle;
  const aerogpu_handle_t vs_handle = pipe.vs->handle;
  const aerogpu_handle_t ps_handle = pipe.ps->handle;

  if (!Check(decl_handle != 0, "internal decl handle non-zero")) {
    return false;
  }
  if (!Check(vs_handle != 0 && ps_handle != 0, "fixed-function shader handles non-zero")) {
    return false;
  }

  // Verify internal decl blob matches the expected FVF layout.
  const D3DVERTEXELEMENT9_COMPAT expected_decl[] = {
      {0, 0, kD3dDeclTypeFloat4, kD3dDeclMethodDefault, kD3dDeclUsagePositionT, 0},
      {0, 16, kD3dDeclTypeD3dColor, kD3dDeclMethodDefault, kD3dDeclUsageColor, 0},
      {0, 20, kD3dDeclTypeFloat2, kD3dDeclMethodDefault, kD3dDeclUsageTexcoord, 0},
      {0xFF, 0, kD3dDeclTypeUnused, 0, 0, 0},
  };
  if (!Check(pipe.vertex_decl->blob.size() == sizeof(expected_decl), "FVF TEX1 decl blob size")) {
    return false;
  }
  if (!Check(std::memcmp(pipe.vertex_decl->blob.data(), expected_decl, sizeof(expected_decl)) == 0,
             "FVF TEX1 decl blob matches expected layout")) {
    return false;
  }

  if (!Check(CountCreateInputLayoutWithHandle(buf, len, decl_handle) == 1,
             "fixed-function TEX1 path creates internal input layout once")) {
    return false;
  }
  if (!Check(CountCreateShaderDxbcWithHandle(buf, len, vs_handle, AEROGPU_SHADER_STAGE_VERTEX) == 1,
             "fixed-function TEX1 path creates internal VS once")) {
    return false;
  }
  if (!Check(CountCreateShaderDxbcWithHandle(buf, len, ps_handle, AEROGPU_SHADER_STAGE_PIXEL) == 1,
             "fixed-function TEX1 path creates internal PS once")) {
    return false;
  }

  const CmdLoc set_layout = FindLastOpcode(buf, len, AEROGPU_CMD_SET_INPUT_LAYOUT);
  if (!Check(set_layout.hdr != nullptr, "set_input_layout emitted")) {
    return false;
  }
  const auto* set_cmd = reinterpret_cast<const aerogpu_cmd_set_input_layout*>(set_layout.hdr);
  if (!Check(set_cmd->input_layout_handle == decl_handle, "set_input_layout binds TEX1 internal decl")) {
    return false;
  }

  const CmdLoc bind = FindLastOpcode(buf, len, AEROGPU_CMD_BIND_SHADERS);
  if (!Check(bind.hdr != nullptr, "bind_shaders emitted")) {
    return false;
  }
  const auto* bind_cmd = reinterpret_cast<const aerogpu_cmd_bind_shaders*>(bind.hdr);
  if (!Check(bind_cmd->vs == vs_handle, "bind_shaders VS matches fixed-function TEX1 VS")) {
    return false;
  }
  if (!Check(bind_cmd->ps == ps_handle, "bind_shaders PS matches fixed-function TEX1 PS")) {
    return false;
  }

  // Validate that the XYZRHW vertices were converted to clip-space and that the
  // extra TEXCOORD field is preserved by the conversion.
  const CmdLoc draw = FindLastOpcode(buf, len, AEROGPU_CMD_DRAW);
  if (!Check(draw.hdr != nullptr, "draw emitted")) {
    return false;
  }
  const CmdLoc upload = FindLastOpcodeBefore(buf, len, draw.offset, AEROGPU_CMD_UPLOAD_RESOURCE);
  if (!Check(upload.hdr != nullptr, "upload_resource emitted")) {
    return false;
  }
  const auto* upload_cmd = reinterpret_cast<const aerogpu_cmd_upload_resource*>(upload.hdr);
  if (!Check(upload_cmd->offset_bytes == 0, "upload_resource offset is 0")) {
    return false;
  }
  if (!Check(upload_cmd->size_bytes == sizeof(verts), "upload_resource size matches vertex data")) {
    return false;
  }

  const uint8_t* payload = reinterpret_cast<const uint8_t*>(upload_cmd) + sizeof(*upload_cmd);
  float x0 = 0.0f;
  float y0 = 0.0f;
  float z0 = 0.0f;
  float w0 = 0.0f;
  uint32_t c0 = 0;
  float u0 = 0.0f;
  float v0 = 0.0f;
  std::memcpy(&x0, payload + 0, sizeof(float));
  std::memcpy(&y0, payload + 4, sizeof(float));
  std::memcpy(&z0, payload + 8, sizeof(float));
  std::memcpy(&w0, payload + 12, sizeof(float));
  std::memcpy(&c0, payload + 16, sizeof(uint32_t));
  std::memcpy(&u0, payload + 20, sizeof(float));
  std::memcpy(&v0, payload + 24, sizeof(float));

  const float expected_x0 = ((verts[0].x + 0.5f - vp.X) / vp.Width) * 2.0f - 1.0f;
  const float expected_y0 = 1.0f - ((verts[0].y + 0.5f - vp.Y) / vp.Height) * 2.0f;
  if (!Check(std::fabs(x0 - expected_x0) < 1e-6f, "XYZRHW|TEX1->clip: x0 matches half-pixel convention")) {
    return false;
  }
  if (!Check(std::fabs(y0 - expected_y0) < 1e-6f, "XYZRHW|TEX1->clip: y0 matches half-pixel convention")) {
    return false;
  }
  if (!Check(std::fabs(z0 - verts[0].z) < 1e-6f, "XYZRHW|TEX1->clip: z preserved")) {
    return false;
  }
  if (!Check(std::fabs(w0 - 1.0f) < 1e-6f, "XYZRHW|TEX1->clip: w preserved")) {
    return false;
  }
  if (!Check(c0 == kGreen, "XYZRHW|TEX1->clip: diffuse color preserved")) {
    return false;
  }
  if (!Check(std::fabs(u0 - verts[0].u) < 1e-6f, "XYZRHW|TEX1->clip: u preserved")) {
    return false;
  }
  return Check(std::fabs(v0 - verts[0].v) < 1e-6f, "XYZRHW|TEX1->clip: v preserved");
}

bool TestFvfXyzrhwTex1TexcoordSize1DrawPrimitiveUpEmitsFixedfuncCommands() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;
 
    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;
 
  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;
 
  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;
 
  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
 
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;
 
  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }
 
  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
 
  // Reset so the stream only contains commands relevant to this test.
  dev->cmd.reset();
 
  // Use a valid viewport so XYZRHW conversion doesn't divide by 0.
  D3DDDIVIEWPORTINFO vp{};
  vp.X = 0.0f;
  vp.Y = 0.0f;
  vp.Width = 256.0f;
  vp.Height = 256.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }
 
  // D3DFVF_XYZRHW (0x4) | D3DFVF_TEX1 (0x100) | D3DFVF_TEXCOORDSIZE1(0) (0x30000).
  constexpr uint32_t kTexcoordSize1Tex0 = 3u << 16u;
  constexpr uint32_t kFvf = kD3dFvfXyzRhw | kD3dFvfTex1 | kTexcoordSize1Tex0; // 0x30104
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, kFvf);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|TEX1|TEXCOORDSIZE1(0))")) {
    return false;
  }
  if (!Check(dev->fvf == kFvf, "GetFVF returns TEXCOORDSIZE bits")) {
    return false;
  }
 
  struct Vertex {
    float x;
    float y;
    float z;
    float rhw;
    float u;
  };
 
  Vertex verts[3]{};
  verts[0] = {256.0f * 0.25f, 256.0f * 0.25f, 0.5f, 1.0f, 0.0f};
  verts[1] = {256.0f * 0.75f, 256.0f * 0.25f, 0.5f, 1.0f, 1.0f};
  verts[2] = {256.0f * 0.50f, 256.0f * 0.75f, 0.5f, 1.0f, 0.5f};
 
  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 1, verts, sizeof(Vertex));
  if (!Check(hr == S_OK, "DrawPrimitiveUP(XYZRHW|TEX1|TEXCOORDSIZE1(0))")) {
    return false;
  }
 
  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();
 
  // Verify SetFVF synthesized a matching internal input layout (POSITIONT float4 + TEXCOORD0 float1).
  const auto it = dev->fvf_vertex_decl_cache.find(kFvf);
  if (!Check(it != dev->fvf_vertex_decl_cache.end(), "FVF decl cached for TEXCOORDSIZE1")) {
    return false;
  }
  VertexDecl* decl = it->second;
  if (!Check(decl != nullptr, "cached decl is non-null")) {
    return false;
  }
  const D3DVERTEXELEMENT9_COMPAT expected_decl[] = {
      {0, 0, kD3dDeclTypeFloat4, kD3dDeclMethodDefault, kD3dDeclUsagePositionT, 0},
      {0, 16, kD3dDeclTypeFloat1, kD3dDeclMethodDefault, kD3dDeclUsageTexcoord, 0},
      {0xFF, 0, kD3dDeclTypeUnused, 0, 0, 0},
  };
  if (!Check(decl->blob.size() == sizeof(expected_decl), "FVF TEXCOORDSIZE1 decl blob size")) {
    return false;
  }
  if (!Check(std::memcmp(decl->blob.data(), expected_decl, sizeof(expected_decl)) == 0,
             "FVF TEXCOORDSIZE1 decl blob matches expected layout")) {
    return false;
  }
  if (!Check(CountCreateInputLayoutWithHandle(buf, len, decl->handle) == 1,
             "SetFVF(XYZRHW|TEX1|TEXCOORDSIZE1(0)) creates internal input layout once")) {
    return false;
  }
 
  // Validate that the XYZRHW vertices were converted to clip-space and that the
  // extra TEXCOORD field is preserved by the conversion.
  const CmdLoc draw = FindLastOpcode(buf, len, AEROGPU_CMD_DRAW);
  if (!Check(draw.hdr != nullptr, "draw emitted")) {
    return false;
  }
  const CmdLoc upload = FindLastOpcodeBefore(buf, len, draw.offset, AEROGPU_CMD_UPLOAD_RESOURCE);
  if (!Check(upload.hdr != nullptr, "upload_resource emitted")) {
    return false;
  }
  const auto* upload_cmd = reinterpret_cast<const aerogpu_cmd_upload_resource*>(upload.hdr);
  if (!Check(upload_cmd->offset_bytes == 0, "upload_resource offset is 0")) {
    return false;
  }
  if (!Check(upload_cmd->size_bytes == sizeof(verts), "upload_resource size matches vertex data")) {
    return false;
  }
 
  const uint8_t* payload = reinterpret_cast<const uint8_t*>(upload_cmd) + sizeof(*upload_cmd);
  float x0 = 0.0f;
  float y0 = 0.0f;
  float z0 = 0.0f;
  float w0 = 0.0f;
  float u0 = 0.0f;
  std::memcpy(&x0, payload + 0, sizeof(float));
  std::memcpy(&y0, payload + 4, sizeof(float));
  std::memcpy(&z0, payload + 8, sizeof(float));
  std::memcpy(&w0, payload + 12, sizeof(float));
  std::memcpy(&u0, payload + 16, sizeof(float));
 
  const float expected_x0 = ((verts[0].x + 0.5f - vp.X) / vp.Width) * 2.0f - 1.0f;
  const float expected_y0 = 1.0f - ((verts[0].y + 0.5f - vp.Y) / vp.Height) * 2.0f;
  if (!Check(std::fabs(x0 - expected_x0) < 1e-6f, "XYZRHW|TEXCOORDSIZE1->clip: x0 matches half-pixel convention")) {
    return false;
  }
  if (!Check(std::fabs(y0 - expected_y0) < 1e-6f, "XYZRHW|TEXCOORDSIZE1->clip: y0 matches half-pixel convention")) {
    return false;
  }
  if (!Check(std::fabs(z0 - verts[0].z) < 1e-6f, "XYZRHW|TEXCOORDSIZE1->clip: z preserved")) {
    return false;
  }
  if (!Check(std::fabs(w0 - 1.0f) < 1e-6f, "XYZRHW|TEXCOORDSIZE1->clip: w preserved")) {
    return false;
  }
  return Check(std::fabs(u0 - verts[0].u) < 1e-6f, "XYZRHW|TEXCOORDSIZE1->clip: u preserved");
}

bool TestSetFvfIgnoresUnusedTexcoordSizeBitsForDeclCache() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;
    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  // Reset so the stream only contains commands relevant to this test.
  dev->cmd.reset();

  // FVF that requires programmable-layout translation (TEX2 is unsupported by the
  // fixed-function subset). Include garbage TEXCOORDSIZE bits for an unused set
  // (set 2) and ensure we don't create a duplicate internal declaration.
  constexpr uint32_t kD3dFvfTex2 = 2u << 8u;
  constexpr uint32_t kFvfBase = kD3dFvfXyzRhw | kD3dFvfTex2; // 0x204
  constexpr uint32_t kGarbageUnusedSet2SizeBits = 1u << 20u; // TEXCOORDSIZE3(2)
  constexpr uint32_t kFvfWithGarbage = kFvfBase | kGarbageUnusedSet2SizeBits;

  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, kFvfBase);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|TEX2)")) {
    return false;
  }
  if (!Check(dev->fvf == kFvfBase, "GetFVF returns base FVF")) {
    return false;
  }
  if (!Check(dev->fvf_vertex_decl_cache.size() == 1, "FVF decl cache contains one entry")) {
    return false;
  }
  const auto it = dev->fvf_vertex_decl_cache.find(kFvfBase);
  if (!Check(it != dev->fvf_vertex_decl_cache.end(), "FVF decl cached for base layout key")) {
    return false;
  }
  VertexDecl* decl = it->second;
  if (!Check(decl != nullptr, "cached decl is non-null")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, kFvfWithGarbage);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|TEX2|garbage TEXCOORDSIZE bits)")) {
    return false;
  }
  if (!Check(dev->fvf == kFvfWithGarbage, "GetFVF returns TEXCOORDSIZE garbage bits")) {
    return false;
  }
  if (!Check(dev->fvf_vertex_decl_cache.size() == 1, "unused TEXCOORDSIZE bits do not create new cache entry")) {
    return false;
  }
  const auto it2 = dev->fvf_vertex_decl_cache.find(kFvfBase);
  if (!Check(it2 != dev->fvf_vertex_decl_cache.end(), "cache entry still accessible via base layout key")) {
    return false;
  }
  return Check(it2->second == decl, "unused TEXCOORDSIZE bits reuse existing decl");
}

bool TestFvfXyzDiffuseDrawPrimitiveUpEmitsFixedfuncCommands() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetTextureStageState != nullptr, "SetTextureStageState must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }

  // D3DFVF_XYZ (0x2) | D3DFVF_DIFFUSE (0x40).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, kD3dFvfXyz | kD3dFvfDiffuse);
  if (!Check(hr == S_OK, "SetFVF(XYZ|DIFFUSE)")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  // Set non-identity transforms: WORLD0 * VIEW * PROJECTION.
  auto set_identity = [](float m[16]) {
    std::memset(m, 0, sizeof(float) * 16);
    m[0] = 1.0f;
    m[5] = 1.0f;
    m[10] = 1.0f;
    m[15] = 1.0f;
  };

  float world[16];
  float view[16];
  float proj[16];
  set_identity(world);
  set_identity(view);
  std::memset(proj, 0, sizeof(proj));

  world[12] = 1.0f;
  world[13] = -1.0f;
  world[14] = 2.0f;

  view[0] = 2.0f;
  view[5] = 3.0f;
  view[10] = 4.0f;

  proj[0] = 1.0f;
  proj[5] = 1.0f;
  proj[10] = 1.0f;
  proj[11] = 1.0f; // w = z

  if (!Check(cleanup.device_funcs.pfnSetTransform != nullptr, "SetTransform must be available")) {
    return false;
  }
  D3DMATRIX world_m{};
  D3DMATRIX view_m{};
  D3DMATRIX proj_m{};
  std::memcpy(world_m.m, world, sizeof(world));
  std::memcpy(view_m.m, view, sizeof(view));
  std::memcpy(proj_m.m, proj, sizeof(proj));
  hr = cleanup.device_funcs.pfnSetTransform(create_dev.hDevice, D3DTS_WORLD, &world_m);
  if (!Check(hr == S_OK, "SetTransform(WORLD)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTransform(create_dev.hDevice, D3DTS_VIEW, &view_m);
  if (!Check(hr == S_OK, "SetTransform(VIEW)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTransform(create_dev.hDevice, D3DTS_PROJECTION, &proj_m);
  if (!Check(hr == S_OK, "SetTransform(PROJECTION)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    uint32_t color;
  };

  constexpr uint32_t kGreen = 0xFF00FF00u;
  Vertex verts[3]{};
  verts[0] = {-0.5f, -0.5f, 0.5f, kGreen};
  verts[1] = {0.5f, -0.5f, 0.5f, kGreen};
  verts[2] = {0.0f, 0.5f, 0.5f, kGreen};

  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(
      create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 1, verts, sizeof(Vertex));
  if (!Check(hr == S_OK, "DrawPrimitiveUP")) {
    return false;
  }

  if (!Check(dev->up_vertex_buffer != nullptr, "up_vertex_buffer allocated")) {
    return false;
  }
  const aerogpu_handle_t up_vb_handle = dev->up_vertex_buffer->handle;
  if (!Check(up_vb_handle != 0, "up_vertex_buffer handle non-zero")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  // Expected WVP columns (transpose of row-major WVP) uploaded to c240..c243.
  float wv[16];
  float wvp[16];
  MulMat4RowMajor(world, view, wv);
  MulMat4RowMajor(wv, proj, wvp);
  float expected_cols[16] = {};
  for (int c = 0; c < 4; ++c) {
    expected_cols[c * 4 + 0] = wvp[0 * 4 + c];
    expected_cols[c * 4 + 1] = wvp[1 * 4 + c];
    expected_cols[c * 4 + 2] = wvp[2 * 4 + c];
    expected_cols[c * 4 + 3] = wvp[3 * 4 + c];
  }

  const CmdLoc upload = FindLastUploadForHandle(buf, len, up_vb_handle);
  if (!Check(upload.hdr != nullptr, "upload_resource(up_vertex_buffer) emitted")) {
    return false;
  }
  const auto* upload_cmd = reinterpret_cast<const aerogpu_cmd_upload_resource*>(upload.hdr);
  if (!Check(upload_cmd->offset_bytes == 0, "upload_resource VB offset is 0")) {
    return false;
  }
  if (!Check(upload_cmd->size_bytes == sizeof(verts), "upload_resource VB size matches original vertex data")) {
    return false;
  }

  const uint8_t* payload = reinterpret_cast<const uint8_t*>(upload_cmd) + sizeof(*upload_cmd);
  float x0 = 0.0f;
  float y0 = 0.0f;
  float z0 = 0.0f;
  uint32_t c0 = 0;
  std::memcpy(&x0, payload + 0, sizeof(float));
  std::memcpy(&y0, payload + 4, sizeof(float));
  std::memcpy(&z0, payload + 8, sizeof(float));
  std::memcpy(&c0, payload + 12, sizeof(uint32_t));

  if (!Check(std::fabs(x0 - verts[0].x) < 1e-6f, "XYZ UP: x0 preserved (no CPU conversion)")) {
    return false;
  }
  if (!Check(std::fabs(y0 - verts[0].y) < 1e-6f, "XYZ UP: y0 preserved (no CPU conversion)")) {
    return false;
  }
  if (!Check(std::fabs(z0 - verts[0].z) < 1e-6f, "XYZ UP: z0 preserved")) {
    return false;
  }
  if (!Check(c0 == kGreen, "XYZ UP: diffuse color preserved")) {
    return false;
  }

  const CmdLoc wvp_consts = FindLastVsWvpConstants(buf, len);
  if (!Check(wvp_consts.hdr != nullptr, "SET_SHADER_CONSTANTS_F uploads WVP constants")) {
    return false;
  }
  const auto* sc = reinterpret_cast<const aerogpu_cmd_set_shader_constants_f*>(wvp_consts.hdr);
  if (!Check(wvp_consts.hdr->size_bytes >= sizeof(*sc) + sizeof(expected_cols), "WVP constants payload size")) {
    return false;
  }
  const float* cols = reinterpret_cast<const float*>(reinterpret_cast<const uint8_t*>(sc) + sizeof(*sc));
  if (!Check(std::memcmp(cols, expected_cols, sizeof(expected_cols)) == 0, "WVP constants payload matches expected columns")) {
    return false;
  }

  const CmdLoc draw = FindLastOpcode(buf, len, AEROGPU_CMD_DRAW);
  if (!Check(draw.hdr != nullptr, "DRAW emitted")) {
    return false;
  }
  const CmdLoc bind = FindLastOpcodeBefore(buf, len, draw.offset, AEROGPU_CMD_BIND_SHADERS);
  if (!Check(bind.hdr != nullptr, "BIND_SHADERS emitted")) {
    return false;
  }
  const auto* bind_cmd = reinterpret_cast<const aerogpu_cmd_bind_shaders*>(bind.hdr);
  if (!Check(bind_cmd->vs != 0, "BIND_SHADERS binds non-zero VS")) {
    return false;
  }
  if (!Check(bind_cmd->ps != 0, "BIND_SHADERS binds non-zero PS")) {
    return false;
  }

  const auto* create_vs = FindCreateShaderByHandle(buf, len, bind_cmd->vs);
  if (!Check(create_vs != nullptr, "CREATE_SHADER_DXBC for bound VS is present")) {
    return false;
  }
  if (!Check(create_vs->stage == AEROGPU_SHADER_STAGE_VERTEX, "bound VS stage is VERTEX")) {
    return false;
  }
  if (!Check(create_vs->dxbc_size_bytes == sizeof(fixedfunc::kVsWvpPosColor), "bound VS bytecode size matches")) {
    return false;
  }
  {
    const uint8_t* vs_payload = reinterpret_cast<const uint8_t*>(create_vs) + sizeof(*create_vs);
    if (!Check(std::memcmp(vs_payload, fixedfunc::kVsWvpPosColor, sizeof(fixedfunc::kVsWvpPosColor)) == 0,
               "bound VS bytecode matches fixedfunc WVP shader")) {
      return false;
    }
  }

  if (!CheckWvpConstantsUploadedBeforeDraw(buf, len, draw.offset, wvp, "XYZ UP: WVP constants uploaded")) {
    return false;
  }

  return ValidateStream(buf, len);
}

bool TestFixedfuncStage0TextureStageStateRebindsPixelShader() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hTex{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_tex = false;

    ~Cleanup() {
      if (has_tex && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hTex);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  constexpr uint32_t kD3dTssColorOp = 1u;    // D3DTSS_COLOROP
  constexpr uint32_t kD3dTssColorArg1 = 2u;  // D3DTSS_COLORARG1
  constexpr uint32_t kD3dTopSelectArg1 = 2u; // D3DTOP_SELECTARG1

  constexpr uint32_t kD3dTaDiffuse = 0u; // D3DTA_DIFFUSE
  constexpr uint32_t kD3dTaTexture = 2u; // D3DTA_TEXTURE

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetTexture != nullptr, "SetTexture must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetTextureStageState != nullptr, "SetTextureStageState must be available")) {
    return false;
  }

  // Bind a dummy texture so stage0 selection can safely choose texture-sampling variants.
  D3D9DDIARG_CREATERESOURCE create_tex{};
  create_tex.type = kD3dRTypeTexture;
  create_tex.format = 22u; // D3DFMT_X8R8G8B8
  create_tex.width = 2;
  create_tex.height = 2;
  create_tex.depth = 1;
  create_tex.mip_levels = 1;
  create_tex.usage = 0;
  create_tex.pool = 0;
  create_tex.size = 0;
  create_tex.hResource.pDrvPrivate = nullptr;
  create_tex.pSharedHandle = nullptr;
  create_tex.pKmdAllocPrivateData = nullptr;
  create_tex.KmdAllocPrivateDataSize = 0;
  create_tex.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_tex);
  if (!Check(hr == S_OK, "CreateResource(texture)")) {
    return false;
  }
  if (!Check(create_tex.hResource.pDrvPrivate != nullptr, "CreateResource returned texture handle")) {
    return false;
  }
  cleanup.hTex = create_tex.hResource;
  cleanup.has_tex = true;

  hr = cleanup.device_funcs.pfnSetTexture(create_dev.hDevice, 0, create_tex.hResource);
  if (!Check(hr == S_OK, "SetTexture(0)")) {
    return false;
  }

  // D3DFVF_XYZRHW | D3DFVF_DIFFUSE | D3DFVF_TEX1.
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x144u);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|DIFFUSE|TEX1)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    float rhw;
    uint32_t color;
    float u;
    float v;
  };
  constexpr uint32_t kWhite = 0xFFFFFFFFu;
  Vertex verts[3]{};
  verts[0] = {0.0f, 0.0f, 0.5f, 1.0f, kWhite, 0.0f, 0.0f};
  verts[1] = {1.0f, 0.0f, 0.5f, 1.0f, kWhite, 1.0f, 0.0f};
  verts[2] = {0.0f, 1.0f, 0.5f, 1.0f, kWhite, 0.0f, 1.0f};

  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(
      create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 1, verts, sizeof(Vertex));
  if (!Check(hr == S_OK, "DrawPrimitiveUP")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  dev->cmd.finalize();
  const uint8_t* buf0 = dev->cmd.data();
  const size_t len0 = dev->cmd.bytes_used();

  const size_t binds0 = CountOpcode(buf0, len0, AEROGPU_CMD_BIND_SHADERS);
  const size_t creates0 = CountOpcode(buf0, len0, AEROGPU_CMD_CREATE_SHADER_DXBC);
  if (!Check(binds0 >= 1, "initial fixedfunc draw emits bind_shaders")) {
    return false;
  }
  if (!Check(creates0 >= 2, "initial fixedfunc draw emits create_shader_dxbc for VS/PS")) {
    return false;
  }

  // 1) Switch from default MODULATE to SELECTARG1(TEXTURE): should create 1 new PS and rebind.
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssColorOp, kD3dTopSelectArg1);
  if (!Check(hr == S_OK, "SetTextureStageState(COLOROP=SELECTARG1)")) {
    return false;
  }
  dev->cmd.finalize();
  const uint8_t* buf1 = dev->cmd.data();
  const size_t len1 = dev->cmd.bytes_used();
  const size_t binds1 = CountOpcode(buf1, len1, AEROGPU_CMD_BIND_SHADERS);
  const size_t creates1 = CountOpcode(buf1, len1, AEROGPU_CMD_CREATE_SHADER_DXBC);
  if (!Check(binds1 == binds0 + 1, "SetTextureStageState causes a shader rebind")) {
    return false;
  }
  if (!Check(creates1 == creates0 + 1, "SetTextureStageState creates one new internal PS")) {
    return false;
  }

  // 2) Switch to SELECTARG1(DIFFUSE): should create 1 new PS and rebind.
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssColorArg1, kD3dTaDiffuse);
  if (!Check(hr == S_OK, "SetTextureStageState(COLORARG1=DIFFUSE)")) {
    return false;
  }
  dev->cmd.finalize();
  const uint8_t* buf2 = dev->cmd.data();
  const size_t len2 = dev->cmd.bytes_used();
  const size_t binds2 = CountOpcode(buf2, len2, AEROGPU_CMD_BIND_SHADERS);
  const size_t creates2 = CountOpcode(buf2, len2, AEROGPU_CMD_CREATE_SHADER_DXBC);
  if (!Check(binds2 == binds1 + 1, "SetTextureStageState(DIFFUSE) causes a shader rebind")) {
    return false;
  }
  if (!Check(creates2 == creates1 + 1, "SetTextureStageState(DIFFUSE) creates one new internal PS")) {
    return false;
  }

  // 3) Switch back to SELECTARG1(TEXTURE): should rebind but not create a new shader.
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssColorArg1, kD3dTaTexture);
  if (!Check(hr == S_OK, "SetTextureStageState(COLORARG1=TEXTURE)")) {
    return false;
  }
  dev->cmd.finalize();
  const uint8_t* buf3 = dev->cmd.data();
  const size_t len3 = dev->cmd.bytes_used();
  const size_t binds3 = CountOpcode(buf3, len3, AEROGPU_CMD_BIND_SHADERS);
  const size_t creates3 = CountOpcode(buf3, len3, AEROGPU_CMD_CREATE_SHADER_DXBC);
  if (!Check(binds3 == binds2 + 1, "SetTextureStageState(TEXTURE) causes a shader rebind")) {
    return false;
  }
  return Check(creates3 == creates2, "SetTextureStageState(TEXTURE) reuses cached shader");
}

bool TestFixedfuncTextureFactorDoesNotClobberPsConst0() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  constexpr uint32_t kD3dRsTextureFactor = 60u; // D3DRS_TEXTUREFACTOR

  constexpr uint32_t kD3dTssColorOp = 1u;    // D3DTSS_COLOROP
  constexpr uint32_t kD3dTssColorArg1 = 2u;  // D3DTSS_COLORARG1
  constexpr uint32_t kD3dTssAlphaOp = 4u;    // D3DTSS_ALPHAOP
  constexpr uint32_t kD3dTssAlphaArg1 = 5u;  // D3DTSS_ALPHAARG1

  constexpr uint32_t kD3dTopSelectArg1 = 2u; // D3DTOP_SELECTARG1
  constexpr uint32_t kD3dTaTFactor = 3u;     // D3DTA_TFACTOR

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetShaderConstF != nullptr, "SetShaderConstF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetTextureStageState != nullptr, "SetTextureStageState must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetRenderState != nullptr, "SetRenderState must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  dev->cmd.reset();

  const float app_ps_c0[4] = {0.1f, 0.2f, 0.3f, 0.4f};
  hr = cleanup.device_funcs.pfnSetShaderConstF(create_dev.hDevice, kD3d9ShaderStagePs, /*start_reg=*/0, app_ps_c0, /*vec4_count=*/1);
  if (!Check(hr == S_OK, "SetShaderConstF(PS, c0)")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, kD3dFvfXyzRhw | kD3dFvfDiffuse);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|DIFFUSE)")) {
    return false;
  }

  // Stage0: use TFACTOR for both color + alpha so the fixed-function stage0 PS
  // must reference the internal TFACTOR constant register.
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssColorOp, kD3dTopSelectArg1);
  if (!Check(hr == S_OK, "SetTextureStageState(COLOROP=SELECTARG1)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssColorArg1, kD3dTaTFactor);
  if (!Check(hr == S_OK, "SetTextureStageState(COLORARG1=TFACTOR)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssAlphaOp, kD3dTopSelectArg1);
  if (!Check(hr == S_OK, "SetTextureStageState(ALPHAOP=SELECTARG1)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssAlphaArg1, kD3dTaTFactor);
  if (!Check(hr == S_OK, "SetTextureStageState(ALPHAARG1=TFACTOR)")) {
    return false;
  }

  // Make sure the driver must upload TEXTUREFACTOR (and not just hit the cache).
  hr = cleanup.device_funcs.pfnSetRenderState(create_dev.hDevice, kD3dRsTextureFactor, 0xFF3366CCu);
  if (!Check(hr == S_OK, "SetRenderState(TEXTUREFACTOR)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    float rhw;
    uint32_t diffuse;
  };
  Vertex tri[3]{};
  tri[0] = {0.0f, 0.0f, 0.5f, 1.0f, 0xFFFFFFFFu};
  tri[1] = {1.0f, 0.0f, 0.5f, 1.0f, 0xFFFFFFFFu};
  tri[2] = {0.0f, 1.0f, 0.5f, 1.0f, 0xFFFFFFFFu};

  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 1, tri, sizeof(Vertex));
  if (!Check(hr == S_OK, "DrawPrimitiveUP")) {
    return false;
  }

  {
    std::lock_guard<std::mutex> lock(dev->mutex);
    if (!Check(std::memcmp(dev->ps_consts_f, app_ps_c0, sizeof(app_ps_c0)) == 0,
               "fixed-function stage0 TFACTOR must not clobber app PS constant c0")) {
      return false;
    }
  }

  return true;
}

bool TestFixedfuncStage0ApplyStateBlockRebindsInteropPixelShader() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hTex{};
    D3D9DDI_HSHADER hVs{};
    D3D9DDI_HSTATEBLOCK hStateBlock{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_tex = false;
    bool has_vs = false;
    bool has_stateblock = false;

    ~Cleanup() {
      if (has_stateblock && device_funcs.pfnDeleteStateBlock) {
        device_funcs.pfnDeleteStateBlock(hDevice, hStateBlock);
      }
      if (has_vs && device_funcs.pfnDestroyShader) {
        device_funcs.pfnDestroyShader(hDevice, hVs);
      }
      if (has_tex && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hTex);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  constexpr uint32_t kD3dTssColorOp = 1u;     // D3DTSS_COLOROP
  constexpr uint32_t kD3dTssColorArg1 = 2u;   // D3DTSS_COLORARG1
  constexpr uint32_t kD3dTssAlphaOp = 4u;     // D3DTSS_ALPHAOP
  constexpr uint32_t kD3dTssAlphaArg1 = 5u;   // D3DTSS_ALPHAARG1
  constexpr uint32_t kD3dTopSelectArg1 = 2u;  // D3DTOP_SELECTARG1
  constexpr uint32_t kD3dTaDiffuse = 0u;      // D3DTA_DIFFUSE
  constexpr uint32_t kD3dTaTexture = 2u;      // D3DTA_TEXTURE

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDestroyResource != nullptr, "DestroyResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetTexture != nullptr, "SetTexture must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnCreateShader != nullptr, "CreateShader must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDestroyShader != nullptr, "DestroyShader must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetShader != nullptr, "SetShader must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetTextureStageState != nullptr, "SetTextureStageState must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnBeginStateBlock != nullptr, "BeginStateBlock must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnEndStateBlock != nullptr, "EndStateBlock must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnApplyStateBlock != nullptr, "ApplyStateBlock must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDeleteStateBlock != nullptr, "DeleteStateBlock must be available")) {
    return false;
  }

  // Bind a dummy texture so stage0 selection can safely choose texture-sampling variants.
  D3D9DDIARG_CREATERESOURCE create_tex{};
  create_tex.type = kD3dRTypeTexture;
  create_tex.format = 22u; // D3DFMT_X8R8G8B8
  create_tex.width = 2;
  create_tex.height = 2;
  create_tex.depth = 1;
  create_tex.mip_levels = 1;
  create_tex.usage = 0;
  create_tex.pool = 0;
  create_tex.size = 0;
  create_tex.hResource.pDrvPrivate = nullptr;
  create_tex.pSharedHandle = nullptr;
  create_tex.pKmdAllocPrivateData = nullptr;
  create_tex.KmdAllocPrivateDataSize = 0;
  create_tex.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_tex);
  if (!Check(hr == S_OK, "CreateResource(texture)")) {
    return false;
  }
  if (!Check(create_tex.hResource.pDrvPrivate != nullptr, "CreateResource returned texture handle")) {
    return false;
  }
  cleanup.hTex = create_tex.hResource;
  cleanup.has_tex = true;

  hr = cleanup.device_funcs.pfnSetTexture(create_dev.hDevice, 0, create_tex.hResource);
  if (!Check(hr == S_OK, "SetTexture(0)")) {
    return false;
  }

  // Bind VS-only shader pipeline so stage0 PS selection uses the interop fallback.
  const uint8_t dxbc[] = {0x44, 0x58, 0x42, 0x43, 0x00, 0x01, 0x02, 0x03};
  D3D9DDI_HSHADER hVs{};
  hr = cleanup.device_funcs.pfnCreateShader(create_dev.hDevice,
                                            kD3d9ShaderStageVs,
                                            dxbc,
                                            static_cast<uint32_t>(sizeof(dxbc)),
                                            &hVs);
  if (!Check(hr == S_OK, "CreateShader(VS)")) {
    return false;
  }
  if (!Check(hVs.pDrvPrivate != nullptr, "CreateShader returned VS handle")) {
    return false;
  }
  cleanup.hVs = hVs;
  cleanup.has_vs = true;

  hr = cleanup.device_funcs.pfnSetShader(create_dev.hDevice, kD3d9ShaderStageVs, hVs);
  if (!Check(hr == S_OK, "SetShader(VS)")) {
    return false;
  }

  // Explicitly clear PS (NULL stage).
  D3D9DDI_HSHADER null_shader{};
  hr = cleanup.device_funcs.pfnSetShader(create_dev.hDevice, kD3d9ShaderStagePs, null_shader);
  if (!Check(hr == S_OK, "SetShader(PS=NULL)")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  // Baseline stage0: SELECTARG1(TEXTURE) for both color + alpha.
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssColorOp, kD3dTopSelectArg1);
  if (!Check(hr == S_OK, "SetTextureStageState(COLOROP=SELECTARG1)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssColorArg1, kD3dTaTexture);
  if (!Check(hr == S_OK, "SetTextureStageState(COLORARG1=TEXTURE)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssAlphaOp, kD3dTopSelectArg1);
  if (!Check(hr == S_OK, "SetTextureStageState(ALPHAOP=SELECTARG1)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssAlphaArg1, kD3dTaTexture);
  if (!Check(hr == S_OK, "SetTextureStageState(ALPHAARG1=TEXTURE)")) {
    return false;
  }

  {
    std::lock_guard<std::mutex> lock(dev->mutex);
    if (!Check(dev->fixedfunc_ps_interop != nullptr, "VS-only interop created fixedfunc_ps_interop")) {
      return false;
    }
    const uint8_t* bytes = dev->fixedfunc_ps_interop->bytecode.data();
    const size_t size = dev->fixedfunc_ps_interop->bytecode.size();
    if (!Check(BytecodeContainsToken(bytes, size, kPsOpTexld), "VS-only interop baseline PS contains texld")) {
      return false;
    }
    if (!Check(!BytecodeContainsToken(bytes, size, kPsOpAdd), "VS-only interop baseline PS contains no add")) {
      return false;
    }
    if (!Check(!BytecodeContainsToken(bytes, size, kPsOpMul), "VS-only interop baseline PS contains no mul")) {
      return false;
    }
  }

  dev->cmd.finalize();
  const uint8_t* buf0 = dev->cmd.data();
  const size_t len0 = dev->cmd.bytes_used();
  const size_t binds0 = CountOpcode(buf0, len0, AEROGPU_CMD_BIND_SHADERS);

  // Record a state block that changes stage0 to SELECTARG1(DIFFUSE) for both color + alpha.
  hr = cleanup.device_funcs.pfnBeginStateBlock(create_dev.hDevice);
  if (!Check(hr == S_OK, "BeginStateBlock")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssColorOp, kD3dTopSelectArg1);
  if (!Check(hr == S_OK, "SetTextureStageState(COLOROP=SELECTARG1) (record)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssColorArg1, kD3dTaDiffuse);
  if (!Check(hr == S_OK, "SetTextureStageState(COLORARG1=DIFFUSE) (record)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssAlphaOp, kD3dTopSelectArg1);
  if (!Check(hr == S_OK, "SetTextureStageState(ALPHAOP=SELECTARG1) (record)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssAlphaArg1, kD3dTaDiffuse);
  if (!Check(hr == S_OK, "SetTextureStageState(ALPHAARG1=DIFFUSE) (record)")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnEndStateBlock(create_dev.hDevice, &cleanup.hStateBlock);
  if (!Check(hr == S_OK, "EndStateBlock")) {
    return false;
  }
  if (!Check(cleanup.hStateBlock.pDrvPrivate != nullptr, "EndStateBlock returns stateblock handle")) {
    return false;
  }
  cleanup.has_stateblock = true;

  // Restore baseline stage0 state (TEXTURE/TEXTURE). Applying the block should switch it back to DIFFUSE/DIFFUSE.
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssColorArg1, kD3dTaTexture);
  if (!Check(hr == S_OK, "SetTextureStageState(COLORARG1=TEXTURE) (restore)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssAlphaArg1, kD3dTaTexture);
  if (!Check(hr == S_OK, "SetTextureStageState(ALPHAARG1=TEXTURE) (restore)")) {
    return false;
  }

  {
    std::lock_guard<std::mutex> lock(dev->mutex);
    if (!Check(dev->fixedfunc_ps_interop != nullptr, "fixedfunc_ps_interop valid after restore")) {
      return false;
    }
    const uint8_t* bytes = dev->fixedfunc_ps_interop->bytecode.data();
    const size_t size = dev->fixedfunc_ps_interop->bytecode.size();
    if (!Check(BytecodeContainsToken(bytes, size, kPsOpTexld), "restore PS contains texld")) {
      return false;
    }
    if (!Check(!BytecodeContainsToken(bytes, size, kPsOpAdd), "restore PS contains no add")) {
      return false;
    }
    if (!Check(!BytecodeContainsToken(bytes, size, kPsOpMul), "restore PS contains no mul")) {
      return false;
    }
  }

  dev->cmd.finalize();
  const uint8_t* buf1 = dev->cmd.data();
  const size_t len1 = dev->cmd.bytes_used();
  const size_t binds1 = CountOpcode(buf1, len1, AEROGPU_CMD_BIND_SHADERS);
  if (!Check(binds1 >= binds0, "bind_shaders count is monotonic")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnApplyStateBlock(create_dev.hDevice, cleanup.hStateBlock);
  if (!Check(hr == S_OK, "ApplyStateBlock")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf2 = dev->cmd.data();
  const size_t len2 = dev->cmd.bytes_used();
  const size_t binds2 = CountOpcode(buf2, len2, AEROGPU_CMD_BIND_SHADERS);
  if (!Check(binds2 == binds1 + 1, "ApplyStateBlock(stage0 TSS) causes a shader rebind in VS-only interop")) {
    return false;
  }

  {
    std::lock_guard<std::mutex> lock(dev->mutex);
    if (!Check(dev->fixedfunc_ps_interop != nullptr, "fixedfunc_ps_interop valid after ApplyStateBlock")) {
      return false;
    }
    const uint8_t* bytes = dev->fixedfunc_ps_interop->bytecode.data();
    const size_t size = dev->fixedfunc_ps_interop->bytecode.size();
    if (!Check(!BytecodeContainsToken(bytes, size, kPsOpTexld), "ApplyStateBlock selected diffuse-only PS (no texld)")) {
      return false;
    }
    if (!Check(!BytecodeContainsToken(bytes, size, kPsOpAdd), "ApplyStateBlock diffuse-only PS contains no add")) {
      return false;
    }
    if (!Check(!BytecodeContainsToken(bytes, size, kPsOpMul), "ApplyStateBlock diffuse-only PS contains no mul")) {
      return false;
    }
  }

  return true;
}

bool TestFixedfuncStage0ApplyStateBlockTextureBindRebindsPixelShader() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hTex{};
    D3D9DDI_HSTATEBLOCK hStateBlock{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_tex = false;
    bool has_stateblock = false;

    ~Cleanup() {
      if (has_stateblock && device_funcs.pfnDeleteStateBlock) {
        device_funcs.pfnDeleteStateBlock(hDevice, hStateBlock);
      }
      if (has_tex && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hTex);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetViewport != nullptr, "SetViewport must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDestroyResource != nullptr, "DestroyResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetTexture != nullptr, "SetTexture must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnBeginStateBlock != nullptr, "BeginStateBlock must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnEndStateBlock != nullptr, "EndStateBlock must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnApplyStateBlock != nullptr, "ApplyStateBlock must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDeleteStateBlock != nullptr, "DeleteStateBlock must be available")) {
    return false;
  }

  D3DDDIVIEWPORTINFO vp{};
  vp.X = 0.0f;
  vp.Y = 0.0f;
  vp.Width = 256.0f;
  vp.Height = 256.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }

  // D3DFVF_XYZRHW (0x4) | D3DFVF_DIFFUSE (0x40) | D3DFVF_TEX1 (0x100).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x144u);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|DIFFUSE|TEX1)")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  // Draw once with no texture bound so the fixed-function pipeline binds a
  // diffuse-only stage0 PS variant (no texld).
  struct Vertex {
    float x;
    float y;
    float z;
    float rhw;
    uint32_t color;
    float u;
    float v;
  };
  constexpr uint32_t kWhite = 0xFFFFFFFFu;
  Vertex verts[3]{};
  verts[0] = {256.0f * 0.25f, 256.0f * 0.25f, 0.5f, 1.0f, kWhite, 0.0f, 0.0f};
  verts[1] = {256.0f * 0.75f, 256.0f * 0.25f, 0.5f, 1.0f, kWhite, 1.0f, 0.0f};
  verts[2] = {256.0f * 0.50f, 256.0f * 0.75f, 0.5f, 1.0f, kWhite, 0.5f, 1.0f};

  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(
      create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 1, verts, sizeof(Vertex));
  if (!Check(hr == S_OK, "DrawPrimitiveUP(untextured)")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf0 = dev->cmd.data();
  const size_t len0 = dev->cmd.bytes_used();
  const size_t binds0 = CountOpcode(buf0, len0, AEROGPU_CMD_BIND_SHADERS);
  if (!Check(binds0 >= 1, "initial fixedfunc draw emits bind_shaders")) {
    return false;
  }
  if (!CheckLastBoundPixelShaderOps(buf0, len0, /*expect_texld=*/false, /*expect_add=*/false, /*expect_mul=*/false,
                                   "untextured fixedfunc PS is color-only")) {
    return false;
  }

  // Create a dummy texture and record a state block that binds it to stage0.
  D3D9DDIARG_CREATERESOURCE create_tex{};
  create_tex.type = kD3dRTypeTexture;
  create_tex.format = 22u; // D3DFMT_X8R8G8B8
  create_tex.width = 2;
  create_tex.height = 2;
  create_tex.depth = 1;
  create_tex.mip_levels = 1;
  create_tex.usage = 0;
  create_tex.pool = 0;
  create_tex.size = 0;
  create_tex.hResource.pDrvPrivate = nullptr;
  create_tex.pSharedHandle = nullptr;
  create_tex.pKmdAllocPrivateData = nullptr;
  create_tex.KmdAllocPrivateDataSize = 0;
  create_tex.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_tex);
  if (!CheckHr(hr, S_OK, "CreateResource(texture)")) {
    return false;
  }
  if (!Check(create_tex.hResource.pDrvPrivate != nullptr, "CreateResource(texture) returned handle")) {
    return false;
  }
  cleanup.hTex = create_tex.hResource;
  cleanup.has_tex = true;

  hr = cleanup.device_funcs.pfnBeginStateBlock(create_dev.hDevice);
  if (!Check(hr == S_OK, "BeginStateBlock")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTexture(create_dev.hDevice, 0, create_tex.hResource);
  if (!Check(hr == S_OK, "SetTexture(stage0) (record)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnEndStateBlock(create_dev.hDevice, &cleanup.hStateBlock);
  if (!Check(hr == S_OK, "EndStateBlock")) {
    return false;
  }
  if (!Check(cleanup.hStateBlock.pDrvPrivate != nullptr, "EndStateBlock returns stateblock handle")) {
    return false;
  }
  cleanup.has_stateblock = true;

  // Restore baseline state (no texture bound).
  D3DDDI_HRESOURCE null_tex{};
  hr = cleanup.device_funcs.pfnSetTexture(create_dev.hDevice, 0, null_tex);
  if (!Check(hr == S_OK, "SetTexture(stage0=NULL) (restore)")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf1 = dev->cmd.data();
  const size_t len1 = dev->cmd.bytes_used();
  const size_t binds1 = CountOpcode(buf1, len1, AEROGPU_CMD_BIND_SHADERS);
  if (!Check(binds1 >= binds0, "bind_shaders count monotonic")) {
    return false;
  }

  // ApplyStateBlock should bind the texture and update the stage0 PS selection
  // immediately (rebind), even though no stage-state changed.
  hr = cleanup.device_funcs.pfnApplyStateBlock(create_dev.hDevice, cleanup.hStateBlock);
  if (!Check(hr == S_OK, "ApplyStateBlock(texture0)")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf2 = dev->cmd.data();
  const size_t len2 = dev->cmd.bytes_used();
  const size_t binds2 = CountOpcode(buf2, len2, AEROGPU_CMD_BIND_SHADERS);
  if (!Check(binds2 == binds1 + 1, "ApplyStateBlock(stage0 texture) causes a shader rebind")) {
    return false;
  }
  if (!CheckLastBoundPixelShaderOps(buf2, len2, /*expect_texld=*/true, /*expect_add=*/false, /*expect_mul=*/true,
                                   "ApplyStateBlock selects textured stage0 PS")) {
    return false;
  }

  return ValidateStream(buf2, len2);
}

bool TestVsOnlyInteropSetShaderSucceedsWhenStage0Unsupported() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3D9DDI_HSHADER hVs{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_vs = false;

    ~Cleanup() {
      if (has_vs && device_funcs.pfnDestroyShader) {
        device_funcs.pfnDestroyShader(hDevice, hVs);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  constexpr uint32_t kD3dTssColorOp = 1u;      // D3DTSS_COLOROP
  constexpr uint32_t kD3dTopAddSmooth = 11u;   // D3DTOP_ADDSMOOTH (unsupported by fixed-function texture stage subset)

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetTextureStageState != nullptr, "SetTextureStageState must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnCreateShader != nullptr, "CreateShader must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetShader != nullptr, "SetShader must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDestroyShader != nullptr, "DestroyShader must be available")) {
    return false;
  }

  // Set an unsupported Stage0 combiner op. This must *not* make SetShader fail
  // in VS-only interop: draws should fail with INVALIDCALL, but state-setting
  // must remain tolerant.
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssColorOp, kD3dTopAddSmooth);
  if (!Check(hr == S_OK, "SetTextureStageState(COLOROP=ADDSMOOTH) succeeds")) {
    return false;
  }

  // Create a dummy VS and bind it (VS-only interop).
  const uint8_t dxbc[] = {0x44, 0x58, 0x42, 0x43, 0x00, 0x01, 0x02, 0x03};
  D3D9DDI_HSHADER hVs{};
  hr = cleanup.device_funcs.pfnCreateShader(create_dev.hDevice,
                                            kD3d9ShaderStageVs,
                                            dxbc,
                                            static_cast<uint32_t>(sizeof(dxbc)),
                                            &hVs);
  if (!Check(hr == S_OK, "CreateShader(VS)")) {
    return false;
  }
  if (!Check(hVs.pDrvPrivate != nullptr, "CreateShader returned VS handle")) {
    return false;
  }
  cleanup.hVs = hVs;
  cleanup.has_vs = true;

  hr = cleanup.device_funcs.pfnSetShader(create_dev.hDevice, kD3d9ShaderStageVs, hVs);
  if (!Check(hr == S_OK, "SetShader(VS) succeeds even when stage0 unsupported")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();
  if (!Check(ValidateStream(buf, len), "ValidateStream(VS-only SetShader unsupported stage0)")) {
    return false;
  }

  const CmdLoc bind = FindLastOpcode(buf, len, AEROGPU_CMD_BIND_SHADERS);
  if (!Check(bind.hdr != nullptr, "bind_shaders emitted")) {
    return false;
  }
  const auto* bind_cmd = reinterpret_cast<const aerogpu_cmd_bind_shaders*>(bind.hdr);
  if (!Check(bind_cmd->vs != 0, "bind_shaders VS handle non-zero")) {
    return false;
  }
  if (!Check(bind_cmd->ps != 0, "bind_shaders PS handle non-zero (fallback)")) {
    return false;
  }

  const auto* create = FindCreateShaderByHandle(buf, len, bind_cmd->ps);
  if (!Check(create != nullptr, "CREATE_SHADER_DXBC for bound fallback PS present")) {
    return false;
  }
  if (!Check(create->stage == AEROGPU_SHADER_STAGE_PIXEL, "fallback shader stage is PIXEL")) {
    return false;
  }
  return true;
}

// Stage0 PS variants can legally alias the same Shader* (e.g. if two different
// stage0 keys map to the same fallback bytecode). Ensure device destruction does
// not double-free in that case.
bool TestFixedfuncStage0DestroyDedupsSharedPixelShaders() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }

  // D3DFVF_XYZRHW (0x4) | D3DFVF_DIFFUSE (0x40).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x44u);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|DIFFUSE)")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  ScopedDeviceCmdVectorReset cmd_reset(dev);

  struct Vertex {
    float x;
    float y;
    float z;
    float rhw;
    uint32_t color;
  };
  constexpr uint32_t kWhite = 0xFFFFFFFFu;
  Vertex verts[3]{};
  verts[0] = {0.0f, 0.0f, 0.5f, 1.0f, kWhite};
  verts[1] = {1.0f, 0.0f, 0.5f, 1.0f, kWhite};
  verts[2] = {0.0f, 1.0f, 0.5f, 1.0f, kWhite};

  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(
      create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 1, verts, sizeof(Vertex));
  if (!Check(hr == S_OK, "DrawPrimitiveUP")) {
    return false;
  }

  // Intentionally create a duplicate cache entry pointing at the same Shader*
  // to emulate stage0 keys that share a fallback shader.
  Shader* shared = nullptr;
  size_t shared_index = 0;
  size_t dup_index = 0;
  {
    std::lock_guard<std::mutex> lock(dev->mutex);
    for (size_t i = 0; i < std::size(dev->fixedfunc_ps_variants); ++i) {
      if (dev->fixedfunc_ps_variants[i]) {
        shared = dev->fixedfunc_ps_variants[i];
        shared_index = i;
        break;
      }
    }
    if (!Check(shared != nullptr, "fixedfunc stage0 PS created")) {
      return false;
    }

    bool dup_found = false;
    for (size_t i = 0; i < std::size(dev->fixedfunc_ps_variants); ++i) {
      if (i == shared_index) {
        continue;
      }
      if (!dev->fixedfunc_ps_variants[i]) {
        dup_index = i;
        dup_found = true;
        break;
      }
    }
    if (!Check(dup_found, "found empty stage0 cache slot for duplicate")) {
      return false;
    }
  }

  hr = device_test_alias_fixedfunc_stage0_ps_variant(
      create_dev.hDevice,
      static_cast<uint32_t>(shared_index),
      static_cast<uint32_t>(dup_index));
  if (!Check(hr == S_OK, "device_test_alias_fixedfunc_stage0_ps_variant")) {
    return false;
  }

  {
    std::lock_guard<std::mutex> lock(dev->mutex);
    if (!Check(dev->fixedfunc_ps_variants[dup_index] == shared, "duplicate stage0 cache slot shares Shader*")) {
      return false;
    }
  }

  // If we reach here and the Cleanup destructor runs without aborting, the
  // device destroy path successfully deduplicated stage0 PS deletes.
  return true;
}

bool TestFvfXyzDiffuseTex1DrawPrimitiveUpEmitsFixedfuncCommands() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }

  // D3DFVF_XYZ (0x2) | D3DFVF_DIFFUSE (0x40) | D3DFVF_TEX1 (0x100).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x142u);
  if (!Check(hr == S_OK, "SetFVF(XYZ|DIFFUSE|TEX1)")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  // Set non-identity transforms: WORLD0 * VIEW * PROJECTION.
  auto set_identity = [](float m[16]) {
    std::memset(m, 0, sizeof(float) * 16);
    m[0] = 1.0f;
    m[5] = 1.0f;
    m[10] = 1.0f;
    m[15] = 1.0f;
  };

  float world[16];
  float view[16];
  float proj[16];
  set_identity(world);
  set_identity(view);
  std::memset(proj, 0, sizeof(proj));

  world[12] = 1.0f;
  world[13] = -1.0f;
  world[14] = 2.0f;

  view[0] = 2.0f;
  view[5] = 3.0f;
  view[10] = 4.0f;

  proj[0] = 1.0f;
  proj[5] = 1.0f;
  proj[10] = 1.0f;
  proj[11] = 1.0f; // w = z

  if (!Check(cleanup.device_funcs.pfnSetTransform != nullptr, "SetTransform must be available")) {
    return false;
  }
  D3DMATRIX world_m{};
  D3DMATRIX view_m{};
  D3DMATRIX proj_m{};
  std::memcpy(world_m.m, world, sizeof(world));
  std::memcpy(view_m.m, view, sizeof(view));
  std::memcpy(proj_m.m, proj, sizeof(proj));
  hr = cleanup.device_funcs.pfnSetTransform(create_dev.hDevice, D3DTS_WORLD, &world_m);
  if (!Check(hr == S_OK, "SetTransform(WORLD)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTransform(create_dev.hDevice, D3DTS_VIEW, &view_m);
  if (!Check(hr == S_OK, "SetTransform(VIEW)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTransform(create_dev.hDevice, D3DTS_PROJECTION, &proj_m);
  if (!Check(hr == S_OK, "SetTransform(PROJECTION)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    uint32_t color;
    float u;
    float v;
  };

  constexpr uint32_t kWhite = 0xFFFFFFFFu;
  Vertex verts[3]{};
  verts[0] = {-0.5f, -0.5f, 0.5f, kWhite, 0.0f, 0.0f};
  verts[1] = {0.5f, -0.5f, 0.5f, kWhite, 1.0f, 0.0f};
  verts[2] = {0.0f, 0.5f, 0.5f, kWhite, 0.5f, 1.0f};

  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(
      create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 1, verts, sizeof(Vertex));
  if (!Check(hr == S_OK, "DrawPrimitiveUP")) {
    return false;
  }

  if (!Check(dev->up_vertex_buffer != nullptr, "up_vertex_buffer allocated")) {
    return false;
  }
  const aerogpu_handle_t up_vb_handle = dev->up_vertex_buffer->handle;
  if (!Check(up_vb_handle != 0, "up_vertex_buffer handle non-zero")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  // Expected WVP columns (transpose of row-major WVP) uploaded to c240..c243.
  float wv[16];
  float wvp[16];
  MulMat4RowMajor(world, view, wv);
  MulMat4RowMajor(wv, proj, wvp);
  float expected_cols[16] = {};
  for (int c = 0; c < 4; ++c) {
    expected_cols[c * 4 + 0] = wvp[0 * 4 + c];
    expected_cols[c * 4 + 1] = wvp[1 * 4 + c];
    expected_cols[c * 4 + 2] = wvp[2 * 4 + c];
    expected_cols[c * 4 + 3] = wvp[3 * 4 + c];
  }

  const CmdLoc upload = FindLastUploadForHandle(buf, len, up_vb_handle);
  if (!Check(upload.hdr != nullptr, "upload_resource(up_vertex_buffer) emitted")) {
    return false;
  }
  const auto* upload_cmd = reinterpret_cast<const aerogpu_cmd_upload_resource*>(upload.hdr);
  if (!Check(upload_cmd->offset_bytes == 0, "upload_resource VB offset is 0")) {
    return false;
  }
  if (!Check(upload_cmd->size_bytes == sizeof(verts), "upload_resource VB size matches original vertex data")) {
    return false;
  }

  const uint8_t* payload = reinterpret_cast<const uint8_t*>(upload_cmd) + sizeof(*upload_cmd);
  float x0 = 0.0f;
  float y0 = 0.0f;
  float z0 = 0.0f;
  uint32_t c0 = 0;
  float u0 = 0.0f;
  float v0_out = 0.0f;
  std::memcpy(&x0, payload + 0, sizeof(float));
  std::memcpy(&y0, payload + 4, sizeof(float));
  std::memcpy(&z0, payload + 8, sizeof(float));
  std::memcpy(&c0, payload + 12, sizeof(uint32_t));
  std::memcpy(&u0, payload + 16, sizeof(float));
  std::memcpy(&v0_out, payload + 20, sizeof(float));

  if (!Check(std::fabs(x0 - verts[0].x) < 1e-6f, "XYZ|TEX1 UP: x0 preserved (no CPU conversion)")) {
    return false;
  }
  if (!Check(std::fabs(y0 - verts[0].y) < 1e-6f, "XYZ|TEX1 UP: y0 preserved (no CPU conversion)")) {
    return false;
  }
  if (!Check(std::fabs(z0 - verts[0].z) < 1e-6f, "XYZ|TEX1 UP: z preserved")) {
    return false;
  }
  if (!Check(c0 == kWhite, "XYZ|TEX1 UP: diffuse color preserved")) {
    return false;
  }
  if (!Check(std::fabs(u0 - verts[0].u) < 1e-6f, "XYZ|TEX1 UP: u preserved")) {
    return false;
  }
  if (!Check(std::fabs(v0_out - verts[0].v) < 1e-6f, "XYZ|TEX1 UP: v preserved")) {
    return false;
  }

  const CmdLoc wvp_consts = FindLastVsWvpConstants(buf, len);
  if (!Check(wvp_consts.hdr != nullptr, "SET_SHADER_CONSTANTS_F uploads WVP constants")) {
    return false;
  }
  const auto* sc = reinterpret_cast<const aerogpu_cmd_set_shader_constants_f*>(wvp_consts.hdr);
  if (!Check(wvp_consts.hdr->size_bytes >= sizeof(*sc) + sizeof(expected_cols), "WVP constants payload size")) {
    return false;
  }
  const float* cols = reinterpret_cast<const float*>(reinterpret_cast<const uint8_t*>(sc) + sizeof(*sc));
  if (!Check(std::memcmp(cols, expected_cols, sizeof(expected_cols)) == 0, "WVP constants payload matches expected columns")) {
    return false;
  }

  const CmdLoc draw = FindLastOpcode(buf, len, AEROGPU_CMD_DRAW);
  if (!Check(draw.hdr != nullptr, "DRAW emitted")) {
    return false;
  }
  const CmdLoc bind = FindLastOpcodeBefore(buf, len, draw.offset, AEROGPU_CMD_BIND_SHADERS);
  if (!Check(bind.hdr != nullptr, "BIND_SHADERS emitted")) {
    return false;
  }
  const auto* bind_cmd = reinterpret_cast<const aerogpu_cmd_bind_shaders*>(bind.hdr);
  if (!Check(bind_cmd->vs != 0, "BIND_SHADERS binds non-zero VS")) {
    return false;
  }

  const auto* create_vs = FindCreateShaderByHandle(buf, len, bind_cmd->vs);
  if (!Check(create_vs != nullptr, "CREATE_SHADER_DXBC for bound VS is present")) {
    return false;
  }
  if (!Check(create_vs->stage == AEROGPU_SHADER_STAGE_VERTEX, "bound VS stage is VERTEX")) {
    return false;
  }
  if (!Check(create_vs->dxbc_size_bytes == sizeof(fixedfunc::kVsWvpPosColorTex0), "bound VS bytecode size matches")) {
    return false;
  }
  {
    const uint8_t* vs_payload = reinterpret_cast<const uint8_t*>(create_vs) + sizeof(*create_vs);
    if (!Check(std::memcmp(vs_payload, fixedfunc::kVsWvpPosColorTex0, sizeof(fixedfunc::kVsWvpPosColorTex0)) == 0,
               "bound VS bytecode matches fixedfunc WVP(TEX1) shader")) {
      return false;
    }
  }

  if (!CheckWvpConstantsUploadedBeforeDraw(buf, len, draw.offset, wvp, "XYZ|TEX1 UP: WVP constants uploaded")) {
    return false;
  }

  return ValidateStream(buf, len);
}

bool TestFvfXyzDiffuseTex1SetTransformDrawPrimitiveUpEmitsWvpConstants() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hTexture{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_texture = false;

    ~Cleanup() {
      if (has_texture && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hTexture);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetTransform != nullptr, "SetTransform must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetTexture != nullptr, "SetTexture must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetTextureStageState != nullptr, "SetTextureStageState must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }

  // Create and bind a small texture at stage0 so stage0 selects the textured PS.
  D3D9DDIARG_CREATERESOURCE create_tex{};
  create_tex.type = kD3dRTypeTexture;
  create_tex.format = 22u; // D3DFMT_X8R8G8B8
  create_tex.width = 2;
  create_tex.height = 2;
  create_tex.depth = 1;
  create_tex.mip_levels = 1;
  create_tex.usage = 0;
  create_tex.pool = 0;
  create_tex.size = 0;
  create_tex.hResource.pDrvPrivate = nullptr;
  create_tex.pSharedHandle = nullptr;
  create_tex.pKmdAllocPrivateData = nullptr;
  create_tex.KmdAllocPrivateDataSize = 0;
  create_tex.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_tex);
  if (!CheckHr(hr, S_OK, "CreateResource(texture)")) {
    return false;
  }
  if (!Check(create_tex.hResource.pDrvPrivate != nullptr, "CreateResource(texture) returned handle")) {
    return false;
  }
  cleanup.hTexture = create_tex.hResource;
  cleanup.has_texture = true;

  hr = cleanup.device_funcs.pfnSetTexture(create_dev.hDevice, 0, create_tex.hResource);
  if (!Check(hr == S_OK, "SetTexture(stage0)")) {
    return false;
  }

  // D3DFVF_XYZ (0x2) | D3DFVF_DIFFUSE (0x40) | D3DFVF_TEX1 (0x100).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x142u);
  if (!Check(hr == S_OK, "SetFVF(XYZ|DIFFUSE|TEX1)")) {
    return false;
  }

  // Set WORLD/VIEW/PROJECTION transforms and verify fixed-function WVP constants
  // (c240..c243) are uploaded for XYZ vertices.
  D3DMATRIX identity{};
  identity.m[0][0] = 1.0f;
  identity.m[1][1] = 1.0f;
  identity.m[2][2] = 1.0f;
  identity.m[3][3] = 1.0f;

  D3DMATRIX world{};
  world.m[0][0] = 2.0f;
  world.m[1][1] = 3.0f;
  world.m[2][2] = 4.0f;
  world.m[3][0] = 5.0f;
  world.m[3][1] = 6.0f;
  world.m[3][2] = 7.0f;
  world.m[3][3] = 1.0f;

  hr = cleanup.device_funcs.pfnSetTransform(create_dev.hDevice, D3DTS_WORLD, &world);
  if (!Check(hr == S_OK, "SetTransform(WORLD)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTransform(create_dev.hDevice, D3DTS_VIEW, &identity);
  if (!Check(hr == S_OK, "SetTransform(VIEW)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTransform(create_dev.hDevice, D3DTS_PROJECTION, &identity);
  if (!Check(hr == S_OK, "SetTransform(PROJECTION)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    uint32_t color;
    float u;
    float v;
  };

  constexpr uint32_t kWhite = 0xFFFFFFFFu;
  Vertex verts[3]{};
  verts[0] = {-0.5f, -0.5f, 0.5f, kWhite, 0.0f, 0.0f};
  verts[1] = {0.5f, -0.5f, 0.5f, kWhite, 1.0f, 0.0f};
  verts[2] = {0.0f, 0.5f, 0.5f, kWhite, 0.5f, 1.0f};

  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 1, verts, sizeof(Vertex));
  if (!Check(hr == S_OK, "DrawPrimitiveUP")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  if (!Check(dev->up_vertex_buffer != nullptr, "up_vertex_buffer allocated")) {
    return false;
  }
  const aerogpu_handle_t up_vb_handle = dev->up_vertex_buffer->handle;
  if (!Check(up_vb_handle != 0, "up_vertex_buffer handle non-zero")) {
    return false;
  }
  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  float world_f[16] = {
      world.m[0][0], world.m[0][1], world.m[0][2], world.m[0][3],
      world.m[1][0], world.m[1][1], world.m[1][2], world.m[1][3],
      world.m[2][0], world.m[2][1], world.m[2][2], world.m[2][3],
      world.m[3][0], world.m[3][1], world.m[3][2], world.m[3][3],
  };
  float view_f[16] = {
      identity.m[0][0], identity.m[0][1], identity.m[0][2], identity.m[0][3],
      identity.m[1][0], identity.m[1][1], identity.m[1][2], identity.m[1][3],
      identity.m[2][0], identity.m[2][1], identity.m[2][2], identity.m[2][3],
      identity.m[3][0], identity.m[3][1], identity.m[3][2], identity.m[3][3],
  };
  float proj_f[16] = {
      identity.m[0][0], identity.m[0][1], identity.m[0][2], identity.m[0][3],
      identity.m[1][0], identity.m[1][1], identity.m[1][2], identity.m[1][3],
      identity.m[2][0], identity.m[2][1], identity.m[2][2], identity.m[2][3],
      identity.m[3][0], identity.m[3][1], identity.m[3][2], identity.m[3][3],
  };

  // Expected WVP columns (transpose of row-major WVP) uploaded to c240..c243.
  float wv[16];
  float wvp[16];
  MulMat4RowMajor(world_f, view_f, wv);
  MulMat4RowMajor(wv, proj_f, wvp);
  float expected_cols[16] = {};
  for (int c = 0; c < 4; ++c) {
    expected_cols[c * 4 + 0] = wvp[0 * 4 + c];
    expected_cols[c * 4 + 1] = wvp[1 * 4 + c];
    expected_cols[c * 4 + 2] = wvp[2 * 4 + c];
    expected_cols[c * 4 + 3] = wvp[3 * 4 + c];
  }

  const CmdLoc upload = FindLastUploadForHandle(buf, len, up_vb_handle);
  if (!Check(upload.hdr != nullptr, "upload_resource(up_vertex_buffer) emitted")) {
    return false;
  }
  const auto* upload_cmd = reinterpret_cast<const aerogpu_cmd_upload_resource*>(upload.hdr);
  if (!Check(upload_cmd->offset_bytes == 0, "upload_resource VB offset is 0")) {
    return false;
  }
  if (!Check(upload_cmd->size_bytes == sizeof(verts), "upload_resource VB size matches original vertex data")) {
    return false;
  }

  const uint8_t* payload = reinterpret_cast<const uint8_t*>(upload_cmd) + sizeof(*upload_cmd);
  float x0 = 0.0f;
  float y0 = 0.0f;
  float z0 = 0.0f;
  uint32_t c0 = 0;
  float u0 = 0.0f;
  float v0_out = 0.0f;
  std::memcpy(&x0, payload + 0, sizeof(float));
  std::memcpy(&y0, payload + 4, sizeof(float));
  std::memcpy(&z0, payload + 8, sizeof(float));
  std::memcpy(&c0, payload + 12, sizeof(uint32_t));
  std::memcpy(&u0, payload + 16, sizeof(float));
  std::memcpy(&v0_out, payload + 20, sizeof(float));

  if (!Check(std::fabs(x0 - verts[0].x) < 1e-6f, "XYZ|TEX1 SetTransform: x0 preserved (no CPU conversion)")) {
    return false;
  }
  if (!Check(std::fabs(y0 - verts[0].y) < 1e-6f, "XYZ|TEX1 SetTransform: y0 preserved (no CPU conversion)")) {
    return false;
  }
  if (!Check(std::fabs(z0 - verts[0].z) < 1e-6f, "XYZ|TEX1 SetTransform: z0 preserved")) {
    return false;
  }
  if (!Check(c0 == kWhite, "XYZ|TEX1 SetTransform: diffuse color preserved")) {
    return false;
  }
  if (!Check(std::fabs(u0 - verts[0].u) < 1e-6f, "XYZ|TEX1 SetTransform: u preserved")) {
    return false;
  }
  if (!Check(std::fabs(v0_out - verts[0].v) < 1e-6f, "XYZ|TEX1 SetTransform: v preserved")) {
    return false;
  }

  const CmdLoc wvp_consts = FindLastVsWvpConstants(buf, len);
  if (!Check(wvp_consts.hdr != nullptr, "SET_SHADER_CONSTANTS_F uploads WVP constants")) {
    return false;
  }
  const auto* sc = reinterpret_cast<const aerogpu_cmd_set_shader_constants_f*>(wvp_consts.hdr);
  if (!Check(wvp_consts.hdr->size_bytes >= sizeof(*sc) + sizeof(expected_cols), "WVP constants payload size")) {
    return false;
  }
  const float* cols = reinterpret_cast<const float*>(reinterpret_cast<const uint8_t*>(sc) + sizeof(*sc));
  if (!Check(std::memcmp(cols, expected_cols, sizeof(expected_cols)) == 0, "WVP constants payload matches expected columns")) {
    return false;
  }

  const CmdLoc draw = FindLastOpcode(buf, len, AEROGPU_CMD_DRAW);
  if (!Check(draw.hdr != nullptr, "DRAW emitted")) {
    return false;
  }
  const CmdLoc bind = FindLastOpcodeBefore(buf, len, draw.offset, AEROGPU_CMD_BIND_SHADERS);
  if (!Check(bind.hdr != nullptr, "BIND_SHADERS emitted")) {
    return false;
  }
  const auto* bind_cmd = reinterpret_cast<const aerogpu_cmd_bind_shaders*>(bind.hdr);
  if (!Check(bind_cmd->vs != 0, "BIND_SHADERS binds non-zero VS")) {
    return false;
  }

  const auto* create_vs = FindCreateShaderByHandle(buf, len, bind_cmd->vs);
  if (!Check(create_vs != nullptr, "CREATE_SHADER_DXBC for bound VS is present")) {
    return false;
  }
  if (!Check(create_vs->stage == AEROGPU_SHADER_STAGE_VERTEX, "bound VS stage is VERTEX")) {
    return false;
  }
  if (!Check(create_vs->dxbc_size_bytes == sizeof(fixedfunc::kVsWvpPosColorTex0), "bound VS bytecode size matches")) {
    return false;
  }
  {
    const uint8_t* vs_payload = reinterpret_cast<const uint8_t*>(create_vs) + sizeof(*create_vs);
    if (!Check(std::memcmp(vs_payload, fixedfunc::kVsWvpPosColorTex0, sizeof(fixedfunc::kVsWvpPosColorTex0)) == 0,
               "bound VS bytecode matches fixedfunc WVP(TEX1) shader")) {
      return false;
    }
  }

  if (!CheckWvpConstantsUploadedBeforeDraw(buf, len, draw.offset, wvp, "XYZ|TEX1 SetTransform: WVP constants uploaded")) {
    return false;
  }

  return ValidateStream(buf, len);
}

bool TestFvfXyzDiffuseTex1ReuploadsWvpAfterUserVsClobbersConstants() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3D9DDI_HSHADER hShader{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_shader = false;

    ~Cleanup() {
      if (has_shader && device_funcs.pfnDestroyShader) {
        device_funcs.pfnDestroyShader(hDevice, hShader);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnCreateShader != nullptr, "CreateShader must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDestroyShader != nullptr, "DestroyShader must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetShader != nullptr, "SetShader must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetShaderConstF != nullptr, "SetShaderConstF must be available")) {
    return false;
  }

  // D3DFVF_XYZ (0x2) | D3DFVF_DIFFUSE (0x40) | D3DFVF_TEX1 (0x100).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x142u);
  if (!Check(hr == S_OK, "SetFVF(XYZ|DIFFUSE|TEX1)")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  float world[16] = {};
  float view[16] = {};
  float proj[16] = {};
  auto set_identity = [](float m[16]) {
    std::memset(m, 0, sizeof(float) * 16);
    m[0] = 1.0f;
    m[5] = 1.0f;
    m[10] = 1.0f;
    m[15] = 1.0f;
  };
  set_identity(world);
  set_identity(view);
  set_identity(proj);
  // Scale + translate.
  world[0] = 2.0f;
  world[5] = 3.0f;
  world[10] = 4.0f;
  world[12] = 5.0f;
  world[13] = 6.0f;
  world[14] = 7.0f;

  if (!Check(cleanup.device_funcs.pfnSetTransform != nullptr, "SetTransform must be available")) {
    return false;
  }
  D3DMATRIX world_m{};
  D3DMATRIX view_m{};
  D3DMATRIX proj_m{};
  std::memcpy(world_m.m, world, sizeof(world));
  std::memcpy(view_m.m, view, sizeof(view));
  std::memcpy(proj_m.m, proj, sizeof(proj));
  hr = cleanup.device_funcs.pfnSetTransform(create_dev.hDevice, D3DTS_WORLD, &world_m);
  if (!Check(hr == S_OK, "SetTransform(WORLD)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTransform(create_dev.hDevice, D3DTS_VIEW, &view_m);
  if (!Check(hr == S_OK, "SetTransform(VIEW)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTransform(create_dev.hDevice, D3DTS_PROJECTION, &proj_m);
  if (!Check(hr == S_OK, "SetTransform(PROJECTION)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    uint32_t color;
    float u;
    float v;
  };
  constexpr uint32_t kWhite = 0xFFFFFFFFu;
  Vertex verts[3]{};
  verts[0] = {-1.0f, -1.0f, 0.0f, kWhite, 0.0f, 0.0f};
  verts[1] = {1.0f, -1.0f, 0.0f, kWhite, 1.0f, 0.0f};
  verts[2] = {0.0f, 1.0f, 0.0f, kWhite, 0.5f, 1.0f};

  // First draw in fixed-function mode.
  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 1, verts, sizeof(Vertex));
  if (!Check(hr == S_OK, "DrawPrimitiveUP (first)")) {
    return false;
  }

  // Bind a user VS and clobber constants, then return to fixed-function mode.
  const uint8_t dxbc[] = {0x44, 0x58, 0x42, 0x43, 0x00, 0x01, 0x02, 0x03};
  D3D9DDI_HSHADER hShader{};
  hr = cleanup.device_funcs.pfnCreateShader(
      create_dev.hDevice, kD3d9ShaderStageVs, dxbc, static_cast<uint32_t>(sizeof(dxbc)), &hShader);
  if (!Check(hr == S_OK, "CreateShader(VS)")) {
    return false;
  }
  cleanup.hShader = hShader;
  cleanup.has_shader = true;

  hr = cleanup.device_funcs.pfnSetShader(create_dev.hDevice, kD3d9ShaderStageVs, hShader);
  if (!Check(hr == S_OK, "SetShader(VS)")) {
    return false;
  }

  float clobber[16];
  for (int i = 0; i < 16; ++i) {
    clobber[i] = 99.0f;
  }
  hr = cleanup.device_funcs.pfnSetShaderConstF(create_dev.hDevice,
                                               kD3d9ShaderStageVs,
                                               kFixedfuncMatrixStartRegister,
                                               clobber,
                                               kFixedfuncMatrixVec4Count);
  if (!Check(hr == S_OK, "SetShaderConstF(VS, c240..c243)")) {
    return false;
  }

  D3D9DDI_HSHADER null_shader{};
  hr = cleanup.device_funcs.pfnSetShader(create_dev.hDevice, kD3d9ShaderStageVs, null_shader);
  if (!Check(hr == S_OK, "SetShader(VS=null)")) {
    return false;
  }

  // Second draw in fixed-function mode.
  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 1, verts, sizeof(Vertex));
  if (!Check(hr == S_OK, "DrawPrimitiveUP (second)")) {
    return false;
  }

  if (!Check(dev->up_vertex_buffer != nullptr, "up_vertex_buffer allocated")) {
    return false;
  }
  const aerogpu_handle_t up_vb_handle = dev->up_vertex_buffer->handle;
  if (!Check(up_vb_handle != 0, "up_vertex_buffer handle non-zero")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  // Expected WVP columns (transpose of row-major WVP) uploaded to c240..c243.
  float wv[16];
  float wvp[16];
  MulMat4RowMajor(world, view, wv);
  MulMat4RowMajor(wv, proj, wvp);
  float expected_cols[16] = {};
  for (int c = 0; c < 4; ++c) {
    expected_cols[c * 4 + 0] = wvp[0 * 4 + c];
    expected_cols[c * 4 + 1] = wvp[1 * 4 + c];
    expected_cols[c * 4 + 2] = wvp[2 * 4 + c];
    expected_cols[c * 4 + 3] = wvp[3 * 4 + c];
  }

  const CmdLoc upload = FindLastUploadForHandle(buf, len, up_vb_handle);
  if (!Check(upload.hdr != nullptr, "upload_resource(up_vertex_buffer) emitted")) {
    return false;
  }
  const auto* upload_cmd = reinterpret_cast<const aerogpu_cmd_upload_resource*>(upload.hdr);
  if (!Check(upload_cmd->offset_bytes == 0, "upload_resource VB offset is 0")) {
    return false;
  }
  if (!Check(upload_cmd->size_bytes == sizeof(verts), "upload_resource VB size matches original vertex data")) {
    return false;
  }

  const uint8_t* payload = reinterpret_cast<const uint8_t*>(upload_cmd) + sizeof(*upload_cmd);
  float x0 = 0.0f;
  float y0 = 0.0f;
  float z0 = 0.0f;
  uint32_t c0 = 0;
  float u0 = 0.0f;
  float v0_out = 0.0f;
  std::memcpy(&x0, payload + 0, sizeof(float));
  std::memcpy(&y0, payload + 4, sizeof(float));
  std::memcpy(&z0, payload + 8, sizeof(float));
  std::memcpy(&c0, payload + 12, sizeof(uint32_t));
  std::memcpy(&u0, payload + 16, sizeof(float));
  std::memcpy(&v0_out, payload + 20, sizeof(float));

  if (!Check(std::fabs(x0 - verts[0].x) < 1e-6f, "XYZ|TEX1 clobber: x0 preserved (no CPU conversion)")) {
    return false;
  }
  if (!Check(std::fabs(y0 - verts[0].y) < 1e-6f, "XYZ|TEX1 clobber: y0 preserved (no CPU conversion)")) {
    return false;
  }
  if (!Check(std::fabs(z0 - verts[0].z) < 1e-6f, "XYZ|TEX1 clobber: z0 preserved")) {
    return false;
  }
  if (!Check(c0 == kWhite, "XYZ|TEX1 clobber: diffuse color preserved")) {
    return false;
  }
  if (!Check(std::fabs(u0 - verts[0].u) < 1e-6f, "XYZ|TEX1 clobber: u preserved")) {
    return false;
  }
  if (!Check(std::fabs(v0_out - verts[0].v) < 1e-6f, "XYZ|TEX1 clobber: v preserved")) {
    return false;
  }

  const CmdLoc wvp_consts = FindLastVsWvpConstants(buf, len);
  if (!Check(wvp_consts.hdr != nullptr, "SET_SHADER_CONSTANTS_F reuploads WVP constants after clobber")) {
    return false;
  }
  const auto* sc = reinterpret_cast<const aerogpu_cmd_set_shader_constants_f*>(wvp_consts.hdr);
  if (!Check(wvp_consts.hdr->size_bytes >= sizeof(*sc) + sizeof(expected_cols), "WVP constants payload size")) {
    return false;
  }
  const float* cols = reinterpret_cast<const float*>(reinterpret_cast<const uint8_t*>(sc) + sizeof(*sc));
  if (!Check(std::memcmp(cols, expected_cols, sizeof(expected_cols)) == 0,
             "WVP constants payload matches expected columns after clobber")) {
    return false;
  }

  const CmdLoc draw = FindLastOpcode(buf, len, AEROGPU_CMD_DRAW);
  if (!Check(draw.hdr != nullptr, "DRAW emitted")) {
    return false;
  }
  if (!CheckWvpConstantsUploadedBeforeDraw(buf, len, draw.offset, wvp, "XYZ|TEX1 clobber: WVP constants uploaded")) {
    return false;
  }

  return ValidateStream(buf, len);
}

bool TestFvfXyzDiffuseTex1DrawIndexedPrimitiveUpAppliesWvpTransform() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawIndexedPrimitive2 != nullptr, "DrawIndexedPrimitive2 must be available")) {
    return false;
  }

  // D3DFVF_XYZ (0x2) | D3DFVF_DIFFUSE (0x40) | D3DFVF_TEX1 (0x100).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x142u);
  if (!Check(hr == S_OK, "SetFVF(XYZ|DIFFUSE|TEX1)")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  // Set non-identity transforms: WORLD0 * VIEW * PROJECTION.
  auto set_identity = [](float m[16]) {
    std::memset(m, 0, sizeof(float) * 16);
    m[0] = 1.0f;
    m[5] = 1.0f;
    m[10] = 1.0f;
    m[15] = 1.0f;
  };

  float world[16];
  float view[16];
  float proj[16];
  set_identity(world);
  set_identity(view);
  std::memset(proj, 0, sizeof(proj));

  world[12] = 1.0f;
  world[13] = -1.0f;
  world[14] = 2.0f;

  view[0] = 2.0f;
  view[5] = 3.0f;
  view[10] = 4.0f;

  proj[0] = 1.0f;
  proj[5] = 1.0f;
  proj[10] = 1.0f;
  proj[11] = 1.0f; // w = z

  if (!Check(cleanup.device_funcs.pfnSetTransform != nullptr, "SetTransform must be available")) {
    return false;
  }
  D3DMATRIX world_m{};
  D3DMATRIX view_m{};
  D3DMATRIX proj_m{};
  std::memcpy(world_m.m, world, sizeof(world));
  std::memcpy(view_m.m, view, sizeof(view));
  std::memcpy(proj_m.m, proj, sizeof(proj));
  hr = cleanup.device_funcs.pfnSetTransform(create_dev.hDevice, D3DTS_WORLD, &world_m);
  if (!Check(hr == S_OK, "SetTransform(WORLD)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTransform(create_dev.hDevice, D3DTS_VIEW, &view_m);
  if (!Check(hr == S_OK, "SetTransform(VIEW)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTransform(create_dev.hDevice, D3DTS_PROJECTION, &proj_m);
  if (!Check(hr == S_OK, "SetTransform(PROJECTION)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    uint32_t color;
    float u;
    float v;
  };
  constexpr uint32_t kWhite = 0xFFFFFFFFu;
  Vertex verts[3]{};
  verts[0] = {-0.5f, -0.5f, 0.5f, kWhite, 0.0f, 0.0f};
  verts[1] = {0.5f, -0.5f, 0.5f, kWhite, 1.0f, 0.0f};
  verts[2] = {0.0f, 0.5f, 0.5f, kWhite, 0.5f, 1.0f};

  const uint16_t indices[3] = {0, 1, 2};
  D3DDDIARG_DRAWINDEXEDPRIMITIVE2 draw{};
  draw.PrimitiveType = D3DDDIPT_TRIANGLELIST;
  draw.PrimitiveCount = 1;
  draw.MinIndex = 0;
  draw.NumVertices = 3;
  draw.pIndexData = indices;
  draw.IndexDataFormat = kD3dFmtIndex16;
  draw.pVertexStreamZeroData = verts;
  draw.VertexStreamZeroStride = sizeof(Vertex);

  hr = cleanup.device_funcs.pfnDrawIndexedPrimitive2(create_dev.hDevice, &draw);
  if (!Check(hr == S_OK, "DrawIndexedPrimitive2")) {
    return false;
  }

  if (!Check(dev->up_vertex_buffer != nullptr, "up_vertex_buffer allocated")) {
    return false;
  }
  const aerogpu_handle_t up_vb_handle = dev->up_vertex_buffer->handle;
  if (!Check(up_vb_handle != 0, "up_vertex_buffer handle non-zero")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  // Expected WVP columns (transpose of row-major WVP) uploaded to c240..c243.
  float wv[16];
  float wvp[16];
  MulMat4RowMajor(world, view, wv);
  MulMat4RowMajor(wv, proj, wvp);
  float expected_cols[16] = {};
  for (int c = 0; c < 4; ++c) {
    expected_cols[c * 4 + 0] = wvp[0 * 4 + c];
    expected_cols[c * 4 + 1] = wvp[1 * 4 + c];
    expected_cols[c * 4 + 2] = wvp[2 * 4 + c];
    expected_cols[c * 4 + 3] = wvp[3 * 4 + c];
  }

  const CmdLoc upload = FindLastUploadForHandle(buf, len, up_vb_handle);
  if (!Check(upload.hdr != nullptr, "upload_resource(up_vertex_buffer) emitted")) {
    return false;
  }
  const auto* upload_cmd = reinterpret_cast<const aerogpu_cmd_upload_resource*>(upload.hdr);
  if (!Check(upload_cmd->offset_bytes == 0, "upload_resource VB offset is 0")) {
    return false;
  }
  if (!Check(upload_cmd->size_bytes == sizeof(verts), "upload_resource VB size matches original vertex data")) {
    return false;
  }

  const uint8_t* payload = reinterpret_cast<const uint8_t*>(upload_cmd) + sizeof(*upload_cmd);
  float x0 = 0.0f;
  float y0 = 0.0f;
  float z0 = 0.0f;
  uint32_t c0 = 0;
  float u0 = 0.0f;
  float v0_out = 0.0f;
  std::memcpy(&x0, payload + 0, sizeof(float));
  std::memcpy(&y0, payload + 4, sizeof(float));
  std::memcpy(&z0, payload + 8, sizeof(float));
  std::memcpy(&c0, payload + 12, sizeof(uint32_t));
  std::memcpy(&u0, payload + 16, sizeof(float));
  std::memcpy(&v0_out, payload + 20, sizeof(float));

  if (!Check(std::fabs(x0 - verts[0].x) < 1e-6f, "XYZ|TEX1 Indexed UP: x0 preserved (no CPU conversion)")) {
    return false;
  }
  if (!Check(std::fabs(y0 - verts[0].y) < 1e-6f, "XYZ|TEX1 Indexed UP: y0 preserved (no CPU conversion)")) {
    return false;
  }
  if (!Check(std::fabs(z0 - verts[0].z) < 1e-6f, "XYZ|TEX1 Indexed UP: z preserved")) {
    return false;
  }
  if (!Check(c0 == kWhite, "XYZ|TEX1 Indexed UP: diffuse color preserved")) {
    return false;
  }
  if (!Check(std::fabs(u0 - verts[0].u) < 1e-6f, "XYZ|TEX1 Indexed UP: u preserved")) {
    return false;
  }
  if (!Check(std::fabs(v0_out - verts[0].v) < 1e-6f, "XYZ|TEX1 Indexed UP: v preserved")) {
    return false;
  }

  const CmdLoc wvp_consts = FindLastVsWvpConstants(buf, len);
  if (!Check(wvp_consts.hdr != nullptr, "SET_SHADER_CONSTANTS_F uploads WVP constants")) {
    return false;
  }
  const auto* sc = reinterpret_cast<const aerogpu_cmd_set_shader_constants_f*>(wvp_consts.hdr);
  if (!Check(wvp_consts.hdr->size_bytes >= sizeof(*sc) + sizeof(expected_cols), "WVP constants payload size")) {
    return false;
  }
  const float* cols = reinterpret_cast<const float*>(reinterpret_cast<const uint8_t*>(sc) + sizeof(*sc));
  if (!Check(std::memcmp(cols, expected_cols, sizeof(expected_cols)) == 0, "WVP constants payload matches expected columns")) {
    return false;
  }

  const CmdLoc draw_cmd = FindLastOpcode(buf, len, AEROGPU_CMD_DRAW_INDEXED);
  if (!Check(draw_cmd.hdr != nullptr, "DRAW_INDEXED emitted")) {
    return false;
  }
  if (!CheckWvpConstantsUploadedBeforeDraw(buf, len, draw_cmd.offset, wvp, "XYZ|TEX1 Indexed UP: WVP constants uploaded")) {
    return false;
  }

  return ValidateStream(buf, len);
}

bool TestFvfXyzDiffuseDrawPrimitiveUpEmitsWvpConstants() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetTransform != nullptr, "SetTransform must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }

  // D3DFVF_XYZ (0x2) | D3DFVF_DIFFUSE (0x40).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x42u);
  if (!Check(hr == S_OK, "SetFVF(XYZ|DIFFUSE)")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  // Non-trivial WORLD/VIEW/PROJECTION so we cover more than simple scale/translate.
  const float world_f[16] = {
      1.0f, 2.0f, 3.0f, 4.0f,
      0.0f, 1.0f, 0.0f, 0.0f,
      5.0f, 6.0f, 7.0f, 8.0f,
      9.0f, 10.0f, 11.0f, 1.0f,
  };
  const float view_f[16] = {
      2.0f, 0.0f, 0.0f, 0.0f,
      0.0f, 3.0f, 0.0f, 0.0f,
      0.0f, 0.0f, 4.0f, 0.0f,
      1.0f, 2.0f, 3.0f, 1.0f,
  };
  const float proj_f[16] = {
      1.0f, 0.0f, 0.0f, 0.0f,
      0.0f, 1.0f, 0.0f, 0.0f,
      0.0f, 0.0f, 1.0f, 0.0f,
      0.25f, 0.5f, 0.75f, 1.0f,
  };

  D3DMATRIX world{};
  std::memcpy(&world.m[0][0], world_f, sizeof(world_f));
  D3DMATRIX view{};
  std::memcpy(&view.m[0][0], view_f, sizeof(view_f));
  D3DMATRIX proj{};
  std::memcpy(&proj.m[0][0], proj_f, sizeof(proj_f));

  hr = cleanup.device_funcs.pfnSetTransform(create_dev.hDevice, D3DTS_WORLD, &world);
  if (!Check(hr == S_OK, "SetTransform(WORLD0)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTransform(create_dev.hDevice, D3DTS_VIEW, &view);
  if (!Check(hr == S_OK, "SetTransform(VIEW)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTransform(create_dev.hDevice, D3DTS_PROJECTION, &proj);
  if (!Check(hr == S_OK, "SetTransform(PROJECTION)")) {
    return false;
  }
  {
    std::lock_guard<std::mutex> lock(dev->mutex);
    const FixedFuncVariant variant = fixedfunc_variant_from_fvf(kD3dFvfXyz | kD3dFvfDiffuse);
    if (!Check(variant != FixedFuncVariant::NONE, "FVF variant recognized")) {
      return false;
    }
    const auto& pipe = dev->fixedfunc_pipelines[static_cast<size_t>(variant)];
    if (!Check(pipe.vertex_decl != nullptr, "FVF internal vertex decl created")) {
      return false;
    }
  }
  struct Vertex {
    float x;
    float y;
    float z;
    uint32_t color;
  };
  constexpr uint32_t kWhite = 0xFFFFFFFFu;
  Vertex verts[3]{};
  verts[0] = {-1.0f, -1.0f, 0.0f, kWhite};
  verts[1] = {1.0f, -1.0f, 0.0f, kWhite};
  verts[2] = {0.0f, 1.0f, 0.0f, kWhite};

  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 1, verts, sizeof(Vertex));
  if (!Check(hr == S_OK, "DrawPrimitiveUP")) {
    return false;
  }

  if (!Check(dev->up_vertex_buffer != nullptr, "up_vertex_buffer allocated")) {
    return false;
  }
  const aerogpu_handle_t up_vb_handle = dev->up_vertex_buffer->handle;
  if (!Check(up_vb_handle != 0, "up_vertex_buffer handle non-zero")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  // Expected WVP columns (transpose of row-major WVP) uploaded to c240..c243.
  float wv[16];
  float wvp[16];
  MulMat4RowMajor(world_f, view_f, wv);
  MulMat4RowMajor(wv, proj_f, wvp);
  float expected_cols[16] = {};
  for (int c = 0; c < 4; ++c) {
    expected_cols[c * 4 + 0] = wvp[0 * 4 + c];
    expected_cols[c * 4 + 1] = wvp[1 * 4 + c];
    expected_cols[c * 4 + 2] = wvp[2 * 4 + c];
    expected_cols[c * 4 + 3] = wvp[3 * 4 + c];
  }

  const CmdLoc upload = FindLastUploadForHandle(buf, len, up_vb_handle);
  if (!Check(upload.hdr != nullptr, "upload_resource(up_vertex_buffer) emitted")) {
    return false;
  }
  const auto* upload_cmd = reinterpret_cast<const aerogpu_cmd_upload_resource*>(upload.hdr);
  if (!Check(upload_cmd->offset_bytes == 0, "upload_resource VB offset is 0")) {
    return false;
  }
  if (!Check(upload_cmd->size_bytes == sizeof(verts), "upload_resource VB size matches original vertex data")) {
    return false;
  }

  const uint8_t* payload = reinterpret_cast<const uint8_t*>(upload_cmd) + sizeof(*upload_cmd);
  float x0 = 0.0f;
  float y0 = 0.0f;
  float z0 = 0.0f;
  uint32_t c0 = 0;
  std::memcpy(&x0, payload + 0, sizeof(float));
  std::memcpy(&y0, payload + 4, sizeof(float));
  std::memcpy(&z0, payload + 8, sizeof(float));
  std::memcpy(&c0, payload + 12, sizeof(uint32_t));

  if (!Check(std::fabs(x0 - verts[0].x) < 1e-6f, "XYZ SetTransform: x0 preserved (no CPU conversion)")) {
    return false;
  }
  if (!Check(std::fabs(y0 - verts[0].y) < 1e-6f, "XYZ SetTransform: y0 preserved (no CPU conversion)")) {
    return false;
  }
  if (!Check(std::fabs(z0 - verts[0].z) < 1e-6f, "XYZ SetTransform: z0 preserved")) {
    return false;
  }
  if (!Check(c0 == kWhite, "XYZ SetTransform: diffuse color preserved")) {
    return false;
  }

  const CmdLoc wvp_consts = FindLastVsWvpConstants(buf, len);
  if (!Check(wvp_consts.hdr != nullptr, "SET_SHADER_CONSTANTS_F uploads WVP constants")) {
    return false;
  }
  const auto* sc = reinterpret_cast<const aerogpu_cmd_set_shader_constants_f*>(wvp_consts.hdr);
  if (!Check(wvp_consts.hdr->size_bytes >= sizeof(*sc) + sizeof(expected_cols), "WVP constants payload size")) {
    return false;
  }
  const float* cols = reinterpret_cast<const float*>(reinterpret_cast<const uint8_t*>(sc) + sizeof(*sc));
  if (!Check(std::memcmp(cols, expected_cols, sizeof(expected_cols)) == 0, "WVP constants payload matches expected columns")) {
    return false;
  }

  const CmdLoc draw = FindLastOpcode(buf, len, AEROGPU_CMD_DRAW);
  if (!Check(draw.hdr != nullptr, "DRAW emitted")) {
    return false;
  }
  if (!CheckWvpConstantsUploadedBeforeDraw(buf, len, draw.offset, wvp, "XYZ SetTransform: WVP constants uploaded")) {
    return false;
  }

  return ValidateStream(buf, len);
}

bool TestFixedFuncXyzStateBlockApplyReuploadsWvpConstants() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3D9DDI_HSTATEBLOCK hStateBlock{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_stateblock = false;

    ~Cleanup() {
      if (has_stateblock && device_funcs.pfnDeleteStateBlock) {
        device_funcs.pfnDeleteStateBlock(hDevice, hStateBlock);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetTransform != nullptr, "SetTransform must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnBeginStateBlock != nullptr, "BeginStateBlock must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnEndStateBlock != nullptr, "EndStateBlock must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnApplyStateBlock != nullptr, "ApplyStateBlock must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDeleteStateBlock != nullptr, "DeleteStateBlock must be available")) {
    return false;
  }

  // D3DFVF_XYZ (0x2) | D3DFVF_DIFFUSE (0x40) | D3DFVF_TEX1 (0x100).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x142u);
  if (!Check(hr == S_OK, "SetFVF(XYZ|DIFFUSE|TEX1)")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  // Ensure view/proj are identity so WVP == WORLD0.
  D3DMATRIX identity{};
  identity.m[0][0] = 1.0f;
  identity.m[1][1] = 1.0f;
  identity.m[2][2] = 1.0f;
  identity.m[3][3] = 1.0f;
  hr = cleanup.device_funcs.pfnSetTransform(create_dev.hDevice, D3DTS_VIEW, &identity);
  if (!Check(hr == S_OK, "SetTransform(VIEW=identity)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTransform(create_dev.hDevice, D3DTS_PROJECTION, &identity);
  if (!Check(hr == S_OK, "SetTransform(PROJECTION=identity)")) {
    return false;
  }

  // Matrix A (captured in state block).
  D3DMATRIX A{};
  A.m[0][0] = 2.0f;
  A.m[1][1] = 3.0f;
  A.m[2][2] = 4.0f;
  A.m[3][3] = 1.0f;
  A.m[3][0] = 5.0f;
  A.m[3][1] = 6.0f;
  A.m[3][2] = 7.0f;

  // Matrix B (mutated after recording).
  D3DMATRIX B{};
  B.m[0][0] = 8.0f;
  B.m[1][1] = 9.0f;
  B.m[2][2] = 10.0f;
  B.m[3][3] = 1.0f;
  B.m[3][0] = 11.0f;
  B.m[3][1] = 12.0f;
  B.m[3][2] = 13.0f;

  // Record a state block that sets WORLD=A.
  hr = cleanup.device_funcs.pfnBeginStateBlock(create_dev.hDevice);
  if (!Check(hr == S_OK, "BeginStateBlock")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTransform(create_dev.hDevice, D3DTS_WORLD, &A);
  if (!Check(hr == S_OK, "SetTransform(WORLD=A)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnEndStateBlock(create_dev.hDevice, &cleanup.hStateBlock);
  if (!Check(hr == S_OK, "EndStateBlock")) {
    return false;
  }
  if (!Check(cleanup.hStateBlock.pDrvPrivate != nullptr, "EndStateBlock returns stateblock handle")) {
    return false;
  }
  cleanup.has_stateblock = true;

  // Mutate WORLD=B.
  hr = cleanup.device_funcs.pfnSetTransform(create_dev.hDevice, D3DTS_WORLD, &B);
  if (!Check(hr == S_OK, "SetTransform(WORLD=B)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    uint32_t color;
    float u;
    float v;
  };
  constexpr uint32_t kWhite = 0xFFFFFFFFu;
  Vertex verts[3]{};
  verts[0] = {-1.0f, -1.0f, 0.0f, kWhite, 0.0f, 0.0f};
  verts[1] = {1.0f, -1.0f, 0.0f, kWhite, 1.0f, 0.0f};
  verts[2] = {0.0f, 1.0f, 0.0f, kWhite, 0.5f, 1.0f};

  // First draw uses WORLD=B.
  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 1, verts, sizeof(Vertex));
  if (!Check(hr == S_OK, "DrawPrimitiveUP (first)")) {
    return false;
  }

  // Apply state block: restores WORLD=A.
  hr = cleanup.device_funcs.pfnApplyStateBlock(create_dev.hDevice, cleanup.hStateBlock);
  if (!Check(hr == S_OK, "ApplyStateBlock")) {
    return false;
  }

  // Second draw must use WORLD=A.
  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 1, verts, sizeof(Vertex));
  if (!Check(hr == S_OK, "DrawPrimitiveUP (second)")) {
    return false;
  }

  if (!Check(dev->up_vertex_buffer != nullptr, "up_vertex_buffer allocated")) {
    return false;
  }
  const aerogpu_handle_t up_vb_handle = dev->up_vertex_buffer->handle;
  if (!Check(up_vb_handle != 0, "up_vertex_buffer handle non-zero")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  // Expected WVP columns for WORLD=A (view/proj identity), uploaded to c240..c243.
  float worldA_f[16] = {
      A.m[0][0], A.m[0][1], A.m[0][2], A.m[0][3],
      A.m[1][0], A.m[1][1], A.m[1][2], A.m[1][3],
      A.m[2][0], A.m[2][1], A.m[2][2], A.m[2][3],
      A.m[3][0], A.m[3][1], A.m[3][2], A.m[3][3],
  };
  float view_f[16] = {
      identity.m[0][0], identity.m[0][1], identity.m[0][2], identity.m[0][3],
      identity.m[1][0], identity.m[1][1], identity.m[1][2], identity.m[1][3],
      identity.m[2][0], identity.m[2][1], identity.m[2][2], identity.m[2][3],
      identity.m[3][0], identity.m[3][1], identity.m[3][2], identity.m[3][3],
  };
  float proj_f[16] = {
      identity.m[0][0], identity.m[0][1], identity.m[0][2], identity.m[0][3],
      identity.m[1][0], identity.m[1][1], identity.m[1][2], identity.m[1][3],
      identity.m[2][0], identity.m[2][1], identity.m[2][2], identity.m[2][3],
      identity.m[3][0], identity.m[3][1], identity.m[3][2], identity.m[3][3],
  };
  float wv[16];
  float wvp[16];
  MulMat4RowMajor(worldA_f, view_f, wv);
  MulMat4RowMajor(wv, proj_f, wvp);
  float expected_cols[16] = {};
  for (int c = 0; c < 4; ++c) {
    expected_cols[c * 4 + 0] = wvp[0 * 4 + c];
    expected_cols[c * 4 + 1] = wvp[1 * 4 + c];
    expected_cols[c * 4 + 2] = wvp[2 * 4 + c];
    expected_cols[c * 4 + 3] = wvp[3 * 4 + c];
  }

  const CmdLoc upload = FindLastUploadForHandle(buf, len, up_vb_handle);
  if (!Check(upload.hdr != nullptr, "upload_resource(up_vertex_buffer) emitted")) {
    return false;
  }
  const auto* upload_cmd = reinterpret_cast<const aerogpu_cmd_upload_resource*>(upload.hdr);
  if (!Check(upload_cmd->offset_bytes == 0, "upload_resource VB offset is 0")) {
    return false;
  }
  if (!Check(upload_cmd->size_bytes == sizeof(verts), "upload_resource VB size matches original vertex data")) {
    return false;
  }

  const uint8_t* payload = reinterpret_cast<const uint8_t*>(upload_cmd) + sizeof(*upload_cmd);
  float x0 = 0.0f;
  float y0 = 0.0f;
  float z0 = 0.0f;
  uint32_t c0 = 0;
  float u0 = 0.0f;
  float v0_out = 0.0f;
  std::memcpy(&x0, payload + 0, sizeof(float));
  std::memcpy(&y0, payload + 4, sizeof(float));
  std::memcpy(&z0, payload + 8, sizeof(float));
  std::memcpy(&c0, payload + 12, sizeof(uint32_t));
  std::memcpy(&u0, payload + 16, sizeof(float));
  std::memcpy(&v0_out, payload + 20, sizeof(float));

  if (!Check(std::fabs(x0 - verts[0].x) < 1e-6f, "StateBlock XYZ|TEX1: x0 preserved (no CPU conversion)")) {
    return false;
  }
  if (!Check(std::fabs(y0 - verts[0].y) < 1e-6f, "StateBlock XYZ|TEX1: y0 preserved (no CPU conversion)")) {
    return false;
  }
  if (!Check(std::fabs(z0 - verts[0].z) < 1e-6f, "StateBlock XYZ|TEX1: z preserved")) {
    return false;
  }
  if (!Check(c0 == kWhite, "StateBlock XYZ|TEX1: diffuse color preserved")) {
    return false;
  }
  if (!Check(std::fabs(u0 - verts[0].u) < 1e-6f, "StateBlock XYZ|TEX1: u preserved")) {
    return false;
  }
  if (!Check(std::fabs(v0_out - verts[0].v) < 1e-6f, "StateBlock XYZ|TEX1: v preserved")) {
    return false;
  }

  const CmdLoc wvp_consts = FindLastVsWvpConstants(buf, len);
  if (!Check(wvp_consts.hdr != nullptr, "SET_SHADER_CONSTANTS_F reuploads WVP constants after ApplyStateBlock")) {
    return false;
  }
  const auto* sc = reinterpret_cast<const aerogpu_cmd_set_shader_constants_f*>(wvp_consts.hdr);
  if (!Check(wvp_consts.hdr->size_bytes >= sizeof(*sc) + sizeof(expected_cols), "WVP constants payload size")) {
    return false;
  }
  const float* cols = reinterpret_cast<const float*>(reinterpret_cast<const uint8_t*>(sc) + sizeof(*sc));
  if (!Check(std::memcmp(cols, expected_cols, sizeof(expected_cols)) == 0,
             "WVP constants payload matches expected columns for WORLD=A")) {
    return false;
  }

  const CmdLoc draw = FindLastOpcode(buf, len, AEROGPU_CMD_DRAW);
  if (!Check(draw.hdr != nullptr, "DRAW emitted")) {
    return false;
  }
  if (!CheckWvpConstantsUploadedBeforeDraw(buf, len, draw.offset, wvp, "StateBlock XYZ|TEX1: WVP constants uploaded after ApplyStateBlock")) {
    return false;
  }

  return ValidateStream(buf, len);
}

bool TestFixedFuncXyzNormalStateBlockApplyReuploadsLightingConstants() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3D9DDI_HSTATEBLOCK hStateBlock{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_stateblock = false;

    ~Cleanup() {
      if (has_stateblock && device_funcs.pfnDeleteStateBlock) {
        device_funcs.pfnDeleteStateBlock(hDevice, hStateBlock);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  constexpr uint32_t kD3dRsAmbient = 26u;   // D3DRS_AMBIENT
  constexpr uint32_t kD3dRsLighting = 137u; // D3DRS_LIGHTING

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetRenderState != nullptr, "SetRenderState must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnBeginStateBlock != nullptr, "BeginStateBlock must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnEndStateBlock != nullptr, "EndStateBlock must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnApplyStateBlock != nullptr, "ApplyStateBlock must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDeleteStateBlock != nullptr, "DeleteStateBlock must be available")) {
    return false;
  }

  // D3DFVF_XYZ (0x2) | D3DFVF_NORMAL (0x10) | D3DFVF_DIFFUSE (0x40).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x52u);
  if (!Check(hr == S_OK, "SetFVF(XYZ|NORMAL|DIFFUSE)")) {
    return false;
  }

  // Enable fixed-function lighting and set an initial global ambient.
  hr = cleanup.device_funcs.pfnSetRenderState(create_dev.hDevice, kD3dRsLighting, 1u);
  if (!Check(hr == S_OK, "SetRenderState(LIGHTING=TRUE)")) {
    return false;
  }
  const uint32_t ambient_blue = 0xFF0000FFu;
  hr = cleanup.device_funcs.pfnSetRenderState(create_dev.hDevice, kD3dRsAmbient, ambient_blue);
  if (!Check(hr == S_OK, "SetRenderState(AMBIENT=blue)")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  // Configure fixed-function lighting state via host-test entrypoints (portable
  // builds do not expose SetLight/SetMaterial in the device vtable).
  D3DLIGHT9 light0{};
  light0.Type = D3DLIGHT_DIRECTIONAL;
  light0.Direction = {0.0f, 0.0f, -1.0f};
  light0.Diffuse = {1.0f, 0.0f, 0.0f, 1.0f};
  light0.Ambient = {0.0f, 0.5f, 0.0f, 1.0f};
  hr = device_set_light(create_dev.hDevice, /*index=*/0, &light0);
  if (!Check(hr == S_OK, "SetLight(0)")) {
    return false;
  }
  hr = device_light_enable(create_dev.hDevice, /*index=*/0, TRUE);
  if (!Check(hr == S_OK, "LightEnable(0, TRUE)")) {
    return false;
  }
  D3DMATERIAL9 mat{};
  mat.Diffuse = {0.5f, 0.5f, 0.5f, 1.0f};
  mat.Ambient = {0.25f, 0.25f, 0.25f, 1.0f};
  mat.Emissive = {0.0f, 0.0f, 0.0f, 0.0f};
  hr = device_set_material(create_dev.hDevice, &mat);
  if (!Check(hr == S_OK, "SetMaterial")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    float nx;
    float ny;
    float nz;
    uint32_t diffuse;
  };
  const Vertex tri[3] = {
      {0.0f, 0.0f, 0.0f, /*nx=*/0.0f, /*ny=*/0.0f, /*nz=*/1.0f, 0xFFFFFFFFu},
      {1.0f, 0.0f, 0.0f, /*nx=*/0.0f, /*ny=*/0.0f, /*nz=*/1.0f, 0xFFFFFFFFu},
      {0.0f, 1.0f, 0.0f, /*nx=*/0.0f, /*ny=*/0.0f, /*nz=*/1.0f, 0xFFFFFFFFu},
  };

  // First draw: upload lighting constants and clear the dirty bit.
  dev->cmd.reset();
  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 1, tri, sizeof(Vertex));
  if (!Check(hr == S_OK, "DrawPrimitiveUP (initial)")) {
    return false;
  }
  dev->cmd.finalize();
  if (!Check(ValidateStream(dev->cmd.data(), dev->cmd.bytes_used()), "ValidateStream(initial draw)")) {
    return false;
  }
  {
    std::lock_guard<std::mutex> lock(dev->mutex);
    if (!Check(!dev->fixedfunc_lighting_dirty, "initial draw cleared fixedfunc_lighting_dirty")) {
      return false;
    }
  }

  // Record a state block that sets AMBIENT=red.
  const uint32_t ambient_red = 0xFFFF0000u;
  hr = cleanup.device_funcs.pfnBeginStateBlock(create_dev.hDevice);
  if (!Check(hr == S_OK, "BeginStateBlock")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetRenderState(create_dev.hDevice, kD3dRsAmbient, ambient_red);
  if (!Check(hr == S_OK, "SetRenderState(AMBIENT=red)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnEndStateBlock(create_dev.hDevice, &cleanup.hStateBlock);
  if (!Check(hr == S_OK, "EndStateBlock")) {
    return false;
  }
  if (!Check(cleanup.hStateBlock.pDrvPrivate != nullptr, "EndStateBlock returns stateblock handle")) {
    return false;
  }
  cleanup.has_stateblock = true;

  // Restore AMBIENT=blue and draw once to clear the dirty bit again. The apply
  // test relies on the lighting block being clean before ApplyStateBlock.
  hr = cleanup.device_funcs.pfnSetRenderState(create_dev.hDevice, kD3dRsAmbient, ambient_blue);
  if (!Check(hr == S_OK, "SetRenderState(AMBIENT=blue restore)")) {
    return false;
  }
  dev->cmd.reset();
  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 1, tri, sizeof(Vertex));
  if (!Check(hr == S_OK, "DrawPrimitiveUP (baseline)")) {
    return false;
  }
  dev->cmd.finalize();
  if (!Check(ValidateStream(dev->cmd.data(), dev->cmd.bytes_used()), "ValidateStream(baseline draw)")) {
    return false;
  }
  {
    std::lock_guard<std::mutex> lock(dev->mutex);
    if (!Check(!dev->fixedfunc_lighting_dirty, "baseline draw cleared fixedfunc_lighting_dirty")) {
      return false;
    }
  }

  // Apply the state block (AMBIENT=red) and draw. This should mark the lighting
  // constants dirty and re-upload the lighting constant block before the draw.
  dev->cmd.reset();
  hr = cleanup.device_funcs.pfnApplyStateBlock(create_dev.hDevice, cleanup.hStateBlock);
  if (!Check(hr == S_OK, "ApplyStateBlock")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 1, tri, sizeof(Vertex));
  if (!Check(hr == S_OK, "DrawPrimitiveUP (after ApplyStateBlock)")) {
    return false;
  }
  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();
  if (!Check(ValidateStream(buf, len), "ValidateStream(ApplyStateBlock lighting)")) {
    return false;
  }

  const CmdLoc draw = FindLastOpcode(buf, len, AEROGPU_CMD_DRAW);
  if (!Check(draw.hdr != nullptr, "DRAW emitted")) {
    return false;
  }

  const CmdLoc lighting_consts = FindLastShaderConstsFBefore(buf,
                                                             len,
                                                             draw.offset,
                                                             AEROGPU_SHADER_STAGE_VERTEX,
                                                             kFixedfuncLightingStartRegister,
                                                             kFixedfuncLightingVec4Count);
  if (!Check(lighting_consts.hdr != nullptr, "ApplyStateBlock triggers lighting constant upload")) {
    return false;
  }
  const auto* sc = reinterpret_cast<const aerogpu_cmd_set_shader_constants_f*>(lighting_consts.hdr);
  constexpr size_t kLightingPayloadBytes = kFixedfuncLightingVec4Count * 4u * sizeof(float);
  if (!Check(lighting_consts.hdr->size_bytes >= sizeof(*sc) + kLightingPayloadBytes, "lighting constant payload size")) {
    return false;
  }
  const float* payload = reinterpret_cast<const float*>(reinterpret_cast<const uint8_t*>(sc) + sizeof(*sc));
  constexpr float kEps = 1e-6f;
  if (!Check(std::fabs(payload[kFixedfuncLightingGlobalAmbientRel * 4 + 0] - 1.0f) < kEps &&
                 std::fabs(payload[kFixedfuncLightingGlobalAmbientRel * 4 + 1] - 0.0f) < kEps &&
                 std::fabs(payload[kFixedfuncLightingGlobalAmbientRel * 4 + 2] - 0.0f) < kEps &&
                 std::fabs(payload[kFixedfuncLightingGlobalAmbientRel * 4 + 3] - 1.0f) < kEps,
             "global ambient constant reflects state-block-applied D3DRS_AMBIENT")) {
    return false;
  }

  return true;
}

bool TestSetShaderConstIEmitsSetShaderConstantsI() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetShaderConstI != nullptr, "SetShaderConstI must be available")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  const int32_t data[8] = {-1, 2, 3, 4, 5, 6, 7, 8};
  hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, kD3d9ShaderStagePs, 5, data, 2);
  if (!Check(hr == S_OK, "SetShaderConstI(PS, i5..i6)")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  const CmdLoc set_consts = FindLastOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_I);
  if (!Check(set_consts.hdr != nullptr, "set_shader_constants_i emitted")) {
    return false;
  }
  const auto* cmd = reinterpret_cast<const aerogpu_cmd_set_shader_constants_i*>(set_consts.hdr);
  if (!Check(cmd->stage == AEROGPU_SHADER_STAGE_PIXEL, "SET_SHADER_CONSTANTS_I stage == PS")) {
    return false;
  }
  if (!Check(cmd->start_register == 5, "SET_SHADER_CONSTANTS_I start_register")) {
    return false;
  }
  if (!Check(cmd->vec4_count == 2, "SET_SHADER_CONSTANTS_I vec4_count")) {
    return false;
  }

  const auto* payload = reinterpret_cast<const int32_t*>(reinterpret_cast<const uint8_t*>(cmd) + sizeof(*cmd));
  for (size_t i = 0; i < 8; ++i) {
    if (!Check(payload[i] == data[i], "SET_SHADER_CONSTANTS_I payload matches")) {
      return false;
    }
  }
  return true;
}

bool TestSetShaderConstBEmitsSetShaderConstantsB() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetShaderConstB != nullptr, "SetShaderConstB must be available")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  const BOOL data[3] = {0, static_cast<BOOL>(0xFFFF'FFFFu), 0};
  hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, kD3d9ShaderStagePs, 7, data, 3);
  if (!Check(hr == S_OK, "SetShaderConstB(PS, b7..b9)")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  const CmdLoc set_consts = FindLastOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_B);
  if (!Check(set_consts.hdr != nullptr, "set_shader_constants_b emitted")) {
    return false;
  }
  const auto* cmd = reinterpret_cast<const aerogpu_cmd_set_shader_constants_b*>(set_consts.hdr);
  if (!Check(cmd->stage == AEROGPU_SHADER_STAGE_PIXEL, "SET_SHADER_CONSTANTS_B stage == PS")) {
    return false;
  }
  if (!Check(cmd->start_register == 7, "SET_SHADER_CONSTANTS_B start_register")) {
    return false;
  }
  if (!Check(cmd->bool_count == 3, "SET_SHADER_CONSTANTS_B bool_count")) {
    return false;
  }

  const auto* payload = reinterpret_cast<const uint32_t*>(reinterpret_cast<const uint8_t*>(cmd) + sizeof(*cmd));
  // Payload uses a single u32 per bool register (0 or 1).
  const uint32_t expected[3] = {0u, 1u, 0u};
  for (size_t i = 0; i < 3; ++i) {
    if (!Check(payload[i] == expected[i], "SET_SHADER_CONSTANTS_B payload matches")) {
      return false;
    }
  }
  return true;
}

bool TestVertexDeclXyzrhwDiffuseTex1DrawPrimitiveUpEmitsFixedfuncCommands() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3D9DDI_HVERTEXDECL hDecl{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_decl = false;

    ~Cleanup() {
      if (has_decl && device_funcs.pfnDestroyVertexDecl) {
        device_funcs.pfnDestroyVertexDecl(hDevice, hDecl);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateVertexDecl != nullptr, "CreateVertexDecl must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetVertexDecl != nullptr, "SetVertexDecl must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }

  D3DDDIVIEWPORTINFO vp{};
  vp.X = 0.0f;
  vp.Y = 0.0f;
  vp.Width = 256.0f;
  vp.Height = 256.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }

  // XYZRHW | DIFFUSE | TEX1:
  //   POSITIONT float4 @0
  //   COLOR0    D3DCOLOR @16
  //   TEXCOORD0 float2 @20
  //   END
  const D3DVERTEXELEMENT9_COMPAT elems[] = {
      {0, 0, kD3dDeclTypeFloat4, kD3dDeclMethodDefault, kD3dDeclUsagePositionT, 0},
      {0, 16, kD3dDeclTypeD3dColor, kD3dDeclMethodDefault, kD3dDeclUsageColor, 0},
      {0, 20, kD3dDeclTypeFloat2, kD3dDeclMethodDefault, kD3dDeclUsageTexcoord, 0},
      {0xFF, 0, kD3dDeclTypeUnused, 0, 0, 0}, // D3DDECL_END
  };

  D3D9DDI_HVERTEXDECL hDecl{};
  hr = cleanup.device_funcs.pfnCreateVertexDecl(
      create_dev.hDevice, elems, static_cast<uint32_t>(sizeof(elems)), &hDecl);
  if (!Check(hr == S_OK, "CreateVertexDecl(XYZRHW|DIFFUSE|TEX1)")) {
    return false;
  }
  cleanup.hDecl = hDecl;
  cleanup.has_decl = true;

  hr = cleanup.device_funcs.pfnSetVertexDecl(create_dev.hDevice, hDecl);
  if (!Check(hr == S_OK, "SetVertexDecl(XYZRHW|DIFFUSE|TEX1)")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  // D3DFVF_XYZRHW (0x4) | D3DFVF_DIFFUSE (0x40) | D3DFVF_TEX1 (0x100).
  if (!Check(dev->fvf == 0x144u, "SetVertexDecl implies FVF=XYZRHW|DIFFUSE|TEX1")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    float rhw;
    uint32_t color;
    float u;
    float v;
  };

  constexpr uint32_t kGreen = 0xFF00FF00u;
  Vertex verts[3]{};
  verts[0] = {256.0f * 0.25f, 256.0f * 0.25f, 0.5f, 1.0f, kGreen, 0.0f, 0.0f};
  verts[1] = {256.0f * 0.75f, 256.0f * 0.25f, 0.5f, 1.0f, kGreen, 1.0f, 0.0f};
  verts[2] = {256.0f * 0.50f, 256.0f * 0.75f, 0.5f, 1.0f, kGreen, 0.5f, 1.0f};

  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(
      create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 1, verts, sizeof(Vertex));
  if (!Check(hr == S_OK, "DrawPrimitiveUP(XYZRHW|DIFFUSE|TEX1)")) {
    return false;
  }
  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_CREATE_SHADER_DXBC) >= 2,
             "fixed-function fallback creates shaders")) {
    return false;
  }
  const FixedFuncVariant variant = fixedfunc_variant_from_fvf(dev->fvf);
  if (!Check(variant != FixedFuncVariant::NONE, "fixed-function variant recognized")) {
    return false;
  }
  const auto& pipe = dev->fixedfunc_pipelines[static_cast<size_t>(variant)];
  if (!Check(pipe.vs != nullptr && pipe.ps != nullptr, "fixed-function TEX1 shaders cached on device")) {
    return false;
  }

  const CmdLoc bind = FindLastOpcode(buf, len, AEROGPU_CMD_BIND_SHADERS);
  if (!Check(bind.hdr != nullptr, "bind_shaders emitted")) {
    return false;
  }
  const auto* bind_cmd = reinterpret_cast<const aerogpu_cmd_bind_shaders*>(bind.hdr);
  if (!Check(bind_cmd->vs == pipe.vs->handle, "bind_shaders uses TEX1 fixed-function VS")) {
    return false;
  }
  if (!Check(bind_cmd->ps == pipe.ps->handle, "bind_shaders uses TEX1 fixed-function PS")) {
    return false;
  }

  const CmdLoc draw = FindLastOpcode(buf, len, AEROGPU_CMD_DRAW);
  if (!Check(draw.hdr != nullptr, "draw emitted")) {
    return false;
  }

  return true;
}

bool TestSetFvfIdempotentRebindsInternalXyzrhwInputLayout() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3D9DDI_HVERTEXDECL hDecl{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_decl = false;

    ~Cleanup() {
      if (has_decl && device_funcs.pfnDestroyVertexDecl) {
        device_funcs.pfnDestroyVertexDecl(hDevice, hDecl);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateVertexDecl != nullptr, "CreateVertexDecl must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetVertexDecl != nullptr, "SetVertexDecl must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }

  // Use a valid viewport so XYZRHW conversion doesn't divide by 0.
  D3DDDIVIEWPORTINFO vp{};
  vp.X = 0.0f;
  vp.Y = 0.0f;
  vp.Width = 256.0f;
  vp.Height = 256.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }

  constexpr uint32_t kSupportedFvfXyzrhwDiffuseTex1 = kD3dFvfXyzRhw | kD3dFvfDiffuse | kD3dFvfTex1; // 0x144

  // Create an explicit decl that implies kSupportedFvfXyzrhwDiffuseTex1, but is
  // *not* byte-for-byte identical to the driver's internal FVF-derived decl.
  //
  // In particular, encode TEXCOORD0 as Usage=POSITION (0) so SetVertexDecl
  // inference still sets dev->fvf=0x144 while leaving a mismatched input layout
  // bound. A subsequent SetFVF(0x144) must override this and bind the internal
  // decl.
  const D3DVERTEXELEMENT9_COMPAT elems[] = {
      {0, 0, kD3dDeclTypeFloat4, kD3dDeclMethodDefault, kD3dDeclUsagePositionT, 0},
      {0, 16, kD3dDeclTypeD3dColor, kD3dDeclMethodDefault, kD3dDeclUsageColor, 0},
      {0, 20, kD3dDeclTypeFloat2, kD3dDeclMethodDefault, kD3dDeclUsagePosition, 0},
      {0xFF, 0, kD3dDeclTypeUnused, 0, 0, 0}, // D3DDECL_END
  };

  D3D9DDI_HVERTEXDECL hDecl{};
  hr = cleanup.device_funcs.pfnCreateVertexDecl(
      create_dev.hDevice, elems, static_cast<uint32_t>(sizeof(elems)), &hDecl);
  if (!Check(hr == S_OK, "CreateVertexDecl(XYZRHW|DIFFUSE|TEX1, tex Usage=POSITION)")) {
    return false;
  }
  cleanup.hDecl = hDecl;
  cleanup.has_decl = true;

  hr = cleanup.device_funcs.pfnSetVertexDecl(create_dev.hDevice, hDecl);
  if (!Check(hr == S_OK, "SetVertexDecl(XYZRHW|DIFFUSE|TEX1, tex Usage=POSITION)")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  auto* user_decl = reinterpret_cast<VertexDecl*>(hDecl.pDrvPrivate);
  if (!Check(user_decl != nullptr, "vertex decl pointer")) {
    return false;
  }

  if (!Check(dev->fvf == kSupportedFvfXyzrhwDiffuseTex1, "SetVertexDecl implies FVF=XYZRHW|DIFFUSE|TEX1")) {
    return false;
  }
  if (!Check(dev->vertex_decl == user_decl, "SetVertexDecl binds the explicit decl")) {
    return false;
  }
  {
    std::lock_guard<std::mutex> lock(dev->mutex);
    const FixedFuncVariant variant = fixedfunc_variant_from_fvf(kSupportedFvfXyzrhwDiffuseTex1);
    if (!Check(variant != FixedFuncVariant::NONE, "FVF variant recognized")) {
      return false;
    }
    const auto& pipe = dev->fixedfunc_pipelines[static_cast<size_t>(variant)];
    if (!Check(pipe.vertex_decl == nullptr, "internal FVF decl not created by SetVertexDecl inference")) {
      return false;
    }
  }

  // Regression: even when fvf == dev->fvf, SetFVF must still bind the internal
  // FVF-derived decl for supported XYZRHW FVFs.
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, kSupportedFvfXyzrhwDiffuseTex1);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|DIFFUSE|TEX1)")) {
    return false;
  }

  VertexDecl* internal_decl = nullptr;
  {
    std::lock_guard<std::mutex> lock(dev->mutex);
    const FixedFuncVariant variant = fixedfunc_variant_from_fvf(kSupportedFvfXyzrhwDiffuseTex1);
    if (!Check(variant != FixedFuncVariant::NONE, "FVF variant recognized")) {
      return false;
    }
    internal_decl = dev->fixedfunc_pipelines[static_cast<size_t>(variant)].vertex_decl;
  }
  if (!Check(internal_decl != nullptr, "SetFVF created internal FVF-derived decl")) {
    return false;
  }
  if (!Check(internal_decl != user_decl, "internal decl differs from explicit decl")) {
    return false;
  }
  if (!Check(dev->vertex_decl == internal_decl, "SetFVF binds internal decl")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    float rhw;
    uint32_t color;
    float u;
    float v;
  };

  constexpr uint32_t kWhite = 0xFFFFFFFFu;
  Vertex verts[3]{};
  verts[0] = {256.0f * 0.25f, 256.0f * 0.25f, 0.5f, 1.0f, kWhite, 0.0f, 0.0f};
  verts[1] = {256.0f * 0.75f, 256.0f * 0.25f, 0.5f, 1.0f, kWhite, 1.0f, 0.0f};
  verts[2] = {256.0f * 0.50f, 256.0f * 0.75f, 0.5f, 1.0f, kWhite, 0.5f, 1.0f};

  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(
      create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 1, verts, sizeof(Vertex));
  if (!Check(hr == S_OK, "DrawPrimitiveUP(XYZRHW|DIFFUSE|TEX1)")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  const CmdLoc draw = FindLastOpcode(buf, len, AEROGPU_CMD_DRAW);
  if (!Check(draw.hdr != nullptr, "draw emitted")) {
    return false;
  }

  const CmdLoc set_layout = FindLastOpcodeBefore(buf, len, draw.offset, AEROGPU_CMD_SET_INPUT_LAYOUT);
  if (!Check(set_layout.hdr != nullptr, "set_input_layout emitted before draw")) {
    return false;
  }

  const auto* set_cmd = reinterpret_cast<const aerogpu_cmd_set_input_layout*>(set_layout.hdr);
  if (!Check(set_cmd->input_layout_handle == internal_decl->handle, "draw uses internal input layout")) {
    return false;
  }
  return true;
}

bool TestVertexDeclXyzDiffuseDrawPrimitiveUpEmitsFixedfuncCommands() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3D9DDI_HVERTEXDECL hDecl{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_decl = false;

    ~Cleanup() {
      if (has_decl && device_funcs.pfnDestroyVertexDecl) {
        device_funcs.pfnDestroyVertexDecl(hDevice, hDecl);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateVertexDecl != nullptr, "CreateVertexDecl must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetVertexDecl != nullptr, "SetVertexDecl must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }

  // XYZ | DIFFUSE:
  //   POSITION float3 @0
  //   COLOR0    D3DCOLOR @12
  //   END
  const D3DVERTEXELEMENT9_COMPAT elems[] = {
      {0, 0, kD3dDeclTypeFloat3, kD3dDeclMethodDefault, kD3dDeclUsagePosition, 0},
      {0, 12, kD3dDeclTypeD3dColor, kD3dDeclMethodDefault, kD3dDeclUsageColor, 0},
      {0xFF, 0, kD3dDeclTypeUnused, 0, 0, 0}, // D3DDECL_END
  };

  D3D9DDI_HVERTEXDECL hDecl{};
  hr = cleanup.device_funcs.pfnCreateVertexDecl(
      create_dev.hDevice, elems, static_cast<uint32_t>(sizeof(elems)), &hDecl);
  if (!Check(hr == S_OK, "CreateVertexDecl(XYZ|DIFFUSE)")) {
    return false;
  }
  cleanup.hDecl = hDecl;
  cleanup.has_decl = true;

  hr = cleanup.device_funcs.pfnSetVertexDecl(create_dev.hDevice, hDecl);
  if (!Check(hr == S_OK, "SetVertexDecl(XYZ|DIFFUSE)")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  // D3DFVF_XYZ (0x2) | D3DFVF_DIFFUSE (0x40).
  if (!Check(dev->fvf == 0x42u, "SetVertexDecl implies FVF=XYZ|DIFFUSE")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    uint32_t color;
  };

  constexpr uint32_t kGreen = 0xFF00FF00u;
  Vertex verts[3]{};
  // Provide clip-space-ish positions (no fixed-function transforms are applied
  // by the bring-up passthrough shader).
  verts[0] = {-0.5f, -0.5f, 0.5f, kGreen};
  verts[1] = {0.5f, -0.5f, 0.5f, kGreen};
  verts[2] = {0.0f, 0.5f, 0.5f, kGreen};

  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(
      create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 1, verts, sizeof(Vertex));
  if (!Check(hr == S_OK, "DrawPrimitiveUP(XYZ|DIFFUSE)")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_CREATE_SHADER_DXBC) >= 2,
             "fixed-function fallback creates shaders")) {
    return false;
  }
  const CmdLoc bind = FindLastOpcode(buf, len, AEROGPU_CMD_BIND_SHADERS);
  if (!Check(bind.hdr != nullptr, "bind_shaders emitted")) {
    return false;
  }
  const auto* bind_cmd = reinterpret_cast<const aerogpu_cmd_bind_shaders*>(bind.hdr);
  return Check(bind_cmd->vs != 0 && bind_cmd->ps != 0, "bind_shaders uses non-zero VS/PS handles");
}

bool TestVertexDeclXyzDiffuseTex1DrawPrimitiveUpEmitsFixedfuncCommands() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3D9DDI_HVERTEXDECL hDecl{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_decl = false;

    ~Cleanup() {
      if (has_decl && device_funcs.pfnDestroyVertexDecl) {
        device_funcs.pfnDestroyVertexDecl(hDevice, hDecl);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateVertexDecl != nullptr, "CreateVertexDecl must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetVertexDecl != nullptr, "SetVertexDecl must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }

  // XYZ | DIFFUSE | TEX1:
  //   POSITION float3 @0
  //   COLOR0    D3DCOLOR @12
  //   TEXCOORD0 float2 @16
  //   END
  const D3DVERTEXELEMENT9_COMPAT elems[] = {
      {0, 0, kD3dDeclTypeFloat3, kD3dDeclMethodDefault, kD3dDeclUsagePosition, 0},
      {0, 12, kD3dDeclTypeD3dColor, kD3dDeclMethodDefault, kD3dDeclUsageColor, 0},
      {0, 16, kD3dDeclTypeFloat2, kD3dDeclMethodDefault, kD3dDeclUsageTexcoord, 0},
      {0xFF, 0, kD3dDeclTypeUnused, 0, 0, 0}, // D3DDECL_END
  };

  D3D9DDI_HVERTEXDECL hDecl{};
  hr = cleanup.device_funcs.pfnCreateVertexDecl(
      create_dev.hDevice, elems, static_cast<uint32_t>(sizeof(elems)), &hDecl);
  if (!Check(hr == S_OK, "CreateVertexDecl(XYZ|DIFFUSE|TEX1)")) {
    return false;
  }
  cleanup.hDecl = hDecl;
  cleanup.has_decl = true;

  hr = cleanup.device_funcs.pfnSetVertexDecl(create_dev.hDevice, hDecl);
  if (!Check(hr == S_OK, "SetVertexDecl(XYZ|DIFFUSE|TEX1)")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  // D3DFVF_XYZ (0x2) | D3DFVF_DIFFUSE (0x40) | D3DFVF_TEX1 (0x100).
  if (!Check(dev->fvf == 0x142u, "SetVertexDecl implies FVF=XYZ|DIFFUSE|TEX1")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    uint32_t color;
    float u;
    float v;
  };

  constexpr uint32_t kGreen = 0xFF00FF00u;
  Vertex verts[3]{};
  verts[0] = {-0.5f, -0.5f, 0.5f, kGreen, 0.0f, 0.0f};
  verts[1] = {0.5f, -0.5f, 0.5f, kGreen, 1.0f, 0.0f};
  verts[2] = {0.0f, 0.5f, 0.5f, kGreen, 0.5f, 1.0f};

  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(
      create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 1, verts, sizeof(Vertex));
  if (!Check(hr == S_OK, "DrawPrimitiveUP(XYZ|DIFFUSE|TEX1)")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_CREATE_SHADER_DXBC) >= 2,
             "fixed-function fallback creates shaders")) {
    return false;
  }
  const CmdLoc bind = FindLastOpcode(buf, len, AEROGPU_CMD_BIND_SHADERS);
  if (!Check(bind.hdr != nullptr, "bind_shaders emitted")) {
    return false;
  }
  const auto* bind_cmd = reinterpret_cast<const aerogpu_cmd_bind_shaders*>(bind.hdr);
  return Check(bind_cmd->vs != 0 && bind_cmd->ps != 0, "bind_shaders uses non-zero VS/PS handles");
}

bool TestStage0TextureStageStateRebindsFixedfuncPsForXyz() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hTex{};
    D3D9DDI_HVERTEXDECL hDecl{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_tex = false;
    bool has_decl = false;

    ~Cleanup() {
      if (has_decl && device_funcs.pfnDestroyVertexDecl) {
        device_funcs.pfnDestroyVertexDecl(hDevice, hDecl);
      }
      if (has_tex && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hTex);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnLock != nullptr && cleanup.device_funcs.pfnUnlock != nullptr, "Lock/Unlock must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetTexture != nullptr, "SetTexture must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnCreateVertexDecl != nullptr, "CreateVertexDecl must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetVertexDecl != nullptr, "SetVertexDecl must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetTextureStageState != nullptr, "SetTextureStageState must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }

  // Create a tiny host-backed texture and upload some bytes.
  D3D9DDIARG_CREATERESOURCE create_tex{};
  create_tex.type = kD3dRTypeTexture; // D3DRTYPE_TEXTURE
  create_tex.format = 22u; // D3DFMT_X8R8G8B8
  create_tex.width = 2;
  create_tex.height = 2;
  create_tex.depth = 1;
  create_tex.mip_levels = 1;
  create_tex.usage = 0;
  create_tex.pool = 0;
  create_tex.size = 0;
  create_tex.hResource.pDrvPrivate = nullptr;
  create_tex.pSharedHandle = nullptr;
  create_tex.pKmdAllocPrivateData = nullptr;
  create_tex.KmdAllocPrivateDataSize = 0;
  create_tex.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_tex);
  if (!Check(hr == S_OK, "CreateResource(texture)")) {
    return false;
  }
  if (!Check(create_tex.hResource.pDrvPrivate != nullptr, "CreateResource returned texture handle")) {
    return false;
  }
  cleanup.hTex = create_tex.hResource;
  cleanup.has_tex = true;

  D3D9DDIARG_LOCK lock{};
  lock.hResource = create_tex.hResource;
  lock.offset_bytes = 0;
  lock.size_bytes = 0;
  lock.flags = 0;
  D3DDDI_LOCKEDBOX locked{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &locked);
  if (!Check(hr == S_OK, "Lock(texture)")) {
    return false;
  }
  if (!Check(locked.pData != nullptr, "Lock(texture) returns pData")) {
    return false;
  }

  for (uint32_t y = 0; y < 2; ++y) {
    uint8_t* row = reinterpret_cast<uint8_t*>(locked.pData) + static_cast<size_t>(y) * locked.RowPitch;
    for (uint32_t x = 0; x < 2; ++x) {
      row[x * 4 + 0] = 0xFF; // B
      row[x * 4 + 1] = 0x00; // G
      row[x * 4 + 2] = 0x00; // R
      row[x * 4 + 3] = 0xFF; // X/A
    }
  }

  D3D9DDIARG_UNLOCK unlock{};
  unlock.hResource = create_tex.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(texture)")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnSetTexture(create_dev.hDevice, 0, create_tex.hResource);
  if (!Check(hr == S_OK, "SetTexture(0)")) {
    return false;
  }

  // XYZ | DIFFUSE | TEX1:
  //   POSITION float3 @0
  //   COLOR0    D3DCOLOR @12
  //   TEXCOORD0 float2 @16
  //   END
  const D3DVERTEXELEMENT9_COMPAT elems[] = {
      {0, 0, kD3dDeclTypeFloat3, kD3dDeclMethodDefault, kD3dDeclUsagePosition, 0},
      {0, 12, kD3dDeclTypeD3dColor, kD3dDeclMethodDefault, kD3dDeclUsageColor, 0},
      {0, 16, kD3dDeclTypeFloat2, kD3dDeclMethodDefault, kD3dDeclUsageTexcoord, 0},
      {0xFF, 0, kD3dDeclTypeUnused, 0, 0, 0}, // D3DDECL_END
  };

  D3D9DDI_HVERTEXDECL hDecl{};
  hr = cleanup.device_funcs.pfnCreateVertexDecl(
      create_dev.hDevice, elems, static_cast<uint32_t>(sizeof(elems)), &hDecl);
  if (!Check(hr == S_OK, "CreateVertexDecl(XYZ|DIFFUSE|TEX1)")) {
    return false;
  }
  cleanup.hDecl = hDecl;
  cleanup.has_decl = true;

  hr = cleanup.device_funcs.pfnSetVertexDecl(create_dev.hDevice, hDecl);
  if (!Check(hr == S_OK, "SetVertexDecl(XYZ|DIFFUSE|TEX1)")) {
    return false;
  }

  // D3DTSS_* values.
  constexpr uint32_t kD3dTssColorOp = 1u;    // D3DTSS_COLOROP
  constexpr uint32_t kD3dTssColorArg1 = 2u;  // D3DTSS_COLORARG1
  constexpr uint32_t kD3dTssColorArg2 = 3u;  // D3DTSS_COLORARG2
  constexpr uint32_t kD3dTssAlphaOp = 4u;    // D3DTSS_ALPHAOP
  constexpr uint32_t kD3dTssAlphaArg1 = 5u;  // D3DTSS_ALPHAARG1
  constexpr uint32_t kD3dTssAlphaArg2 = 6u;  // D3DTSS_ALPHAARG2
  // D3DTOP_*.
  constexpr uint32_t kD3dTopSelectArg1 = 2u; // D3DTOP_SELECTARG1
  constexpr uint32_t kD3dTopModulate = 4u;   // D3DTOP_MODULATE
  // D3DTA_*.
  constexpr uint32_t kD3dTaDiffuse = 0u;     // D3DTA_DIFFUSE
  constexpr uint32_t kD3dTaTexture = 2u;     // D3DTA_TEXTURE

  // Make stage0 sample TEXTURE for both color and alpha (SELECTARG1/TEXTURE).
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssColorOp, kD3dTopSelectArg1);
  if (!Check(hr == S_OK, "SetTextureStageState(COLOROP=SELECTARG1)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssColorArg1, kD3dTaTexture);
  if (!Check(hr == S_OK, "SetTextureStageState(COLORARG1=TEXTURE)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssColorArg2, kD3dTaDiffuse);
  if (!Check(hr == S_OK, "SetTextureStageState(COLORARG2=DIFFUSE)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssAlphaOp, kD3dTopSelectArg1);
  if (!Check(hr == S_OK, "SetTextureStageState(ALPHAOP=SELECTARG1)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssAlphaArg1, kD3dTaTexture);
  if (!Check(hr == S_OK, "SetTextureStageState(ALPHAARG1=TEXTURE)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssAlphaArg2, kD3dTaDiffuse);
  if (!Check(hr == S_OK, "SetTextureStageState(ALPHAARG2=DIFFUSE)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    uint32_t color;
    float u;
    float v;
  };

  constexpr uint32_t kWhite = 0xFFFFFFFFu;
  Vertex verts[3]{};
  verts[0] = {-0.5f, -0.5f, 0.5f, kWhite, 0.0f, 0.0f};
  verts[1] = {0.5f, -0.5f, 0.5f, kWhite, 1.0f, 0.0f};
  verts[2] = {0.0f, 0.5f, 0.5f, kWhite, 0.5f, 1.0f};

  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(
      create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 1, verts, sizeof(Vertex));
  if (!Check(hr == S_OK, "DrawPrimitiveUP(XYZ|DIFFUSE|TEX1)")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  const aerogpu_handle_t old_ps_handle = dev->ps ? dev->ps->handle : 0;
  if (!Check(old_ps_handle != 0, "fixed-function PS bound after draw")) {
    return false;
  }

  const size_t split_offset = dev->cmd.bytes_used();

  // Flip only COLOROP to MODULATE. With COLORARG1=TEXTURE and COLORARG2=DIFFUSE
  // already set, this forces a different fixed-function PS variant. The driver
  // should immediately emit CREATE_SHADER_DXBC + BIND_SHADERS to swap to the new
  // PS (no draw-time fallback needed).
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssColorOp, kD3dTopModulate);
  if (!Check(hr == S_OK, "SetTextureStageState(COLOROP=MODULATE)")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  if (!Check(split_offset < len, "stage0 change appended commands")) {
    return false;
  }

  aerogpu_handle_t created_ps_handle = 0;
  size_t create_offset = 0;
  {
    size_t offset = split_offset;
    while (offset + sizeof(aerogpu_cmd_hdr) <= len) {
      const auto* hdr = reinterpret_cast<const aerogpu_cmd_hdr*>(buf + offset);
      if (hdr->opcode == AEROGPU_CMD_CREATE_SHADER_DXBC) {
        const auto* cmd = reinterpret_cast<const aerogpu_cmd_create_shader_dxbc*>(hdr);
        if (cmd->stage == AEROGPU_SHADER_STAGE_PIXEL) {
          created_ps_handle = cmd->shader_handle;
          create_offset = offset;
          break;
        }
      }
      if (hdr->size_bytes == 0 || hdr->size_bytes > len - offset) {
        break;
      }
      offset += hdr->size_bytes;
    }
  }
  if (!Check(created_ps_handle != 0, "stage0 change emits CREATE_SHADER_DXBC(PS)")) {
    return false;
  }

  bool found_bind = false;
  aerogpu_handle_t bound_ps_handle = 0;
  {
    size_t offset = create_offset;
    while (offset + sizeof(aerogpu_cmd_hdr) <= len) {
      const auto* hdr = reinterpret_cast<const aerogpu_cmd_hdr*>(buf + offset);
      if (hdr->opcode == AEROGPU_CMD_BIND_SHADERS) {
        const auto* cmd = reinterpret_cast<const aerogpu_cmd_bind_shaders*>(hdr);
        bound_ps_handle = cmd->ps;
        found_bind = true;
        break;
      }
      if (hdr->size_bytes == 0 || hdr->size_bytes > len - offset) {
        break;
      }
      offset += hdr->size_bytes;
    }
  }
  if (!Check(found_bind, "stage0 change emits BIND_SHADERS")) {
    return false;
  }
  if (!Check(bound_ps_handle == created_ps_handle, "BIND_SHADERS binds newly created PS")) {
    return false;
  }
  if (!Check(bound_ps_handle != old_ps_handle, "BIND_SHADERS updates PS handle")) {
    return false;
  }
  return ValidateStream(buf, len);
}

bool TestFixedFuncPsSelectionNoTextureColorOpDisableUsesColorOnly() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetViewport != nullptr, "SetViewport must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }

  D3DDDIVIEWPORTINFO vp{};
  vp.X = 0.0f;
  vp.Y = 0.0f;
  vp.Width = 256.0f;
  vp.Height = 256.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }

  // D3DFVF_XYZRHW (0x4) | D3DFVF_DIFFUSE (0x40).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x44u);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|DIFFUSE)")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  // Stage-state override: COLOROP=DISABLE. No texture bound -> should pick ColorOnly.
  constexpr uint32_t kD3dTssColorOp = 1u;
  constexpr uint32_t kD3dTopDisable = 1u;
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssColorOp, kD3dTopDisable);
  if (!Check(hr == S_OK, "SetTextureStageState(stage0, COLOROP=DISABLE)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    float rhw;
    uint32_t color;
  };

  constexpr uint32_t kWhite = 0xFFFFFFFFu;
  Vertex verts[3]{};
  verts[0] = {256.0f * 0.25f, 256.0f * 0.25f, 0.5f, 1.0f, kWhite};
  verts[1] = {256.0f * 0.75f, 256.0f * 0.25f, 0.5f, 1.0f, kWhite};
  verts[2] = {256.0f * 0.50f, 256.0f * 0.75f, 0.5f, 1.0f, kWhite};

  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(
      create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 1, verts, sizeof(Vertex));
  if (!Check(hr == S_OK, "DrawPrimitiveUP")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  return CheckLastBoundPixelShaderMatches(
      buf,
      len,
      reinterpret_cast<const void*>(fixedfunc::kPsColorOnly),
      sizeof(fixedfunc::kPsColorOnly),
      "bind_shaders emitted");
}

bool TestFixedFuncPsSelectionTextureBoundColorOpDisableIgnoresAlphaTextureUsesColorOnly() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hTexture{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_texture = false;

    ~Cleanup() {
      if (has_texture && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hTexture);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetViewport != nullptr, "SetViewport must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetTexture != nullptr, "SetTexture must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetTextureStageState != nullptr, "SetTextureStageState must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }

  D3DDDIVIEWPORTINFO vp{};
  vp.X = 0.0f;
  vp.Y = 0.0f;
  vp.Width = 256.0f;
  vp.Height = 256.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }

  // D3DFVF_XYZRHW (0x4) | D3DFVF_DIFFUSE (0x40) | D3DFVF_TEX1 (0x100).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x144u);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|DIFFUSE|TEX1)")) {
    return false;
  }

  // Create and bind a small texture at stage0 (should still not be sampled when
  // COLOROP=DISABLE).
  D3D9DDIARG_CREATERESOURCE create_tex{};
  create_tex.type = kD3dRTypeTexture;
  create_tex.format = 22u; // D3DFMT_X8R8G8B8
  create_tex.width = 2;
  create_tex.height = 2;
  create_tex.depth = 1;
  create_tex.mip_levels = 1;
  create_tex.usage = 0;
  create_tex.pool = 0;
  create_tex.size = 0;
  create_tex.hResource.pDrvPrivate = nullptr;
  create_tex.pSharedHandle = nullptr;
  create_tex.pKmdAllocPrivateData = nullptr;
  create_tex.KmdAllocPrivateDataSize = 0;
  create_tex.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_tex);
  if (!CheckHr(hr, S_OK, "CreateResource(texture)")) {
    return false;
  }
  if (!Check(create_tex.hResource.pDrvPrivate != nullptr, "CreateResource(texture) returned handle")) {
    return false;
  }
  cleanup.hTexture = create_tex.hResource;
  cleanup.has_texture = true;

  hr = cleanup.device_funcs.pfnSetTexture(create_dev.hDevice, 0, create_tex.hResource);
  if (!Check(hr == S_OK, "SetTexture(stage0)")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  // Stage-state override:
  // - COLOROP=DISABLE (stage disabled)
  // - ALPHAOP=SELECTARG1(TEXTURE) (must be ignored because stage is disabled)
  constexpr uint32_t kD3dTssColorOp = 1u;
  constexpr uint32_t kD3dTssAlphaOp = 4u;
  constexpr uint32_t kD3dTssAlphaArg1 = 5u;
  constexpr uint32_t kD3dTopDisable = 1u;
  constexpr uint32_t kD3dTopSelectArg1 = 2u;
  constexpr uint32_t kD3dTaTexture = 2u;
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssColorOp, kD3dTopDisable);
  if (!Check(hr == S_OK, "SetTextureStageState(stage0, COLOROP=DISABLE)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssAlphaOp, kD3dTopSelectArg1);
  if (!Check(hr == S_OK, "SetTextureStageState(stage0, ALPHAOP=SELECTARG1)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssAlphaArg1, kD3dTaTexture);
  if (!Check(hr == S_OK, "SetTextureStageState(stage0, ALPHAARG1=TEXTURE)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    float rhw;
    uint32_t color;
    float u;
    float v;
  };

  constexpr uint32_t kWhite = 0xFFFFFFFFu;
  Vertex verts[3]{};
  verts[0] = {256.0f * 0.25f, 256.0f * 0.25f, 0.5f, 1.0f, kWhite, 0.0f, 0.0f};
  verts[1] = {256.0f * 0.75f, 256.0f * 0.25f, 0.5f, 1.0f, kWhite, 1.0f, 0.0f};
  verts[2] = {256.0f * 0.50f, 256.0f * 0.75f, 0.5f, 1.0f, kWhite, 0.5f, 1.0f};

  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(
      create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 1, verts, sizeof(Vertex));
  if (!Check(hr == S_OK, "DrawPrimitiveUP")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  return CheckLastBoundPixelShaderMatches(
      buf,
      len,
      reinterpret_cast<const void*>(fixedfunc::kPsColorOnly),
      sizeof(fixedfunc::kPsColorOnly),
      "bind_shaders emitted");
}

bool TestFixedFuncPsSelectionSetTextureUpdatesBoundPsToModulateWithoutDraw() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hTexture{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_texture = false;

    ~Cleanup() {
      if (has_texture && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hTexture);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetViewport != nullptr, "SetViewport must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetTexture != nullptr, "SetTexture must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetTextureStageState != nullptr, "SetTextureStageState must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }

  D3DDDIVIEWPORTINFO vp{};
  vp.X = 0.0f;
  vp.Y = 0.0f;
  vp.Width = 256.0f;
  vp.Height = 256.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }

  // D3DFVF_XYZRHW (0x4) | D3DFVF_DIFFUSE (0x40) | D3DFVF_TEX1 (0x100).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x144u);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|DIFFUSE|TEX1)")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  // Draw once with no texture bound so the fixed-function pipeline binds a
  // diffuse-only PS variant.
  struct Vertex {
    float x;
    float y;
    float z;
    float rhw;
    uint32_t color;
    float u;
    float v;
  };

  constexpr uint32_t kWhite = 0xFFFFFFFFu;
  Vertex verts[3]{};
  verts[0] = {256.0f * 0.25f, 256.0f * 0.25f, 0.5f, 1.0f, kWhite, 0.0f, 0.0f};
  verts[1] = {256.0f * 0.75f, 256.0f * 0.25f, 0.5f, 1.0f, kWhite, 1.0f, 0.0f};
  verts[2] = {256.0f * 0.50f, 256.0f * 0.75f, 0.5f, 1.0f, kWhite, 0.5f, 1.0f};

  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(
      create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 1, verts, sizeof(Vertex));
  if (!Check(hr == S_OK, "DrawPrimitiveUP (untextured)")) {
    return false;
  }

  // Create and bind a small texture at stage0. Without issuing another draw,
  // SetTexture must update the fixed-function PS selection because stage0
  // texturing is now active by default (MODULATE + alpha from texture).
  D3D9DDIARG_CREATERESOURCE create_tex{};
  create_tex.type = kD3dRTypeTexture;
  create_tex.format = 22u; // D3DFMT_X8R8G8B8
  create_tex.width = 2;
  create_tex.height = 2;
  create_tex.depth = 1;
  create_tex.mip_levels = 1;
  create_tex.usage = 0;
  create_tex.pool = 0;
  create_tex.size = 0;
  create_tex.hResource.pDrvPrivate = nullptr;
  create_tex.pSharedHandle = nullptr;
  create_tex.pKmdAllocPrivateData = nullptr;
  create_tex.KmdAllocPrivateDataSize = 0;
  create_tex.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_tex);
  if (!CheckHr(hr, S_OK, "CreateResource(texture)")) {
    return false;
  }
  if (!Check(create_tex.hResource.pDrvPrivate != nullptr, "CreateResource(texture) returned handle")) {
    return false;
  }
  cleanup.hTexture = create_tex.hResource;
  cleanup.has_texture = true;

  hr = cleanup.device_funcs.pfnSetTexture(create_dev.hDevice, 0, create_tex.hResource);
  if (!Check(hr == S_OK, "SetTexture(stage0)")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_BIND_SHADERS) >= 2,
             "SetTexture re-emits bind_shaders for fixed-function PS selection")) {
    return false;
  }

  return CheckLastBoundPixelShaderMatches(
      buf,
      len,
      reinterpret_cast<const void*>(fixedfunc::kPsStage0ModulateTexture),
      sizeof(fixedfunc::kPsStage0ModulateTexture),
      "bind_shaders emitted");
}

bool TestFixedFuncPsSelectionUnsetTextureUpdatesBoundPsToColorOnlyWithoutDraw() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hTexture{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_texture = false;

    ~Cleanup() {
      if (has_texture && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hTexture);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetViewport != nullptr, "SetViewport must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetTexture != nullptr, "SetTexture must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetTextureStageState != nullptr, "SetTextureStageState must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }

  D3DDDIVIEWPORTINFO vp{};
  vp.X = 0.0f;
  vp.Y = 0.0f;
  vp.Width = 256.0f;
  vp.Height = 256.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }

  // D3DFVF_XYZRHW (0x4) | D3DFVF_DIFFUSE (0x40) | D3DFVF_TEX1 (0x100).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x144u);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|DIFFUSE|TEX1)")) {
    return false;
  }

  // Create and bind a small texture at stage0.
  D3D9DDIARG_CREATERESOURCE create_tex{};
  create_tex.type = kD3dRTypeTexture;
  create_tex.format = 22u; // D3DFMT_X8R8G8B8
  create_tex.width = 2;
  create_tex.height = 2;
  create_tex.depth = 1;
  create_tex.mip_levels = 1;
  create_tex.usage = 0;
  create_tex.pool = 0;
  create_tex.size = 0;
  create_tex.hResource.pDrvPrivate = nullptr;
  create_tex.pSharedHandle = nullptr;
  create_tex.pKmdAllocPrivateData = nullptr;
  create_tex.KmdAllocPrivateDataSize = 0;
  create_tex.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_tex);
  if (!CheckHr(hr, S_OK, "CreateResource(texture)")) {
    return false;
  }
  if (!Check(create_tex.hResource.pDrvPrivate != nullptr, "CreateResource(texture) returned handle")) {
    return false;
  }
  cleanup.hTexture = create_tex.hResource;
  cleanup.has_texture = true;

  hr = cleanup.device_funcs.pfnSetTexture(create_dev.hDevice, 0, create_tex.hResource);
  if (!Check(hr == S_OK, "SetTexture(stage0)")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    float rhw;
    uint32_t color;
    float u;
    float v;
  };

  constexpr uint32_t kWhite = 0xFFFFFFFFu;
  Vertex verts[3]{};
  verts[0] = {256.0f * 0.25f, 256.0f * 0.25f, 0.5f, 1.0f, kWhite, 0.0f, 0.0f};
  verts[1] = {256.0f * 0.75f, 256.0f * 0.25f, 0.5f, 1.0f, kWhite, 1.0f, 0.0f};
  verts[2] = {256.0f * 0.50f, 256.0f * 0.75f, 0.5f, 1.0f, kWhite, 0.5f, 1.0f};

  // Draw once with texture bound to ensure we start from a texture-sampling PS.
  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(
      create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 1, verts, sizeof(Vertex));
  if (!Check(hr == S_OK, "DrawPrimitiveUP (textured)")) {
    return false;
  }

  // Unbind texture without issuing another draw. The driver must re-select the
  // diffuse-only fixed-function PS variant.
  D3DDDI_HRESOURCE null_tex{};
  hr = cleanup.device_funcs.pfnSetTexture(create_dev.hDevice, 0, null_tex);
  if (!Check(hr == S_OK, "SetTexture(stage0=null)")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_BIND_SHADERS) >= 2,
             "SetTexture(null) re-emits bind_shaders for fixed-function PS selection")) {
    return false;
  }

  return CheckLastBoundPixelShaderMatches(
      buf,
      len,
      reinterpret_cast<const void*>(fixedfunc::kPsColorOnly),
      sizeof(fixedfunc::kPsColorOnly),
      "bind_shaders emitted");
}

bool TestFixedFuncPsSelectionTex1OnlyFvfSetTextureUpdatesBoundPsToModulateWithoutDraw() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hTexture{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_texture = false;

    ~Cleanup() {
      if (has_texture && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hTexture);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetViewport != nullptr, "SetViewport must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetTexture != nullptr, "SetTexture must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetTextureStageState != nullptr, "SetTextureStageState must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }

  D3DDDIVIEWPORTINFO vp{};
  vp.X = 0.0f;
  vp.Y = 0.0f;
  vp.Width = 256.0f;
  vp.Height = 256.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }

  // D3DFVF_XYZRHW (0x4) | D3DFVF_TEX1 (0x100). No diffuse provided; VS supplies white.
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x104u);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|TEX1)")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  // Force the default stage0 state (MODULATE + alpha from texture) so the PS
  // variant selection after SetTexture is deterministic.
  constexpr uint32_t kD3dTssColorOp = 1u;
  constexpr uint32_t kD3dTssColorArg1 = 2u;
  constexpr uint32_t kD3dTssColorArg2 = 3u;
  constexpr uint32_t kD3dTssAlphaOp = 4u;
  constexpr uint32_t kD3dTssAlphaArg1 = 5u;
  constexpr uint32_t kD3dTopModulate = 4u;
  constexpr uint32_t kD3dTopSelectArg1 = 2u;
  constexpr uint32_t kD3dTaDiffuse = 0u;
  constexpr uint32_t kD3dTaTexture = 2u;
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssColorOp, kD3dTopModulate);
  if (!Check(hr == S_OK, "SetTextureStageState(stage0, COLOROP=MODULATE)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssColorArg1, kD3dTaTexture);
  if (!Check(hr == S_OK, "SetTextureStageState(stage0, COLORARG1=TEXTURE)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssColorArg2, kD3dTaDiffuse);
  if (!Check(hr == S_OK, "SetTextureStageState(stage0, COLORARG2=DIFFUSE)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssAlphaOp, kD3dTopSelectArg1);
  if (!Check(hr == S_OK, "SetTextureStageState(stage0, ALPHAOP=SELECTARG1)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssAlphaArg1, kD3dTaTexture);
  if (!Check(hr == S_OK, "SetTextureStageState(stage0, ALPHAARG1=TEXTURE)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    float rhw;
    float u;
    float v;
  };

  Vertex verts[3]{};
  verts[0] = {256.0f * 0.25f, 256.0f * 0.25f, 0.5f, 1.0f, 0.0f, 0.0f};
  verts[1] = {256.0f * 0.75f, 256.0f * 0.25f, 0.5f, 1.0f, 1.0f, 0.0f};
  verts[2] = {256.0f * 0.50f, 256.0f * 0.75f, 0.5f, 1.0f, 0.5f, 1.0f};

  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(
      create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 1, verts, sizeof(Vertex));
  if (!Check(hr == S_OK, "DrawPrimitiveUP (untextured)")) {
    return false;
  }

  // Create and bind a small texture at stage0. Without issuing another draw,
  // SetTexture must update the fixed-function PS selection.
  D3D9DDIARG_CREATERESOURCE create_tex{};
  create_tex.type = kD3dRTypeTexture;
  create_tex.format = 22u; // D3DFMT_X8R8G8B8
  create_tex.width = 2;
  create_tex.height = 2;
  create_tex.depth = 1;
  create_tex.mip_levels = 1;
  create_tex.usage = 0;
  create_tex.pool = 0;
  create_tex.size = 0;
  create_tex.hResource.pDrvPrivate = nullptr;
  create_tex.pSharedHandle = nullptr;
  create_tex.pKmdAllocPrivateData = nullptr;
  create_tex.KmdAllocPrivateDataSize = 0;
  create_tex.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_tex);
  if (!CheckHr(hr, S_OK, "CreateResource(texture)")) {
    return false;
  }
  if (!Check(create_tex.hResource.pDrvPrivate != nullptr, "CreateResource(texture) returned handle")) {
    return false;
  }
  cleanup.hTexture = create_tex.hResource;
  cleanup.has_texture = true;

  hr = cleanup.device_funcs.pfnSetTexture(create_dev.hDevice, 0, create_tex.hResource);
  if (!Check(hr == S_OK, "SetTexture(stage0)")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_BIND_SHADERS) >= 2,
             "SetTexture re-emits bind_shaders for fixed-function PS selection (XYZRHW|TEX1)")) {
    return false;
  }

  return CheckLastBoundPixelShaderMatches(
      buf,
      len,
      reinterpret_cast<const void*>(fixedfunc::kPsStage0ModulateTexture),
      sizeof(fixedfunc::kPsStage0ModulateTexture),
      "bind_shaders emitted");
}

bool TestFixedFuncPsSelectionTex1OnlyFvfSelectArg1TextureUsesTextureOnly() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hTexture{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_texture = false;

    ~Cleanup() {
      if (has_texture && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hTexture);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetViewport != nullptr, "SetViewport must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetTexture != nullptr, "SetTexture must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetTextureStageState != nullptr, "SetTextureStageState must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }

  D3DDDIVIEWPORTINFO vp{};
  vp.X = 0.0f;
  vp.Y = 0.0f;
  vp.Width = 256.0f;
  vp.Height = 256.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }

  // D3DFVF_XYZRHW (0x4) | D3DFVF_TEX1 (0x100).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x104u);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|TEX1)")) {
    return false;
  }

  // Create and bind a small texture at stage0.
  D3D9DDIARG_CREATERESOURCE create_tex{};
  create_tex.type = kD3dRTypeTexture;
  create_tex.format = 22u; // D3DFMT_X8R8G8B8
  create_tex.width = 2;
  create_tex.height = 2;
  create_tex.depth = 1;
  create_tex.mip_levels = 1;
  create_tex.usage = 0;
  create_tex.pool = 0;
  create_tex.size = 0;
  create_tex.hResource.pDrvPrivate = nullptr;
  create_tex.pSharedHandle = nullptr;
  create_tex.pKmdAllocPrivateData = nullptr;
  create_tex.KmdAllocPrivateDataSize = 0;
  create_tex.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_tex);
  if (!CheckHr(hr, S_OK, "CreateResource(texture)")) {
    return false;
  }
  if (!Check(create_tex.hResource.pDrvPrivate != nullptr, "CreateResource(texture) returned handle")) {
    return false;
  }
  cleanup.hTexture = create_tex.hResource;
  cleanup.has_texture = true;

  hr = cleanup.device_funcs.pfnSetTexture(create_dev.hDevice, 0, create_tex.hResource);
  if (!Check(hr == S_OK, "SetTexture(stage0)")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  // Stage-state override: select texture for both color and alpha.
  constexpr uint32_t kD3dTssColorOp = 1u;
  constexpr uint32_t kD3dTssColorArg1 = 2u;
  constexpr uint32_t kD3dTssAlphaOp = 4u;
  constexpr uint32_t kD3dTssAlphaArg1 = 5u;
  constexpr uint32_t kD3dTopSelectArg1 = 2u;
  constexpr uint32_t kD3dTaTexture = 2u;
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssColorOp, kD3dTopSelectArg1);
  if (!Check(hr == S_OK, "SetTextureStageState(stage0, COLOROP=SELECTARG1)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssColorArg1, kD3dTaTexture);
  if (!Check(hr == S_OK, "SetTextureStageState(stage0, COLORARG1=TEXTURE)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssAlphaOp, kD3dTopSelectArg1);
  if (!Check(hr == S_OK, "SetTextureStageState(stage0, ALPHAOP=SELECTARG1)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssAlphaArg1, kD3dTaTexture);
  if (!Check(hr == S_OK, "SetTextureStageState(stage0, ALPHAARG1=TEXTURE)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    float rhw;
    float u;
    float v;
  };

  Vertex verts[3]{};
  verts[0] = {256.0f * 0.25f, 256.0f * 0.25f, 0.5f, 1.0f, 0.0f, 0.0f};
  verts[1] = {256.0f * 0.75f, 256.0f * 0.25f, 0.5f, 1.0f, 1.0f, 0.0f};
  verts[2] = {256.0f * 0.50f, 256.0f * 0.75f, 0.5f, 1.0f, 0.5f, 1.0f};

  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(
      create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 1, verts, sizeof(Vertex));
  if (!Check(hr == S_OK, "DrawPrimitiveUP")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  return CheckLastBoundPixelShaderMatches(
      buf,
      len,
      reinterpret_cast<const void*>(fixedfunc::kPsStage0TextureTexture),
      sizeof(fixedfunc::kPsStage0TextureTexture),
      "bind_shaders emitted");
}

bool TestFixedFuncPsSelectionTextureBoundDefaultModulateUsesModulate() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hTexture{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_texture = false;

    ~Cleanup() {
      if (has_texture && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hTexture);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetViewport != nullptr, "SetViewport must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetTexture != nullptr, "SetTexture must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetTextureStageState != nullptr, "SetTextureStageState must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }

  D3DDDIVIEWPORTINFO vp{};
  vp.X = 0.0f;
  vp.Y = 0.0f;
  vp.Width = 256.0f;
  vp.Height = 256.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }

  // D3DFVF_XYZRHW (0x4) | D3DFVF_DIFFUSE (0x40) | D3DFVF_TEX1 (0x100).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x144u);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|DIFFUSE|TEX1)")) {
    return false;
  }

  // Create and bind a small texture at stage0.
  D3D9DDIARG_CREATERESOURCE create_tex{};
  create_tex.type = kD3dRTypeTexture;
  create_tex.format = 22u; // D3DFMT_X8R8G8B8
  create_tex.width = 2;
  create_tex.height = 2;
  create_tex.depth = 1;
  create_tex.mip_levels = 1;
  create_tex.usage = 0;
  create_tex.pool = 0;
  create_tex.size = 0;
  create_tex.hResource.pDrvPrivate = nullptr;
  create_tex.pSharedHandle = nullptr;
  create_tex.pKmdAllocPrivateData = nullptr;
  create_tex.KmdAllocPrivateDataSize = 0;
  create_tex.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_tex);
  if (!CheckHr(hr, S_OK, "CreateResource(texture)")) {
    return false;
  }
  if (!Check(create_tex.hResource.pDrvPrivate != nullptr, "CreateResource(texture) returned handle")) {
    return false;
  }
  cleanup.hTexture = create_tex.hResource;
  cleanup.has_texture = true;

  hr = cleanup.device_funcs.pfnSetTexture(create_dev.hDevice, 0, create_tex.hResource);
  if (!Check(hr == S_OK, "SetTexture(stage0)")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  // Explicitly set the default stage0 modulation state.
  constexpr uint32_t kD3dTssColorOp = 1u;
  constexpr uint32_t kD3dTssColorArg1 = 2u;
  constexpr uint32_t kD3dTssColorArg2 = 3u;
  constexpr uint32_t kD3dTopModulate = 4u;
  constexpr uint32_t kD3dTaDiffuse = 0u;
  constexpr uint32_t kD3dTaTexture = 2u;
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssColorOp, kD3dTopModulate);
  if (!Check(hr == S_OK, "SetTextureStageState(stage0, COLOROP=MODULATE)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssColorArg1, kD3dTaTexture);
  if (!Check(hr == S_OK, "SetTextureStageState(stage0, COLORARG1=TEXTURE)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssColorArg2, kD3dTaDiffuse);
  if (!Check(hr == S_OK, "SetTextureStageState(stage0, COLORARG2=DIFFUSE)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    float rhw;
    uint32_t color;
    float u;
    float v;
  };

  constexpr uint32_t kWhite = 0xFFFFFFFFu;
  Vertex verts[3]{};
  verts[0] = {256.0f * 0.25f, 256.0f * 0.25f, 0.5f, 1.0f, kWhite, 0.0f, 0.0f};
  verts[1] = {256.0f * 0.75f, 256.0f * 0.25f, 0.5f, 1.0f, kWhite, 1.0f, 0.0f};
  verts[2] = {256.0f * 0.50f, 256.0f * 0.75f, 0.5f, 1.0f, kWhite, 0.5f, 1.0f};

  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(
      create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 1, verts, sizeof(Vertex));
  if (!Check(hr == S_OK, "DrawPrimitiveUP")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  return CheckLastBoundPixelShaderMatches(
      buf,
      len,
      reinterpret_cast<const void*>(fixedfunc::kPsStage0ModulateTexture),
      sizeof(fixedfunc::kPsStage0ModulateTexture),
      "bind_shaders emitted");
}

bool TestFixedFuncPsSelectionTextureBoundSelectArg1TextureUsesTextureOnly() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hTexture{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_texture = false;

    ~Cleanup() {
      if (has_texture && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hTexture);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetViewport != nullptr, "SetViewport must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetTexture != nullptr, "SetTexture must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetTextureStageState != nullptr, "SetTextureStageState must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }

  D3DDDIVIEWPORTINFO vp{};
  vp.X = 0.0f;
  vp.Y = 0.0f;
  vp.Width = 256.0f;
  vp.Height = 256.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }

  // D3DFVF_XYZRHW (0x4) | D3DFVF_DIFFUSE (0x40) | D3DFVF_TEX1 (0x100).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x144u);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|DIFFUSE|TEX1)")) {
    return false;
  }

  // Create and bind a small texture at stage0.
  D3D9DDIARG_CREATERESOURCE create_tex{};
  create_tex.type = kD3dRTypeTexture;
  create_tex.format = 22u; // D3DFMT_X8R8G8B8
  create_tex.width = 2;
  create_tex.height = 2;
  create_tex.depth = 1;
  create_tex.mip_levels = 1;
  create_tex.usage = 0;
  create_tex.pool = 0;
  create_tex.size = 0;
  create_tex.hResource.pDrvPrivate = nullptr;
  create_tex.pSharedHandle = nullptr;
  create_tex.pKmdAllocPrivateData = nullptr;
  create_tex.KmdAllocPrivateDataSize = 0;
  create_tex.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_tex);
  if (!CheckHr(hr, S_OK, "CreateResource(texture)")) {
    return false;
  }
  if (!Check(create_tex.hResource.pDrvPrivate != nullptr, "CreateResource(texture) returned handle")) {
    return false;
  }
  cleanup.hTexture = create_tex.hResource;
  cleanup.has_texture = true;

  hr = cleanup.device_funcs.pfnSetTexture(create_dev.hDevice, 0, create_tex.hResource);
  if (!Check(hr == S_OK, "SetTexture(stage0)")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  // Stage-state override: COLOROP=SELECTARG1, COLORARG1=TEXTURE.
  constexpr uint32_t kD3dTssColorOp = 1u;
  constexpr uint32_t kD3dTssColorArg1 = 2u;
  constexpr uint32_t kD3dTopSelectArg1 = 2u;
  constexpr uint32_t kD3dTaTexture = 2u;
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssColorOp, kD3dTopSelectArg1);
  if (!Check(hr == S_OK, "SetTextureStageState(stage0, COLOROP=SELECTARG1)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssColorArg1, kD3dTaTexture);
  if (!Check(hr == S_OK, "SetTextureStageState(stage0, COLORARG1=TEXTURE)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    float rhw;
    uint32_t color;
    float u;
    float v;
  };

  constexpr uint32_t kWhite = 0xFFFFFFFFu;
  Vertex verts[3]{};
  verts[0] = {256.0f * 0.25f, 256.0f * 0.25f, 0.5f, 1.0f, kWhite, 0.0f, 0.0f};
  verts[1] = {256.0f * 0.75f, 256.0f * 0.25f, 0.5f, 1.0f, kWhite, 1.0f, 0.0f};
  verts[2] = {256.0f * 0.50f, 256.0f * 0.75f, 0.5f, 1.0f, kWhite, 0.5f, 1.0f};

  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(
      create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 1, verts, sizeof(Vertex));
  if (!Check(hr == S_OK, "DrawPrimitiveUP")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  return CheckLastBoundPixelShaderMatches(
      buf,
      len,
      reinterpret_cast<const void*>(fixedfunc::kPsTextureOnly),
      sizeof(fixedfunc::kPsTextureOnly),
      "bind_shaders emitted");
}

bool TestFixedFuncPsSelectionTextureBoundSelectArg2TextureUsesTextureOnly() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hTexture{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_texture = false;

    ~Cleanup() {
      if (has_texture && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hTexture);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetViewport != nullptr, "SetViewport must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetTexture != nullptr, "SetTexture must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetTextureStageState != nullptr, "SetTextureStageState must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }

  D3DDDIVIEWPORTINFO vp{};
  vp.X = 0.0f;
  vp.Y = 0.0f;
  vp.Width = 256.0f;
  vp.Height = 256.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }

  // D3DFVF_XYZRHW (0x4) | D3DFVF_DIFFUSE (0x40) | D3DFVF_TEX1 (0x100).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x144u);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|DIFFUSE|TEX1)")) {
    return false;
  }

  // Create and bind a small texture at stage0.
  D3D9DDIARG_CREATERESOURCE create_tex{};
  create_tex.type = kD3dRTypeTexture;
  create_tex.format = 22u; // D3DFMT_X8R8G8B8
  create_tex.width = 2;
  create_tex.height = 2;
  create_tex.depth = 1;
  create_tex.mip_levels = 1;
  create_tex.usage = 0;
  create_tex.pool = 0;
  create_tex.size = 0;
  create_tex.hResource.pDrvPrivate = nullptr;
  create_tex.pSharedHandle = nullptr;
  create_tex.pKmdAllocPrivateData = nullptr;
  create_tex.KmdAllocPrivateDataSize = 0;
  create_tex.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_tex);
  if (!CheckHr(hr, S_OK, "CreateResource(texture)")) {
    return false;
  }
  if (!Check(create_tex.hResource.pDrvPrivate != nullptr, "CreateResource(texture) returned handle")) {
    return false;
  }
  cleanup.hTexture = create_tex.hResource;
  cleanup.has_texture = true;

  hr = cleanup.device_funcs.pfnSetTexture(create_dev.hDevice, 0, create_tex.hResource);
  if (!Check(hr == S_OK, "SetTexture(stage0)")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  // Stage-state override: COLOROP=SELECTARG2, COLORARG2=TEXTURE.
  constexpr uint32_t kD3dTssColorOp = 1u;
  constexpr uint32_t kD3dTssColorArg2 = 3u;
  constexpr uint32_t kD3dTopSelectArg2 = 3u;
  constexpr uint32_t kD3dTaTexture = 2u;
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssColorOp, kD3dTopSelectArg2);
  if (!Check(hr == S_OK, "SetTextureStageState(stage0, COLOROP=SELECTARG2)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssColorArg2, kD3dTaTexture);
  if (!Check(hr == S_OK, "SetTextureStageState(stage0, COLORARG2=TEXTURE)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    float rhw;
    uint32_t color;
    float u;
    float v;
  };

  constexpr uint32_t kWhite = 0xFFFFFFFFu;
  Vertex verts[3]{};
  verts[0] = {256.0f * 0.25f, 256.0f * 0.25f, 0.5f, 1.0f, kWhite, 0.0f, 0.0f};
  verts[1] = {256.0f * 0.75f, 256.0f * 0.25f, 0.5f, 1.0f, kWhite, 1.0f, 0.0f};
  verts[2] = {256.0f * 0.50f, 256.0f * 0.75f, 0.5f, 1.0f, kWhite, 0.5f, 1.0f};

  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(
      create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 1, verts, sizeof(Vertex));
  if (!Check(hr == S_OK, "DrawPrimitiveUP")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  return CheckLastBoundPixelShaderMatches(
      buf,
      len,
      reinterpret_cast<const void*>(fixedfunc::kPsTextureOnly),
      sizeof(fixedfunc::kPsTextureOnly),
      "bind_shaders emitted");
}

bool TestFixedFuncPsSelectionTextureBoundSelectArg2DiffuseColorSelectArg2TextureAlphaUsesDiffuseTexture() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hTexture{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_texture = false;

    ~Cleanup() {
      if (has_texture && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hTexture);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetViewport != nullptr, "SetViewport must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetTexture != nullptr, "SetTexture must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetTextureStageState != nullptr, "SetTextureStageState must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }

  D3DDDIVIEWPORTINFO vp{};
  vp.X = 0.0f;
  vp.Y = 0.0f;
  vp.Width = 256.0f;
  vp.Height = 256.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }

  // D3DFVF_XYZRHW (0x4) | D3DFVF_DIFFUSE (0x40) | D3DFVF_TEX1 (0x100).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x144u);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|DIFFUSE|TEX1)")) {
    return false;
  }

  // Create and bind a small texture at stage0.
  D3D9DDIARG_CREATERESOURCE create_tex{};
  create_tex.type = kD3dRTypeTexture;
  create_tex.format = 22u; // D3DFMT_X8R8G8B8
  create_tex.width = 2;
  create_tex.height = 2;
  create_tex.depth = 1;
  create_tex.mip_levels = 1;
  create_tex.usage = 0;
  create_tex.pool = 0;
  create_tex.size = 0;
  create_tex.hResource.pDrvPrivate = nullptr;
  create_tex.pSharedHandle = nullptr;
  create_tex.pKmdAllocPrivateData = nullptr;
  create_tex.KmdAllocPrivateDataSize = 0;
  create_tex.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_tex);
  if (!CheckHr(hr, S_OK, "CreateResource(texture)")) {
    return false;
  }
  if (!Check(create_tex.hResource.pDrvPrivate != nullptr, "CreateResource(texture) returned handle")) {
    return false;
  }
  cleanup.hTexture = create_tex.hResource;
  cleanup.has_texture = true;

  hr = cleanup.device_funcs.pfnSetTexture(create_dev.hDevice, 0, create_tex.hResource);
  if (!Check(hr == S_OK, "SetTexture(stage0)")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  // Stage-state override:
  // - COLOROP=SELECTARG2, COLORARG2=DIFFUSE
  // - ALPHAOP=SELECTARG2, ALPHAARG2=TEXTURE
  // This must sample the texture solely to source alpha; RGB comes from diffuse.
  constexpr uint32_t kD3dTssColorOp = 1u;
  constexpr uint32_t kD3dTssColorArg2 = 3u;
  constexpr uint32_t kD3dTssAlphaOp = 4u;
  constexpr uint32_t kD3dTssAlphaArg2 = 6u;
  constexpr uint32_t kD3dTopSelectArg2 = 3u;
  constexpr uint32_t kD3dTaDiffuse = 0u;
  constexpr uint32_t kD3dTaTexture = 2u;
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssColorOp, kD3dTopSelectArg2);
  if (!Check(hr == S_OK, "SetTextureStageState(stage0, COLOROP=SELECTARG2)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssColorArg2, kD3dTaDiffuse);
  if (!Check(hr == S_OK, "SetTextureStageState(stage0, COLORARG2=DIFFUSE)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssAlphaOp, kD3dTopSelectArg2);
  if (!Check(hr == S_OK, "SetTextureStageState(stage0, ALPHAOP=SELECTARG2)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssAlphaArg2, kD3dTaTexture);
  if (!Check(hr == S_OK, "SetTextureStageState(stage0, ALPHAARG2=TEXTURE)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    float rhw;
    uint32_t color;
    float u;
    float v;
  };

  constexpr uint32_t kWhite = 0xFFFFFFFFu;
  Vertex verts[3]{};
  verts[0] = {256.0f * 0.25f, 256.0f * 0.25f, 0.5f, 1.0f, kWhite, 0.0f, 0.0f};
  verts[1] = {256.0f * 0.75f, 256.0f * 0.25f, 0.5f, 1.0f, kWhite, 1.0f, 0.0f};
  verts[2] = {256.0f * 0.50f, 256.0f * 0.75f, 0.5f, 1.0f, kWhite, 0.5f, 1.0f};

  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(
      create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 1, verts, sizeof(Vertex));
  if (!Check(hr == S_OK, "DrawPrimitiveUP")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  return CheckLastBoundPixelShaderMatches(
      buf,
      len,
      reinterpret_cast<const void*>(fixedfunc::kPsStage0DiffuseTexture),
      sizeof(fixedfunc::kPsStage0DiffuseTexture),
      "bind_shaders emitted");
}

bool TestFixedFuncPsSelectionTextureBoundModulateDiffuseDiffuseUsesColorOnly() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hTexture{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_texture = false;

    ~Cleanup() {
      if (has_texture && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hTexture);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetViewport != nullptr, "SetViewport must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetTexture != nullptr, "SetTexture must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetTextureStageState != nullptr, "SetTextureStageState must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }

  D3DDDIVIEWPORTINFO vp{};
  vp.X = 0.0f;
  vp.Y = 0.0f;
  vp.Width = 256.0f;
  vp.Height = 256.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }

  // D3DFVF_XYZRHW (0x4) | D3DFVF_DIFFUSE (0x40) | D3DFVF_TEX1 (0x100).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x144u);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|DIFFUSE|TEX1)")) {
    return false;
  }

  // Create and bind a small texture at stage0.
  D3D9DDIARG_CREATERESOURCE create_tex{};
  create_tex.type = kD3dRTypeTexture;
  create_tex.format = 22u; // D3DFMT_X8R8G8B8
  create_tex.width = 2;
  create_tex.height = 2;
  create_tex.depth = 1;
  create_tex.mip_levels = 1;
  create_tex.usage = 0;
  create_tex.pool = 0;
  create_tex.size = 0;
  create_tex.hResource.pDrvPrivate = nullptr;
  create_tex.pSharedHandle = nullptr;
  create_tex.pKmdAllocPrivateData = nullptr;
  create_tex.KmdAllocPrivateDataSize = 0;
  create_tex.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_tex);
  if (!CheckHr(hr, S_OK, "CreateResource(texture)")) {
    return false;
  }
  if (!Check(create_tex.hResource.pDrvPrivate != nullptr, "CreateResource(texture) returned handle")) {
    return false;
  }
  cleanup.hTexture = create_tex.hResource;
  cleanup.has_texture = true;

  hr = cleanup.device_funcs.pfnSetTexture(create_dev.hDevice, 0, create_tex.hResource);
  if (!Check(hr == S_OK, "SetTexture(stage0)")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  // Stage-state override:
  // - COLOROP=MODULATE, COLORARG1=DIFFUSE, COLORARG2=DIFFUSE
  // - ALPHAOP=SELECTARG1(DIFFUSE)
  //
  // This should not sample the texture at all: MODULATE(DIFFUSE,DIFFUSE) is
  // diffuse-only, so the fixed-function PS variant should be ColorOnly.
  constexpr uint32_t kD3dTssColorOp = 1u;
  constexpr uint32_t kD3dTssColorArg1 = 2u;
  constexpr uint32_t kD3dTssColorArg2 = 3u;
  constexpr uint32_t kD3dTssAlphaOp = 4u;
  constexpr uint32_t kD3dTssAlphaArg1 = 5u;
  constexpr uint32_t kD3dTopModulate = 4u;
  constexpr uint32_t kD3dTopSelectArg1 = 2u;
  constexpr uint32_t kD3dTaDiffuse = 0u;
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssColorOp, kD3dTopModulate);
  if (!Check(hr == S_OK, "SetTextureStageState(stage0, COLOROP=MODULATE)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssColorArg1, kD3dTaDiffuse);
  if (!Check(hr == S_OK, "SetTextureStageState(stage0, COLORARG1=DIFFUSE)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssColorArg2, kD3dTaDiffuse);
  if (!Check(hr == S_OK, "SetTextureStageState(stage0, COLORARG2=DIFFUSE)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssAlphaOp, kD3dTopSelectArg1);
  if (!Check(hr == S_OK, "SetTextureStageState(stage0, ALPHAOP=SELECTARG1)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssAlphaArg1, kD3dTaDiffuse);
  if (!Check(hr == S_OK, "SetTextureStageState(stage0, ALPHAARG1=DIFFUSE)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    float rhw;
    uint32_t color;
    float u;
    float v;
  };

  constexpr uint32_t kWhite = 0xFFFFFFFFu;
  Vertex verts[3]{};
  verts[0] = {256.0f * 0.25f, 256.0f * 0.25f, 0.5f, 1.0f, kWhite, 0.0f, 0.0f};
  verts[1] = {256.0f * 0.75f, 256.0f * 0.25f, 0.5f, 1.0f, kWhite, 1.0f, 0.0f};
  verts[2] = {256.0f * 0.50f, 256.0f * 0.75f, 0.5f, 1.0f, kWhite, 0.5f, 1.0f};

  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(
      create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 1, verts, sizeof(Vertex));
  if (!Check(hr == S_OK, "DrawPrimitiveUP")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  // MODULATE with DIFFUSE-only args must not sample the bound texture, but still
  // performs a mul in the fixed-function combiner.
  return CheckLastBoundPixelShaderOps(
      buf,
      len,
      /*expect_texld=*/false,
      /*expect_add=*/false,
      /*expect_mul=*/true,
      "bind_shaders emitted");
}

bool TestFixedFuncPsSelectionTextureBoundUnknownColorOpDiffuseArgsUsesColorOnly() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hTexture{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_texture = false;

    ~Cleanup() {
      if (has_texture && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hTexture);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetViewport != nullptr, "SetViewport must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetTexture != nullptr, "SetTexture must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetTextureStageState != nullptr, "SetTextureStageState must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }

  D3DDDIVIEWPORTINFO vp{};
  vp.X = 0.0f;
  vp.Y = 0.0f;
  vp.Width = 256.0f;
  vp.Height = 256.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }

  // D3DFVF_XYZRHW (0x4) | D3DFVF_DIFFUSE (0x40) | D3DFVF_TEX1 (0x100).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x144u);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|DIFFUSE|TEX1)")) {
    return false;
  }

  // Create and bind a small texture at stage0 (should still not be sampled).
  D3D9DDIARG_CREATERESOURCE create_tex{};
  create_tex.type = kD3dRTypeTexture;
  create_tex.format = 22u; // D3DFMT_X8R8G8B8
  create_tex.width = 2;
  create_tex.height = 2;
  create_tex.depth = 1;
  create_tex.mip_levels = 1;
  create_tex.usage = 0;
  create_tex.pool = 0;
  create_tex.size = 0;
  create_tex.hResource.pDrvPrivate = nullptr;
  create_tex.pSharedHandle = nullptr;
  create_tex.pKmdAllocPrivateData = nullptr;
  create_tex.KmdAllocPrivateDataSize = 0;
  create_tex.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_tex);
  if (!CheckHr(hr, S_OK, "CreateResource(texture)")) {
    return false;
  }
  if (!Check(create_tex.hResource.pDrvPrivate != nullptr, "CreateResource(texture) returned handle")) {
    return false;
  }
  cleanup.hTexture = create_tex.hResource;
  cleanup.has_texture = true;

  hr = cleanup.device_funcs.pfnSetTexture(create_dev.hDevice, 0, create_tex.hResource);
  if (!Check(hr == S_OK, "SetTexture(stage0)")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  // Stage-state override:
  // Use D3DTOP_ADD with DIFFUSE-only args. The PS selection should remain diffuse-only
  // and avoid sampling the bound texture.
  constexpr uint32_t kD3dTssColorOp = 1u;
  constexpr uint32_t kD3dTssColorArg1 = 2u;
  constexpr uint32_t kD3dTssColorArg2 = 3u;
  constexpr uint32_t kD3dTssAlphaOp = 4u;
  constexpr uint32_t kD3dTssAlphaArg1 = 5u;

  constexpr uint32_t kD3dTopAdd = 7u; // D3DTOP_ADD
  constexpr uint32_t kD3dTopSelectArg1 = 2u;
  constexpr uint32_t kD3dTaDiffuse = 0u;

  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssColorOp, kD3dTopAdd);
  if (!Check(hr == S_OK, "SetTextureStageState(stage0, COLOROP=ADD)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssColorArg1, kD3dTaDiffuse);
  if (!Check(hr == S_OK, "SetTextureStageState(stage0, COLORARG1=DIFFUSE)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssColorArg2, kD3dTaDiffuse);
  if (!Check(hr == S_OK, "SetTextureStageState(stage0, COLORARG2=DIFFUSE)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssAlphaOp, kD3dTopSelectArg1);
  if (!Check(hr == S_OK, "SetTextureStageState(stage0, ALPHAOP=SELECTARG1)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssAlphaArg1, kD3dTaDiffuse);
  if (!Check(hr == S_OK, "SetTextureStageState(stage0, ALPHAARG1=DIFFUSE)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    float rhw;
    uint32_t color;
    float u;
    float v;
  };

  constexpr uint32_t kWhite = 0xFFFFFFFFu;
  Vertex verts[3]{};
  verts[0] = {256.0f * 0.25f, 256.0f * 0.25f, 0.5f, 1.0f, kWhite, 0.0f, 0.0f};
  verts[1] = {256.0f * 0.75f, 256.0f * 0.25f, 0.5f, 1.0f, kWhite, 1.0f, 0.0f};
  verts[2] = {256.0f * 0.50f, 256.0f * 0.75f, 0.5f, 1.0f, kWhite, 0.5f, 1.0f};

  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(
      create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 1, verts, sizeof(Vertex));
  if (!Check(hr == S_OK, "DrawPrimitiveUP")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  return CheckLastBoundPixelShaderOps(
      buf,
      len,
      /*expect_texld=*/false,
      /*expect_add=*/true,
      /*expect_mul=*/false,
      "bind_shaders emitted");
}

bool TestFixedFuncPsSelectionTextureBoundUnknownColorOpFallsBackToModulate() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hTexture{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_texture = false;

    ~Cleanup() {
      if (has_texture && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hTexture);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetViewport != nullptr, "SetViewport must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetTexture != nullptr, "SetTexture must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }

  D3DDDIVIEWPORTINFO vp{};
  vp.X = 0.0f;
  vp.Y = 0.0f;
  vp.Width = 256.0f;
  vp.Height = 256.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }

  // D3DFVF_XYZRHW (0x4) | D3DFVF_DIFFUSE (0x40) | D3DFVF_TEX1 (0x100).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x144u);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|DIFFUSE|TEX1)")) {
    return false;
  }

  // Create and bind a small texture at stage0.
  D3D9DDIARG_CREATERESOURCE create_tex{};
  create_tex.type = kD3dRTypeTexture;
  create_tex.format = 22u; // D3DFMT_X8R8G8B8
  create_tex.width = 2;
  create_tex.height = 2;
  create_tex.depth = 1;
  create_tex.mip_levels = 1;
  create_tex.usage = 0;
  create_tex.pool = 0;
  create_tex.size = 0;
  create_tex.hResource.pDrvPrivate = nullptr;
  create_tex.pSharedHandle = nullptr;
  create_tex.pKmdAllocPrivateData = nullptr;
  create_tex.KmdAllocPrivateDataSize = 0;
  create_tex.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_tex);
  if (!CheckHr(hr, S_OK, "CreateResource(texture)")) {
    return false;
  }
  if (!Check(create_tex.hResource.pDrvPrivate != nullptr, "CreateResource(texture) returned handle")) {
    return false;
  }
  cleanup.hTexture = create_tex.hResource;
  cleanup.has_texture = true;

  hr = cleanup.device_funcs.pfnSetTexture(create_dev.hDevice, 0, create_tex.hResource);
  if (!Check(hr == S_OK, "SetTexture(stage0)")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  // Stage-state override: COLOROP = ADD(TEXTURE, DIFFUSE).
  constexpr uint32_t kD3dTssColorOp = 1u;
  constexpr uint32_t kD3dTssColorArg1 = 2u;
  constexpr uint32_t kD3dTssColorArg2 = 3u;
  constexpr uint32_t kD3dTssAlphaOp = 4u;
  constexpr uint32_t kD3dTssAlphaArg1 = 5u;
  constexpr uint32_t kD3dTssAlphaArg2 = 6u;

  constexpr uint32_t kD3dTopAdd = 7u; // D3DTOP_ADD
  constexpr uint32_t kD3dTopSelectArg1 = 2u;
  constexpr uint32_t kD3dTaDiffuse = 0u;
  constexpr uint32_t kD3dTaTexture = 2u;

  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssColorOp, kD3dTopAdd);
  if (!Check(hr == S_OK, "SetTextureStageState(stage0, COLOROP=ADD)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssColorArg1, kD3dTaTexture);
  if (!Check(hr == S_OK, "SetTextureStageState(stage0, COLORARG1=TEXTURE)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssColorArg2, kD3dTaDiffuse);
  if (!Check(hr == S_OK, "SetTextureStageState(stage0, COLORARG2=DIFFUSE)")) {
    return false;
  }

  // Alpha: keep default "take alpha from texture" semantics.
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssAlphaOp, kD3dTopSelectArg1);
  if (!Check(hr == S_OK, "SetTextureStageState(stage0, ALPHAOP=SELECTARG1)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssAlphaArg1, kD3dTaTexture);
  if (!Check(hr == S_OK, "SetTextureStageState(stage0, ALPHAARG1=TEXTURE)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTextureStageState(create_dev.hDevice, 0, kD3dTssAlphaArg2, kD3dTaDiffuse);
  if (!Check(hr == S_OK, "SetTextureStageState(stage0, ALPHAARG2=DIFFUSE)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    float rhw;
    uint32_t color;
    float u;
    float v;
  };

  constexpr uint32_t kWhite = 0xFFFFFFFFu;
  Vertex verts[3]{};
  verts[0] = {256.0f * 0.25f, 256.0f * 0.25f, 0.5f, 1.0f, kWhite, 0.0f, 0.0f};
  verts[1] = {256.0f * 0.75f, 256.0f * 0.25f, 0.5f, 1.0f, kWhite, 1.0f, 0.0f};
  verts[2] = {256.0f * 0.50f, 256.0f * 0.75f, 0.5f, 1.0f, kWhite, 0.5f, 1.0f};

  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(
      create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 1, verts, sizeof(Vertex));
  if (!Check(hr == S_OK, "DrawPrimitiveUP")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  return CheckLastBoundPixelShaderOps(
      buf,
      len,
      /*expect_texld=*/true,
      /*expect_add=*/true,
      /*expect_mul=*/false,
      "bind_shaders emitted");
}

bool TestFvfXyzrhwDiffuseDrawPrimitiveEmulationConvertsVertices() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hVb{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_vb = false;

    ~Cleanup() {
      if (has_vb && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hVb);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnLock != nullptr && cleanup.device_funcs.pfnUnlock != nullptr, "Lock/Unlock must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetStreamSource != nullptr, "SetStreamSource must be available")) {
    return false;
  }

  D3DDDIVIEWPORTINFO vp{};
  vp.X = 0.0f;
  vp.Y = 0.0f;
  vp.Width = 256.0f;
  vp.Height = 256.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }

  // D3DFVF_XYZRHW (0x4) | D3DFVF_DIFFUSE (0x40).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x44u);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|DIFFUSE)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    float rhw;
    uint32_t color;
  };

  constexpr uint32_t kGreen = 0xFF00FF00u;
  Vertex verts[3]{};
  verts[0] = {256.0f * 0.25f, 256.0f * 0.25f, 0.5f, 1.0f, kGreen};
  verts[1] = {256.0f * 0.75f, 256.0f * 0.25f, 0.5f, 1.0f, kGreen};
  verts[2] = {256.0f * 0.50f, 256.0f * 0.75f, 0.5f, 1.0f, kGreen};

  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = 0;
  create_res.format = 0;
  create_res.width = 0;
  create_res.height = 0;
  create_res.depth = 0;
  create_res.mip_levels = 1;
  create_res.usage = 0;
  create_res.pool = 0;
  create_res.size = sizeof(verts);
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr;
  create_res.pKmdAllocPrivateData = nullptr;
  create_res.KmdAllocPrivateDataSize = 0;
  create_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == S_OK, "CreateResource(vertex buffer)")) {
    return false;
  }
  cleanup.hVb = create_res.hResource;
  cleanup.has_vb = true;

  D3D9DDIARG_LOCK lock{};
  lock.hResource = create_res.hResource;
  lock.offset_bytes = 0;
  lock.size_bytes = 0;
  lock.flags = 0;
  D3DDDI_LOCKEDBOX box{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(vertex buffer)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock returns pData")) {
    return false;
  }
  std::memcpy(box.pData, verts, sizeof(verts));

  D3D9DDIARG_UNLOCK unlock{};
  unlock.hResource = create_res.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(vertex buffer)")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnSetStreamSource(create_dev.hDevice, 0, create_res.hResource, 0, sizeof(Vertex));
  if (!Check(hr == S_OK, "SetStreamSource")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnDrawPrimitive(create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 0, 1);
  if (!Check(hr == S_OK, "DrawPrimitive")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_CREATE_SHADER_DXBC) >= 2,
             "fixed-function fallback creates shaders")) {
    return false;
  }

  const CmdLoc upload = FindLastOpcode(buf, len, AEROGPU_CMD_UPLOAD_RESOURCE);
  if (!Check(upload.hdr != nullptr, "upload_resource emitted")) {
    return false;
  }
  const auto* upload_cmd = reinterpret_cast<const aerogpu_cmd_upload_resource*>(upload.hdr);
  if (!Check(upload_cmd->size_bytes == sizeof(verts), "upload_resource size matches vertex data")) {
    return false;
  }

  const uint8_t* payload = reinterpret_cast<const uint8_t*>(upload_cmd) + sizeof(*upload_cmd);
  float x0 = 0.0f;
  float y0 = 0.0f;
  float z0 = 0.0f;
  float w0 = 0.0f;
  uint32_t c0 = 0;
  std::memcpy(&x0, payload + 0, sizeof(float));
  std::memcpy(&y0, payload + 4, sizeof(float));
  std::memcpy(&z0, payload + 8, sizeof(float));
  std::memcpy(&w0, payload + 12, sizeof(float));
  std::memcpy(&c0, payload + 16, sizeof(uint32_t));

  const float expected_x0 = ((verts[0].x + 0.5f - vp.X) / vp.Width) * 2.0f - 1.0f;
  const float expected_y0 = 1.0f - ((verts[0].y + 0.5f - vp.Y) / vp.Height) * 2.0f;
  if (!Check(std::fabs(x0 - expected_x0) < 1e-6f, "DrawPrimitive: x0 matches half-pixel convention")) {
    return false;
  }
  if (!Check(std::fabs(y0 - expected_y0) < 1e-6f, "DrawPrimitive: y0 matches half-pixel convention")) {
    return false;
  }
  if (!Check(std::fabs(z0 - verts[0].z) < 1e-6f, "DrawPrimitive: z preserved")) {
    return false;
  }
  if (!Check(std::fabs(w0 - 1.0f) < 1e-6f, "DrawPrimitive: w preserved")) {
    return false;
  }
  return Check(c0 == kGreen, "DrawPrimitive: diffuse color preserved");
}

bool TestFvfXyzrhwDiffuseTex1DrawPrimitiveEmulationConvertsVertices() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hVb{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_vb = false;

    ~Cleanup() {
      if (has_vb && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hVb);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnLock != nullptr && cleanup.device_funcs.pfnUnlock != nullptr, "Lock/Unlock must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetStreamSource != nullptr, "SetStreamSource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitive != nullptr, "DrawPrimitive must be available")) {
    return false;
  }

  D3DDDIVIEWPORTINFO vp{};
  vp.X = 0.0f;
  vp.Y = 0.0f;
  vp.Width = 256.0f;
  vp.Height = 256.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }

  // D3DFVF_XYZRHW (0x4) | D3DFVF_DIFFUSE (0x40) | D3DFVF_TEX1 (0x100).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x144u);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|DIFFUSE|TEX1)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    float rhw;
    uint32_t color;
    float u;
    float v;
  };

  constexpr uint32_t kGreen = 0xFF00FF00u;
  Vertex verts[3]{};
  verts[0] = {256.0f * 0.25f, 256.0f * 0.25f, 0.5f, 1.0f, kGreen, 0.25f, 0.75f};
  verts[1] = {256.0f * 0.75f, 256.0f * 0.25f, 0.5f, 1.0f, kGreen, 0.75f, 0.75f};
  verts[2] = {256.0f * 0.50f, 256.0f * 0.75f, 0.5f, 1.0f, kGreen, 0.50f, 0.25f};

  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = 0;
  create_res.format = 0;
  create_res.width = 0;
  create_res.height = 0;
  create_res.depth = 0;
  create_res.mip_levels = 1;
  create_res.usage = 0;
  create_res.pool = 0;
  create_res.size = sizeof(verts);
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr;
  create_res.pKmdAllocPrivateData = nullptr;
  create_res.KmdAllocPrivateDataSize = 0;
  create_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == S_OK, "CreateResource(vertex buffer)")) {
    return false;
  }
  cleanup.hVb = create_res.hResource;
  cleanup.has_vb = true;

  D3D9DDIARG_LOCK lock{};
  lock.hResource = create_res.hResource;
  lock.offset_bytes = 0;
  lock.size_bytes = 0;
  lock.flags = 0;
  D3DDDI_LOCKEDBOX box{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(vertex buffer)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock returns pData")) {
    return false;
  }
  std::memcpy(box.pData, verts, sizeof(verts));

  D3D9DDIARG_UNLOCK unlock{};
  unlock.hResource = create_res.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(vertex buffer)")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnSetStreamSource(create_dev.hDevice, 0, create_res.hResource, 0, sizeof(Vertex));
  if (!Check(hr == S_OK, "SetStreamSource")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnDrawPrimitive(create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 0, 1);
  if (!Check(hr == S_OK, "DrawPrimitive")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_CREATE_SHADER_DXBC) >= 2,
             "fixed-function fallback creates shaders")) {
    return false;
  }

  const uint32_t up_vb_handle = (dev->up_vertex_buffer) ? dev->up_vertex_buffer->handle : 0;
  if (!Check(up_vb_handle != 0, "fixed-function conversion allocates scratch VB")) {
    return false;
  }

  const aerogpu_cmd_upload_resource* upload_cmd = nullptr;
  const size_t stream_len = StreamBytesUsed(buf, len);
  size_t off = sizeof(aerogpu_cmd_stream_header);
  while (off + sizeof(aerogpu_cmd_hdr) <= stream_len) {
    const auto* hdr = reinterpret_cast<const aerogpu_cmd_hdr*>(buf + off);
    if (hdr->opcode == AEROGPU_CMD_UPLOAD_RESOURCE) {
      const auto* u = reinterpret_cast<const aerogpu_cmd_upload_resource*>(hdr);
      if (u->resource_handle == up_vb_handle && u->offset_bytes == 0 && u->size_bytes >= sizeof(Vertex)) {
        upload_cmd = u;
      }
    }
    if (hdr->size_bytes == 0 || hdr->size_bytes > stream_len - off) {
      break;
    }
    off += hdr->size_bytes;
  }

  if (!Check(upload_cmd != nullptr, "upload_resource for scratch VB")) {
    return false;
  }

  const uint8_t* payload = reinterpret_cast<const uint8_t*>(upload_cmd) + sizeof(*upload_cmd);
  float x0 = 0.0f;
  float y0 = 0.0f;
  float z0 = 0.0f;
  float w0 = 0.0f;
  uint32_t c0 = 0;
  float u0 = 0.0f;
  float v0 = 0.0f;
  std::memcpy(&x0, payload + 0, sizeof(float));
  std::memcpy(&y0, payload + 4, sizeof(float));
  std::memcpy(&z0, payload + 8, sizeof(float));
  std::memcpy(&w0, payload + 12, sizeof(float));
  std::memcpy(&c0, payload + 16, sizeof(uint32_t));
  std::memcpy(&u0, payload + 20, sizeof(float));
  std::memcpy(&v0, payload + 24, sizeof(float));

  const float expected_x0 = ((verts[0].x + 0.5f - vp.X) / vp.Width) * 2.0f - 1.0f;
  const float expected_y0 = 1.0f - ((verts[0].y + 0.5f - vp.Y) / vp.Height) * 2.0f;
  if (!Check(std::fabs(x0 - expected_x0) < 1e-6f, "XYZRHW|TEX1: x0 matches half-pixel convention")) {
    return false;
  }
  if (!Check(std::fabs(y0 - expected_y0) < 1e-6f, "XYZRHW|TEX1: y0 matches half-pixel convention")) {
    return false;
  }
  if (!Check(std::fabs(z0 - verts[0].z) < 1e-6f, "XYZRHW|TEX1: z preserved")) {
    return false;
  }
  if (!Check(std::fabs(w0 - 1.0f) < 1e-6f, "XYZRHW|TEX1: w preserved")) {
    return false;
  }
  if (!Check(c0 == kGreen, "XYZRHW|TEX1: diffuse color preserved")) {
    return false;
  }
  if (!Check(std::fabs(u0 - verts[0].u) < 1e-6f, "XYZRHW|TEX1: u preserved")) {
    return false;
  }
  return Check(std::fabs(v0 - verts[0].v) < 1e-6f, "XYZRHW|TEX1: v preserved");
}

bool TestFvfXyzrhwTex1DrawPrimitiveEmulationConvertsVertices() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hVb{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_vb = false;

    ~Cleanup() {
      if (has_vb && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hVb);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnLock != nullptr && cleanup.device_funcs.pfnUnlock != nullptr, "Lock/Unlock must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetStreamSource != nullptr, "SetStreamSource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitive != nullptr, "DrawPrimitive must be available")) {
    return false;
  }

  D3DDDIVIEWPORTINFO vp{};
  vp.X = 0.0f;
  vp.Y = 0.0f;
  vp.Width = 256.0f;
  vp.Height = 256.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }

  // D3DFVF_XYZRHW (0x4) | D3DFVF_TEX1 (0x100).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x104u);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|TEX1)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    float rhw;
    float u;
    float v;
  };

  Vertex verts[3]{};
  verts[0] = {256.0f * 0.25f, 256.0f * 0.25f, 0.5f, 1.0f, 0.25f, 0.75f};
  verts[1] = {256.0f * 0.75f, 256.0f * 0.25f, 0.5f, 1.0f, 0.75f, 0.75f};
  verts[2] = {256.0f * 0.50f, 256.0f * 0.75f, 0.5f, 1.0f, 0.50f, 0.25f};

  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = 0;
  create_res.format = 0;
  create_res.width = 0;
  create_res.height = 0;
  create_res.depth = 0;
  create_res.mip_levels = 1;
  create_res.usage = 0;
  create_res.pool = 0;
  create_res.size = sizeof(verts);
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr;
  create_res.pKmdAllocPrivateData = nullptr;
  create_res.KmdAllocPrivateDataSize = 0;
  create_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == S_OK, "CreateResource(vertex buffer)")) {
    return false;
  }
  cleanup.hVb = create_res.hResource;
  cleanup.has_vb = true;

  D3D9DDIARG_LOCK lock{};
  lock.hResource = create_res.hResource;
  lock.offset_bytes = 0;
  lock.size_bytes = 0;
  lock.flags = 0;
  D3DDDI_LOCKEDBOX box{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(vertex buffer)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock returns pData")) {
    return false;
  }
  std::memcpy(box.pData, verts, sizeof(verts));

  D3D9DDIARG_UNLOCK unlock{};
  unlock.hResource = create_res.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(vertex buffer)")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnSetStreamSource(create_dev.hDevice, 0, create_res.hResource, 0, sizeof(Vertex));
  if (!Check(hr == S_OK, "SetStreamSource")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnDrawPrimitive(create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 0, 1);
  if (!Check(hr == S_OK, "DrawPrimitive")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_CREATE_SHADER_DXBC) >= 2,
             "fixed-function fallback creates shaders")) {
    return false;
  }

  const uint32_t up_vb_handle = (dev->up_vertex_buffer) ? dev->up_vertex_buffer->handle : 0;
  if (!Check(up_vb_handle != 0, "fixed-function conversion allocates scratch VB")) {
    return false;
  }

  const aerogpu_cmd_upload_resource* upload_cmd = nullptr;
  const size_t stream_len = StreamBytesUsed(buf, len);
  size_t off = sizeof(aerogpu_cmd_stream_header);
  while (off + sizeof(aerogpu_cmd_hdr) <= stream_len) {
    const auto* hdr = reinterpret_cast<const aerogpu_cmd_hdr*>(buf + off);
    if (hdr->opcode == AEROGPU_CMD_UPLOAD_RESOURCE) {
      const auto* u = reinterpret_cast<const aerogpu_cmd_upload_resource*>(hdr);
      if (u->resource_handle == up_vb_handle && u->offset_bytes == 0 && u->size_bytes >= sizeof(Vertex)) {
        upload_cmd = u;
      }
    }
    if (hdr->size_bytes == 0 || hdr->size_bytes > stream_len - off) {
      break;
    }
    off += hdr->size_bytes;
  }

  if (!Check(upload_cmd != nullptr, "upload_resource for scratch VB")) {
    return false;
  }

  const uint8_t* payload = reinterpret_cast<const uint8_t*>(upload_cmd) + sizeof(*upload_cmd);
  float x0 = 0.0f;
  float y0 = 0.0f;
  float z0 = 0.0f;
  float w0 = 0.0f;
  float u0 = 0.0f;
  float v0 = 0.0f;
  std::memcpy(&x0, payload + 0, sizeof(float));
  std::memcpy(&y0, payload + 4, sizeof(float));
  std::memcpy(&z0, payload + 8, sizeof(float));
  std::memcpy(&w0, payload + 12, sizeof(float));
  std::memcpy(&u0, payload + 16, sizeof(float));
  std::memcpy(&v0, payload + 20, sizeof(float));

  const float expected_x0 = ((verts[0].x + 0.5f - vp.X) / vp.Width) * 2.0f - 1.0f;
  const float expected_y0 = 1.0f - ((verts[0].y + 0.5f - vp.Y) / vp.Height) * 2.0f;
  if (!Check(std::fabs(x0 - expected_x0) < 1e-6f, "XYZRHW|TEX1(no diffuse): x0 matches half-pixel convention")) {
    return false;
  }
  if (!Check(std::fabs(y0 - expected_y0) < 1e-6f, "XYZRHW|TEX1(no diffuse): y0 matches half-pixel convention")) {
    return false;
  }
  if (!Check(std::fabs(z0 - verts[0].z) < 1e-6f, "XYZRHW|TEX1(no diffuse): z preserved")) {
    return false;
  }
  if (!Check(std::fabs(w0 - 1.0f) < 1e-6f, "XYZRHW|TEX1(no diffuse): w preserved")) {
    return false;
  }
  if (!Check(std::fabs(u0 - verts[0].u) < 1e-6f, "XYZRHW|TEX1(no diffuse): u preserved")) {
    return false;
  }
  if (!Check(std::fabs(v0 - verts[0].v) < 1e-6f, "XYZRHW|TEX1(no diffuse): v preserved")) {
    return false;
  }
  return ValidateStream(buf, len);
}

bool TestFvfXyzrhwDiffuseTex1DrawPrimitiveUpEmulationConvertsVertices() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetViewport != nullptr, "SetViewport must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }

  D3DDDIVIEWPORTINFO vp{};
  vp.X = 0.0f;
  vp.Y = 0.0f;
  vp.Width = 256.0f;
  vp.Height = 256.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }

  // D3DFVF_XYZRHW (0x4) | D3DFVF_DIFFUSE (0x40) | D3DFVF_TEX1 (0x100).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x144u);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|DIFFUSE|TEX1)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    float rhw;
    uint32_t color;
    float u;
    float v;
  };

  constexpr uint32_t kGreen = 0xFF00FF00u;
  Vertex verts[3]{};
  verts[0] = {256.0f * 0.25f, 256.0f * 0.25f, 0.5f, 1.0f, kGreen, 0.25f, 0.75f};
  verts[1] = {256.0f * 0.75f, 256.0f * 0.25f, 0.5f, 1.0f, kGreen, 0.75f, 0.75f};
  verts[2] = {256.0f * 0.50f, 256.0f * 0.75f, 0.5f, 1.0f, kGreen, 0.50f, 0.25f};

  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 1, verts, sizeof(Vertex));
  if (!Check(hr == S_OK, "DrawPrimitiveUP")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  if (!Check(dev->up_vertex_buffer != nullptr, "up_vertex_buffer allocated")) {
    return false;
  }
  const uint32_t up_vb_handle = dev->up_vertex_buffer->handle;
  if (!Check(up_vb_handle != 0, "up_vertex_buffer handle non-zero")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  const size_t expected_bytes = AlignUp(sizeof(verts), 4);
  std::vector<uint8_t> vb_upload(expected_bytes, 0);
  size_t vb_uploaded_bytes = 0;

  const size_t stream_len = StreamBytesUsed(buf, len);
  size_t off = sizeof(aerogpu_cmd_stream_header);
  while (off + sizeof(aerogpu_cmd_hdr) <= stream_len) {
    const auto* hdr = reinterpret_cast<const aerogpu_cmd_hdr*>(buf + off);
    if (hdr->opcode == AEROGPU_CMD_UPLOAD_RESOURCE) {
      const auto* upload = reinterpret_cast<const aerogpu_cmd_upload_resource*>(hdr);
      if (upload->resource_handle == up_vb_handle) {
        const size_t payload_bytes = upload->size_bytes;
        if (!Check(upload->offset_bytes + payload_bytes <= expected_bytes, "upload_resource(UP VB) bounds")) {
          return false;
        }
        if (!Check(sizeof(*upload) + payload_bytes <= hdr->size_bytes, "upload_resource(UP VB) payload bounds")) {
          return false;
        }
        const uint8_t* payload = reinterpret_cast<const uint8_t*>(upload) + sizeof(*upload);
        std::memcpy(vb_upload.data() + upload->offset_bytes, payload, payload_bytes);
        vb_uploaded_bytes += payload_bytes;
      }
    }
    if (hdr->size_bytes == 0 || hdr->size_bytes > stream_len - off) {
      break;
    }
    off += hdr->size_bytes;
  }

  if (!Check(vb_uploaded_bytes == expected_bytes, "UP VB upload emitted")) {
    return false;
  }

  float x0 = 0.0f;
  float y0 = 0.0f;
  float z0 = 0.0f;
  float w0 = 0.0f;
  uint32_t c0 = 0;
  float u0 = 0.0f;
  float v0 = 0.0f;
  std::memcpy(&x0, vb_upload.data() + 0, sizeof(float));
  std::memcpy(&y0, vb_upload.data() + 4, sizeof(float));
  std::memcpy(&z0, vb_upload.data() + 8, sizeof(float));
  std::memcpy(&w0, vb_upload.data() + 12, sizeof(float));
  std::memcpy(&c0, vb_upload.data() + 16, sizeof(uint32_t));
  std::memcpy(&u0, vb_upload.data() + 20, sizeof(float));
  std::memcpy(&v0, vb_upload.data() + 24, sizeof(float));

  const float expected_x0 = ((verts[0].x + 0.5f - vp.X) / vp.Width) * 2.0f - 1.0f;
  const float expected_y0 = 1.0f - ((verts[0].y + 0.5f - vp.Y) / vp.Height) * 2.0f;
  if (!Check(std::fabs(x0 - expected_x0) < 1e-6f, "XYZRHW|TEX1 UP: x0 matches half-pixel convention")) {
    return false;
  }
  if (!Check(std::fabs(y0 - expected_y0) < 1e-6f, "XYZRHW|TEX1 UP: y0 matches half-pixel convention")) {
    return false;
  }
  if (!Check(std::fabs(z0 - verts[0].z) < 1e-6f, "XYZRHW|TEX1 UP: z preserved")) {
    return false;
  }
  if (!Check(std::fabs(w0 - 1.0f) < 1e-6f, "XYZRHW|TEX1 UP: w preserved")) {
    return false;
  }
  if (!Check(c0 == kGreen, "XYZRHW|TEX1 UP: diffuse color preserved")) {
    return false;
  }
  if (!Check(std::fabs(u0 - verts[0].u) < 1e-6f, "XYZRHW|TEX1 UP: u preserved")) {
    return false;
  }
  if (!Check(std::fabs(v0 - verts[0].v) < 1e-6f, "XYZRHW|TEX1 UP: v preserved")) {
    return false;
  }

  return ValidateStream(buf, len);
}

bool TestFvfXyzrhwTex1DrawPrimitiveUpEmulationConvertsVertices() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetViewport != nullptr, "SetViewport must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }

  D3DDDIVIEWPORTINFO vp{};
  vp.X = 0.0f;
  vp.Y = 0.0f;
  vp.Width = 256.0f;
  vp.Height = 256.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }

  // D3DFVF_XYZRHW (0x4) | D3DFVF_TEX1 (0x100).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x104u);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|TEX1)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    float rhw;
    float u;
    float v;
  };

  Vertex verts[3]{};
  verts[0] = {256.0f * 0.25f, 256.0f * 0.25f, 0.5f, 1.0f, 0.25f, 0.75f};
  verts[1] = {256.0f * 0.75f, 256.0f * 0.25f, 0.5f, 1.0f, 0.75f, 0.75f};
  verts[2] = {256.0f * 0.50f, 256.0f * 0.75f, 0.5f, 1.0f, 0.50f, 0.25f};

  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 1, verts, sizeof(Vertex));
  if (!Check(hr == S_OK, "DrawPrimitiveUP")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  if (!Check(dev->up_vertex_buffer != nullptr, "up_vertex_buffer allocated")) {
    return false;
  }
  const uint32_t up_vb_handle = dev->up_vertex_buffer->handle;
  if (!Check(up_vb_handle != 0, "up_vertex_buffer handle non-zero")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  const size_t expected_bytes = AlignUp(sizeof(verts), 4);
  std::vector<uint8_t> vb_upload(expected_bytes, 0);
  size_t vb_uploaded_bytes = 0;

  const size_t stream_len = StreamBytesUsed(buf, len);
  size_t off = sizeof(aerogpu_cmd_stream_header);
  while (off + sizeof(aerogpu_cmd_hdr) <= stream_len) {
    const auto* hdr = reinterpret_cast<const aerogpu_cmd_hdr*>(buf + off);
    if (hdr->opcode == AEROGPU_CMD_UPLOAD_RESOURCE) {
      const auto* upload = reinterpret_cast<const aerogpu_cmd_upload_resource*>(hdr);
      if (upload->resource_handle == up_vb_handle) {
        const size_t payload_bytes = upload->size_bytes;
        if (!Check(upload->offset_bytes + payload_bytes <= expected_bytes, "upload_resource(UP VB) bounds")) {
          return false;
        }
        if (!Check(sizeof(*upload) + payload_bytes <= hdr->size_bytes, "upload_resource(UP VB) payload bounds")) {
          return false;
        }
        const uint8_t* payload = reinterpret_cast<const uint8_t*>(upload) + sizeof(*upload);
        std::memcpy(vb_upload.data() + upload->offset_bytes, payload, payload_bytes);
        vb_uploaded_bytes += payload_bytes;
      }
    }
    if (hdr->size_bytes == 0 || hdr->size_bytes > stream_len - off) {
      break;
    }
    off += hdr->size_bytes;
  }

  if (!Check(vb_uploaded_bytes == expected_bytes, "UP VB upload emitted")) {
    return false;
  }

  float x0 = 0.0f;
  float y0 = 0.0f;
  float z0 = 0.0f;
  float w0 = 0.0f;
  float u0 = 0.0f;
  float v0 = 0.0f;
  std::memcpy(&x0, vb_upload.data() + 0, sizeof(float));
  std::memcpy(&y0, vb_upload.data() + 4, sizeof(float));
  std::memcpy(&z0, vb_upload.data() + 8, sizeof(float));
  std::memcpy(&w0, vb_upload.data() + 12, sizeof(float));
  std::memcpy(&u0, vb_upload.data() + 16, sizeof(float));
  std::memcpy(&v0, vb_upload.data() + 20, sizeof(float));

  const float expected_x0 = ((verts[0].x + 0.5f - vp.X) / vp.Width) * 2.0f - 1.0f;
  const float expected_y0 = 1.0f - ((verts[0].y + 0.5f - vp.Y) / vp.Height) * 2.0f;
  if (!Check(std::fabs(x0 - expected_x0) < 1e-6f, "XYZRHW|TEX1(no diffuse) UP: x0 matches half-pixel convention")) {
    return false;
  }
  if (!Check(std::fabs(y0 - expected_y0) < 1e-6f, "XYZRHW|TEX1(no diffuse) UP: y0 matches half-pixel convention")) {
    return false;
  }
  if (!Check(std::fabs(z0 - verts[0].z) < 1e-6f, "XYZRHW|TEX1(no diffuse) UP: z preserved")) {
    return false;
  }
  if (!Check(std::fabs(w0 - 1.0f) < 1e-6f, "XYZRHW|TEX1(no diffuse) UP: w preserved")) {
    return false;
  }
  if (!Check(std::fabs(u0 - verts[0].u) < 1e-6f, "XYZRHW|TEX1(no diffuse) UP: u preserved")) {
    return false;
  }
  if (!Check(std::fabs(v0 - verts[0].v) < 1e-6f, "XYZRHW|TEX1(no diffuse) UP: v preserved")) {
    return false;
  }
  return ValidateStream(buf, len);
}

bool TestFvfXyzrhwTex1DrawPrimitiveUpEmulationAppliesViewportOffsetAndRhw() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetViewport != nullptr, "SetViewport must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }

  // Use a non-zero viewport offset to validate the XYZRHW conversion path
  // respects vp.X/vp.Y (not just width/height).
  D3DDDIVIEWPORTINFO vp{};
  vp.X = 10.0f;
  vp.Y = 20.0f;
  vp.Width = 128.0f;
  vp.Height = 64.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }

  // D3DFVF_XYZRHW (0x4) | D3DFVF_TEX1 (0x100).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x104u);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|TEX1)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    float rhw;
    float u;
    float v;
  };

  Vertex verts[3]{};
  verts[0] = {vp.X + vp.Width * 0.25f, vp.Y + vp.Height * 0.25f, 0.6f, 2.0f, 0.25f, 0.75f};
  verts[1] = {vp.X + vp.Width * 0.75f, vp.Y + vp.Height * 0.25f, 0.6f, 1.0f, 0.75f, 0.75f};
  verts[2] = {vp.X + vp.Width * 0.50f, vp.Y + vp.Height * 0.75f, 0.6f, 1.0f, 0.50f, 0.25f};

  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 1, verts, sizeof(Vertex));
  if (!Check(hr == S_OK, "DrawPrimitiveUP")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  if (!Check(dev->up_vertex_buffer != nullptr, "up_vertex_buffer allocated")) {
    return false;
  }
  const uint32_t up_vb_handle = dev->up_vertex_buffer->handle;
  if (!Check(up_vb_handle != 0, "up_vertex_buffer handle non-zero")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  const size_t expected_bytes = AlignUp(sizeof(verts), 4);
  std::vector<uint8_t> vb_upload(expected_bytes, 0);
  size_t vb_uploaded_bytes = 0;

  const size_t stream_len = StreamBytesUsed(buf, len);
  size_t off = sizeof(aerogpu_cmd_stream_header);
  while (off + sizeof(aerogpu_cmd_hdr) <= stream_len) {
    const auto* hdr = reinterpret_cast<const aerogpu_cmd_hdr*>(buf + off);
    if (hdr->opcode == AEROGPU_CMD_UPLOAD_RESOURCE) {
      const auto* upload = reinterpret_cast<const aerogpu_cmd_upload_resource*>(hdr);
      if (upload->resource_handle == up_vb_handle) {
        const size_t payload_bytes = upload->size_bytes;
        if (!Check(upload->offset_bytes + payload_bytes <= expected_bytes, "upload_resource(UP VB) bounds")) {
          return false;
        }
        if (!Check(sizeof(*upload) + payload_bytes <= hdr->size_bytes, "upload_resource(UP VB) payload bounds")) {
          return false;
        }
        const uint8_t* payload = reinterpret_cast<const uint8_t*>(upload) + sizeof(*upload);
        std::memcpy(vb_upload.data() + upload->offset_bytes, payload, payload_bytes);
        vb_uploaded_bytes += payload_bytes;
      }
    }
    if (hdr->size_bytes == 0 || hdr->size_bytes > stream_len - off) {
      break;
    }
    off += hdr->size_bytes;
  }

  if (!Check(vb_uploaded_bytes == expected_bytes, "UP VB upload emitted")) {
    return false;
  }

  float x0 = 0.0f;
  float y0 = 0.0f;
  float z0 = 0.0f;
  float w0 = 0.0f;
  float u0 = 0.0f;
  float v0 = 0.0f;
  std::memcpy(&x0, vb_upload.data() + 0, sizeof(float));
  std::memcpy(&y0, vb_upload.data() + 4, sizeof(float));
  std::memcpy(&z0, vb_upload.data() + 8, sizeof(float));
  std::memcpy(&w0, vb_upload.data() + 12, sizeof(float));
  std::memcpy(&u0, vb_upload.data() + 16, sizeof(float));
  std::memcpy(&v0, vb_upload.data() + 20, sizeof(float));

  const float expected_w = 1.0f / verts[0].rhw;
  const float expected_ndc_x = ((verts[0].x + 0.5f - vp.X) / vp.Width) * 2.0f - 1.0f;
  const float expected_ndc_y = 1.0f - ((verts[0].y + 0.5f - vp.Y) / vp.Height) * 2.0f;

  if (!Check(std::fabs(x0 - expected_ndc_x * expected_w) < 1e-6f, "XYZRHW|TEX1 viewport offset: x0 matches RHW clip conversion")) {
    return false;
  }
  if (!Check(std::fabs(y0 - expected_ndc_y * expected_w) < 1e-6f, "XYZRHW|TEX1 viewport offset: y0 matches RHW clip conversion")) {
    return false;
  }
  if (!Check(std::fabs(z0 - verts[0].z * expected_w) < 1e-6f, "XYZRHW|TEX1 viewport offset: z scales by w")) {
    return false;
  }
  if (!Check(std::fabs(w0 - expected_w) < 1e-6f, "XYZRHW|TEX1 viewport offset: w computed from rhw")) {
    return false;
  }
  if (!Check(std::fabs(u0 - verts[0].u) < 1e-6f, "XYZRHW|TEX1 viewport offset: u preserved")) {
    return false;
  }
  if (!Check(std::fabs(v0 - verts[0].v) < 1e-6f, "XYZRHW|TEX1 viewport offset: v preserved")) {
    return false;
  }
  return ValidateStream(buf, len);
}

bool TestFvfXyzTex1DrawPrimitiveNoScratchVbConversion() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hVb{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_vb = false;

    ~Cleanup() {
      if (has_vb && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hVb);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnLock != nullptr && cleanup.device_funcs.pfnUnlock != nullptr, "Lock/Unlock must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetStreamSource != nullptr, "SetStreamSource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitive != nullptr, "DrawPrimitive must be available")) {
    return false;
  }

  // D3DFVF_XYZ (0x2) | D3DFVF_TEX1 (0x100).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x102u);
  if (!Check(hr == S_OK, "SetFVF(XYZ|TEX1)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    float u;
    float v;
  };

  Vertex verts[3]{};
  verts[0] = {-0.5f, -0.5f, 0.5f, 0.25f, 0.75f};
  verts[1] = {0.5f, -0.5f, 0.5f, 0.75f, 0.75f};
  verts[2] = {0.0f, 0.5f, 0.5f, 0.50f, 0.25f};

  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = 0;
  create_res.format = 0;
  create_res.width = 0;
  create_res.height = 0;
  create_res.depth = 0;
  create_res.mip_levels = 1;
  create_res.usage = 0;
  create_res.pool = 0;
  create_res.size = sizeof(verts);
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr;
  create_res.pKmdAllocPrivateData = nullptr;
  create_res.KmdAllocPrivateDataSize = 0;
  create_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == S_OK, "CreateResource(vertex buffer)")) {
    return false;
  }
  cleanup.hVb = create_res.hResource;
  cleanup.has_vb = true;

  D3D9DDIARG_LOCK lock{};
  lock.hResource = create_res.hResource;
  lock.offset_bytes = 0;
  lock.size_bytes = 0;
  lock.flags = 0;
  D3DDDI_LOCKEDBOX box{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(vertex buffer)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock returns pData")) {
    return false;
  }
  std::memcpy(box.pData, verts, sizeof(verts));

  D3D9DDIARG_UNLOCK unlock{};
  unlock.hResource = create_res.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(vertex buffer)")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnSetStreamSource(create_dev.hDevice, 0, create_res.hResource, 0, sizeof(Vertex));
  if (!Check(hr == S_OK, "SetStreamSource")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnDrawPrimitive(create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 0, 1);
  if (!Check(hr == S_OK, "DrawPrimitive")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  if (!Check(dev->up_vertex_buffer == nullptr, "XYZ|TEX1 draw does not allocate scratch VB")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_DRAW) >= 1, "draw emitted")) {
    return false;
  }

  const auto* vb_res = reinterpret_cast<const Resource*>(create_res.hResource.pDrvPrivate);
  if (!Check(vb_res != nullptr, "vb pointer")) {
    return false;
  }
  const uint32_t vb_handle = vb_res->handle;
  if (!Check(vb_handle != 0, "vb handle")) {
    return false;
  }

  // Ensure we didn't upload to any internal scratch VB: XYZ fixed-function draws
  // should not require CPU conversion.
  const size_t stream_len = StreamBytesUsed(buf, len);
  size_t off = sizeof(aerogpu_cmd_stream_header);
  bool saw_upload = false;
  while (off + sizeof(aerogpu_cmd_hdr) <= stream_len) {
    const auto* hdr = reinterpret_cast<const aerogpu_cmd_hdr*>(buf + off);
    if (hdr->opcode == AEROGPU_CMD_UPLOAD_RESOURCE) {
      saw_upload = true;
      const auto* u = reinterpret_cast<const aerogpu_cmd_upload_resource*>(hdr);
      if (!Check(u->resource_handle == vb_handle, "XYZ|TEX1 draw emits no scratch UPLOAD_RESOURCE")) {
        return false;
      }
    }
    if (hdr->size_bytes == 0 || hdr->size_bytes > stream_len - off) {
      break;
    }
    off += hdr->size_bytes;
  }
  if (!Check(saw_upload, "vertex buffer upload emitted")) {
    return false;
  }

  return ValidateStream(buf, len);
}

bool TestFvfXyzTex1DrawPrimitiveUpDoesNotConvertVertices() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }

  // D3DFVF_XYZ (0x2) | D3DFVF_TEX1 (0x100).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x102u);
  if (!Check(hr == S_OK, "SetFVF(XYZ|TEX1)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    float u;
    float v;
  };

  Vertex verts[3]{};
  verts[0] = {-0.5f, -0.5f, 0.5f, 0.25f, 0.75f};
  verts[1] = {0.5f, -0.5f, 0.5f, 0.75f, 0.75f};
  verts[2] = {0.0f, 0.5f, 0.5f, 0.50f, 0.25f};

  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 1, verts, sizeof(Vertex));
  if (!Check(hr == S_OK, "DrawPrimitiveUP")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  if (!Check(dev->up_vertex_buffer != nullptr, "up_vertex_buffer allocated")) {
    return false;
  }
  const uint32_t up_vb_handle = dev->up_vertex_buffer->handle;
  if (!Check(up_vb_handle != 0, "up_vertex_buffer handle non-zero")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  const size_t expected_bytes = AlignUp(sizeof(verts), 4);
  std::vector<uint8_t> vb_upload(expected_bytes, 0);
  size_t vb_uploaded_bytes = 0;

  const size_t stream_len = StreamBytesUsed(buf, len);
  size_t off = sizeof(aerogpu_cmd_stream_header);
  while (off + sizeof(aerogpu_cmd_hdr) <= stream_len) {
    const auto* hdr = reinterpret_cast<const aerogpu_cmd_hdr*>(buf + off);
    if (hdr->opcode == AEROGPU_CMD_UPLOAD_RESOURCE) {
      const auto* upload = reinterpret_cast<const aerogpu_cmd_upload_resource*>(hdr);
      if (upload->resource_handle == up_vb_handle) {
        const size_t payload_bytes = upload->size_bytes;
        if (!Check(upload->offset_bytes + payload_bytes <= expected_bytes, "upload_resource(UP VB) bounds")) {
          return false;
        }
        if (!Check(sizeof(*upload) + payload_bytes <= hdr->size_bytes, "upload_resource(UP VB) payload bounds")) {
          return false;
        }
        const uint8_t* payload = reinterpret_cast<const uint8_t*>(upload) + sizeof(*upload);
        std::memcpy(vb_upload.data() + upload->offset_bytes, payload, payload_bytes);
        vb_uploaded_bytes += payload_bytes;
      }
    }
    if (hdr->size_bytes == 0 || hdr->size_bytes > stream_len - off) {
      break;
    }
    off += hdr->size_bytes;
  }

  if (!Check(vb_uploaded_bytes == expected_bytes, "UP VB upload emitted")) {
    return false;
  }

  float x0 = 0.0f;
  float y0 = 0.0f;
  float z0 = 0.0f;
  float u0 = 0.0f;
  float v0 = 0.0f;
  std::memcpy(&x0, vb_upload.data() + 0, sizeof(float));
  std::memcpy(&y0, vb_upload.data() + 4, sizeof(float));
  std::memcpy(&z0, vb_upload.data() + 8, sizeof(float));
  std::memcpy(&u0, vb_upload.data() + 12, sizeof(float));
  std::memcpy(&v0, vb_upload.data() + 16, sizeof(float));

  if (!Check(std::fabs(x0 - verts[0].x) < 1e-6f, "XYZ|TEX1 UP: x0 preserved (no CPU conversion)")) {
    return false;
  }
  if (!Check(std::fabs(y0 - verts[0].y) < 1e-6f, "XYZ|TEX1 UP: y0 preserved (no CPU conversion)")) {
    return false;
  }
  if (!Check(std::fabs(z0 - verts[0].z) < 1e-6f, "XYZ|TEX1 UP: z preserved")) {
    return false;
  }
  if (!Check(std::fabs(u0 - verts[0].u) < 1e-6f, "XYZ|TEX1 UP: u preserved")) {
    return false;
  }
  if (!Check(std::fabs(v0 - verts[0].v) < 1e-6f, "XYZ|TEX1 UP: v preserved")) {
    return false;
  }
  return ValidateStream(buf, len);
}

bool TestFvfXyzDiffuseDrawPrimitiveUpDoesNotConvertVertices() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3D9DDI_HVERTEXDECL hDecl{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_decl = false;

    ~Cleanup() {
      if (has_decl && device_funcs.pfnDestroyVertexDecl) {
        device_funcs.pfnDestroyVertexDecl(hDevice, hDecl);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateVertexDecl != nullptr, "CreateVertexDecl must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetVertexDecl != nullptr, "SetVertexDecl must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }

  // XYZ | DIFFUSE:
  //   POSITION float3 @0
  //   COLOR0    D3DCOLOR @12
  //   END
  const D3DVERTEXELEMENT9_COMPAT elems[] = {
      {0, 0, kD3dDeclTypeFloat3, kD3dDeclMethodDefault, kD3dDeclUsagePosition, 0},
      {0, 12, kD3dDeclTypeD3dColor, kD3dDeclMethodDefault, kD3dDeclUsageColor, 0},
      {0xFF, 0, kD3dDeclTypeUnused, 0, 0, 0}, // D3DDECL_END
  };

  D3D9DDI_HVERTEXDECL hDecl{};
  hr = cleanup.device_funcs.pfnCreateVertexDecl(
      create_dev.hDevice, elems, static_cast<uint32_t>(sizeof(elems)), &hDecl);
  if (!Check(hr == S_OK, "CreateVertexDecl(XYZ|DIFFUSE)")) {
    return false;
  }
  cleanup.hDecl = hDecl;
  cleanup.has_decl = true;

  hr = cleanup.device_funcs.pfnSetVertexDecl(create_dev.hDevice, hDecl);
  if (!Check(hr == S_OK, "SetVertexDecl(XYZ|DIFFUSE)")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  // Set non-identity transforms: WORLD0 * VIEW * PROJECTION.
  auto set_identity = [](float m[16]) {
    std::memset(m, 0, sizeof(float) * 16);
    m[0] = 1.0f;
    m[5] = 1.0f;
    m[10] = 1.0f;
    m[15] = 1.0f;
  };

  float world[16];
  float view[16];
  float proj[16];
  set_identity(world);
  set_identity(view);
  std::memset(proj, 0, sizeof(proj));

  world[12] = 1.0f;
  world[13] = -1.0f;
  world[14] = 2.0f;

  view[0] = 2.0f;
  view[5] = 3.0f;
  view[10] = 4.0f;

  proj[0] = 1.0f;
  proj[5] = 1.0f;
  proj[10] = 1.0f;
  proj[11] = 1.0f; // w = z

  if (!Check(cleanup.device_funcs.pfnSetTransform != nullptr, "SetTransform must be available")) {
    return false;
  }
  D3DMATRIX world_m{};
  D3DMATRIX view_m{};
  D3DMATRIX proj_m{};
  std::memcpy(world_m.m, world, sizeof(world));
  std::memcpy(view_m.m, view, sizeof(view));
  std::memcpy(proj_m.m, proj, sizeof(proj));
  hr = cleanup.device_funcs.pfnSetTransform(create_dev.hDevice, D3DTS_WORLD, &world_m);
  if (!Check(hr == S_OK, "SetTransform(WORLD)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTransform(create_dev.hDevice, D3DTS_VIEW, &view_m);
  if (!Check(hr == S_OK, "SetTransform(VIEW)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTransform(create_dev.hDevice, D3DTS_PROJECTION, &proj_m);
  if (!Check(hr == S_OK, "SetTransform(PROJECTION)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    uint32_t color;
  };

  constexpr uint32_t kGreen = 0xFF00FF00u;
  Vertex verts[3]{};
  verts[0] = {-0.5f, -0.5f, 0.5f, kGreen};
  verts[1] = {0.5f, -0.5f, 0.5f, kGreen};
  verts[2] = {0.0f, 0.5f, 0.5f, kGreen};

  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 1, verts, sizeof(Vertex));
  if (!Check(hr == S_OK, "DrawPrimitiveUP")) {
    return false;
  }

  if (!Check(dev->up_vertex_buffer != nullptr, "up_vertex_buffer allocated")) {
    return false;
  }
  const uint32_t up_vb_handle = dev->up_vertex_buffer->handle;
  if (!Check(up_vb_handle != 0, "up_vertex_buffer handle non-zero")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  // Expected WVP columns (transpose of row-major WVP) uploaded to c240..c243.
  float wv[16];
  float wvp[16];
  MulMat4RowMajor(world, view, wv);
  MulMat4RowMajor(wv, proj, wvp);
  float expected_cols[16] = {};
  for (int c = 0; c < 4; ++c) {
    expected_cols[c * 4 + 0] = wvp[0 * 4 + c];
    expected_cols[c * 4 + 1] = wvp[1 * 4 + c];
    expected_cols[c * 4 + 2] = wvp[2 * 4 + c];
    expected_cols[c * 4 + 3] = wvp[3 * 4 + c];
  }

  const CmdLoc upload = FindLastUploadForHandle(buf, len, up_vb_handle);
  if (!Check(upload.hdr != nullptr, "upload_resource(up_vertex_buffer) emitted")) {
    return false;
  }
  const auto* upload_cmd = reinterpret_cast<const aerogpu_cmd_upload_resource*>(upload.hdr);
  if (!Check(upload_cmd->offset_bytes == 0, "upload_resource VB offset is 0")) {
    return false;
  }
  if (!Check(upload_cmd->size_bytes == sizeof(verts), "upload_resource VB size matches original vertex data")) {
    return false;
  }

  const uint8_t* payload = reinterpret_cast<const uint8_t*>(upload_cmd) + sizeof(*upload_cmd);
  float x0 = 0.0f;
  float y0 = 0.0f;
  float z0 = 0.0f;
  uint32_t c0 = 0;
  std::memcpy(&x0, payload + 0, sizeof(float));
  std::memcpy(&y0, payload + 4, sizeof(float));
  std::memcpy(&z0, payload + 8, sizeof(float));
  std::memcpy(&c0, payload + 12, sizeof(uint32_t));

  if (!Check(std::fabs(x0 - verts[0].x) < 1e-6f, "XYZ UP: x0 preserved (no CPU conversion)")) {
    return false;
  }
  if (!Check(std::fabs(y0 - verts[0].y) < 1e-6f, "XYZ UP: y0 preserved (no CPU conversion)")) {
    return false;
  }
  if (!Check(std::fabs(z0 - verts[0].z) < 1e-6f, "XYZ UP: z0 preserved")) {
    return false;
  }
  if (!Check(c0 == kGreen, "XYZ UP: diffuse color preserved")) {
    return false;
  }

  const CmdLoc wvp_consts = FindLastVsWvpConstants(buf, len);
  if (!Check(wvp_consts.hdr != nullptr, "SET_SHADER_CONSTANTS_F uploads WVP constants")) {
    return false;
  }
  const auto* sc = reinterpret_cast<const aerogpu_cmd_set_shader_constants_f*>(wvp_consts.hdr);
  if (!Check(wvp_consts.hdr->size_bytes >= sizeof(*sc) + sizeof(expected_cols), "WVP constants payload size")) {
    return false;
  }
  const float* cols = reinterpret_cast<const float*>(reinterpret_cast<const uint8_t*>(sc) + sizeof(*sc));
  if (!Check(std::memcmp(cols, expected_cols, sizeof(expected_cols)) == 0, "WVP constants payload matches expected columns")) {
    return false;
  }

  const CmdLoc draw = FindLastOpcode(buf, len, AEROGPU_CMD_DRAW);
  if (!Check(draw.hdr != nullptr, "DRAW emitted")) {
    return false;
  }
  if (!CheckWvpConstantsUploadedBeforeDraw(buf, len, draw.offset, wvp, "XYZ UP: WVP constants uploaded")) {
    return false;
  }

  return ValidateStream(buf, len);
}

bool TestFvfXyzDiffuseDrawPrimitiveNoScratchVbConversion() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hVb{};
    D3D9DDI_HVERTEXDECL hDecl{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_vb = false;
    bool has_decl = false;

    ~Cleanup() {
      if (has_vb && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hVb);
      }
      if (has_decl && device_funcs.pfnDestroyVertexDecl) {
        device_funcs.pfnDestroyVertexDecl(hDevice, hDecl);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnCreateVertexDecl != nullptr, "CreateVertexDecl must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetVertexDecl != nullptr, "SetVertexDecl must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnLock != nullptr && cleanup.device_funcs.pfnUnlock != nullptr, "Lock/Unlock must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetStreamSource != nullptr, "SetStreamSource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitive != nullptr, "DrawPrimitive must be available")) {
    return false;
  }

  // XYZ | DIFFUSE:
  //   POSITION float3 @0
  //   COLOR0    D3DCOLOR @12
  //   END
  const D3DVERTEXELEMENT9_COMPAT elems[] = {
      {0, 0, kD3dDeclTypeFloat3, kD3dDeclMethodDefault, kD3dDeclUsagePosition, 0},
      {0, 12, kD3dDeclTypeD3dColor, kD3dDeclMethodDefault, kD3dDeclUsageColor, 0},
      {0xFF, 0, kD3dDeclTypeUnused, 0, 0, 0}, // D3DDECL_END
  };

  D3D9DDI_HVERTEXDECL hDecl{};
  hr = cleanup.device_funcs.pfnCreateVertexDecl(
      create_dev.hDevice, elems, static_cast<uint32_t>(sizeof(elems)), &hDecl);
  if (!Check(hr == S_OK, "CreateVertexDecl(XYZ|DIFFUSE)")) {
    return false;
  }
  cleanup.hDecl = hDecl;
  cleanup.has_decl = true;

  hr = cleanup.device_funcs.pfnSetVertexDecl(create_dev.hDevice, hDecl);
  if (!Check(hr == S_OK, "SetVertexDecl(XYZ|DIFFUSE)")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  // Set non-identity transforms: WORLD0 * VIEW * PROJECTION.
  auto set_identity = [](float m[16]) {
    std::memset(m, 0, sizeof(float) * 16);
    m[0] = 1.0f;
    m[5] = 1.0f;
    m[10] = 1.0f;
    m[15] = 1.0f;
  };

  float world[16];
  float view[16];
  float proj[16];
  set_identity(world);
  set_identity(view);
  std::memset(proj, 0, sizeof(proj));

  world[12] = 1.0f;
  world[13] = -1.0f;
  world[14] = 2.0f;

  view[0] = 2.0f;
  view[5] = 3.0f;
  view[10] = 4.0f;

  proj[0] = 1.0f;
  proj[5] = 1.0f;
  proj[10] = 1.0f;
  proj[11] = 1.0f; // w = z

  if (!Check(cleanup.device_funcs.pfnSetTransform != nullptr, "SetTransform must be available")) {
    return false;
  }
  D3DMATRIX world_m{};
  D3DMATRIX view_m{};
  D3DMATRIX proj_m{};
  std::memcpy(world_m.m, world, sizeof(world));
  std::memcpy(view_m.m, view, sizeof(view));
  std::memcpy(proj_m.m, proj, sizeof(proj));
  hr = cleanup.device_funcs.pfnSetTransform(create_dev.hDevice, D3DTS_WORLD, &world_m);
  if (!Check(hr == S_OK, "SetTransform(WORLD)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTransform(create_dev.hDevice, D3DTS_VIEW, &view_m);
  if (!Check(hr == S_OK, "SetTransform(VIEW)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTransform(create_dev.hDevice, D3DTS_PROJECTION, &proj_m);
  if (!Check(hr == S_OK, "SetTransform(PROJECTION)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    uint32_t color;
  };

  constexpr uint32_t kGreen = 0xFF00FF00u;
  Vertex verts[3]{};
  verts[0] = {-0.5f, -0.5f, 0.5f, kGreen};
  verts[1] = {0.5f, -0.5f, 0.5f, kGreen};
  verts[2] = {0.0f, 0.5f, 0.5f, kGreen};

  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = 0;
  create_res.format = 0;
  create_res.width = 0;
  create_res.height = 0;
  create_res.depth = 0;
  create_res.mip_levels = 1;
  create_res.usage = 0;
  create_res.pool = 0;
  create_res.size = sizeof(verts);
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr;
  create_res.pKmdAllocPrivateData = nullptr;
  create_res.KmdAllocPrivateDataSize = 0;
  create_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == S_OK, "CreateResource(vertex buffer)")) {
    return false;
  }
  cleanup.hVb = create_res.hResource;
  cleanup.has_vb = true;

  D3D9DDIARG_LOCK lock{};
  lock.hResource = create_res.hResource;
  lock.offset_bytes = 0;
  lock.size_bytes = 0;
  lock.flags = 0;
  D3DDDI_LOCKEDBOX box{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(vertex buffer)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock returns pData")) {
    return false;
  }
  std::memcpy(box.pData, verts, sizeof(verts));

  D3D9DDIARG_UNLOCK unlock{};
  unlock.hResource = create_res.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(vertex buffer)")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnSetStreamSource(create_dev.hDevice, 0, create_res.hResource, 0, sizeof(Vertex));
  if (!Check(hr == S_OK, "SetStreamSource")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnDrawPrimitive(create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 0, 1);
  if (!Check(hr == S_OK, "DrawPrimitive")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_DRAW) >= 1, "draw emitted")) {
    return false;
  }

  if (!Check(dev->up_vertex_buffer == nullptr, "XYZ draw does not allocate scratch VB")) {
    return false;
  }

  const auto* vb_res = reinterpret_cast<const Resource*>(create_res.hResource.pDrvPrivate);
  if (!Check(vb_res != nullptr, "vb pointer")) {
    return false;
  }
  const uint32_t vb_handle = vb_res->handle;
  if (!Check(vb_handle != 0, "vb handle")) {
    return false;
  }

  const CmdLoc draw_loc = FindLastOpcode(buf, len, AEROGPU_CMD_DRAW);
  if (!Check(draw_loc.hdr != nullptr, "DRAW emitted")) {
    return false;
  }

  // Expected WVP columns (transpose of row-major WVP) uploaded to c240..c243.
  float wv[16];
  float wvp[16];
  MulMat4RowMajor(world, view, wv);
  MulMat4RowMajor(wv, proj, wvp);
  float expected_cols[16] = {};
  for (int c = 0; c < 4; ++c) {
    expected_cols[c * 4 + 0] = wvp[0 * 4 + c];
    expected_cols[c * 4 + 1] = wvp[1 * 4 + c];
    expected_cols[c * 4 + 2] = wvp[2 * 4 + c];
    expected_cols[c * 4 + 3] = wvp[3 * 4 + c];
  }

  const CmdLoc wvp_consts = FindLastVsWvpConstants(buf, len);
  if (!Check(wvp_consts.hdr != nullptr, "SET_SHADER_CONSTANTS_F uploads WVP constants")) {
    return false;
  }
  const auto* sc = reinterpret_cast<const aerogpu_cmd_set_shader_constants_f*>(wvp_consts.hdr);
  if (!Check(wvp_consts.hdr->size_bytes >= sizeof(*sc) + sizeof(expected_cols), "WVP constants payload size")) {
    return false;
  }
  const float* cols = reinterpret_cast<const float*>(reinterpret_cast<const uint8_t*>(sc) + sizeof(*sc));
  if (!Check(std::memcmp(cols, expected_cols, sizeof(expected_cols)) == 0, "WVP constants payload matches expected columns")) {
    return false;
  }

  if (!CheckWvpConstantsUploadedBeforeDraw(buf, len, draw_loc.offset, wvp, "XYZ draw: WVP constants uploaded")) {
    return false;
  }

  // Ensure we didn't upload to any internal scratch VB: XYZ fixed-function draws
  // should not require CPU conversion.
  const size_t stream_len = StreamBytesUsed(buf, len);
  size_t off = sizeof(aerogpu_cmd_stream_header);
  bool saw_upload = false;
  while (off + sizeof(aerogpu_cmd_hdr) <= stream_len) {
    const auto* hdr = reinterpret_cast<const aerogpu_cmd_hdr*>(buf + off);
    if (hdr->opcode == AEROGPU_CMD_UPLOAD_RESOURCE) {
      saw_upload = true;
      const auto* u = reinterpret_cast<const aerogpu_cmd_upload_resource*>(hdr);
      if (!Check(u->resource_handle == vb_handle, "XYZ draw emits no scratch UPLOAD_RESOURCE")) {
        return false;
      }
    }
    if (hdr->size_bytes == 0 || hdr->size_bytes > stream_len - off) {
      break;
    }
    off += hdr->size_bytes;
  }
  if (!Check(saw_upload, "vertex buffer upload emitted")) {
    return false;
  }

  return ValidateStream(buf, len);
}

bool TestFvfXyzDiffuseTex1DrawPrimitiveNoScratchVbConversion() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hVb{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_vb = false;

    ~Cleanup() {
      if (has_vb && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hVb);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnLock != nullptr && cleanup.device_funcs.pfnUnlock != nullptr, "Lock/Unlock must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetStreamSource != nullptr, "SetStreamSource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitive != nullptr, "DrawPrimitive must be available")) {
    return false;
  }

  // D3DFVF_XYZ (0x2) | D3DFVF_DIFFUSE (0x40) | D3DFVF_TEX1 (0x100).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x142u);
  if (!Check(hr == S_OK, "SetFVF(XYZ|DIFFUSE|TEX1)")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  // Set non-identity transforms: WORLD0 * VIEW * PROJECTION.
  auto set_identity = [](float m[16]) {
    std::memset(m, 0, sizeof(float) * 16);
    m[0] = 1.0f;
    m[5] = 1.0f;
    m[10] = 1.0f;
    m[15] = 1.0f;
  };

  float world[16];
  float view[16];
  float proj[16];
  set_identity(world);
  set_identity(view);
  std::memset(proj, 0, sizeof(proj));

  world[12] = 1.0f;
  world[13] = -1.0f;
  world[14] = 2.0f;

  view[0] = 2.0f;
  view[5] = 3.0f;
  view[10] = 4.0f;

  proj[0] = 1.0f;
  proj[5] = 1.0f;
  proj[10] = 1.0f;
  proj[11] = 1.0f; // w = z

  if (!Check(cleanup.device_funcs.pfnSetTransform != nullptr, "SetTransform must be available")) {
    return false;
  }
  D3DMATRIX world_m{};
  D3DMATRIX view_m{};
  D3DMATRIX proj_m{};
  std::memcpy(world_m.m, world, sizeof(world));
  std::memcpy(view_m.m, view, sizeof(view));
  std::memcpy(proj_m.m, proj, sizeof(proj));
  hr = cleanup.device_funcs.pfnSetTransform(create_dev.hDevice, D3DTS_WORLD, &world_m);
  if (!Check(hr == S_OK, "SetTransform(WORLD)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTransform(create_dev.hDevice, D3DTS_VIEW, &view_m);
  if (!Check(hr == S_OK, "SetTransform(VIEW)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTransform(create_dev.hDevice, D3DTS_PROJECTION, &proj_m);
  if (!Check(hr == S_OK, "SetTransform(PROJECTION)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    uint32_t color;
    float u;
    float v;
  };

  constexpr uint32_t kGreen = 0xFF00FF00u;
  Vertex verts[3]{};
  verts[0] = {-0.5f, -0.5f, 0.5f, kGreen, 0.25f, 0.75f};
  verts[1] = {0.5f, -0.5f, 0.5f, kGreen, 0.75f, 0.75f};
  verts[2] = {0.0f, 0.5f, 0.5f, kGreen, 0.50f, 0.25f};

  // Create and fill VB.
  D3D9DDIARG_CREATERESOURCE create_vb{};
  create_vb.type = 0;
  create_vb.format = 0;
  create_vb.width = 0;
  create_vb.height = 0;
  create_vb.depth = 0;
  create_vb.mip_levels = 1;
  create_vb.usage = 0;
  create_vb.pool = 0;
  create_vb.size = sizeof(verts);
  create_vb.hResource.pDrvPrivate = nullptr;
  create_vb.pSharedHandle = nullptr;
  create_vb.pKmdAllocPrivateData = nullptr;
  create_vb.KmdAllocPrivateDataSize = 0;
  create_vb.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_vb);
  if (!Check(hr == S_OK, "CreateResource(vertex buffer)")) {
    return false;
  }
  cleanup.hVb = create_vb.hResource;
  cleanup.has_vb = true;

  D3D9DDIARG_LOCK lock{};
  lock.hResource = create_vb.hResource;
  lock.offset_bytes = 0;
  lock.size_bytes = 0;
  lock.flags = 0;
  D3DDDI_LOCKEDBOX box{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(vertex buffer)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock(VB) returns pData")) {
    return false;
  }
  std::memcpy(box.pData, verts, sizeof(verts));

  D3D9DDIARG_UNLOCK unlock{};
  unlock.hResource = create_vb.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(vertex buffer)")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnSetStreamSource(create_dev.hDevice, 0, create_vb.hResource, 0, sizeof(Vertex));
  if (!Check(hr == S_OK, "SetStreamSource")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnDrawPrimitive(create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 0, 1);
  if (!Check(hr == S_OK, "DrawPrimitive")) {
    return false;
  }

  if (!Check(dev->up_vertex_buffer == nullptr, "XYZ|DIFFUSE|TEX1 draw does not allocate scratch VB")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_DRAW) >= 1, "DRAW emitted")) {
    return false;
  }
  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_DRAW_INDEXED) == 0, "no DRAW_INDEXED emitted")) {
    return false;
  }

  const auto* vb_res = reinterpret_cast<const Resource*>(create_vb.hResource.pDrvPrivate);
  if (!Check(vb_res != nullptr, "vb pointer")) {
    return false;
  }
  const uint32_t vb_handle = vb_res->handle;
  if (!Check(vb_handle != 0, "vb handle")) {
    return false;
  }

  // Expected WVP matrix (row-major).
  float wv[16];
  float wvp[16];
  MulMat4RowMajor(world, view, wv);
  MulMat4RowMajor(wv, proj, wvp);

  // Expected WVP columns (transpose of row-major WVP) uploaded to c240..c243.
  float expected_cols[16] = {};
  for (int c = 0; c < 4; ++c) {
    expected_cols[c * 4 + 0] = wvp[0 * 4 + c];
    expected_cols[c * 4 + 1] = wvp[1 * 4 + c];
    expected_cols[c * 4 + 2] = wvp[2 * 4 + c];
    expected_cols[c * 4 + 3] = wvp[3 * 4 + c];
  }

  const CmdLoc wvp_consts = FindLastVsWvpConstants(buf, len);
  if (!Check(wvp_consts.hdr != nullptr, "SET_SHADER_CONSTANTS_F uploads WVP constants")) {
    return false;
  }
  const auto* sc = reinterpret_cast<const aerogpu_cmd_set_shader_constants_f*>(wvp_consts.hdr);
  if (!Check(wvp_consts.hdr->size_bytes >= sizeof(*sc) + sizeof(expected_cols), "WVP constants payload size")) {
    return false;
  }
  const float* cols = reinterpret_cast<const float*>(reinterpret_cast<const uint8_t*>(sc) + sizeof(*sc));
  if (!Check(std::memcmp(cols, expected_cols, sizeof(expected_cols)) == 0, "WVP constants payload matches expected columns")) {
    return false;
  }

  const CmdLoc draw_loc = FindLastOpcode(buf, len, AEROGPU_CMD_DRAW);
  if (!Check(draw_loc.hdr != nullptr, "DRAW emitted")) {
    return false;
  }
  if (!CheckWvpConstantsUploadedBeforeDraw(buf, len, draw_loc.offset, wvp, "XYZ|DIFFUSE|TEX1 draw: WVP constants uploaded")) {
    return false;
  }

  // Ensure we upload only the user-provided VB and not a scratch VB conversion.
  bool saw_vb_upload = false;
  const size_t stream_len = StreamBytesUsed(buf, len);
  size_t off = sizeof(aerogpu_cmd_stream_header);
  while (off + sizeof(aerogpu_cmd_hdr) <= stream_len) {
    const auto* hdr = reinterpret_cast<const aerogpu_cmd_hdr*>(buf + off);
    if (hdr->opcode == AEROGPU_CMD_UPLOAD_RESOURCE) {
      const auto* u = reinterpret_cast<const aerogpu_cmd_upload_resource*>(hdr);
      if (u->resource_handle == vb_handle) {
        saw_vb_upload = true;
      } else {
        return Check(false, "XYZ|DIFFUSE|TEX1 draw emits no scratch UPLOAD_RESOURCE");
      }
    }
    if (hdr->size_bytes == 0 || hdr->size_bytes > stream_len - off) {
      break;
    }
    off += hdr->size_bytes;
  }
  if (!Check(saw_vb_upload, "vertex buffer upload emitted")) {
    return false;
  }

  const CmdLoc vb_upload = FindLastUploadForHandle(buf, len, vb_handle);
  if (!Check(vb_upload.hdr != nullptr, "upload_resource(VB) emitted")) {
    return false;
  }
  const auto* vb_upload_cmd = reinterpret_cast<const aerogpu_cmd_upload_resource*>(vb_upload.hdr);
  if (!Check(vb_upload_cmd->offset_bytes == 0, "upload_resource VB offset is 0")) {
    return false;
  }
  if (!Check(vb_upload_cmd->size_bytes == sizeof(verts), "upload_resource VB size matches original vertex data")) {
    return false;
  }

  const uint8_t* payload = reinterpret_cast<const uint8_t*>(vb_upload_cmd) + sizeof(*vb_upload_cmd);
  float x0 = 0.0f;
  float y0 = 0.0f;
  float z0 = 0.0f;
  uint32_t c0 = 0;
  float u0 = 0.0f;
  float v0_out = 0.0f;
  std::memcpy(&x0, payload + 0, sizeof(float));
  std::memcpy(&y0, payload + 4, sizeof(float));
  std::memcpy(&z0, payload + 8, sizeof(float));
  std::memcpy(&c0, payload + 12, sizeof(uint32_t));
  std::memcpy(&u0, payload + 16, sizeof(float));
  std::memcpy(&v0_out, payload + 20, sizeof(float));

  if (!Check(std::fabs(x0 - verts[0].x) < 1e-6f, "XYZ|DIFFUSE|TEX1 draw: x0 preserved (no CPU conversion)")) {
    return false;
  }
  if (!Check(std::fabs(y0 - verts[0].y) < 1e-6f, "XYZ|DIFFUSE|TEX1 draw: y0 preserved (no CPU conversion)")) {
    return false;
  }
  if (!Check(std::fabs(z0 - verts[0].z) < 1e-6f, "XYZ|DIFFUSE|TEX1 draw: z0 preserved")) {
    return false;
  }
  if (!Check(c0 == kGreen, "XYZ|DIFFUSE|TEX1 draw: diffuse color preserved")) {
    return false;
  }
  if (!Check(std::fabs(u0 - verts[0].u) < 1e-6f, "XYZ|DIFFUSE|TEX1 draw: u preserved")) {
    return false;
  }
  if (!Check(std::fabs(v0_out - verts[0].v) < 1e-6f, "XYZ|DIFFUSE|TEX1 draw: v preserved")) {
    return false;
  }

  return ValidateStream(buf, len);
}

bool TestFixedfuncStrideTooSmallFailsAndDoesNotEmitDraw() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hVb{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_vb = false;

    ~Cleanup() {
      if (has_vb && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hVb);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnLock != nullptr && cleanup.device_funcs.pfnUnlock != nullptr, "Lock/Unlock must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetStreamSource != nullptr, "SetStreamSource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitive != nullptr, "DrawPrimitive must be available")) {
    return false;
  }

  // D3DFVF_XYZRHW (0x4) | D3DFVF_DIFFUSE (0x40) | D3DFVF_TEX1 (0x100).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x144u);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|DIFFUSE|TEX1)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    float rhw;
    uint32_t color;
    float u;
    float v;
  };

  constexpr uint32_t kGreen = 0xFF00FF00u;
  Vertex verts[3]{};
  verts[0] = {256.0f * 0.25f, 256.0f * 0.25f, 0.5f, 1.0f, kGreen, 0.25f, 0.75f};
  verts[1] = {256.0f * 0.75f, 256.0f * 0.25f, 0.5f, 1.0f, kGreen, 0.75f, 0.75f};
  verts[2] = {256.0f * 0.50f, 256.0f * 0.75f, 0.5f, 1.0f, kGreen, 0.50f, 0.25f};

  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = 0;
  create_res.format = 0;
  create_res.width = 0;
  create_res.height = 0;
  create_res.depth = 0;
  create_res.mip_levels = 1;
  create_res.usage = 0;
  create_res.pool = 0;
  create_res.size = sizeof(verts);
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr;
  create_res.pKmdAllocPrivateData = nullptr;
  create_res.KmdAllocPrivateDataSize = 0;
  create_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == S_OK, "CreateResource(vertex buffer)")) {
    return false;
  }
  cleanup.hVb = create_res.hResource;
  cleanup.has_vb = true;

  D3D9DDIARG_LOCK lock{};
  lock.hResource = create_res.hResource;
  lock.offset_bytes = 0;
  lock.size_bytes = 0;
  lock.flags = 0;
  D3DDDI_LOCKEDBOX box{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(vertex buffer)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock returns pData")) {
    return false;
  }
  std::memcpy(box.pData, verts, sizeof(verts));

  D3D9DDIARG_UNLOCK unlock{};
  unlock.hResource = create_res.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(vertex buffer)")) {
    return false;
  }

  // Stride is smaller than required for XYZRHW|DIFFUSE|TEX1 (expects >= 28 bytes).
  hr = cleanup.device_funcs.pfnSetStreamSource(create_dev.hDevice, 0, create_res.hResource, 0, 20u);
  if (!Check(hr == S_OK, "SetStreamSource(stride too small)")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnDrawPrimitive(create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 0, 1);
  if (!Check(hr == kD3DErrInvalidCall, "DrawPrimitive rejects stride-too-small fixedfunc draw")) {
    return false;
  }

  // Also validate the stride checks for the TEX1-only fixed-function variants.
  // - XYZRHW|TEX1 requires >= 24 bytes (float4 + float2).
  // - XYZ|TEX1 requires >= 20 bytes (float3 + float2).

  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x104u);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|TEX1)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetStreamSource(create_dev.hDevice, 0, create_res.hResource, 0, 20u);
  if (!Check(hr == S_OK, "SetStreamSource(stride too small, XYZRHW|TEX1)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnDrawPrimitive(create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 0, 1);
  if (!Check(hr == kD3DErrInvalidCall, "DrawPrimitive rejects stride-too-small XYZRHW|TEX1")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x102u);
  if (!Check(hr == S_OK, "SetFVF(XYZ|TEX1)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetStreamSource(create_dev.hDevice, 0, create_res.hResource, 0, 16u);
  if (!Check(hr == S_OK, "SetStreamSource(stride too small, XYZ|TEX1)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnDrawPrimitive(create_dev.hDevice, D3DDDIPT_TRIANGLELIST, 0, 1);
  if (!Check(hr == kD3DErrInvalidCall, "DrawPrimitive rejects stride-too-small XYZ|TEX1")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_DRAW) == 0, "stride-too-small emits no DRAW")) {
    return false;
  }
  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_DRAW_INDEXED) == 0, "stride-too-small emits no DRAW_INDEXED")) {
    return false;
  }

  const auto* vb_res = reinterpret_cast<const Resource*>(create_res.hResource.pDrvPrivate);
  const uint32_t vb_handle = vb_res ? vb_res->handle : 0;
  if (!Check(vb_handle != 0, "vb handle")) {
    return false;
  }

  const size_t stream_len = StreamBytesUsed(buf, len);
  size_t off = sizeof(aerogpu_cmd_stream_header);
  while (off + sizeof(aerogpu_cmd_hdr) <= stream_len) {
    const auto* hdr = reinterpret_cast<const aerogpu_cmd_hdr*>(buf + off);
    if (hdr->opcode == AEROGPU_CMD_UPLOAD_RESOURCE) {
      const auto* u = reinterpret_cast<const aerogpu_cmd_upload_resource*>(hdr);
      if (!Check(u->resource_handle == vb_handle, "stride-too-small emits no scratch UPLOAD_RESOURCE")) {
        return false;
      }
    }
    if (hdr->size_bytes == 0 || hdr->size_bytes > stream_len - off) {
      break;
    }
    off += hdr->size_bytes;
  }

  return ValidateStream(buf, len);
}

bool TestFixedfuncIndexedStrideTooSmallFailsAndDoesNotEmitDraw() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hVb{};
    D3DDDI_HRESOURCE hIb{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_vb = false;
    bool has_ib = false;

    ~Cleanup() {
      if (has_ib && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hIb);
      }
      if (has_vb && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hVb);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnLock != nullptr && cleanup.device_funcs.pfnUnlock != nullptr, "Lock/Unlock must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetStreamSource != nullptr, "SetStreamSource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetIndices != nullptr, "SetIndices must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawIndexedPrimitive != nullptr, "DrawIndexedPrimitive must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawIndexedPrimitive2 != nullptr, "DrawIndexedPrimitive2 must be available")) {
    return false;
  }

  struct VertexXyzrhwDiffuseTex1 {
    float x;
    float y;
    float z;
    float rhw;
    uint32_t color;
    float u;
    float v;
  };
  constexpr uint32_t kGreen = 0xFF00FF00u;
  VertexXyzrhwDiffuseTex1 verts_rhw[3]{};
  verts_rhw[0] = {256.0f * 0.25f, 256.0f * 0.25f, 0.5f, 1.0f, kGreen, 0.25f, 0.75f};
  verts_rhw[1] = {256.0f * 0.75f, 256.0f * 0.25f, 0.5f, 1.0f, kGreen, 0.75f, 0.75f};
  verts_rhw[2] = {256.0f * 0.50f, 256.0f * 0.75f, 0.5f, 1.0f, kGreen, 0.50f, 0.25f};

  struct VertexXyzTex1 {
    float x;
    float y;
    float z;
    float u;
    float v;
  };
  VertexXyzTex1 verts_xyz[3]{};
  verts_xyz[0] = {-0.5f, -0.5f, 0.5f, 0.25f, 0.75f};
  verts_xyz[1] = {0.5f, -0.5f, 0.5f, 0.75f, 0.75f};
  verts_xyz[2] = {0.0f, 0.5f, 0.5f, 0.50f, 0.25f};

  const uint16_t indices[3] = {0, 1, 2};

  // Create and fill VB.
  D3D9DDIARG_CREATERESOURCE create_vb{};
  create_vb.type = 0;
  create_vb.format = 0;
  create_vb.width = 0;
  create_vb.height = 0;
  create_vb.depth = 0;
  create_vb.mip_levels = 1;
  create_vb.usage = 0;
  create_vb.pool = 0;
  create_vb.size = sizeof(verts_rhw);
  create_vb.hResource.pDrvPrivate = nullptr;
  create_vb.pSharedHandle = nullptr;
  create_vb.pKmdAllocPrivateData = nullptr;
  create_vb.KmdAllocPrivateDataSize = 0;
  create_vb.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_vb);
  if (!Check(hr == S_OK, "CreateResource(vertex buffer)")) {
    return false;
  }
  cleanup.hVb = create_vb.hResource;
  cleanup.has_vb = true;

  D3D9DDIARG_LOCK lock{};
  lock.hResource = create_vb.hResource;
  lock.offset_bytes = 0;
  lock.size_bytes = 0;
  lock.flags = 0;
  D3DDDI_LOCKEDBOX box{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(vertex buffer)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock(VB) returns pData")) {
    return false;
  }
  std::memcpy(box.pData, verts_rhw, sizeof(verts_rhw));

  D3D9DDIARG_UNLOCK unlock{};
  unlock.hResource = create_vb.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(vertex buffer)")) {
    return false;
  }

  // Create and fill IB.
  D3D9DDIARG_CREATERESOURCE create_ib{};
  create_ib.type = 0;
  create_ib.format = 0;
  create_ib.width = 0;
  create_ib.height = 0;
  create_ib.depth = 0;
  create_ib.mip_levels = 1;
  create_ib.usage = 0;
  create_ib.pool = 0;
  create_ib.size = sizeof(indices);
  create_ib.hResource.pDrvPrivate = nullptr;
  create_ib.pSharedHandle = nullptr;
  create_ib.pKmdAllocPrivateData = nullptr;
  create_ib.KmdAllocPrivateDataSize = 0;
  create_ib.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_ib);
  if (!Check(hr == S_OK, "CreateResource(index buffer)")) {
    return false;
  }
  cleanup.hIb = create_ib.hResource;
  cleanup.has_ib = true;

  lock.hResource = create_ib.hResource;
  lock.offset_bytes = 0;
  lock.size_bytes = 0;
  lock.flags = 0;
  std::memset(&box, 0, sizeof(box));
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(index buffer)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock(IB) returns pData")) {
    return false;
  }
  std::memcpy(box.pData, indices, sizeof(indices));

  unlock.hResource = create_ib.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(index buffer)")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnSetIndices(create_dev.hDevice, create_ib.hResource, kD3dFmtIndex16, 0);
  if (!Check(hr == S_OK, "SetIndices")) {
    return false;
  }

  // Indexed draws with fixed-function emulation must validate stream stride on
  // both the resource-backed and UP paths.
  struct IndexedStrideCase {
    uint32_t fvf = 0;
    const char* name = nullptr;
    uint32_t bad_stride = 0;
    const void* up_verts = nullptr;
  };
  IndexedStrideCase cases[] = {
      {0x144u, "XYZRHW|DIFFUSE|TEX1", 20u, verts_rhw},  // min 28
      {0x104u, "XYZRHW|TEX1", 20u, verts_rhw},          // min 24
      {0x102u, "XYZ|TEX1", 16u, verts_xyz},             // min 20
  };

  for (const auto& c : cases) {
    hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, c.fvf);
    if (!Check(hr == S_OK, "SetFVF")) {
      return false;
    }

    hr = cleanup.device_funcs.pfnSetStreamSource(create_dev.hDevice, 0, create_vb.hResource, 0, c.bad_stride);
    if (!Check(hr == S_OK, "SetStreamSource(stride too small)")) {
      return false;
    }

    hr = cleanup.device_funcs.pfnDrawIndexedPrimitive(create_dev.hDevice,
                                                      D3DDDIPT_TRIANGLELIST,
                                                      /*base_vertex=*/0,
                                                      /*min_index=*/0,
                                                      /*num_vertices=*/3,
                                                      /*start_index=*/0,
                                                      /*primitive_count=*/1);
    if (!Check(hr == kD3DErrInvalidCall, c.name)) {
      return false;
    }

    D3DDDIARG_DRAWINDEXEDPRIMITIVE2 draw{};
    draw.PrimitiveType = D3DDDIPT_TRIANGLELIST;
    draw.PrimitiveCount = 1;
    draw.MinIndex = 0;
    draw.NumVertices = 3;
    draw.pIndexData = indices;
    draw.IndexDataFormat = kD3dFmtIndex16;
    draw.pVertexStreamZeroData = c.up_verts;
    draw.VertexStreamZeroStride = c.bad_stride;

    hr = cleanup.device_funcs.pfnDrawIndexedPrimitive2(create_dev.hDevice, &draw);
    if (!Check(hr == kD3DErrInvalidCall, "DrawIndexedPrimitive2 rejects stride-too-small fixedfunc draw")) {
      return false;
    }
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  if (!Check(dev->up_vertex_buffer == nullptr, "stride-too-small indexed draw does not allocate scratch VB")) {
    return false;
  }
  if (!Check(dev->up_index_buffer == nullptr, "stride-too-small indexed draw does not allocate scratch IB")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_DRAW) == 0, "stride-too-small emits no DRAW")) {
    return false;
  }
  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_DRAW_INDEXED) == 0, "stride-too-small emits no DRAW_INDEXED")) {
    return false;
  }

  const auto* vb_res = reinterpret_cast<const Resource*>(create_vb.hResource.pDrvPrivate);
  const auto* ib_res = reinterpret_cast<const Resource*>(create_ib.hResource.pDrvPrivate);
  const uint32_t vb_handle = vb_res ? vb_res->handle : 0;
  const uint32_t ib_handle = ib_res ? ib_res->handle : 0;
  if (!Check(vb_handle != 0, "vb handle")) {
    return false;
  }
  if (!Check(ib_handle != 0, "ib handle")) {
    return false;
  }

  const size_t stream_len = StreamBytesUsed(buf, len);
  size_t off = sizeof(aerogpu_cmd_stream_header);
  while (off + sizeof(aerogpu_cmd_hdr) <= stream_len) {
    const auto* hdr = reinterpret_cast<const aerogpu_cmd_hdr*>(buf + off);
    if (hdr->opcode == AEROGPU_CMD_UPLOAD_RESOURCE) {
      const auto* u = reinterpret_cast<const aerogpu_cmd_upload_resource*>(hdr);
      if (!Check(u->resource_handle == vb_handle || u->resource_handle == ib_handle,
                 "stride-too-small indexed draw emits no scratch UPLOAD_RESOURCE")) {
        return false;
      }
    }
    if (hdr->size_bytes == 0 || hdr->size_bytes > stream_len - off) {
      break;
    }
    off += hdr->size_bytes;
  }

  return ValidateStream(buf, len);
}

bool TestDrawRectPatchReusesTessellationCache() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hVb{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_vb = false;

    ~Cleanup() {
      if (has_vb && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hVb);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnLock != nullptr && cleanup.device_funcs.pfnUnlock != nullptr, "Lock/Unlock must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetStreamSource != nullptr, "SetStreamSource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawRectPatch != nullptr, "DrawRectPatch must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDeletePatch != nullptr, "DeletePatch must be available")) {
    return false;
  }

  D3DDDIVIEWPORTINFO vp{};
  vp.X = 0.0f;
  vp.Y = 0.0f;
  vp.Width = 256.0f;
  vp.Height = 256.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }

  // D3DFVF_XYZRHW (0x4) | D3DFVF_DIFFUSE (0x40).
  //
  // Include TEXCOORDSIZE bits for an unused texcoord set to validate the patch
  // handle cache ignores garbage per-set texcoord size bits.
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x40044u);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|DIFFUSE)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    float rhw;
    uint32_t color;
  };

  Vertex cps[16]{};
  constexpr uint32_t kGreen = 0xFF00FF00u;
  for (uint32_t y = 0; y < 4; ++y) {
    for (uint32_t x = 0; x < 4; ++x) {
      const uint32_t idx = y * 4 + x;
      cps[idx].x = 64.0f + 32.0f * static_cast<float>(x);
      cps[idx].y = 64.0f + 32.0f * static_cast<float>(y);
      cps[idx].z = 0.5f;
      cps[idx].rhw = 1.0f;
      cps[idx].color = kGreen;
    }
  }

  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = 0;
  create_res.format = 0;
  create_res.width = 0;
  create_res.height = 0;
  create_res.depth = 0;
  create_res.mip_levels = 1;
  create_res.usage = 0;
  create_res.pool = 0;
  create_res.size = sizeof(cps);
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr;
  create_res.pKmdAllocPrivateData = nullptr;
  create_res.KmdAllocPrivateDataSize = 0;
  create_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == S_OK, "CreateResource(control point VB)")) {
    return false;
  }
  cleanup.hVb = create_res.hResource;
  cleanup.has_vb = true;

  D3D9DDIARG_LOCK lock{};
  lock.hResource = create_res.hResource;
  lock.offset_bytes = 0;
  lock.size_bytes = 0;
  lock.flags = 0;
  D3DDDI_LOCKEDBOX box{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(control point VB)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock returns pData")) {
    return false;
  }
  std::memcpy(box.pData, cps, sizeof(cps));

  D3D9DDIARG_UNLOCK unlock{};
  unlock.hResource = create_res.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(control point VB)")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnSetStreamSource(create_dev.hDevice, 0, create_res.hResource, 0, sizeof(Vertex));
  if (!Check(hr == S_OK, "SetStreamSource(control point VB)")) {
    return false;
  }

  float segs[4] = {2.0f, 2.0f, 2.0f, 2.0f};
  D3DRECTPATCH_INFO info{};
  info.StartVertexOffset = 0;
  info.NumVertices = 16;
  info.Basis = D3DBASIS_BEZIER;
  info.Degree = D3DDEGREE_CUBIC;

  D3DDDIARG_DRAWRECTPATCH draw{};
  draw.Handle = 1;
  draw.pNumSegs = segs;
  draw.pRectPatchInfo = &info;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  const uint64_t tessellate_base = dev->patch_tessellate_count;
  const uint64_t cache_hit_base = dev->patch_cache_hit_count;
  if (!Check(dev->patch_cache.empty(), "patch cache starts empty")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnDrawRectPatch(create_dev.hDevice, &draw);
  if (!Check(hr == S_OK, "DrawRectPatch(first)")) {
    return false;
  }
  if (!Check(dev->patch_tessellate_count == tessellate_base + 1, "DrawRectPatch(first) tessellates once")) {
    return false;
  }
  if (!Check(dev->patch_cache.size() == 1, "DrawRectPatch inserts cache entry")) {
    return false;
  }

  // Clear the garbage TEXCOORDSIZE bits; the patch cache should still hit.
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x44u);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|DIFFUSE) (second)")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnDrawRectPatch(create_dev.hDevice, &draw);
  if (!Check(hr == S_OK, "DrawRectPatch(second)")) {
    return false;
  }
  if (!Check(dev->patch_tessellate_count == tessellate_base + 1, "DrawRectPatch(second) reuses tessellation")) {
    return false;
  }
  if (!Check(dev->patch_cache_hit_count >= cache_hit_base + 1, "DrawRectPatch(second) increments cache hit count")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnDeletePatch(create_dev.hDevice, 1);
  if (!Check(hr == S_OK, "DeletePatch")) {
    return false;
  }
  if (!Check(dev->patch_cache.empty(), "DeletePatch evicts cache entry")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnDrawRectPatch(create_dev.hDevice, &draw);
  if (!Check(hr == S_OK, "DrawRectPatch(after DeletePatch)")) {
    return false;
  }
  if (!Check(dev->patch_tessellate_count == tessellate_base + 2, "DrawRectPatch(after DeletePatch) re-tessellates")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();
  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_DRAW_INDEXED) >= 3,
             "DrawRectPatch emits indexed draws")) {
    return false;
  }
  return ValidateStream(buf, len);
}

bool TestDrawTriPatchReusesTessellationCache() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hVb{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_vb = false;

    ~Cleanup() {
      if (has_vb && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hVb);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnLock != nullptr && cleanup.device_funcs.pfnUnlock != nullptr, "Lock/Unlock must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetStreamSource != nullptr, "SetStreamSource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawTriPatch != nullptr, "DrawTriPatch must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDeletePatch != nullptr, "DeletePatch must be available")) {
    return false;
  }

  D3DDDIVIEWPORTINFO vp{};
  vp.X = 0.0f;
  vp.Y = 0.0f;
  vp.Width = 256.0f;
  vp.Height = 256.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }

  // D3DFVF_XYZRHW (0x4) | D3DFVF_DIFFUSE (0x40).
  //
  // Include TEXCOORDSIZE bits for an unused texcoord set to validate the patch
  // handle cache ignores garbage per-set texcoord size bits.
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x40044u);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|DIFFUSE)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    float rhw;
    uint32_t color;
  };

  Vertex cps[10]{};
  constexpr uint32_t kYellow = 0xFFFFFF00u;
  for (uint32_t i = 0; i < 10; ++i) {
    const float t = static_cast<float>(i) / 9.0f;
    cps[i].x = 64.0f + 64.0f * t;
    cps[i].y = 64.0f + 32.0f * t;
    cps[i].z = 0.5f;
    cps[i].rhw = 1.0f;
    cps[i].color = kYellow;
  }

  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = 0;
  create_res.format = 0;
  create_res.width = 0;
  create_res.height = 0;
  create_res.depth = 0;
  create_res.mip_levels = 1;
  create_res.usage = 0;
  create_res.pool = 0;
  create_res.size = sizeof(cps);
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr;
  create_res.pKmdAllocPrivateData = nullptr;
  create_res.KmdAllocPrivateDataSize = 0;
  create_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == S_OK, "CreateResource(control point VB)")) {
    return false;
  }
  cleanup.hVb = create_res.hResource;
  cleanup.has_vb = true;

  D3D9DDIARG_LOCK lock{};
  lock.hResource = create_res.hResource;
  lock.offset_bytes = 0;
  lock.size_bytes = 0;
  lock.flags = 0;
  D3DDDI_LOCKEDBOX box{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(control point VB)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock returns pData")) {
    return false;
  }
  std::memcpy(box.pData, cps, sizeof(cps));

  D3D9DDIARG_UNLOCK unlock{};
  unlock.hResource = create_res.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(control point VB)")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnSetStreamSource(create_dev.hDevice, 0, create_res.hResource, 0, sizeof(Vertex));
  if (!Check(hr == S_OK, "SetStreamSource(control point VB)")) {
    return false;
  }

  float segs[3] = {2.0f, 2.0f, 2.0f};
  D3DTRIPATCH_INFO info{};
  info.StartVertexOffset = 0;
  info.NumVertices = 10;
  info.Basis = D3DBASIS_BEZIER;
  info.Degree = D3DDEGREE_CUBIC;

  D3DDDIARG_DRAWTRIPATCH draw{};
  draw.Handle = 1;
  draw.pNumSegs = segs;
  draw.pTriPatchInfo = &info;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  const uint64_t tessellate_base = dev->patch_tessellate_count;
  const uint64_t cache_hit_base = dev->patch_cache_hit_count;
  if (!Check(dev->patch_cache.empty(), "patch cache starts empty")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnDrawTriPatch(create_dev.hDevice, &draw);
  if (!Check(hr == S_OK, "DrawTriPatch(first)")) {
    return false;
  }
  if (!Check(dev->patch_tessellate_count == tessellate_base + 1, "DrawTriPatch(first) tessellates once")) {
    return false;
  }
  if (!Check(dev->patch_cache.size() == 1, "DrawTriPatch inserts cache entry")) {
    return false;
  }

  // Clear the garbage TEXCOORDSIZE bits; the patch cache should still hit.
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x44u);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|DIFFUSE) (second)")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnDrawTriPatch(create_dev.hDevice, &draw);
  if (!Check(hr == S_OK, "DrawTriPatch(second)")) {
    return false;
  }
  if (!Check(dev->patch_tessellate_count == tessellate_base + 1, "DrawTriPatch(second) reuses tessellation")) {
    return false;
  }
  if (!Check(dev->patch_cache_hit_count >= cache_hit_base + 1, "DrawTriPatch(second) increments cache hit count")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnDeletePatch(create_dev.hDevice, 1);
  if (!Check(hr == S_OK, "DeletePatch")) {
    return false;
  }
  if (!Check(dev->patch_cache.empty(), "DeletePatch evicts cache entry")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnDrawTriPatch(create_dev.hDevice, &draw);
  if (!Check(hr == S_OK, "DrawTriPatch(after DeletePatch)")) {
    return false;
  }
  if (!Check(dev->patch_tessellate_count == tessellate_base + 2, "DrawTriPatch(after DeletePatch) re-tessellates")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();
  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_DRAW_INDEXED) >= 3,
             "DrawTriPatch emits indexed draws")) {
    return false;
  }
  return ValidateStream(buf, len);
}

bool TestPatchCacheDistinguishesTexcoordSizeBetweenFloat1AndFloat2() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hVb{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_vb = false;
    ~Cleanup() {
      if (has_vb && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hVb);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetStreamSource != nullptr, "SetStreamSource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawRectPatch != nullptr, "DrawRectPatch must be available")) {
    return false;
  }

  D3DDDIVIEWPORTINFO vp{};
  vp.X = 0.0f;
  vp.Y = 0.0f;
  vp.Width = 256.0f;
  vp.Height = 256.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }

  struct VertexTex2 {
    float x;
    float y;
    float z;
    float rhw;
    uint32_t color;
    float u;
    float v;
  };

  VertexTex2 cps[16]{};
  for (uint32_t y = 0; y < 4; ++y) {
    for (uint32_t x = 0; x < 4; ++x) {
      const uint32_t idx = y * 4 + x;
      cps[idx].x = 64.0f + 32.0f * static_cast<float>(x);
      cps[idx].y = 64.0f + 32.0f * static_cast<float>(y);
      cps[idx].z = 0.5f;
      cps[idx].rhw = 1.0f;
      cps[idx].color = 0xFFFFFFFFu;
      cps[idx].u = 0.0f;
      cps[idx].v = static_cast<float>(idx);
    }
  }

  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = 0;
  create_res.format = 0;
  create_res.width = 0;
  create_res.height = 0;
  create_res.depth = 0;
  create_res.mip_levels = 1;
  create_res.usage = 0;
  create_res.pool = 0;
  create_res.size = sizeof(cps);
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr;
  create_res.pKmdAllocPrivateData = nullptr;
  create_res.KmdAllocPrivateDataSize = 0;
  create_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == S_OK, "CreateResource(control point VB)")) {
    return false;
  }
  cleanup.hVb = create_res.hResource;
  cleanup.has_vb = true;

  D3D9DDIARG_LOCK lock{};
  lock.hResource = create_res.hResource;
  lock.offset_bytes = 0;
  lock.size_bytes = 0;
  lock.flags = 0;
  D3DDDI_LOCKEDBOX box{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(VB)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock returns pData")) {
    return false;
  }
  std::memcpy(box.pData, cps, sizeof(cps));

  D3D9DDIARG_UNLOCK unlock{};
  unlock.hResource = create_res.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(VB)")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnSetStreamSource(create_dev.hDevice, 0, create_res.hResource, 0, sizeof(VertexTex2));
  if (!Check(hr == S_OK, "SetStreamSource")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  float segs[4] = {1.0f, 1.0f, 1.0f, 1.0f};
  D3DRECTPATCH_INFO info{};
  info.StartVertexOffset = 0;
  info.NumVertices = 16;
  info.Basis = D3DBASIS_BEZIER;
  info.Degree = D3DDEGREE_CUBIC;
  D3DDDIARG_DRAWRECTPATCH draw{};
  draw.Handle = 1;
  draw.pNumSegs = segs;
  draw.pRectPatchInfo = &info;

  const uint64_t tessellate_base = dev->patch_tessellate_count;
  const uint64_t cache_hit_base = dev->patch_cache_hit_count;
  if (!Check(dev->patch_cache.empty(), "patch cache starts empty")) {
    return false;
  }

  // First draw: TEXCOORDSIZE1(0) (float1). Uses u only; v is ignored.
  constexpr uint32_t kTexcoordSize1Tex0 = 3u << 16u; // float1
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, kD3dFvfXyzRhw | kD3dFvfDiffuse | kD3dFvfTex1 | kTexcoordSize1Tex0);
  if (!Check(hr == S_OK, "SetFVF(float1 texcoord)")) {
    return false;
  }
  dev->cmd.reset();
  hr = cleanup.device_funcs.pfnDrawRectPatch(create_dev.hDevice, &draw);
  if (!Check(hr == S_OK, "DrawRectPatch(float1)")) {
    return false;
  }
  if (!Check(dev->patch_tessellate_count == tessellate_base + 1, "DrawRectPatch(float1) tessellates once")) {
    return false;
  }

  // Second draw: default TEXCOORDSIZE2(0) (float2). Must NOT reuse the float1
  // tessellation result, even though the stride/control point bytes are the same.
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, kD3dFvfXyzRhw | kD3dFvfDiffuse | kD3dFvfTex1);
  if (!Check(hr == S_OK, "SetFVF(float2 texcoord)")) {
    return false;
  }
  dev->cmd.reset();
  hr = cleanup.device_funcs.pfnDrawRectPatch(create_dev.hDevice, &draw);
  if (!Check(hr == S_OK, "DrawRectPatch(float2)")) {
    return false;
  }
  if (!Check(dev->patch_tessellate_count == tessellate_base + 2, "DrawRectPatch(float2) does not reuse float1 tessellation")) {
    return false;
  }
  if (!Check(dev->patch_cache_hit_count == cache_hit_base, "DrawRectPatch(float2) does not increment cache hit count")) {
    return false;
  }

  if (!Check(dev->up_vertex_buffer != nullptr, "up_vertex_buffer allocated")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  const CmdLoc draw_loc = FindLastOpcode(buf, len, AEROGPU_CMD_DRAW_INDEXED);
  if (!Check(draw_loc.hdr != nullptr, "draw_indexed emitted")) {
    return false;
  }

  const uint32_t up_vb_handle = dev->up_vertex_buffer->handle;
  const CmdLoc vb_upload = FindLastUploadResourceBefore(buf, len, draw_loc.offset, up_vb_handle);
  if (!Check(vb_upload.hdr != nullptr, "upload_resource targeting UP VB emitted before draw")) {
    return false;
  }
  const auto* upload_cmd = reinterpret_cast<const aerogpu_cmd_upload_resource*>(vb_upload.hdr);
  if (!Check(upload_cmd->size_bytes == 4u * sizeof(VertexTex2), "UP VB upload size matches tessellated float2 vertices")) {
    return false;
  }

  // For segs_u=segs_v=1, vertices are (u,v)=(0,0),(1,0),(0,1),(1,1), mapping to
  // control points cp[0],cp[3],cp[12],cp[15] respectively.
  const uint8_t* payload = reinterpret_cast<const uint8_t*>(upload_cmd) + sizeof(*upload_cmd);
  float v0 = 0.0f;
  float v1 = 0.0f;
  float v2 = 0.0f;
  float v3 = 0.0f;
  std::memcpy(&v0, payload + 24, sizeof(float));
  std::memcpy(&v1, payload + sizeof(VertexTex2) + 24, sizeof(float));
  std::memcpy(&v2, payload + 2 * sizeof(VertexTex2) + 24, sizeof(float));
  std::memcpy(&v3, payload + 3 * sizeof(VertexTex2) + 24, sizeof(float));

  if (!Check(std::fabs(v0 - cps[0].v) < 1e-6f, "patch cache float2: v0 preserved")) {
    return false;
  }
  if (!Check(std::fabs(v1 - cps[3].v) < 1e-6f, "patch cache float2: v1 preserved")) {
    return false;
  }
  if (!Check(std::fabs(v2 - cps[12].v) < 1e-6f, "patch cache float2: v2 preserved")) {
    return false;
  }
  return Check(std::fabs(v3 - cps[15].v) < 1e-6f, "patch cache float2: v3 preserved");
}

bool TestDrawIndexedPrimitiveUpEmitsIndexBufferCommands() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetViewport != nullptr, "SetViewport must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawIndexedPrimitive2 != nullptr, "DrawIndexedPrimitive2 must be available")) {
    return false;
  }

  D3DDDIVIEWPORTINFO vp{};
  vp.X = 0.0f;
  vp.Y = 0.0f;
  vp.Width = 256.0f;
  vp.Height = 256.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }

  // D3DFVF_XYZRHW (0x4) | D3DFVF_DIFFUSE (0x40).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x44u);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|DIFFUSE)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    float rhw;
    uint32_t color;
  };

  constexpr uint32_t kRed = 0xFFFF0000u;
  Vertex verts[3]{};
  verts[0] = {256.0f * 0.25f, 256.0f * 0.25f, 0.5f, 1.0f, kRed};
  verts[1] = {256.0f * 0.75f, 256.0f * 0.25f, 0.5f, 1.0f, kRed};
  verts[2] = {256.0f * 0.50f, 256.0f * 0.75f, 0.5f, 1.0f, kRed};

  const uint16_t indices[3] = {0, 1, 2};

  D3DDDIARG_DRAWINDEXEDPRIMITIVE2 draw{};
  draw.PrimitiveType = D3DDDIPT_TRIANGLELIST;
  draw.PrimitiveCount = 1;
  draw.MinIndex = 0;
  draw.NumVertices = 3;
  draw.pIndexData = indices;
  draw.IndexDataFormat = kD3dFmtIndex16;
  draw.pVertexStreamZeroData = verts;
  draw.VertexStreamZeroStride = sizeof(Vertex);

  hr = cleanup.device_funcs.pfnDrawIndexedPrimitive2(create_dev.hDevice, &draw);
  if (!Check(hr == S_OK, "DrawIndexedPrimitive2")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  if (!Check(dev->up_vertex_buffer != nullptr, "up_vertex_buffer allocated")) {
    return false;
  }
  if (!Check(dev->up_index_buffer != nullptr, "up_index_buffer allocated")) {
    return false;
  }
  const aerogpu_handle_t vb_handle = dev->up_vertex_buffer->handle;
  const aerogpu_handle_t ib_handle = dev->up_index_buffer->handle;
  if (!Check(vb_handle != 0, "up_vertex_buffer handle non-zero")) {
    return false;
  }
  if (!Check(ib_handle != 0, "up_index_buffer handle non-zero")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  size_t vb_uploaded_bytes = 0;
  size_t ib_uploaded_bytes = 0;
  const size_t expected_vb_bytes = AlignUp(sizeof(verts), 4);
  std::vector<uint8_t> vb_upload(expected_vb_bytes, 0);
  // Buffer uploads are padded to 4-byte alignment so host-side WebGPU copies
  // remain valid for non-4-byte-sized payloads (e.g. 3x u16 indices).
  const size_t expected_ib_bytes = AlignUp(sizeof(indices), 4);
  std::vector<uint8_t> ib_upload(expected_ib_bytes, 0);
  bool saw_set_ib = false;

  size_t offset = sizeof(aerogpu_cmd_stream_header);
  while (offset + sizeof(aerogpu_cmd_hdr) <= len) {
    const auto* hdr = reinterpret_cast<const aerogpu_cmd_hdr*>(buf + offset);
    if (hdr->opcode == AEROGPU_CMD_UPLOAD_RESOURCE) {
      const auto* upload = reinterpret_cast<const aerogpu_cmd_upload_resource*>(hdr);
      if (upload->resource_handle == vb_handle) {
        vb_uploaded_bytes += upload->size_bytes;
        const size_t payload_bytes = upload->size_bytes;
        if (!Check(upload->offset_bytes + payload_bytes <= expected_vb_bytes, "upload_resource(VB) bounds")) {
          return false;
        }
        if (!Check(sizeof(*upload) + payload_bytes <= hdr->size_bytes, "upload_resource(VB) payload bounds")) {
          return false;
        }
        const uint8_t* payload = reinterpret_cast<const uint8_t*>(upload) + sizeof(*upload);
        std::memcpy(vb_upload.data() + upload->offset_bytes, payload, payload_bytes);
      }
      if (upload->resource_handle == ib_handle) {
        ib_uploaded_bytes += upload->size_bytes;
        const size_t payload_bytes = upload->size_bytes;
        if (!Check(upload->offset_bytes + payload_bytes <= expected_ib_bytes, "upload_resource(IB) bounds")) {
          return false;
        }
        if (!Check(sizeof(*upload) + payload_bytes <= hdr->size_bytes, "upload_resource(IB) payload bounds")) {
          return false;
        }

        const uint8_t* payload = reinterpret_cast<const uint8_t*>(upload) + sizeof(*upload);
        std::memcpy(ib_upload.data() + upload->offset_bytes, payload, payload_bytes);
      }
    } else if (hdr->opcode == AEROGPU_CMD_SET_INDEX_BUFFER) {
      const auto* set_ib = reinterpret_cast<const aerogpu_cmd_set_index_buffer*>(hdr);
      if (set_ib->buffer == ib_handle) {
        saw_set_ib = true;
        if (!Check(set_ib->format == AEROGPU_INDEX_FORMAT_UINT16, "set_index_buffer format")) {
          return false;
        }
        if (!Check(set_ib->offset_bytes == 0, "set_index_buffer offset")) {
          return false;
        }
      }
    }

    if (hdr->size_bytes == 0 || hdr->size_bytes > len - offset) {
      break;
    }
    offset += hdr->size_bytes;
  }

  if (!Check(vb_uploaded_bytes == expected_vb_bytes, "VB upload emitted")) {
    return false;
  }
  if (!Check(ib_uploaded_bytes == expected_ib_bytes, "IB upload emitted (aligned)")) {
    return false;
  }
  if (!Check(saw_set_ib, "SET_INDEX_BUFFER emitted for UP IB")) {
    return false;
  }

  if (!Check(std::memcmp(ib_upload.data(), indices, sizeof(indices)) == 0, "IB upload payload matches indices")) {
    return false;
  }
  for (size_t i = sizeof(indices); i < expected_ib_bytes; ++i) {
    if (!Check(ib_upload[i] == 0, "IB upload padding is zero")) {
      return false;
    }
  }

  float x0 = 0.0f;
  float y0 = 0.0f;
  float z0 = 0.0f;
  float w0 = 0.0f;
  uint32_t c0 = 0;
  std::memcpy(&x0, vb_upload.data() + 0, sizeof(float));
  std::memcpy(&y0, vb_upload.data() + 4, sizeof(float));
  std::memcpy(&z0, vb_upload.data() + 8, sizeof(float));
  std::memcpy(&w0, vb_upload.data() + 12, sizeof(float));
  std::memcpy(&c0, vb_upload.data() + 16, sizeof(uint32_t));

  const float expected_x0 = ((verts[0].x + 0.5f - vp.X) / vp.Width) * 2.0f - 1.0f;
  const float expected_y0 = 1.0f - ((verts[0].y + 0.5f - vp.Y) / vp.Height) * 2.0f;
  if (!Check(std::fabs(x0 - expected_x0) < 1e-6f, "DrawIndexedPrimitive2: x0 matches half-pixel convention")) {
    return false;
  }
  if (!Check(std::fabs(y0 - expected_y0) < 1e-6f, "DrawIndexedPrimitive2: y0 matches half-pixel convention")) {
    return false;
  }
  if (!Check(std::fabs(z0 - verts[0].z) < 1e-6f, "DrawIndexedPrimitive2: z preserved")) {
    return false;
  }
  if (!Check(std::fabs(w0 - 1.0f) < 1e-6f, "DrawIndexedPrimitive2: w preserved")) {
    return false;
  }
  if (!Check(c0 == kRed, "DrawIndexedPrimitive2: diffuse color preserved")) {
    return false;
  }

  const CmdLoc draw_loc = FindLastOpcode(buf, len, AEROGPU_CMD_DRAW_INDEXED);
  if (!Check(draw_loc.hdr != nullptr, "DRAW_INDEXED emitted")) {
    return false;
  }
  const auto* draw_cmd = reinterpret_cast<const aerogpu_cmd_draw_indexed*>(draw_loc.hdr);
  if (!Check(draw_cmd->index_count == 3, "DRAW_INDEXED index_count")) {
    return false;
  }
  if (!Check(draw_cmd->first_index == 0, "DRAW_INDEXED first_index")) {
    return false;
  }
  return Check(draw_cmd->base_vertex == 0, "DRAW_INDEXED base_vertex");
}

bool TestFvfXyzrhwDiffuseDrawIndexedPrimitiveEmulationConvertsVertices() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hVb{};
    D3DDDI_HRESOURCE hIb{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_vb = false;
    bool has_ib = false;

    ~Cleanup() {
      if (has_ib && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hIb);
      }
      if (has_vb && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hVb);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnLock != nullptr && cleanup.device_funcs.pfnUnlock != nullptr, "Lock/Unlock must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetStreamSource != nullptr, "SetStreamSource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetIndices != nullptr, "SetIndices must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawIndexedPrimitive != nullptr, "DrawIndexedPrimitive must be available")) {
    return false;
  }

  D3DDDIVIEWPORTINFO vp{};
  vp.X = 0.0f;
  vp.Y = 0.0f;
  vp.Width = 256.0f;
  vp.Height = 256.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }

  // D3DFVF_XYZRHW (0x4) | D3DFVF_DIFFUSE (0x40).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x44u);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|DIFFUSE)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    float rhw;
    uint32_t color;
  };

  constexpr uint32_t kBlue = 0xFF0000FFu;
  Vertex verts[3]{};
  verts[0] = {256.0f * 0.25f, 256.0f * 0.25f, 0.5f, 1.0f, kBlue};
  verts[1] = {256.0f * 0.75f, 256.0f * 0.25f, 0.5f, 1.0f, kBlue};
  verts[2] = {256.0f * 0.50f, 256.0f * 0.75f, 0.5f, 1.0f, kBlue};

  const uint16_t indices[3] = {0, 1, 2};

  // Create and fill VB.
  D3D9DDIARG_CREATERESOURCE create_vb{};
  create_vb.type = 0;
  create_vb.format = 0;
  create_vb.width = 0;
  create_vb.height = 0;
  create_vb.depth = 0;
  create_vb.mip_levels = 1;
  create_vb.usage = 0;
  create_vb.pool = 0;
  create_vb.size = sizeof(verts);
  create_vb.hResource.pDrvPrivate = nullptr;
  create_vb.pSharedHandle = nullptr;
  create_vb.pKmdAllocPrivateData = nullptr;
  create_vb.KmdAllocPrivateDataSize = 0;
  create_vb.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_vb);
  if (!Check(hr == S_OK, "CreateResource(vertex buffer)")) {
    return false;
  }
  cleanup.hVb = create_vb.hResource;
  cleanup.has_vb = true;

  D3D9DDIARG_LOCK lock{};
  lock.hResource = create_vb.hResource;
  lock.offset_bytes = 0;
  lock.size_bytes = 0;
  lock.flags = 0;
  D3DDDI_LOCKEDBOX box{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(vertex buffer)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock(VB) returns pData")) {
    return false;
  }
  std::memcpy(box.pData, verts, sizeof(verts));

  D3D9DDIARG_UNLOCK unlock{};
  unlock.hResource = create_vb.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(vertex buffer)")) {
    return false;
  }

  // Create and fill IB.
  D3D9DDIARG_CREATERESOURCE create_ib{};
  create_ib.type = 0;
  create_ib.format = 0;
  create_ib.width = 0;
  create_ib.height = 0;
  create_ib.depth = 0;
  create_ib.mip_levels = 1;
  create_ib.usage = 0;
  create_ib.pool = 0;
  create_ib.size = sizeof(indices);
  create_ib.hResource.pDrvPrivate = nullptr;
  create_ib.pSharedHandle = nullptr;
  create_ib.pKmdAllocPrivateData = nullptr;
  create_ib.KmdAllocPrivateDataSize = 0;
  create_ib.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_ib);
  if (!Check(hr == S_OK, "CreateResource(index buffer)")) {
    return false;
  }
  cleanup.hIb = create_ib.hResource;
  cleanup.has_ib = true;

  lock.hResource = create_ib.hResource;
  lock.offset_bytes = 0;
  lock.size_bytes = 0;
  lock.flags = 0;
  std::memset(&box, 0, sizeof(box));
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(index buffer)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock(IB) returns pData")) {
    return false;
  }
  std::memcpy(box.pData, indices, sizeof(indices));

  unlock.hResource = create_ib.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(index buffer)")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnSetStreamSource(create_dev.hDevice, 0, create_vb.hResource, 0, sizeof(Vertex));
  if (!Check(hr == S_OK, "SetStreamSource")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnSetIndices(create_dev.hDevice, create_ib.hResource, kD3dFmtIndex16, 0);
  if (!Check(hr == S_OK, "SetIndices")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnDrawIndexedPrimitive(create_dev.hDevice,
                                                    D3DDDIPT_TRIANGLELIST,
                                                    /*base_vertex=*/0,
                                                    /*min_index=*/0,
                                                    /*num_vertices=*/3,
                                                    /*start_index=*/0,
                                                    /*primitive_count=*/1);
  if (!Check(hr == S_OK, "DrawIndexedPrimitive")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  if (!Check(dev->up_vertex_buffer != nullptr, "up_vertex_buffer allocated")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  const CmdLoc upload = FindLastOpcode(buf, len, AEROGPU_CMD_UPLOAD_RESOURCE);
  if (!Check(upload.hdr != nullptr, "upload_resource emitted")) {
    return false;
  }
  const auto* upload_cmd = reinterpret_cast<const aerogpu_cmd_upload_resource*>(upload.hdr);
  if (!Check(upload_cmd->resource_handle == dev->up_vertex_buffer->handle, "upload_resource targets UP VB")) {
    return false;
  }
  if (!Check(upload_cmd->size_bytes == sizeof(verts), "upload_resource size matches expanded vertex data")) {
    return false;
  }

  const uint8_t* payload = reinterpret_cast<const uint8_t*>(upload_cmd) + sizeof(*upload_cmd);
  float x0 = 0.0f;
  float y0 = 0.0f;
  float z0 = 0.0f;
  float w0 = 0.0f;
  uint32_t c0 = 0;
  std::memcpy(&x0, payload + 0, sizeof(float));
  std::memcpy(&y0, payload + 4, sizeof(float));
  std::memcpy(&z0, payload + 8, sizeof(float));
  std::memcpy(&w0, payload + 12, sizeof(float));
  std::memcpy(&c0, payload + 16, sizeof(uint32_t));

  const float expected_x0 = ((verts[0].x + 0.5f - vp.X) / vp.Width) * 2.0f - 1.0f;
  const float expected_y0 = 1.0f - ((verts[0].y + 0.5f - vp.Y) / vp.Height) * 2.0f;
  if (!Check(std::fabs(x0 - expected_x0) < 1e-6f, "DrawIndexedPrimitive: x0 matches half-pixel convention")) {
    return false;
  }
  if (!Check(std::fabs(y0 - expected_y0) < 1e-6f, "DrawIndexedPrimitive: y0 matches half-pixel convention")) {
    return false;
  }
  if (!Check(std::fabs(z0 - verts[0].z) < 1e-6f, "DrawIndexedPrimitive: z preserved")) {
    return false;
  }
  if (!Check(std::fabs(w0 - 1.0f) < 1e-6f, "DrawIndexedPrimitive: w preserved")) {
    return false;
  }
  return Check(c0 == kBlue, "DrawIndexedPrimitive: diffuse color preserved");
}

bool TestFvfXyzrhwDiffuseTex1DrawIndexedPrimitiveEmulationConvertsVertices() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hVb{};
    D3DDDI_HRESOURCE hIb{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_vb = false;
    bool has_ib = false;

    ~Cleanup() {
      if (has_ib && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hIb);
      }
      if (has_vb && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hVb);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnLock != nullptr && cleanup.device_funcs.pfnUnlock != nullptr, "Lock/Unlock must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetStreamSource != nullptr, "SetStreamSource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetIndices != nullptr, "SetIndices must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawIndexedPrimitive != nullptr, "DrawIndexedPrimitive must be available")) {
    return false;
  }

  D3DDDIVIEWPORTINFO vp{};
  vp.X = 0.0f;
  vp.Y = 0.0f;
  vp.Width = 256.0f;
  vp.Height = 256.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }

  // D3DFVF_XYZRHW (0x4) | D3DFVF_DIFFUSE (0x40) | D3DFVF_TEX1 (0x100).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x144u);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|DIFFUSE|TEX1)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    float rhw;
    uint32_t color;
    float u;
    float v;
  };

  constexpr uint32_t kGreen = 0xFF00FF00u;
  Vertex verts[3]{};
  verts[0] = {256.0f * 0.25f, 256.0f * 0.25f, 0.5f, 1.0f, kGreen, 0.25f, 0.75f};
  verts[1] = {256.0f * 0.75f, 256.0f * 0.25f, 0.5f, 1.0f, kGreen, 0.75f, 0.75f};
  verts[2] = {256.0f * 0.50f, 256.0f * 0.75f, 0.5f, 1.0f, kGreen, 0.50f, 0.25f};

  const uint16_t indices[3] = {0, 1, 2};

  // Create and fill VB.
  D3D9DDIARG_CREATERESOURCE create_vb{};
  create_vb.type = 0;
  create_vb.format = 0;
  create_vb.width = 0;
  create_vb.height = 0;
  create_vb.depth = 0;
  create_vb.mip_levels = 1;
  create_vb.usage = 0;
  create_vb.pool = 0;
  create_vb.size = sizeof(verts);
  create_vb.hResource.pDrvPrivate = nullptr;
  create_vb.pSharedHandle = nullptr;
  create_vb.pKmdAllocPrivateData = nullptr;
  create_vb.KmdAllocPrivateDataSize = 0;
  create_vb.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_vb);
  if (!Check(hr == S_OK, "CreateResource(vertex buffer)")) {
    return false;
  }
  cleanup.hVb = create_vb.hResource;
  cleanup.has_vb = true;

  D3D9DDIARG_LOCK lock{};
  lock.hResource = create_vb.hResource;
  lock.offset_bytes = 0;
  lock.size_bytes = 0;
  lock.flags = 0;
  D3DDDI_LOCKEDBOX box{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(vertex buffer)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock(VB) returns pData")) {
    return false;
  }
  std::memcpy(box.pData, verts, sizeof(verts));

  D3D9DDIARG_UNLOCK unlock{};
  unlock.hResource = create_vb.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(vertex buffer)")) {
    return false;
  }

  // Create and fill IB.
  D3D9DDIARG_CREATERESOURCE create_ib{};
  create_ib.type = 0;
  create_ib.format = 0;
  create_ib.width = 0;
  create_ib.height = 0;
  create_ib.depth = 0;
  create_ib.mip_levels = 1;
  create_ib.usage = 0;
  create_ib.pool = 0;
  create_ib.size = sizeof(indices);
  create_ib.hResource.pDrvPrivate = nullptr;
  create_ib.pSharedHandle = nullptr;
  create_ib.pKmdAllocPrivateData = nullptr;
  create_ib.KmdAllocPrivateDataSize = 0;
  create_ib.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_ib);
  if (!Check(hr == S_OK, "CreateResource(index buffer)")) {
    return false;
  }
  cleanup.hIb = create_ib.hResource;
  cleanup.has_ib = true;

  lock.hResource = create_ib.hResource;
  lock.offset_bytes = 0;
  lock.size_bytes = 0;
  lock.flags = 0;
  std::memset(&box, 0, sizeof(box));
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(index buffer)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock(IB) returns pData")) {
    return false;
  }
  std::memcpy(box.pData, indices, sizeof(indices));

  unlock.hResource = create_ib.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(index buffer)")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnSetStreamSource(create_dev.hDevice, 0, create_vb.hResource, 0, sizeof(Vertex));
  if (!Check(hr == S_OK, "SetStreamSource")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnSetIndices(create_dev.hDevice, create_ib.hResource, kD3dFmtIndex16, 0);
  if (!Check(hr == S_OK, "SetIndices")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnDrawIndexedPrimitive(create_dev.hDevice,
                                                    D3DDDIPT_TRIANGLELIST,
                                                    /*base_vertex=*/0,
                                                    /*min_index=*/0,
                                                    /*num_vertices=*/3,
                                                    /*start_index=*/0,
                                                    /*primitive_count=*/1);
  if (!Check(hr == S_OK, "DrawIndexedPrimitive")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  if (!Check(dev->up_vertex_buffer != nullptr, "up_vertex_buffer allocated")) {
    return false;
  }
  const uint32_t up_vb_handle = dev->up_vertex_buffer->handle;
  if (!Check(up_vb_handle != 0, "up_vertex_buffer handle non-zero")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  const size_t expected_bytes = AlignUp(sizeof(verts), 4);
  std::vector<uint8_t> vb_upload(expected_bytes, 0);
  size_t vb_uploaded_bytes = 0;

  const size_t stream_len = StreamBytesUsed(buf, len);
  size_t off = sizeof(aerogpu_cmd_stream_header);
  while (off + sizeof(aerogpu_cmd_hdr) <= stream_len) {
    const auto* hdr = reinterpret_cast<const aerogpu_cmd_hdr*>(buf + off);
    if (hdr->opcode == AEROGPU_CMD_UPLOAD_RESOURCE) {
      const auto* upload = reinterpret_cast<const aerogpu_cmd_upload_resource*>(hdr);
      if (upload->resource_handle == up_vb_handle) {
        const size_t payload_bytes = upload->size_bytes;
        if (!Check(upload->offset_bytes + payload_bytes <= expected_bytes, "upload_resource(UP VB) bounds")) {
          return false;
        }
        if (!Check(sizeof(*upload) + payload_bytes <= hdr->size_bytes, "upload_resource(UP VB) payload bounds")) {
          return false;
        }
        const uint8_t* payload = reinterpret_cast<const uint8_t*>(upload) + sizeof(*upload);
        std::memcpy(vb_upload.data() + upload->offset_bytes, payload, payload_bytes);
        vb_uploaded_bytes += payload_bytes;
      }
    }
    if (hdr->size_bytes == 0 || hdr->size_bytes > stream_len - off) {
      break;
    }
    off += hdr->size_bytes;
  }

  if (!Check(vb_uploaded_bytes == expected_bytes, "expanded vertex upload emitted")) {
    return false;
  }

  float x0 = 0.0f;
  float y0 = 0.0f;
  float z0 = 0.0f;
  float w0 = 0.0f;
  uint32_t c0 = 0;
  float u0 = 0.0f;
  float v0 = 0.0f;
  std::memcpy(&x0, vb_upload.data() + 0, sizeof(float));
  std::memcpy(&y0, vb_upload.data() + 4, sizeof(float));
  std::memcpy(&z0, vb_upload.data() + 8, sizeof(float));
  std::memcpy(&w0, vb_upload.data() + 12, sizeof(float));
  std::memcpy(&c0, vb_upload.data() + 16, sizeof(uint32_t));
  std::memcpy(&u0, vb_upload.data() + 20, sizeof(float));
  std::memcpy(&v0, vb_upload.data() + 24, sizeof(float));

  const float expected_x0 = ((verts[0].x + 0.5f - vp.X) / vp.Width) * 2.0f - 1.0f;
  const float expected_y0 = 1.0f - ((verts[0].y + 0.5f - vp.Y) / vp.Height) * 2.0f;
  if (!Check(std::fabs(x0 - expected_x0) < 1e-6f, "DrawIndexedPrimitive TEX1: x0 matches half-pixel convention")) {
    return false;
  }
  if (!Check(std::fabs(y0 - expected_y0) < 1e-6f, "DrawIndexedPrimitive TEX1: y0 matches half-pixel convention")) {
    return false;
  }
  if (!Check(std::fabs(z0 - verts[0].z) < 1e-6f, "DrawIndexedPrimitive TEX1: z preserved")) {
    return false;
  }
  if (!Check(std::fabs(w0 - 1.0f) < 1e-6f, "DrawIndexedPrimitive TEX1: w preserved")) {
    return false;
  }
  if (!Check(c0 == kGreen, "DrawIndexedPrimitive TEX1: diffuse color preserved")) {
    return false;
  }
  if (!Check(std::fabs(u0 - verts[0].u) < 1e-6f, "DrawIndexedPrimitive TEX1: u preserved")) {
    return false;
  }
  if (!Check(std::fabs(v0 - verts[0].v) < 1e-6f, "DrawIndexedPrimitive TEX1: v preserved")) {
    return false;
  }
  return ValidateStream(buf, len);
}

bool TestFvfXyzrhwTex1DrawIndexedPrimitiveEmulationConvertsVertices() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hVb{};
    D3DDDI_HRESOURCE hIb{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_vb = false;
    bool has_ib = false;

    ~Cleanup() {
      if (has_ib && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hIb);
      }
      if (has_vb && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hVb);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnLock != nullptr && cleanup.device_funcs.pfnUnlock != nullptr, "Lock/Unlock must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetStreamSource != nullptr, "SetStreamSource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetIndices != nullptr, "SetIndices must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawIndexedPrimitive != nullptr, "DrawIndexedPrimitive must be available")) {
    return false;
  }

  D3DDDIVIEWPORTINFO vp{};
  vp.X = 0.0f;
  vp.Y = 0.0f;
  vp.Width = 256.0f;
  vp.Height = 256.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }

  // D3DFVF_XYZRHW (0x4) | D3DFVF_TEX1 (0x100).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x104u);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|TEX1)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    float rhw;
    float u;
    float v;
  };

  Vertex verts[3]{};
  verts[0] = {256.0f * 0.25f, 256.0f * 0.25f, 0.5f, 1.0f, 0.25f, 0.75f};
  verts[1] = {256.0f * 0.75f, 256.0f * 0.25f, 0.5f, 1.0f, 0.75f, 0.75f};
  verts[2] = {256.0f * 0.50f, 256.0f * 0.75f, 0.5f, 1.0f, 0.50f, 0.25f};

  const uint16_t indices[3] = {0, 1, 2};

  // Create and fill VB.
  D3D9DDIARG_CREATERESOURCE create_vb{};
  create_vb.type = 0;
  create_vb.format = 0;
  create_vb.width = 0;
  create_vb.height = 0;
  create_vb.depth = 0;
  create_vb.mip_levels = 1;
  create_vb.usage = 0;
  create_vb.pool = 0;
  create_vb.size = sizeof(verts);
  create_vb.hResource.pDrvPrivate = nullptr;
  create_vb.pSharedHandle = nullptr;
  create_vb.pKmdAllocPrivateData = nullptr;
  create_vb.KmdAllocPrivateDataSize = 0;
  create_vb.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_vb);
  if (!Check(hr == S_OK, "CreateResource(vertex buffer)")) {
    return false;
  }
  cleanup.hVb = create_vb.hResource;
  cleanup.has_vb = true;

  D3D9DDIARG_LOCK lock{};
  lock.hResource = create_vb.hResource;
  lock.offset_bytes = 0;
  lock.size_bytes = 0;
  lock.flags = 0;
  D3DDDI_LOCKEDBOX box{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(vertex buffer)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock(VB) returns pData")) {
    return false;
  }
  std::memcpy(box.pData, verts, sizeof(verts));

  D3D9DDIARG_UNLOCK unlock{};
  unlock.hResource = create_vb.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(vertex buffer)")) {
    return false;
  }

  // Create and fill IB.
  D3D9DDIARG_CREATERESOURCE create_ib{};
  create_ib.type = 0;
  create_ib.format = 0;
  create_ib.width = 0;
  create_ib.height = 0;
  create_ib.depth = 0;
  create_ib.mip_levels = 1;
  create_ib.usage = 0;
  create_ib.pool = 0;
  create_ib.size = sizeof(indices);
  create_ib.hResource.pDrvPrivate = nullptr;
  create_ib.pSharedHandle = nullptr;
  create_ib.pKmdAllocPrivateData = nullptr;
  create_ib.KmdAllocPrivateDataSize = 0;
  create_ib.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_ib);
  if (!Check(hr == S_OK, "CreateResource(index buffer)")) {
    return false;
  }
  cleanup.hIb = create_ib.hResource;
  cleanup.has_ib = true;

  lock.hResource = create_ib.hResource;
  lock.offset_bytes = 0;
  lock.size_bytes = 0;
  lock.flags = 0;
  std::memset(&box, 0, sizeof(box));
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(index buffer)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock(IB) returns pData")) {
    return false;
  }
  std::memcpy(box.pData, indices, sizeof(indices));

  unlock.hResource = create_ib.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(index buffer)")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnSetStreamSource(create_dev.hDevice, 0, create_vb.hResource, 0, sizeof(Vertex));
  if (!Check(hr == S_OK, "SetStreamSource")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnSetIndices(create_dev.hDevice, create_ib.hResource, kD3dFmtIndex16, 0);
  if (!Check(hr == S_OK, "SetIndices")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnDrawIndexedPrimitive(create_dev.hDevice,
                                                    D3DDDIPT_TRIANGLELIST,
                                                    /*base_vertex=*/0,
                                                    /*min_index=*/0,
                                                    /*num_vertices=*/3,
                                                    /*start_index=*/0,
                                                    /*primitive_count=*/1);
  if (!Check(hr == S_OK, "DrawIndexedPrimitive")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  if (!Check(dev->up_vertex_buffer != nullptr, "up_vertex_buffer allocated")) {
    return false;
  }
  const uint32_t up_vb_handle = dev->up_vertex_buffer->handle;
  if (!Check(up_vb_handle != 0, "up_vertex_buffer handle non-zero")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  const size_t expected_bytes = AlignUp(sizeof(verts), 4);
  std::vector<uint8_t> vb_upload(expected_bytes, 0);
  size_t vb_uploaded_bytes = 0;

  const size_t stream_len = StreamBytesUsed(buf, len);
  size_t off = sizeof(aerogpu_cmd_stream_header);
  while (off + sizeof(aerogpu_cmd_hdr) <= stream_len) {
    const auto* hdr = reinterpret_cast<const aerogpu_cmd_hdr*>(buf + off);
    if (hdr->opcode == AEROGPU_CMD_UPLOAD_RESOURCE) {
      const auto* upload = reinterpret_cast<const aerogpu_cmd_upload_resource*>(hdr);
      if (upload->resource_handle == up_vb_handle) {
        const size_t payload_bytes = upload->size_bytes;
        if (!Check(upload->offset_bytes + payload_bytes <= expected_bytes, "upload_resource(UP VB) bounds")) {
          return false;
        }
        if (!Check(sizeof(*upload) + payload_bytes <= hdr->size_bytes, "upload_resource(UP VB) payload bounds")) {
          return false;
        }
        const uint8_t* payload = reinterpret_cast<const uint8_t*>(upload) + sizeof(*upload);
        std::memcpy(vb_upload.data() + upload->offset_bytes, payload, payload_bytes);
        vb_uploaded_bytes += payload_bytes;
      }
    }
    if (hdr->size_bytes == 0 || hdr->size_bytes > stream_len - off) {
      break;
    }
    off += hdr->size_bytes;
  }

  if (!Check(vb_uploaded_bytes == expected_bytes, "expanded vertex upload emitted")) {
    return false;
  }

  float x0 = 0.0f;
  float y0 = 0.0f;
  float z0 = 0.0f;
  float w0 = 0.0f;
  float u0 = 0.0f;
  float v0 = 0.0f;
  std::memcpy(&x0, vb_upload.data() + 0, sizeof(float));
  std::memcpy(&y0, vb_upload.data() + 4, sizeof(float));
  std::memcpy(&z0, vb_upload.data() + 8, sizeof(float));
  std::memcpy(&w0, vb_upload.data() + 12, sizeof(float));
  std::memcpy(&u0, vb_upload.data() + 16, sizeof(float));
  std::memcpy(&v0, vb_upload.data() + 20, sizeof(float));

  const float expected_x0 = ((verts[0].x + 0.5f - vp.X) / vp.Width) * 2.0f - 1.0f;
  const float expected_y0 = 1.0f - ((verts[0].y + 0.5f - vp.Y) / vp.Height) * 2.0f;
  if (!Check(std::fabs(x0 - expected_x0) < 1e-6f, "DrawIndexedPrimitive TEX1(no diffuse): x0 matches half-pixel convention")) {
    return false;
  }
  if (!Check(std::fabs(y0 - expected_y0) < 1e-6f, "DrawIndexedPrimitive TEX1(no diffuse): y0 matches half-pixel convention")) {
    return false;
  }
  if (!Check(std::fabs(z0 - verts[0].z) < 1e-6f, "DrawIndexedPrimitive TEX1(no diffuse): z preserved")) {
    return false;
  }
  if (!Check(std::fabs(w0 - 1.0f) < 1e-6f, "DrawIndexedPrimitive TEX1(no diffuse): w preserved")) {
    return false;
  }
  if (!Check(std::fabs(u0 - verts[0].u) < 1e-6f, "DrawIndexedPrimitive TEX1(no diffuse): u preserved")) {
    return false;
  }
  if (!Check(std::fabs(v0 - verts[0].v) < 1e-6f, "DrawIndexedPrimitive TEX1(no diffuse): v preserved")) {
    return false;
  }
  return ValidateStream(buf, len);
}

bool TestFvfXyzrhwDiffuseTex1DrawIndexedPrimitiveEmulationAppliesBaseVertexAndRhw() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hVb{};
    D3DDDI_HRESOURCE hIb{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_vb = false;
    bool has_ib = false;

    ~Cleanup() {
      if (has_ib && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hIb);
      }
      if (has_vb && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hVb);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnLock != nullptr && cleanup.device_funcs.pfnUnlock != nullptr, "Lock/Unlock must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetStreamSource != nullptr, "SetStreamSource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetIndices != nullptr, "SetIndices must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawIndexedPrimitive != nullptr, "DrawIndexedPrimitive must be available")) {
    return false;
  }

  D3DDDIVIEWPORTINFO vp{};
  vp.X = 0.0f;
  vp.Y = 0.0f;
  vp.Width = 256.0f;
  vp.Height = 256.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }

  // D3DFVF_XYZRHW (0x4) | D3DFVF_DIFFUSE (0x40) | D3DFVF_TEX1 (0x100).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x144u);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|DIFFUSE|TEX1)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    float rhw;
    uint32_t color;
    float u;
    float v;
  };

  constexpr uint32_t kRed = 0xFFFF0000u;
  constexpr uint32_t kGreen = 0xFF00FF00u;
  constexpr uint32_t kBlue = 0xFF0000FFu;
  constexpr uint32_t kYellow = 0xFFFFFF00u;
  constexpr uint32_t kMagenta = 0xFFFF00FFu;

  Vertex verts[5]{};
  verts[0] = {10.0f, 10.0f, 0.1f, 1.0f, kRed, 0.0f, 0.0f};
  verts[1] = {20.0f, 30.0f, 0.2f, 1.0f, kGreen, 0.25f, 0.25f};
  // rhw=2.0 => w=0.5. This should scale clip-space x/y/z by 0.5.
  verts[2] = {100.0f, 80.0f, 0.6f, 2.0f, kBlue, 0.75f, 0.5f};
  verts[3] = {140.0f, 160.0f, 0.7f, 1.0f, kYellow, 0.5f, 0.75f};
  verts[4] = {200.0f, 220.0f, 0.8f, 1.0f, kMagenta, 1.0f, 1.0f};

  const uint16_t indices[4] = {0, 1, 2, 3};

  // Create and fill VB.
  D3D9DDIARG_CREATERESOURCE create_vb{};
  create_vb.type = 0;
  create_vb.format = 0;
  create_vb.width = 0;
  create_vb.height = 0;
  create_vb.depth = 0;
  create_vb.mip_levels = 1;
  create_vb.usage = 0;
  create_vb.pool = 0;
  create_vb.size = sizeof(verts);
  create_vb.hResource.pDrvPrivate = nullptr;
  create_vb.pSharedHandle = nullptr;
  create_vb.pKmdAllocPrivateData = nullptr;
  create_vb.KmdAllocPrivateDataSize = 0;
  create_vb.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_vb);
  if (!Check(hr == S_OK, "CreateResource(vertex buffer)")) {
    return false;
  }
  cleanup.hVb = create_vb.hResource;
  cleanup.has_vb = true;

  D3D9DDIARG_LOCK lock{};
  lock.hResource = create_vb.hResource;
  lock.offset_bytes = 0;
  lock.size_bytes = 0;
  lock.flags = 0;
  D3DDDI_LOCKEDBOX box{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(vertex buffer)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock(VB) returns pData")) {
    return false;
  }
  std::memcpy(box.pData, verts, sizeof(verts));

  D3D9DDIARG_UNLOCK unlock{};
  unlock.hResource = create_vb.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(vertex buffer)")) {
    return false;
  }

  // Create and fill IB.
  D3D9DDIARG_CREATERESOURCE create_ib{};
  create_ib.type = 0;
  create_ib.format = 0;
  create_ib.width = 0;
  create_ib.height = 0;
  create_ib.depth = 0;
  create_ib.mip_levels = 1;
  create_ib.usage = 0;
  create_ib.pool = 0;
  create_ib.size = sizeof(indices);
  create_ib.hResource.pDrvPrivate = nullptr;
  create_ib.pSharedHandle = nullptr;
  create_ib.pKmdAllocPrivateData = nullptr;
  create_ib.KmdAllocPrivateDataSize = 0;
  create_ib.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_ib);
  if (!Check(hr == S_OK, "CreateResource(index buffer)")) {
    return false;
  }
  cleanup.hIb = create_ib.hResource;
  cleanup.has_ib = true;

  lock.hResource = create_ib.hResource;
  lock.offset_bytes = 0;
  lock.size_bytes = 0;
  lock.flags = 0;
  std::memset(&box, 0, sizeof(box));
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(index buffer)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock(IB) returns pData")) {
    return false;
  }
  std::memcpy(box.pData, indices, sizeof(indices));

  unlock.hResource = create_ib.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(index buffer)")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnSetStreamSource(create_dev.hDevice, 0, create_vb.hResource, 0, sizeof(Vertex));
  if (!Check(hr == S_OK, "SetStreamSource")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnSetIndices(create_dev.hDevice, create_ib.hResource, kD3dFmtIndex16, 0);
  if (!Check(hr == S_OK, "SetIndices")) {
    return false;
  }

  // For TRIANGLELIST primitive_count=1 => index_count=3. With start_index=1 this
  // consumes indices[1..3]. With base_vertex=1, the first expanded vertex should
  // come from verts[base_vertex + indices[1]] == verts[2].
  hr = cleanup.device_funcs.pfnDrawIndexedPrimitive(create_dev.hDevice,
                                                    D3DDDIPT_TRIANGLELIST,
                                                    /*base_vertex=*/1,
                                                    /*min_index=*/1,
                                                    /*num_vertices=*/3,
                                                    /*start_index=*/1,
                                                    /*primitive_count=*/1);
  if (!Check(hr == S_OK, "DrawIndexedPrimitive")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  if (!Check(dev->up_vertex_buffer != nullptr, "up_vertex_buffer allocated")) {
    return false;
  }
  const uint32_t up_vb_handle = dev->up_vertex_buffer->handle;
  if (!Check(up_vb_handle != 0, "up_vertex_buffer handle non-zero")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_DRAW) >= 1, "indexed fixedfunc emulation emits non-indexed DRAW")) {
    return false;
  }
  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_DRAW_INDEXED) == 0, "indexed fixedfunc emulation emits no DRAW_INDEXED")) {
    return false;
  }

  constexpr size_t kExpandedVertexCount = 3;
  const size_t expected_bytes = AlignUp(sizeof(Vertex) * kExpandedVertexCount, 4);
  std::vector<uint8_t> vb_upload(expected_bytes, 0);
  size_t vb_uploaded_bytes = 0;

  const size_t stream_len = StreamBytesUsed(buf, len);
  size_t off = sizeof(aerogpu_cmd_stream_header);
  while (off + sizeof(aerogpu_cmd_hdr) <= stream_len) {
    const auto* hdr = reinterpret_cast<const aerogpu_cmd_hdr*>(buf + off);
    if (hdr->opcode == AEROGPU_CMD_UPLOAD_RESOURCE) {
      const auto* upload = reinterpret_cast<const aerogpu_cmd_upload_resource*>(hdr);
      if (upload->resource_handle == up_vb_handle) {
        const size_t payload_bytes = upload->size_bytes;
        if (!Check(upload->offset_bytes + payload_bytes <= expected_bytes, "upload_resource(UP VB) bounds")) {
          return false;
        }
        if (!Check(sizeof(*upload) + payload_bytes <= hdr->size_bytes, "upload_resource(UP VB) payload bounds")) {
          return false;
        }
        const uint8_t* payload = reinterpret_cast<const uint8_t*>(upload) + sizeof(*upload);
        std::memcpy(vb_upload.data() + upload->offset_bytes, payload, payload_bytes);
        vb_uploaded_bytes += payload_bytes;
      }
    }
    if (hdr->size_bytes == 0 || hdr->size_bytes > stream_len - off) {
      break;
    }
    off += hdr->size_bytes;
  }

  if (!Check(vb_uploaded_bytes == expected_bytes, "expanded vertex upload emitted")) {
    return false;
  }

  float x0 = 0.0f;
  float y0 = 0.0f;
  float z0 = 0.0f;
  float w0 = 0.0f;
  uint32_t c0 = 0;
  float u0 = 0.0f;
  float v0 = 0.0f;
  std::memcpy(&x0, vb_upload.data() + 0, sizeof(float));
  std::memcpy(&y0, vb_upload.data() + 4, sizeof(float));
  std::memcpy(&z0, vb_upload.data() + 8, sizeof(float));
  std::memcpy(&w0, vb_upload.data() + 12, sizeof(float));
  std::memcpy(&c0, vb_upload.data() + 16, sizeof(uint32_t));
  std::memcpy(&u0, vb_upload.data() + 20, sizeof(float));
  std::memcpy(&v0, vb_upload.data() + 24, sizeof(float));

  const Vertex& src0 = verts[2];
  const float w = 1.0f / src0.rhw;
  const float ndc_x = ((src0.x + 0.5f - vp.X) / vp.Width) * 2.0f - 1.0f;
  const float ndc_y = 1.0f - ((src0.y + 0.5f - vp.Y) / vp.Height) * 2.0f;

  if (!Check(std::fabs(x0 - ndc_x * w) < 1e-6f, "DrawIndexedPrimitive base_vertex: x0 matches RHW clip conversion")) {
    return false;
  }
  if (!Check(std::fabs(y0 - ndc_y * w) < 1e-6f, "DrawIndexedPrimitive base_vertex: y0 matches RHW clip conversion")) {
    return false;
  }
  if (!Check(std::fabs(z0 - src0.z * w) < 1e-6f, "DrawIndexedPrimitive base_vertex: z scales by w")) {
    return false;
  }
  if (!Check(std::fabs(w0 - w) < 1e-6f, "DrawIndexedPrimitive base_vertex: w computed from rhw")) {
    return false;
  }
  if (!Check(c0 == src0.color, "DrawIndexedPrimitive base_vertex: diffuse preserved")) {
    return false;
  }
  if (!Check(std::fabs(u0 - src0.u) < 1e-6f, "DrawIndexedPrimitive base_vertex: u preserved")) {
    return false;
  }
  if (!Check(std::fabs(v0 - src0.v) < 1e-6f, "DrawIndexedPrimitive base_vertex: v preserved")) {
    return false;
  }
  return ValidateStream(buf, len);
}

bool TestFvfXyzrhwDiffuseTex1DrawIndexedPrimitiveEmulationSupportsIndex32AndIndexOffset() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hVb{};
    D3DDDI_HRESOURCE hIb{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_vb = false;
    bool has_ib = false;

    ~Cleanup() {
      if (has_ib && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hIb);
      }
      if (has_vb && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hVb);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnLock != nullptr && cleanup.device_funcs.pfnUnlock != nullptr, "Lock/Unlock must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetStreamSource != nullptr, "SetStreamSource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetIndices != nullptr, "SetIndices must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawIndexedPrimitive != nullptr, "DrawIndexedPrimitive must be available")) {
    return false;
  }

  D3DDDIVIEWPORTINFO vp{};
  vp.X = 10.0f;
  vp.Y = 20.0f;
  vp.Width = 256.0f;
  vp.Height = 256.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }

  // D3DFVF_XYZRHW (0x4) | D3DFVF_DIFFUSE (0x40) | D3DFVF_TEX1 (0x100).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x144u);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|DIFFUSE|TEX1)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    float rhw;
    uint32_t color;
    float u;
    float v;
  };

  constexpr uint32_t kRed = 0xFFFF0000u;
  constexpr uint32_t kGreen = 0xFF00FF00u;
  constexpr uint32_t kBlue = 0xFF0000FFu;
  constexpr uint32_t kYellow = 0xFFFFFF00u;

  Vertex verts[4]{};
  verts[0] = {15.0f, 25.0f, 0.2f, 1.0f, kRed, 0.0f, 0.0f};
  verts[1] = {45.0f, 55.0f, 0.3f, 1.0f, kGreen, 0.25f, 0.5f};
  // rhw=2.0 => w=0.5. This should scale clip-space x/y/z by 0.5.
  verts[2] = {75.0f, 95.0f, 0.4f, 2.0f, kBlue, 0.5f, 0.75f};
  verts[3] = {105.0f, 135.0f, 0.6f, 1.0f, kYellow, 0.75f, 1.0f};

  const uint32_t indices[4] = {0, 1, 2, 3};

  // Create and fill VB.
  D3D9DDIARG_CREATERESOURCE create_vb{};
  create_vb.type = 0;
  create_vb.format = 0;
  create_vb.width = 0;
  create_vb.height = 0;
  create_vb.depth = 0;
  create_vb.mip_levels = 1;
  create_vb.usage = 0;
  create_vb.pool = 0;
  create_vb.size = sizeof(verts);
  create_vb.hResource.pDrvPrivate = nullptr;
  create_vb.pSharedHandle = nullptr;
  create_vb.pKmdAllocPrivateData = nullptr;
  create_vb.KmdAllocPrivateDataSize = 0;
  create_vb.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_vb);
  if (!Check(hr == S_OK, "CreateResource(vertex buffer)")) {
    return false;
  }
  cleanup.hVb = create_vb.hResource;
  cleanup.has_vb = true;

  D3D9DDIARG_LOCK lock{};
  lock.hResource = create_vb.hResource;
  lock.offset_bytes = 0;
  lock.size_bytes = 0;
  lock.flags = 0;
  D3DDDI_LOCKEDBOX box{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(vertex buffer)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock(VB) returns pData")) {
    return false;
  }
  std::memcpy(box.pData, verts, sizeof(verts));

  D3D9DDIARG_UNLOCK unlock{};
  unlock.hResource = create_vb.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(vertex buffer)")) {
    return false;
  }

  // Create and fill IB.
  D3D9DDIARG_CREATERESOURCE create_ib{};
  create_ib.type = 0;
  create_ib.format = 0;
  create_ib.width = 0;
  create_ib.height = 0;
  create_ib.depth = 0;
  create_ib.mip_levels = 1;
  create_ib.usage = 0;
  create_ib.pool = 0;
  create_ib.size = sizeof(indices);
  create_ib.hResource.pDrvPrivate = nullptr;
  create_ib.pSharedHandle = nullptr;
  create_ib.pKmdAllocPrivateData = nullptr;
  create_ib.KmdAllocPrivateDataSize = 0;
  create_ib.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_ib);
  if (!Check(hr == S_OK, "CreateResource(index buffer)")) {
    return false;
  }
  cleanup.hIb = create_ib.hResource;
  cleanup.has_ib = true;

  lock.hResource = create_ib.hResource;
  lock.offset_bytes = 0;
  lock.size_bytes = 0;
  lock.flags = 0;
  std::memset(&box, 0, sizeof(box));
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(index buffer)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock(IB) returns pData")) {
    return false;
  }
  std::memcpy(box.pData, indices, sizeof(indices));

  unlock.hResource = create_ib.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(index buffer)")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnSetStreamSource(create_dev.hDevice, 0, create_vb.hResource, 0, sizeof(Vertex));
  if (!Check(hr == S_OK, "SetStreamSource")) {
    return false;
  }

  // Use Index32 with a non-zero base offset so DrawIndexedPrimitive reads indices
  // from indices[1..] (i.e. {1,2,3} for TRIANGLELIST primitive_count=1).
  hr = cleanup.device_funcs.pfnSetIndices(create_dev.hDevice, create_ib.hResource, kD3dFmtIndex32, 4);
  if (!Check(hr == S_OK, "SetIndices(Index32, offset_bytes=4)")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnDrawIndexedPrimitive(create_dev.hDevice,
                                                    D3DDDIPT_TRIANGLELIST,
                                                    /*base_vertex=*/0,
                                                    /*min_index=*/0,
                                                    /*num_vertices=*/4,
                                                    /*start_index=*/0,
                                                    /*primitive_count=*/1);
  if (!Check(hr == S_OK, "DrawIndexedPrimitive")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  if (!Check(dev->up_vertex_buffer != nullptr, "up_vertex_buffer allocated")) {
    return false;
  }
  const uint32_t up_vb_handle = dev->up_vertex_buffer->handle;
  if (!Check(up_vb_handle != 0, "up_vertex_buffer handle non-zero")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_DRAW) >= 1, "indexed fixedfunc emulation emits non-indexed DRAW")) {
    return false;
  }
  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_DRAW_INDEXED) == 0, "indexed fixedfunc emulation emits no DRAW_INDEXED")) {
    return false;
  }

  constexpr size_t kExpandedVertexCount = 3;
  const size_t expected_bytes = AlignUp(sizeof(Vertex) * kExpandedVertexCount, 4);
  std::vector<uint8_t> vb_upload(expected_bytes, 0);
  size_t vb_uploaded_bytes = 0;

  const size_t stream_len = StreamBytesUsed(buf, len);
  size_t off = sizeof(aerogpu_cmd_stream_header);
  while (off + sizeof(aerogpu_cmd_hdr) <= stream_len) {
    const auto* hdr = reinterpret_cast<const aerogpu_cmd_hdr*>(buf + off);
    if (hdr->opcode == AEROGPU_CMD_UPLOAD_RESOURCE) {
      const auto* upload = reinterpret_cast<const aerogpu_cmd_upload_resource*>(hdr);
      if (upload->resource_handle == up_vb_handle) {
        const size_t payload_bytes = upload->size_bytes;
        if (!Check(upload->offset_bytes + payload_bytes <= expected_bytes, "upload_resource(UP VB) bounds")) {
          return false;
        }
        if (!Check(sizeof(*upload) + payload_bytes <= hdr->size_bytes, "upload_resource(UP VB) payload bounds")) {
          return false;
        }
        const uint8_t* payload = reinterpret_cast<const uint8_t*>(upload) + sizeof(*upload);
        std::memcpy(vb_upload.data() + upload->offset_bytes, payload, payload_bytes);
        vb_uploaded_bytes += payload_bytes;
      }
    }
    if (hdr->size_bytes == 0 || hdr->size_bytes > stream_len - off) {
      break;
    }
    off += hdr->size_bytes;
  }

  if (!Check(vb_uploaded_bytes == expected_bytes, "expanded vertex upload emitted")) {
    return false;
  }

  auto check_vertex = [&](size_t expanded_idx, const Vertex& src) -> bool {
    const size_t base = expanded_idx * sizeof(Vertex);
    float x = 0.0f;
    float y = 0.0f;
    float z = 0.0f;
    float w = 0.0f;
    uint32_t c = 0;
    float u = 0.0f;
    float v = 0.0f;
    std::memcpy(&x, vb_upload.data() + base + 0, sizeof(float));
    std::memcpy(&y, vb_upload.data() + base + 4, sizeof(float));
    std::memcpy(&z, vb_upload.data() + base + 8, sizeof(float));
    std::memcpy(&w, vb_upload.data() + base + 12, sizeof(float));
    std::memcpy(&c, vb_upload.data() + base + 16, sizeof(uint32_t));
    std::memcpy(&u, vb_upload.data() + base + 20, sizeof(float));
    std::memcpy(&v, vb_upload.data() + base + 24, sizeof(float));

    const float expected_w = 1.0f / src.rhw;
    const float ndc_x = ((src.x + 0.5f - vp.X) / vp.Width) * 2.0f - 1.0f;
    const float ndc_y = 1.0f - ((src.y + 0.5f - vp.Y) / vp.Height) * 2.0f;
    if (!Check(std::fabs(x - ndc_x * expected_w) < 1e-6f, "DrawIndexedPrimitive(Index32+offset): x matches RHW clip conversion")) {
      return false;
    }
    if (!Check(std::fabs(y - ndc_y * expected_w) < 1e-6f, "DrawIndexedPrimitive(Index32+offset): y matches RHW clip conversion")) {
      return false;
    }
    if (!Check(std::fabs(z - src.z * expected_w) < 1e-6f, "DrawIndexedPrimitive(Index32+offset): z scales by w")) {
      return false;
    }
    if (!Check(std::fabs(w - expected_w) < 1e-6f, "DrawIndexedPrimitive(Index32+offset): w computed from rhw")) {
      return false;
    }
    if (!Check(c == src.color, "DrawIndexedPrimitive(Index32+offset): diffuse preserved")) {
      return false;
    }
    if (!Check(std::fabs(u - src.u) < 1e-6f, "DrawIndexedPrimitive(Index32+offset): u preserved")) {
      return false;
    }
    if (!Check(std::fabs(v - src.v) < 1e-6f, "DrawIndexedPrimitive(Index32+offset): v preserved")) {
      return false;
    }
    return true;
  };

  if (!check_vertex(0, verts[1])) {
    return false;
  }
  if (!check_vertex(1, verts[2])) {
    return false;
  }
  if (!check_vertex(2, verts[3])) {
    return false;
  }
  return ValidateStream(buf, len);
}

bool TestFvfXyzTex1DrawIndexedPrimitiveNoScratchVbConversion() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hVb{};
    D3DDDI_HRESOURCE hIb{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_vb = false;
    bool has_ib = false;

    ~Cleanup() {
      if (has_ib && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hIb);
      }
      if (has_vb && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hVb);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnLock != nullptr && cleanup.device_funcs.pfnUnlock != nullptr, "Lock/Unlock must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetStreamSource != nullptr, "SetStreamSource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetIndices != nullptr, "SetIndices must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawIndexedPrimitive != nullptr, "DrawIndexedPrimitive must be available")) {
    return false;
  }

  // D3DFVF_XYZ (0x2) | D3DFVF_TEX1 (0x100).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x102u);
  if (!Check(hr == S_OK, "SetFVF(XYZ|TEX1)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    float u;
    float v;
  };

  Vertex verts[3]{};
  verts[0] = {-0.5f, -0.5f, 0.5f, 0.25f, 0.75f};
  verts[1] = {0.5f, -0.5f, 0.5f, 0.75f, 0.75f};
  verts[2] = {0.0f, 0.5f, 0.5f, 0.50f, 0.25f};

  const uint16_t indices[3] = {0, 1, 2};

  // Create and fill VB.
  D3D9DDIARG_CREATERESOURCE create_vb{};
  create_vb.type = 0;
  create_vb.format = 0;
  create_vb.width = 0;
  create_vb.height = 0;
  create_vb.depth = 0;
  create_vb.mip_levels = 1;
  create_vb.usage = 0;
  create_vb.pool = 0;
  create_vb.size = sizeof(verts);
  create_vb.hResource.pDrvPrivate = nullptr;
  create_vb.pSharedHandle = nullptr;
  create_vb.pKmdAllocPrivateData = nullptr;
  create_vb.KmdAllocPrivateDataSize = 0;
  create_vb.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_vb);
  if (!Check(hr == S_OK, "CreateResource(vertex buffer)")) {
    return false;
  }
  cleanup.hVb = create_vb.hResource;
  cleanup.has_vb = true;

  D3D9DDIARG_LOCK lock{};
  lock.hResource = create_vb.hResource;
  lock.offset_bytes = 0;
  lock.size_bytes = 0;
  lock.flags = 0;
  D3DDDI_LOCKEDBOX box{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(vertex buffer)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock(VB) returns pData")) {
    return false;
  }
  std::memcpy(box.pData, verts, sizeof(verts));

  D3D9DDIARG_UNLOCK unlock{};
  unlock.hResource = create_vb.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(vertex buffer)")) {
    return false;
  }

  // Create and fill IB.
  D3D9DDIARG_CREATERESOURCE create_ib{};
  create_ib.type = 0;
  create_ib.format = 0;
  create_ib.width = 0;
  create_ib.height = 0;
  create_ib.depth = 0;
  create_ib.mip_levels = 1;
  create_ib.usage = 0;
  create_ib.pool = 0;
  create_ib.size = sizeof(indices);
  create_ib.hResource.pDrvPrivate = nullptr;
  create_ib.pSharedHandle = nullptr;
  create_ib.pKmdAllocPrivateData = nullptr;
  create_ib.KmdAllocPrivateDataSize = 0;
  create_ib.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_ib);
  if (!Check(hr == S_OK, "CreateResource(index buffer)")) {
    return false;
  }
  cleanup.hIb = create_ib.hResource;
  cleanup.has_ib = true;

  lock.hResource = create_ib.hResource;
  lock.offset_bytes = 0;
  lock.size_bytes = 0;
  lock.flags = 0;
  std::memset(&box, 0, sizeof(box));
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(index buffer)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock(IB) returns pData")) {
    return false;
  }
  std::memcpy(box.pData, indices, sizeof(indices));

  unlock.hResource = create_ib.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(index buffer)")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnSetStreamSource(create_dev.hDevice, 0, create_vb.hResource, 0, sizeof(Vertex));
  if (!Check(hr == S_OK, "SetStreamSource")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnSetIndices(create_dev.hDevice, create_ib.hResource, kD3dFmtIndex16, 0);
  if (!Check(hr == S_OK, "SetIndices")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnDrawIndexedPrimitive(create_dev.hDevice,
                                                    D3DDDIPT_TRIANGLELIST,
                                                    /*base_vertex=*/0,
                                                    /*min_index=*/0,
                                                    /*num_vertices=*/3,
                                                    /*start_index=*/0,
                                                    /*primitive_count=*/1);
  if (!Check(hr == S_OK, "DrawIndexedPrimitive")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  if (!Check(dev->up_vertex_buffer == nullptr, "XYZ|TEX1 indexed draw does not allocate scratch VB")) {
    return false;
  }
  if (!Check(dev->up_index_buffer == nullptr, "XYZ|TEX1 indexed draw does not allocate scratch IB")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_DRAW_INDEXED) >= 1, "DRAW_INDEXED emitted")) {
    return false;
  }
  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_DRAW) == 0, "no non-indexed DRAW emitted")) {
    return false;
  }

  const auto* vb_res = reinterpret_cast<const Resource*>(create_vb.hResource.pDrvPrivate);
  const auto* ib_res = reinterpret_cast<const Resource*>(create_ib.hResource.pDrvPrivate);
  const uint32_t vb_handle = vb_res ? vb_res->handle : 0;
  const uint32_t ib_handle = ib_res ? ib_res->handle : 0;
  if (!Check(vb_handle != 0, "vb handle")) {
    return false;
  }
  if (!Check(ib_handle != 0, "ib handle")) {
    return false;
  }

  bool saw_vb_upload = false;
  bool saw_ib_upload = false;
  const size_t stream_len = StreamBytesUsed(buf, len);
  size_t off = sizeof(aerogpu_cmd_stream_header);
  while (off + sizeof(aerogpu_cmd_hdr) <= stream_len) {
    const auto* hdr = reinterpret_cast<const aerogpu_cmd_hdr*>(buf + off);
    if (hdr->opcode == AEROGPU_CMD_UPLOAD_RESOURCE) {
      const auto* u = reinterpret_cast<const aerogpu_cmd_upload_resource*>(hdr);
      if (u->resource_handle == vb_handle) {
        saw_vb_upload = true;
      } else if (u->resource_handle == ib_handle) {
        saw_ib_upload = true;
      } else {
        return Check(false, "XYZ|TEX1 indexed draw emits no scratch UPLOAD_RESOURCE");
      }
    }
    if (hdr->size_bytes == 0 || hdr->size_bytes > stream_len - off) {
      break;
    }
    off += hdr->size_bytes;
  }
  if (!Check(saw_vb_upload, "vertex buffer upload emitted")) {
    return false;
  }
  if (!Check(saw_ib_upload, "index buffer upload emitted")) {
    return false;
  }
  return ValidateStream(buf, len);
}

bool TestFvfXyzDiffuseTex1DrawIndexedPrimitiveNoScratchVbConversion() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hVb{};
    D3DDDI_HRESOURCE hIb{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_vb = false;
    bool has_ib = false;

    ~Cleanup() {
      if (has_ib && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hIb);
      }
      if (has_vb && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hVb);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "CreateResource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnLock != nullptr && cleanup.device_funcs.pfnUnlock != nullptr, "Lock/Unlock must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetStreamSource != nullptr, "SetStreamSource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetIndices != nullptr, "SetIndices must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawIndexedPrimitive != nullptr, "DrawIndexedPrimitive must be available")) {
    return false;
  }

  // D3DFVF_XYZ (0x2) | D3DFVF_DIFFUSE (0x40) | D3DFVF_TEX1 (0x100).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x142u);
  if (!Check(hr == S_OK, "SetFVF(XYZ|DIFFUSE|TEX1)")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  // Set non-identity transforms: WORLD0 * VIEW * PROJECTION.
  auto set_identity = [](float m[16]) {
    std::memset(m, 0, sizeof(float) * 16);
    m[0] = 1.0f;
    m[5] = 1.0f;
    m[10] = 1.0f;
    m[15] = 1.0f;
  };

  float world[16];
  float view[16];
  float proj[16];
  set_identity(world);
  set_identity(view);
  std::memset(proj, 0, sizeof(proj));

  world[12] = 1.0f;
  world[13] = -1.0f;
  world[14] = 2.0f;

  view[0] = 2.0f;
  view[5] = 3.0f;
  view[10] = 4.0f;

  proj[0] = 1.0f;
  proj[5] = 1.0f;
  proj[10] = 1.0f;
  proj[11] = 1.0f; // w = z

  if (!Check(cleanup.device_funcs.pfnSetTransform != nullptr, "SetTransform must be available")) {
    return false;
  }
  D3DMATRIX world_m{};
  D3DMATRIX view_m{};
  D3DMATRIX proj_m{};
  std::memcpy(world_m.m, world, sizeof(world));
  std::memcpy(view_m.m, view, sizeof(view));
  std::memcpy(proj_m.m, proj, sizeof(proj));
  hr = cleanup.device_funcs.pfnSetTransform(create_dev.hDevice, D3DTS_WORLD, &world_m);
  if (!Check(hr == S_OK, "SetTransform(WORLD)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTransform(create_dev.hDevice, D3DTS_VIEW, &view_m);
  if (!Check(hr == S_OK, "SetTransform(VIEW)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTransform(create_dev.hDevice, D3DTS_PROJECTION, &proj_m);
  if (!Check(hr == S_OK, "SetTransform(PROJECTION)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    uint32_t color;
    float u;
    float v;
  };

  constexpr uint32_t kGreen = 0xFF00FF00u;
  Vertex verts[3]{};
  verts[0] = {-0.5f, -0.5f, 0.5f, kGreen, 0.25f, 0.75f};
  verts[1] = {0.5f, -0.5f, 0.5f, kGreen, 0.75f, 0.75f};
  verts[2] = {0.0f, 0.5f, 0.5f, kGreen, 0.50f, 0.25f};

  const uint16_t indices[3] = {0, 1, 2};

  // Create and fill VB.
  D3D9DDIARG_CREATERESOURCE create_vb{};
  create_vb.type = 0;
  create_vb.format = 0;
  create_vb.width = 0;
  create_vb.height = 0;
  create_vb.depth = 0;
  create_vb.mip_levels = 1;
  create_vb.usage = 0;
  create_vb.pool = 0;
  create_vb.size = sizeof(verts);
  create_vb.hResource.pDrvPrivate = nullptr;
  create_vb.pSharedHandle = nullptr;
  create_vb.pKmdAllocPrivateData = nullptr;
  create_vb.KmdAllocPrivateDataSize = 0;
  create_vb.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_vb);
  if (!Check(hr == S_OK, "CreateResource(vertex buffer)")) {
    return false;
  }
  cleanup.hVb = create_vb.hResource;
  cleanup.has_vb = true;

  D3D9DDIARG_LOCK lock{};
  lock.hResource = create_vb.hResource;
  lock.offset_bytes = 0;
  lock.size_bytes = 0;
  lock.flags = 0;
  D3DDDI_LOCKEDBOX box{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(vertex buffer)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock(VB) returns pData")) {
    return false;
  }
  std::memcpy(box.pData, verts, sizeof(verts));

  D3D9DDIARG_UNLOCK unlock{};
  unlock.hResource = create_vb.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(vertex buffer)")) {
    return false;
  }

  // Create and fill IB.
  D3D9DDIARG_CREATERESOURCE create_ib{};
  create_ib.type = 0;
  create_ib.format = 0;
  create_ib.width = 0;
  create_ib.height = 0;
  create_ib.depth = 0;
  create_ib.mip_levels = 1;
  create_ib.usage = 0;
  create_ib.pool = 0;
  create_ib.size = sizeof(indices);
  create_ib.hResource.pDrvPrivate = nullptr;
  create_ib.pSharedHandle = nullptr;
  create_ib.pKmdAllocPrivateData = nullptr;
  create_ib.KmdAllocPrivateDataSize = 0;
  create_ib.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_ib);
  if (!Check(hr == S_OK, "CreateResource(index buffer)")) {
    return false;
  }
  cleanup.hIb = create_ib.hResource;
  cleanup.has_ib = true;

  lock.hResource = create_ib.hResource;
  lock.offset_bytes = 0;
  lock.size_bytes = 0;
  lock.flags = 0;
  std::memset(&box, 0, sizeof(box));
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(index buffer)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock(IB) returns pData")) {
    return false;
  }
  std::memcpy(box.pData, indices, sizeof(indices));

  unlock.hResource = create_ib.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(index buffer)")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnSetStreamSource(create_dev.hDevice, 0, create_vb.hResource, 0, sizeof(Vertex));
  if (!Check(hr == S_OK, "SetStreamSource")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnSetIndices(create_dev.hDevice, create_ib.hResource, kD3dFmtIndex16, 0);
  if (!Check(hr == S_OK, "SetIndices")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnDrawIndexedPrimitive(create_dev.hDevice,
                                                    D3DDDIPT_TRIANGLELIST,
                                                    /*base_vertex=*/0,
                                                    /*min_index=*/0,
                                                    /*num_vertices=*/3,
                                                      /*start_index=*/0,
                                                      /*primitive_count=*/1);
  if (!Check(hr == S_OK, "DrawIndexedPrimitive")) {
    return false;
  }

  if (!Check(dev->up_vertex_buffer == nullptr, "XYZ|DIFFUSE|TEX1 indexed draw does not allocate scratch VB")) {
    return false;
  }
  if (!Check(dev->up_index_buffer == nullptr, "XYZ|DIFFUSE|TEX1 indexed draw does not allocate scratch IB")) {
    return false;
  }
 
  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();
 
  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_DRAW_INDEXED) >= 1, "DRAW_INDEXED emitted")) {
    return false;
  }
  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_DRAW) == 0, "no non-indexed DRAW emitted")) {
    return false;
  }
 
  const auto* vb_res = reinterpret_cast<const Resource*>(create_vb.hResource.pDrvPrivate);
  if (!Check(vb_res != nullptr, "vb pointer")) {
    return false;
  }
  const uint32_t vb_handle = vb_res->handle;
  if (!Check(vb_handle != 0, "vb handle")) {
    return false;
  }
 
  const auto* ib_res = reinterpret_cast<const Resource*>(create_ib.hResource.pDrvPrivate);
  if (!Check(ib_res != nullptr, "ib pointer")) {
    return false;
  }
  const uint32_t ib_handle = ib_res->handle;
  if (!Check(ib_handle != 0, "ib handle")) {
    return false;
  }
 
  // Expected WVP matrix (row-major).
  float wv[16];
  float wvp[16];
  MulMat4RowMajor(world, view, wv);
  MulMat4RowMajor(wv, proj, wvp);

  // Expected WVP columns (transpose of row-major WVP) uploaded to c240..c243.
  float expected_cols[16] = {};
  for (int c = 0; c < 4; ++c) {
    expected_cols[c * 4 + 0] = wvp[0 * 4 + c];
    expected_cols[c * 4 + 1] = wvp[1 * 4 + c];
    expected_cols[c * 4 + 2] = wvp[2 * 4 + c];
    expected_cols[c * 4 + 3] = wvp[3 * 4 + c];
  }
 
  const CmdLoc wvp_consts = FindLastVsWvpConstants(buf, len);
  if (!Check(wvp_consts.hdr != nullptr, "SET_SHADER_CONSTANTS_F uploads WVP constants")) {
    return false;
  }
  const auto* sc = reinterpret_cast<const aerogpu_cmd_set_shader_constants_f*>(wvp_consts.hdr);
  if (!Check(wvp_consts.hdr->size_bytes >= sizeof(*sc) + sizeof(expected_cols), "WVP constants payload size")) {
    return false;
  }
  const float* cols = reinterpret_cast<const float*>(reinterpret_cast<const uint8_t*>(sc) + sizeof(*sc));
  if (!Check(std::memcmp(cols, expected_cols, sizeof(expected_cols)) == 0, "WVP constants payload matches expected columns")) {
    return false;
  }
 
  const CmdLoc draw_loc = FindLastOpcode(buf, len, AEROGPU_CMD_DRAW_INDEXED);
  if (!Check(draw_loc.hdr != nullptr, "DRAW_INDEXED emitted")) {
    return false;
  }
  if (!CheckWvpConstantsUploadedBeforeDraw(buf, len, draw_loc.offset, wvp, "XYZ|DIFFUSE|TEX1 indexed draw: WVP constants uploaded")) {
    return false;
  }
 
  // Ensure we upload only the user-provided VB/IB and not a scratch VB conversion.
  bool saw_vb_upload = false;
  bool saw_ib_upload = false;
  const size_t stream_len = StreamBytesUsed(buf, len);
  size_t off = sizeof(aerogpu_cmd_stream_header);
  while (off + sizeof(aerogpu_cmd_hdr) <= stream_len) {
    const auto* hdr = reinterpret_cast<const aerogpu_cmd_hdr*>(buf + off);
    if (hdr->opcode == AEROGPU_CMD_UPLOAD_RESOURCE) {
      const auto* u = reinterpret_cast<const aerogpu_cmd_upload_resource*>(hdr);
      if (u->resource_handle == vb_handle) {
        saw_vb_upload = true;
      } else if (u->resource_handle == ib_handle) {
        saw_ib_upload = true;
      } else {
        return Check(false, "XYZ|DIFFUSE|TEX1 indexed draw emits no scratch UPLOAD_RESOURCE");
      }
    }
    if (hdr->size_bytes == 0 || hdr->size_bytes > stream_len - off) {
      break;
    }
    off += hdr->size_bytes;
  }
  if (!Check(saw_vb_upload, "vertex buffer upload emitted")) {
    return false;
  }
  if (!Check(saw_ib_upload, "index buffer upload emitted")) {
    return false;
  }
 
  const CmdLoc vb_upload = FindLastUploadForHandle(buf, len, vb_handle);
  if (!Check(vb_upload.hdr != nullptr, "upload_resource(VB) emitted")) {
    return false;
  }
  const auto* vb_upload_cmd = reinterpret_cast<const aerogpu_cmd_upload_resource*>(vb_upload.hdr);
  if (!Check(vb_upload_cmd->offset_bytes == 0, "upload_resource VB offset is 0")) {
    return false;
  }
  if (!Check(vb_upload_cmd->size_bytes == sizeof(verts), "upload_resource VB size matches original vertex data")) {
    return false;
  }
 
  const uint8_t* payload = reinterpret_cast<const uint8_t*>(vb_upload_cmd) + sizeof(*vb_upload_cmd);
  float x0 = 0.0f;
  float y0 = 0.0f;
  float z0 = 0.0f;
  uint32_t c0 = 0;
  float u0 = 0.0f;
  float v0_out = 0.0f;
  std::memcpy(&x0, payload + 0, sizeof(float));
  std::memcpy(&y0, payload + 4, sizeof(float));
  std::memcpy(&z0, payload + 8, sizeof(float));
  std::memcpy(&c0, payload + 12, sizeof(uint32_t));
  std::memcpy(&u0, payload + 16, sizeof(float));
  std::memcpy(&v0_out, payload + 20, sizeof(float));
 
  if (!Check(std::fabs(x0 - verts[0].x) < 1e-6f, "XYZ|DIFFUSE|TEX1 indexed draw: x0 preserved (no CPU conversion)")) {
    return false;
  }
  if (!Check(std::fabs(y0 - verts[0].y) < 1e-6f, "XYZ|DIFFUSE|TEX1 indexed draw: y0 preserved (no CPU conversion)")) {
    return false;
  }
  if (!Check(std::fabs(z0 - verts[0].z) < 1e-6f, "XYZ|DIFFUSE|TEX1 indexed draw: z0 preserved")) {
    return false;
  }
  if (!Check(c0 == kGreen, "XYZ|DIFFUSE|TEX1 indexed draw: diffuse color preserved")) {
    return false;
  }
  if (!Check(std::fabs(u0 - verts[0].u) < 1e-6f, "XYZ|DIFFUSE|TEX1 indexed draw: u preserved")) {
    return false;
  }
  if (!Check(std::fabs(v0_out - verts[0].v) < 1e-6f, "XYZ|DIFFUSE|TEX1 indexed draw: v preserved")) {
    return false;
  }
 
  return ValidateStream(buf, len);
}

bool TestDrawRectPatchEmitsDrawIndexedAndUploadsScratchVb() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hVb{};
    D3DDDI_HRESOURCE hIb{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_vb = false;
    bool has_ib = false;

    ~Cleanup() {
      if (has_ib && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hIb);
      }
      if (has_vb && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hVb);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetStreamSource != nullptr, "SetStreamSource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetIndices != nullptr, "SetIndices must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawRectPatch != nullptr, "DrawRectPatch must be available")) {
    return false;
  }

  D3DDDIVIEWPORTINFO vp{};
  vp.X = 0.0f;
  vp.Y = 0.0f;
  vp.Width = 256.0f;
  vp.Height = 256.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }

  // D3DFVF_XYZRHW (0x4) | D3DFVF_DIFFUSE (0x40).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x44u);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|DIFFUSE)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    float rhw;
    uint32_t color;
  };

  // 4x4 control points (contiguous). Keep it simple: planar quad with varying color.
  Vertex cps[16]{};
  for (uint32_t y = 0; y < 4; ++y) {
    for (uint32_t x = 0; x < 4; ++x) {
      const float fx = static_cast<float>(x) / 3.0f;
      const float fy = static_cast<float>(y) / 3.0f;
      const float px = 256.0f * (0.25f + 0.5f * fx);
      const float py = 256.0f * (0.25f + 0.5f * fy);
      const uint32_t r = static_cast<uint32_t>(fx * 255.0f);
      const uint32_t g = static_cast<uint32_t>(fy * 255.0f);
      const uint32_t b = 0u;
      cps[y * 4 + x] = {px, py, 0.5f, 1.0f, 0xFF000000u | (r << 16) | (g << 8) | b};
    }
  }

  D3D9DDIARG_CREATERESOURCE create_vb{};
  create_vb.type = 0;
  create_vb.format = 0;
  create_vb.width = 0;
  create_vb.height = 0;
  create_vb.depth = 0;
  create_vb.mip_levels = 1;
  create_vb.usage = 0;
  create_vb.pool = 0;
  create_vb.size = sizeof(cps);
  create_vb.hResource.pDrvPrivate = nullptr;
  create_vb.pSharedHandle = nullptr;
  create_vb.pKmdAllocPrivateData = nullptr;
  create_vb.KmdAllocPrivateDataSize = 0;
  create_vb.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_vb);
  if (!Check(hr == S_OK, "CreateResource(control point VB)")) {
    return false;
  }
  cleanup.hVb = create_vb.hResource;
  cleanup.has_vb = true;

  D3D9DDIARG_LOCK lock{};
  lock.hResource = create_vb.hResource;
  lock.offset_bytes = 0;
  lock.size_bytes = 0;
  lock.flags = 0;
  D3DDDI_LOCKEDBOX box{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(VB)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock returns pData")) {
    return false;
  }
  std::memcpy(box.pData, cps, sizeof(cps));

  D3D9DDIARG_UNLOCK unlock{};
  unlock.hResource = create_vb.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(VB)")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnSetStreamSource(create_dev.hDevice, 0, create_vb.hResource, 0, sizeof(Vertex));
  if (!Check(hr == S_OK, "SetStreamSource")) {
    return false;
  }

  // Bind an app-provided index buffer so we can validate that DrawRectPatch
  // restores it after temporarily binding the scratch UP index buffer.
  const uint16_t app_indices[3] = {0, 1, 2};
  D3D9DDIARG_CREATERESOURCE create_ib{};
  create_ib.type = 0;
  create_ib.format = 0;
  create_ib.width = 0;
  create_ib.height = 0;
  create_ib.depth = 0;
  create_ib.mip_levels = 1;
  create_ib.usage = 0;
  create_ib.pool = 0;
  create_ib.size = sizeof(app_indices);
  create_ib.hResource.pDrvPrivate = nullptr;
  create_ib.pSharedHandle = nullptr;
  create_ib.pKmdAllocPrivateData = nullptr;
  create_ib.KmdAllocPrivateDataSize = 0;
  create_ib.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_ib);
  if (!Check(hr == S_OK, "CreateResource(app index buffer)")) {
    return false;
  }
  cleanup.hIb = create_ib.hResource;
  cleanup.has_ib = true;

  lock.hResource = create_ib.hResource;
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(IB)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock(IB) returns pData")) {
    return false;
  }
  std::memcpy(box.pData, app_indices, sizeof(app_indices));

  unlock.hResource = create_ib.hResource;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(IB)")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnSetIndices(create_dev.hDevice, create_ib.hResource, kD3dFmtIndex16, 0);
  if (!Check(hr == S_OK, "SetIndices")) {
    return false;
  }

  // Force a non-trianglelist cached topology so the patch draw must emit a set-topology command.
  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  const Vertex strip[3] = {cps[0], cps[1], cps[2]};
  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(create_dev.hDevice, D3DDDIPT_TRIANGLESTRIP, 1, strip, sizeof(Vertex));
  if (!Check(hr == S_OK, "DrawPrimitiveUP(triangle strip prelude)")) {
    return false;
  }

  float segs[4] = {1.0f, 1.0f, 1.0f, 1.0f};
  D3DRECTPATCH_INFO info{};
  info.StartVertexOffset = 0;
  info.NumVertices = 16;
  info.Basis = D3DBASIS_BEZIER;
  info.Degree = D3DDEGREE_CUBIC;

  D3DDDIARG_DRAWRECTPATCH draw_rect{};
  draw_rect.Handle = 1;
  draw_rect.pNumSegs = segs;
  draw_rect.pRectPatchInfo = &info;

  hr = cleanup.device_funcs.pfnDrawRectPatch(create_dev.hDevice, &draw_rect);
  if (!Check(hr == S_OK, "DrawRectPatch")) {
    return false;
  }

  auto* vb_res = reinterpret_cast<Resource*>(create_vb.hResource.pDrvPrivate);
  auto* ib_res = reinterpret_cast<Resource*>(create_ib.hResource.pDrvPrivate);
  if (!Check(vb_res != nullptr, "VB resource pointer")) {
    return false;
  }
  if (!Check(ib_res != nullptr, "IB resource pointer")) {
    return false;
  }
  if (!Check(dev->streams[0].vb == vb_res, "DrawRectPatch restores stream source 0")) {
    return false;
  }
  if (!Check(dev->index_buffer == ib_res, "DrawRectPatch restores index buffer")) {
    return false;
  }

  if (!Check(dev->up_vertex_buffer != nullptr, "up_vertex_buffer allocated")) {
    return false;
  }
  if (!Check(dev->up_index_buffer != nullptr, "up_index_buffer allocated")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  const CmdLoc draw = FindLastOpcode(buf, len, AEROGPU_CMD_DRAW_INDEXED);
  if (!Check(draw.hdr != nullptr, "draw_indexed emitted")) {
    return false;
  }

  const CmdLoc topo = FindLastOpcodeBefore(buf, len, draw.offset, AEROGPU_CMD_SET_PRIMITIVE_TOPOLOGY);
  if (!Check(topo.hdr != nullptr, "set_primitive_topology emitted before draw")) {
    return false;
  }
  const auto* topo_cmd = reinterpret_cast<const aerogpu_cmd_set_primitive_topology*>(topo.hdr);
  if (!Check(topo_cmd->topology == AEROGPU_TOPOLOGY_TRIANGLELIST, "patch draw uses TRIANGLELIST topology")) {
    return false;
  }

  // Verify scratch VB/IB uploads targeting the UP buffers occurred before the draw.
  const uint32_t up_vb_handle = dev->up_vertex_buffer->handle;
  const uint32_t up_ib_handle = dev->up_index_buffer->handle;
  const CmdLoc vb_upload = FindLastUploadResourceBefore(buf, len, draw.offset, up_vb_handle);
  const CmdLoc ib_upload = FindLastUploadResourceBefore(buf, len, draw.offset, up_ib_handle);
  if (!Check(vb_upload.hdr != nullptr, "upload_resource targeting UP VB emitted before draw")) {
    return false;
  }
  if (!Check(ib_upload.hdr != nullptr, "upload_resource targeting UP IB emitted before draw")) {
    return false;
  }

  const auto* vb_upload_cmd = reinterpret_cast<const aerogpu_cmd_upload_resource*>(vb_upload.hdr);
  const auto* ib_upload_cmd = reinterpret_cast<const aerogpu_cmd_upload_resource*>(ib_upload.hdr);
  const uint32_t expected_vb_upload = 4u * sizeof(Vertex); // (segs_u+1)*(segs_v+1) vertices for segs=1
  const uint32_t expected_ib_upload = static_cast<uint32_t>(AlignUp(12u, 4u)); // 6 u16 indices (aligned)
  if (!Check(vb_upload_cmd->size_bytes == expected_vb_upload, "UP VB upload size matches tessellated vertex data")) {
    return false;
  }
  if (!Check(ib_upload_cmd->size_bytes == expected_ib_upload, "UP IB upload size matches tessellated index data (aligned)")) {
    return false;
  }

  const CmdLoc set_ib = FindLastOpcodeBefore(buf, len, draw.offset, AEROGPU_CMD_SET_INDEX_BUFFER);
  if (!Check(set_ib.hdr != nullptr, "set_index_buffer emitted before draw")) {
    return false;
  }
  const auto* set_ib_cmd = reinterpret_cast<const aerogpu_cmd_set_index_buffer*>(set_ib.hdr);
  if (!Check(set_ib_cmd->buffer == up_ib_handle, "patch draw binds UP IB")) {
    return false;
  }

  // Validate the restore commands after the draw.
  const CmdLoc restore_ib = FindLastOpcode(buf, len, AEROGPU_CMD_SET_INDEX_BUFFER);
  if (!Check(restore_ib.hdr != nullptr, "set_index_buffer restore emitted")) {
    return false;
  }
  if (!Check(restore_ib.offset > draw.offset, "set_index_buffer restore occurs after draw")) {
    return false;
  }
  const auto* restore_ib_cmd = reinterpret_cast<const aerogpu_cmd_set_index_buffer*>(restore_ib.hdr);
  if (!Check(restore_ib_cmd->buffer == ib_res->handle, "patch draw restores app IB binding")) {
    return false;
  }

  const CmdLoc restore_vb = FindLastOpcode(buf, len, AEROGPU_CMD_SET_VERTEX_BUFFERS);
  if (!Check(restore_vb.hdr != nullptr, "set_vertex_buffers restore emitted")) {
    return false;
  }
  if (!Check(restore_vb.offset > draw.offset, "set_vertex_buffers restore occurs after draw")) {
    return false;
  }
  const auto* restore_vb_cmd = reinterpret_cast<const aerogpu_cmd_set_vertex_buffers*>(restore_vb.hdr);
  if (!Check(restore_vb_cmd->start_slot == 0 && restore_vb_cmd->buffer_count == 1, "set_vertex_buffers restore binds slot 0")) {
    return false;
  }
  const auto* binding = reinterpret_cast<const aerogpu_vertex_buffer_binding*>(
      reinterpret_cast<const uint8_t*>(restore_vb_cmd) + sizeof(*restore_vb_cmd));
  if (!Check(binding->buffer == vb_res->handle, "patch draw restores app VB binding")) {
    return false;
  }
  if (!Check(binding->stride_bytes == sizeof(Vertex), "patch draw restores VB stride")) {
    return false;
  }
  return Check(binding->offset_bytes == 0, "patch draw restores VB offset");
}

bool TestDrawRectPatchTex1ValidatesStrideAndPreservesTexcoords() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hVb{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_vb = false;
    ~Cleanup() {
      if (has_vb && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hVb);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetStreamSource != nullptr, "SetStreamSource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawRectPatch != nullptr, "DrawRectPatch must be available")) {
    return false;
  }

  D3DDDIVIEWPORTINFO vp{};
  vp.X = 0.0f;
  vp.Y = 0.0f;
  vp.Width = 256.0f;
  vp.Height = 256.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }

  // D3DFVF_XYZRHW (0x4) | D3DFVF_DIFFUSE (0x40) | D3DFVF_TEX1 (0x100).
  //
  // Include TEXCOORDSIZE bits for an *unused* texcoord set to validate we mask
  // out the per-set D3DFVF_TEXCOORDSIZE* bits for fixed-function patch paths.
  //
  // 0x40000 = D3DFVF_TEXCOORDSIZE3(1) (2-bit encoding at bits 18..19).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x40144u);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|DIFFUSE|TEX1)")) {
    return false;
  }

  struct VertexTex {
    float x;
    float y;
    float z;
    float rhw;
    uint32_t color;
    float u;
    float v;
  };

  constexpr float kU = 0.25f;
  constexpr float kV = 0.75f;

  // 4x4 control points (contiguous). Keep it simple: planar quad with constant UVs.
  VertexTex cps[16]{};
  for (uint32_t y = 0; y < 4; ++y) {
    for (uint32_t x = 0; x < 4; ++x) {
      const float fx = static_cast<float>(x) / 3.0f;
      const float fy = static_cast<float>(y) / 3.0f;
      const float px = 256.0f * (0.25f + 0.5f * fx);
      const float py = 256.0f * (0.25f + 0.5f * fy);
      const uint32_t r = static_cast<uint32_t>(fx * 255.0f);
      const uint32_t g = static_cast<uint32_t>(fy * 255.0f);
      cps[y * 4 + x] = {px, py, 0.5f, 1.0f, 0xFF000000u | (r << 16) | (g << 8), kU, kV};
    }
  }

  D3D9DDIARG_CREATERESOURCE create_vb{};
  create_vb.type = 0;
  create_vb.format = 0;
  create_vb.width = 0;
  create_vb.height = 0;
  create_vb.depth = 0;
  create_vb.mip_levels = 1;
  create_vb.usage = 0;
  create_vb.pool = 0;
  create_vb.size = sizeof(cps);
  create_vb.hResource.pDrvPrivate = nullptr;
  create_vb.pSharedHandle = nullptr;
  create_vb.pKmdAllocPrivateData = nullptr;
  create_vb.KmdAllocPrivateDataSize = 0;
  create_vb.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_vb);
  if (!Check(hr == S_OK, "CreateResource(control point VB)")) {
    return false;
  }
  cleanup.hVb = create_vb.hResource;
  cleanup.has_vb = true;

  D3D9DDIARG_LOCK lock{};
  lock.hResource = create_vb.hResource;
  lock.offset_bytes = 0;
  lock.size_bytes = 0;
  lock.flags = 0;
  D3DDDI_LOCKEDBOX box{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(VB)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock returns pData")) {
    return false;
  }
  std::memcpy(box.pData, cps, sizeof(cps));

  D3D9DDIARG_UNLOCK unlock{};
  unlock.hResource = create_vb.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(VB)")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  float segs[4] = {1.0f, 1.0f, 1.0f, 1.0f};
  D3DRECTPATCH_INFO info{};
  info.StartVertexOffset = 0;
  info.NumVertices = 16;
  info.Basis = D3DBASIS_BEZIER;
  info.Degree = D3DDEGREE_CUBIC;
  D3DDDIARG_DRAWRECTPATCH draw_rect{};
  draw_rect.Handle = 1;
  draw_rect.pNumSegs = segs;
  draw_rect.pRectPatchInfo = &info;

  // Stride too small for TEX1 should fail.
  hr = cleanup.device_funcs.pfnSetStreamSource(create_dev.hDevice, 0, create_vb.hResource, 0, /*stride=*/20u);
  if (!Check(hr == S_OK, "SetStreamSource(stride=20)")) {
    return false;
  }
  dev->cmd.reset();
  hr = cleanup.device_funcs.pfnDrawRectPatch(create_dev.hDevice, &draw_rect);
  if (!Check(hr == E_FAIL, "DrawRectPatch(TEX1 stride<28) fails")) {
    return false;
  }

  // Valid stride should succeed and preserve UVs in the uploaded scratch VB.
  hr = cleanup.device_funcs.pfnSetStreamSource(create_dev.hDevice, 0, create_vb.hResource, 0, sizeof(VertexTex));
  if (!Check(hr == S_OK, "SetStreamSource(stride=28)")) {
    return false;
  }

  // Force a non-trianglelist cached topology so the patch draw must emit a set-topology command.
  const VertexTex strip[3] = {cps[0], cps[1], cps[2]};
  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(create_dev.hDevice, D3DDDIPT_TRIANGLESTRIP, 1, strip, sizeof(VertexTex));
  if (!Check(hr == S_OK, "DrawPrimitiveUP(triangle strip prelude)")) {
    return false;
  }
  dev->cmd.reset();
  hr = cleanup.device_funcs.pfnDrawRectPatch(create_dev.hDevice, &draw_rect);
  if (!Check(hr == S_OK, "DrawRectPatch(TEX1 stride=28)")) {
    return false;
  }
  if (!Check(dev->up_vertex_buffer != nullptr, "up_vertex_buffer allocated")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  const CmdLoc draw = FindLastOpcode(buf, len, AEROGPU_CMD_DRAW_INDEXED);
  if (!Check(draw.hdr != nullptr, "draw_indexed emitted")) {
    return false;
  }

  const uint32_t up_vb_handle = dev->up_vertex_buffer->handle;
  const aerogpu_cmd_upload_resource* up_upload = nullptr;
  {
    const size_t stream_len = StreamBytesUsed(buf, len);
    size_t offset = sizeof(aerogpu_cmd_stream_header);
    while (offset + sizeof(aerogpu_cmd_hdr) <= stream_len) {
      const auto* hdr = reinterpret_cast<const aerogpu_cmd_hdr*>(buf + offset);
      if (hdr->opcode == AEROGPU_CMD_UPLOAD_RESOURCE) {
        const auto* upload = reinterpret_cast<const aerogpu_cmd_upload_resource*>(hdr);
        if (upload->resource_handle == up_vb_handle && upload->offset_bytes == 0 && offset < draw.offset) {
          up_upload = upload;
          break;
        }
      }
      if (hdr->size_bytes == 0 || hdr->size_bytes > stream_len - offset) {
        break;
      }
      offset += hdr->size_bytes;
    }
  }
  if (!Check(up_upload != nullptr, "upload_resource targeting UP VB emitted before draw")) {
    return false;
  }
  if (!Check(up_upload->size_bytes >= sizeof(VertexTex), "UP VB upload contains at least one vertex")) {
    return false;
  }

  const uint8_t* payload = reinterpret_cast<const uint8_t*>(up_upload) + sizeof(*up_upload);
  float u0 = 0.0f;
  float v0 = 0.0f;
  std::memcpy(&u0, payload + 20, sizeof(float));
  std::memcpy(&v0, payload + 24, sizeof(float));
  if (!Check(std::fabs(u0 - kU) < 1e-6f, "DrawRectPatch(TEX1): u preserved")) {
    return false;
  }
  if (!Check(std::fabs(v0 - kV) < 1e-6f, "DrawRectPatch(TEX1): v preserved")) {
    return false;
  }
  return true;
}

bool TestDrawRectPatchTex1TexcoordSize1ValidatesStrideAndPreservesTexcoords() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hVb{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_vb = false;
    ~Cleanup() {
      if (has_vb && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hVb);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetStreamSource != nullptr, "SetStreamSource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawRectPatch != nullptr, "DrawRectPatch must be available")) {
    return false;
  }

  D3DDDIVIEWPORTINFO vp{};
  vp.X = 0.0f;
  vp.Y = 0.0f;
  vp.Width = 256.0f;
  vp.Height = 256.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }

  // D3DFVF_XYZRHW (0x4) | D3DFVF_DIFFUSE (0x40) | D3DFVF_TEX1 (0x100) | D3DFVF_TEXCOORDSIZE1(0) (0x30000).
  constexpr uint32_t kTexcoordSize1Tex0 = 3u << 16u; // float1
  const uint32_t fvf = kD3dFvfXyzRhw | kD3dFvfDiffuse | kD3dFvfTex1 | kTexcoordSize1Tex0;
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, fvf);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|DIFFUSE|TEX1|TEXCOORDSIZE1(0))")) {
    return false;
  }

  struct VertexTex1 {
    float x;
    float y;
    float z;
    float rhw;
    uint32_t color;
    float u;
  };

  // 4x4 control points (contiguous). Use varying u values so tessellation must
  // compute and write per-vertex u (cannot just memcpy the template vertex).
  VertexTex1 cps[16]{};
  for (uint32_t y = 0; y < 4; ++y) {
    for (uint32_t x = 0; x < 4; ++x) {
      const float fx = static_cast<float>(x) / 3.0f;
      const float fy = static_cast<float>(y) / 3.0f;
      const float px = 256.0f * (0.25f + 0.5f * fx);
      const float py = 256.0f * (0.25f + 0.5f * fy);
      const uint32_t r = static_cast<uint32_t>(fx * 255.0f);
      const uint32_t g = static_cast<uint32_t>(fy * 255.0f);
      cps[y * 4 + x] = {px, py, 0.5f, 1.0f, 0xFF000000u | (r << 16) | (g << 8), fx};
    }
  }

  D3D9DDIARG_CREATERESOURCE create_vb{};
  create_vb.type = 0;
  create_vb.format = 0;
  create_vb.width = 0;
  create_vb.height = 0;
  create_vb.depth = 0;
  create_vb.mip_levels = 1;
  create_vb.usage = 0;
  create_vb.pool = 0;
  create_vb.size = sizeof(cps);
  create_vb.hResource.pDrvPrivate = nullptr;
  create_vb.pSharedHandle = nullptr;
  create_vb.pKmdAllocPrivateData = nullptr;
  create_vb.KmdAllocPrivateDataSize = 0;
  create_vb.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_vb);
  if (!Check(hr == S_OK, "CreateResource(control point VB)")) {
    return false;
  }
  cleanup.hVb = create_vb.hResource;
  cleanup.has_vb = true;

  D3D9DDIARG_LOCK lock{};
  lock.hResource = create_vb.hResource;
  lock.offset_bytes = 0;
  lock.size_bytes = 0;
  lock.flags = 0;
  D3DDDI_LOCKEDBOX box{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(VB)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock returns pData")) {
    return false;
  }
  std::memcpy(box.pData, cps, sizeof(cps));

  D3D9DDIARG_UNLOCK unlock{};
  unlock.hResource = create_vb.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(VB)")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  float segs[4] = {1.0f, 1.0f, 1.0f, 1.0f};
  D3DRECTPATCH_INFO info{};
  info.StartVertexOffset = 0;
  info.NumVertices = 16;
  info.Basis = D3DBASIS_BEZIER;
  info.Degree = D3DDEGREE_CUBIC;
  D3DDDIARG_DRAWRECTPATCH draw_rect{};
  draw_rect.Handle = 1;
  draw_rect.pNumSegs = segs;
  draw_rect.pRectPatchInfo = &info;

  // Stride too small for TEXCOORDSIZE1 should fail.
  hr = cleanup.device_funcs.pfnSetStreamSource(create_dev.hDevice, 0, create_vb.hResource, 0, /*stride=*/20u);
  if (!Check(hr == S_OK, "SetStreamSource(stride=20)")) {
    return false;
  }
  dev->cmd.reset();
  hr = cleanup.device_funcs.pfnDrawRectPatch(create_dev.hDevice, &draw_rect);
  if (!Check(hr == E_FAIL, "DrawRectPatch(TEXCOORDSIZE1 stride<24) fails")) {
    return false;
  }

  // Valid stride should succeed and preserve u values in the uploaded scratch VB.
  hr = cleanup.device_funcs.pfnSetStreamSource(create_dev.hDevice, 0, create_vb.hResource, 0, sizeof(VertexTex1));
  if (!Check(hr == S_OK, "SetStreamSource(stride=24)")) {
    return false;
  }

  // Force a non-trianglelist cached topology so the patch draw must emit a set-topology command.
  const VertexTex1 strip[3] = {cps[0], cps[1], cps[2]};
  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(create_dev.hDevice, D3DDDIPT_TRIANGLESTRIP, 1, strip, sizeof(VertexTex1));
  if (!Check(hr == S_OK, "DrawPrimitiveUP(triangle strip prelude)")) {
    return false;
  }

  dev->cmd.reset();
  hr = cleanup.device_funcs.pfnDrawRectPatch(create_dev.hDevice, &draw_rect);
  if (!Check(hr == S_OK, "DrawRectPatch(TEXCOORDSIZE1 stride=24)")) {
    return false;
  }
  if (!Check(dev->up_vertex_buffer != nullptr, "up_vertex_buffer allocated")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  const CmdLoc draw = FindLastOpcode(buf, len, AEROGPU_CMD_DRAW_INDEXED);
  if (!Check(draw.hdr != nullptr, "draw_indexed emitted")) {
    return false;
  }

  const uint32_t up_vb_handle = dev->up_vertex_buffer->handle;
  const CmdLoc vb_upload = FindLastUploadResourceBefore(buf, len, draw.offset, up_vb_handle);
  if (!Check(vb_upload.hdr != nullptr, "upload_resource targeting UP VB emitted before draw")) {
    return false;
  }
  const auto* up_upload = reinterpret_cast<const aerogpu_cmd_upload_resource*>(vb_upload.hdr);
  if (!Check(up_upload->offset_bytes == 0, "upload_resource UP VB offset is 0")) {
    return false;
  }
  // For segs=1, tessellation produces a 2x2 grid (4 vertices).
  if (!Check(up_upload->size_bytes == 4u * sizeof(VertexTex1), "UP VB upload size matches tessellated float1 vertex data")) {
    return false;
  }

  const uint8_t* payload = reinterpret_cast<const uint8_t*>(up_upload) + sizeof(*up_upload);
  float u0 = 0.0f;
  float u1 = 0.0f;
  std::memcpy(&u0, payload + 20, sizeof(float));
  std::memcpy(&u1, payload + sizeof(VertexTex1) + 20, sizeof(float));

  // For segs_u=segs_v=1, vertices are (u,v)=(0,0),(1,0),(0,1),(1,1), mapping to
  // control points cp[0],cp[3],cp[12],cp[15] respectively.
  if (!Check(std::fabs(u0 - cps[0].u) < 1e-6f, "DrawRectPatch(TEXCOORDSIZE1): u0 preserved")) {
    return false;
  }
  return Check(std::fabs(u1 - cps[3].u) < 1e-6f, "DrawRectPatch(TEXCOORDSIZE1): u1 preserved");
}

bool TestDrawRectPatchTex1TexcoordSize3ValidatesStrideAndPreservesTexcoords() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hVb{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_vb = false;
    ~Cleanup() {
      if (has_vb && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hVb);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetStreamSource != nullptr, "SetStreamSource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawRectPatch != nullptr, "DrawRectPatch must be available")) {
    return false;
  }

  D3DDDIVIEWPORTINFO vp{};
  vp.X = 0.0f;
  vp.Y = 0.0f;
  vp.Width = 256.0f;
  vp.Height = 256.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }

  // D3DFVF_XYZRHW (0x4) | D3DFVF_DIFFUSE (0x40) | D3DFVF_TEX1 (0x100) | D3DFVF_TEXCOORDSIZE3(0) (0x10000).
  constexpr uint32_t kTexcoordSize3Tex0 = 1u << 16u; // float3
  const uint32_t fvf = kD3dFvfXyzRhw | kD3dFvfDiffuse | kD3dFvfTex1 | kTexcoordSize3Tex0;
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, fvf);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|DIFFUSE|TEX1|TEXCOORDSIZE3(0))")) {
    return false;
  }

  struct VertexTex3 {
    float x;
    float y;
    float z;
    float rhw;
    uint32_t color;
    float u;
    float v;
    float w;
  };

  constexpr float kU = 0.25f;
  constexpr float kV = 0.75f;
  constexpr float kW = 0.5f;

  // 4x4 control points (contiguous). Keep it simple: planar quad with constant UVs and constant third texcoord component.
  VertexTex3 cps[16]{};
  for (uint32_t y = 0; y < 4; ++y) {
    for (uint32_t x = 0; x < 4; ++x) {
      const float fx = static_cast<float>(x) / 3.0f;
      const float fy = static_cast<float>(y) / 3.0f;
      const float px = 256.0f * (0.25f + 0.5f * fx);
      const float py = 256.0f * (0.25f + 0.5f * fy);
      const uint32_t r = static_cast<uint32_t>(fx * 255.0f);
      const uint32_t g = static_cast<uint32_t>(fy * 255.0f);
      cps[y * 4 + x] = {px, py, 0.5f, 1.0f, 0xFF000000u | (r << 16) | (g << 8), kU, kV, kW};
    }
  }

  D3D9DDIARG_CREATERESOURCE create_vb{};
  create_vb.type = 0;
  create_vb.format = 0;
  create_vb.width = 0;
  create_vb.height = 0;
  create_vb.depth = 0;
  create_vb.mip_levels = 1;
  create_vb.usage = 0;
  create_vb.pool = 0;
  create_vb.size = sizeof(cps);
  create_vb.hResource.pDrvPrivate = nullptr;
  create_vb.pSharedHandle = nullptr;
  create_vb.pKmdAllocPrivateData = nullptr;
  create_vb.KmdAllocPrivateDataSize = 0;
  create_vb.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_vb);
  if (!Check(hr == S_OK, "CreateResource(control point VB)")) {
    return false;
  }
  cleanup.hVb = create_vb.hResource;
  cleanup.has_vb = true;

  D3D9DDIARG_LOCK lock{};
  lock.hResource = create_vb.hResource;
  lock.offset_bytes = 0;
  lock.size_bytes = 0;
  lock.flags = 0;
  D3DDDI_LOCKEDBOX box{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(VB)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock returns pData")) {
    return false;
  }
  std::memcpy(box.pData, cps, sizeof(cps));

  D3D9DDIARG_UNLOCK unlock{};
  unlock.hResource = create_vb.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(VB)")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  float segs[4] = {1.0f, 1.0f, 1.0f, 1.0f};
  D3DRECTPATCH_INFO info{};
  info.StartVertexOffset = 0;
  info.NumVertices = 16;
  info.Basis = D3DBASIS_BEZIER;
  info.Degree = D3DDEGREE_CUBIC;
  D3DDDIARG_DRAWRECTPATCH draw_rect{};
  draw_rect.Handle = 1;
  draw_rect.pNumSegs = segs;
  draw_rect.pRectPatchInfo = &info;

  // Stride must account for TEXCOORDSIZE3(0).
  hr = cleanup.device_funcs.pfnSetStreamSource(create_dev.hDevice, 0, create_vb.hResource, 0, /*stride=*/28u);
  if (!Check(hr == S_OK, "SetStreamSource(stride=28)")) {
    return false;
  }
  dev->cmd.reset();
  hr = cleanup.device_funcs.pfnDrawRectPatch(create_dev.hDevice, &draw_rect);
  if (!Check(hr == E_FAIL, "DrawRectPatch(TEXCOORDSIZE3 stride<32) fails")) {
    return false;
  }

  // Valid stride should succeed and preserve UVs in the uploaded scratch VB.
  hr = cleanup.device_funcs.pfnSetStreamSource(create_dev.hDevice, 0, create_vb.hResource, 0, sizeof(VertexTex3));
  if (!Check(hr == S_OK, "SetStreamSource(stride=32)")) {
    return false;
  }

  // Force a non-trianglelist cached topology so the patch draw must emit a set-topology command.
  const VertexTex3 strip[3] = {cps[0], cps[1], cps[2]};
  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(create_dev.hDevice, D3DDDIPT_TRIANGLESTRIP, 1, strip, sizeof(VertexTex3));
  if (!Check(hr == S_OK, "DrawPrimitiveUP(triangle strip prelude)")) {
    return false;
  }

  dev->cmd.reset();
  hr = cleanup.device_funcs.pfnDrawRectPatch(create_dev.hDevice, &draw_rect);
  if (!Check(hr == S_OK, "DrawRectPatch(TEXCOORDSIZE3 stride=32)")) {
    return false;
  }
  if (!Check(dev->up_vertex_buffer != nullptr, "up_vertex_buffer allocated")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  const CmdLoc draw = FindLastOpcode(buf, len, AEROGPU_CMD_DRAW_INDEXED);
  if (!Check(draw.hdr != nullptr, "draw_indexed emitted")) {
    return false;
  }

  const uint32_t up_vb_handle = dev->up_vertex_buffer->handle;
  const CmdLoc vb_upload = FindLastUploadResourceBefore(buf, len, draw.offset, up_vb_handle);
  if (!Check(vb_upload.hdr != nullptr, "upload_resource targeting UP VB emitted before draw")) {
    return false;
  }
  const auto* up_upload = reinterpret_cast<const aerogpu_cmd_upload_resource*>(vb_upload.hdr);
  if (!Check(up_upload->offset_bytes == 0, "upload_resource UP VB offset is 0")) {
    return false;
  }
  // For segs=1, tessellation produces a 2x2 grid (4 vertices).
  if (!Check(up_upload->size_bytes == 4u * sizeof(VertexTex3), "UP VB upload size matches tessellated float3 vertex data")) {
    return false;
  }

  const uint8_t* payload = reinterpret_cast<const uint8_t*>(up_upload) + sizeof(*up_upload);
  float u0 = 0.0f;
  float v0 = 0.0f;
  std::memcpy(&u0, payload + 20, sizeof(float));
  std::memcpy(&v0, payload + 24, sizeof(float));
  if (!Check(std::fabs(u0 - kU) < 1e-6f, "DrawRectPatch(TEXCOORDSIZE3): u preserved")) {
    return false;
  }
  return Check(std::fabs(v0 - kV) < 1e-6f, "DrawRectPatch(TEXCOORDSIZE3): v preserved");
}

bool TestDrawRectPatchTex1TexcoordSize4ValidatesStrideAndPreservesTexcoords() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hVb{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_vb = false;
    ~Cleanup() {
      if (has_vb && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hVb);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetStreamSource != nullptr, "SetStreamSource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawRectPatch != nullptr, "DrawRectPatch must be available")) {
    return false;
  }

  D3DDDIVIEWPORTINFO vp{};
  vp.X = 0.0f;
  vp.Y = 0.0f;
  vp.Width = 256.0f;
  vp.Height = 256.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }

  // D3DFVF_XYZRHW (0x4) | D3DFVF_DIFFUSE (0x40) | D3DFVF_TEX1 (0x100) | D3DFVF_TEXCOORDSIZE4(0) (0x20000).
  constexpr uint32_t kTexcoordSize4Tex0 = 2u << 16u; // float4
  const uint32_t fvf = kD3dFvfXyzRhw | kD3dFvfDiffuse | kD3dFvfTex1 | kTexcoordSize4Tex0;
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, fvf);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|DIFFUSE|TEX1|TEXCOORDSIZE4(0))")) {
    return false;
  }

  struct VertexTex4 {
    float x;
    float y;
    float z;
    float rhw;
    uint32_t color;
    float u;
    float v;
    float w;
    float q;
  };

  constexpr float kU = 0.25f;
  constexpr float kV = 0.75f;
  constexpr float kW = 0.5f;
  constexpr float kQ = 1.0f;

  // 4x4 control points (contiguous). Keep it simple: planar quad with constant UVs and constant extra texcoord components.
  VertexTex4 cps[16]{};
  for (uint32_t y = 0; y < 4; ++y) {
    for (uint32_t x = 0; x < 4; ++x) {
      const float fx = static_cast<float>(x) / 3.0f;
      const float fy = static_cast<float>(y) / 3.0f;
      const float px = 256.0f * (0.25f + 0.5f * fx);
      const float py = 256.0f * (0.25f + 0.5f * fy);
      const uint32_t r = static_cast<uint32_t>(fx * 255.0f);
      const uint32_t g = static_cast<uint32_t>(fy * 255.0f);
      cps[y * 4 + x] = {px, py, 0.5f, 1.0f, 0xFF000000u | (r << 16) | (g << 8), kU, kV, kW, kQ};
    }
  }

  D3D9DDIARG_CREATERESOURCE create_vb{};
  create_vb.type = 0;
  create_vb.format = 0;
  create_vb.width = 0;
  create_vb.height = 0;
  create_vb.depth = 0;
  create_vb.mip_levels = 1;
  create_vb.usage = 0;
  create_vb.pool = 0;
  create_vb.size = sizeof(cps);
  create_vb.hResource.pDrvPrivate = nullptr;
  create_vb.pSharedHandle = nullptr;
  create_vb.pKmdAllocPrivateData = nullptr;
  create_vb.KmdAllocPrivateDataSize = 0;
  create_vb.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_vb);
  if (!Check(hr == S_OK, "CreateResource(control point VB)")) {
    return false;
  }
  cleanup.hVb = create_vb.hResource;
  cleanup.has_vb = true;

  D3D9DDIARG_LOCK lock{};
  lock.hResource = create_vb.hResource;
  lock.offset_bytes = 0;
  lock.size_bytes = 0;
  lock.flags = 0;
  D3DDDI_LOCKEDBOX box{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(VB)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock returns pData")) {
    return false;
  }
  std::memcpy(box.pData, cps, sizeof(cps));

  D3D9DDIARG_UNLOCK unlock{};
  unlock.hResource = create_vb.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(VB)")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  float segs[4] = {1.0f, 1.0f, 1.0f, 1.0f};
  D3DRECTPATCH_INFO info{};
  info.StartVertexOffset = 0;
  info.NumVertices = 16;
  info.Basis = D3DBASIS_BEZIER;
  info.Degree = D3DDEGREE_CUBIC;
  D3DDDIARG_DRAWRECTPATCH draw_rect{};
  draw_rect.Handle = 1;
  draw_rect.pNumSegs = segs;
  draw_rect.pRectPatchInfo = &info;

  // Stride must account for TEXCOORDSIZE4(0).
  hr = cleanup.device_funcs.pfnSetStreamSource(create_dev.hDevice, 0, create_vb.hResource, 0, /*stride=*/32u);
  if (!Check(hr == S_OK, "SetStreamSource(stride=32)")) {
    return false;
  }
  dev->cmd.reset();
  hr = cleanup.device_funcs.pfnDrawRectPatch(create_dev.hDevice, &draw_rect);
  if (!Check(hr == E_FAIL, "DrawRectPatch(TEXCOORDSIZE4 stride<36) fails")) {
    return false;
  }

  // Valid stride should succeed and preserve UVs in the uploaded scratch VB.
  hr = cleanup.device_funcs.pfnSetStreamSource(create_dev.hDevice, 0, create_vb.hResource, 0, sizeof(VertexTex4));
  if (!Check(hr == S_OK, "SetStreamSource(stride=36)")) {
    return false;
  }

  // Force a non-trianglelist cached topology so the patch draw must emit a set-topology command.
  const VertexTex4 strip[3] = {cps[0], cps[1], cps[2]};
  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(create_dev.hDevice, D3DDDIPT_TRIANGLESTRIP, 1, strip, sizeof(VertexTex4));
  if (!Check(hr == S_OK, "DrawPrimitiveUP(triangle strip prelude)")) {
    return false;
  }

  dev->cmd.reset();
  hr = cleanup.device_funcs.pfnDrawRectPatch(create_dev.hDevice, &draw_rect);
  if (!Check(hr == S_OK, "DrawRectPatch(TEXCOORDSIZE4 stride=36)")) {
    return false;
  }
  if (!Check(dev->up_vertex_buffer != nullptr, "up_vertex_buffer allocated")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  const CmdLoc draw = FindLastOpcode(buf, len, AEROGPU_CMD_DRAW_INDEXED);
  if (!Check(draw.hdr != nullptr, "draw_indexed emitted")) {
    return false;
  }

  const uint32_t up_vb_handle = dev->up_vertex_buffer->handle;
  const CmdLoc vb_upload = FindLastUploadResourceBefore(buf, len, draw.offset, up_vb_handle);
  if (!Check(vb_upload.hdr != nullptr, "upload_resource targeting UP VB emitted before draw")) {
    return false;
  }
  const auto* up_upload = reinterpret_cast<const aerogpu_cmd_upload_resource*>(vb_upload.hdr);
  if (!Check(up_upload->offset_bytes == 0, "upload_resource UP VB offset is 0")) {
    return false;
  }
  // For segs=1, tessellation produces a 2x2 grid (4 vertices).
  if (!Check(up_upload->size_bytes == 4u * sizeof(VertexTex4), "UP VB upload size matches tessellated float4 vertex data")) {
    return false;
  }

  const uint8_t* payload = reinterpret_cast<const uint8_t*>(up_upload) + sizeof(*up_upload);
  float u0 = 0.0f;
  float v0 = 0.0f;
  float w0 = 0.0f;
  float q0 = 0.0f;
  std::memcpy(&u0, payload + 20, sizeof(float));
  std::memcpy(&v0, payload + 24, sizeof(float));
  std::memcpy(&w0, payload + 28, sizeof(float));
  std::memcpy(&q0, payload + 32, sizeof(float));
  if (!Check(std::fabs(u0 - kU) < 1e-6f, "DrawRectPatch(TEXCOORDSIZE4): u preserved")) {
    return false;
  }
  if (!Check(std::fabs(v0 - kV) < 1e-6f, "DrawRectPatch(TEXCOORDSIZE4): v preserved")) {
    return false;
  }
  if (!Check(std::fabs(w0 - kW) < 1e-6f, "DrawRectPatch(TEXCOORDSIZE4): w preserved from template")) {
    return false;
  }
  return Check(std::fabs(q0 - kQ) < 1e-6f, "DrawRectPatch(TEXCOORDSIZE4): q preserved from template");
}

bool TestDrawTriPatchEmitsDrawIndexedAndUploadsScratchVb() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hVb{};
    D3DDDI_HRESOURCE hIb{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_vb = false;
    bool has_ib = false;

    ~Cleanup() {
      if (has_ib && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hIb);
      }
      if (has_vb && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hVb);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetStreamSource != nullptr, "SetStreamSource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawTriPatch != nullptr, "DrawTriPatch must be available")) {
    return false;
  }

  D3DDDIVIEWPORTINFO vp{};
  vp.X = 0.0f;
  vp.Y = 0.0f;
  vp.Width = 256.0f;
  vp.Height = 256.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }

  // D3DFVF_XYZRHW (0x4) | D3DFVF_DIFFUSE (0x40).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x44u);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|DIFFUSE)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    float rhw;
    uint32_t color;
  };

  // 10 control points (cubic triangular Bezier patch). Keep it simple.
  Vertex cps[10]{};
  for (uint32_t i = 0; i < 10; ++i) {
    const float t = static_cast<float>(i) / 9.0f;
    cps[i].x = 256.0f * (0.25f + 0.5f * t);
    cps[i].y = 256.0f * (0.25f + 0.25f * t);
    cps[i].z = 0.5f;
    cps[i].rhw = 1.0f;
    const uint32_t r = static_cast<uint32_t>(t * 255.0f);
    cps[i].color = 0xFF000000u | (r << 16);
  }

  D3D9DDIARG_CREATERESOURCE create_vb{};
  create_vb.type = 0;
  create_vb.format = 0;
  create_vb.width = 0;
  create_vb.height = 0;
  create_vb.depth = 0;
  create_vb.mip_levels = 1;
  create_vb.usage = 0;
  create_vb.pool = 0;
  create_vb.size = sizeof(cps);
  create_vb.hResource.pDrvPrivate = nullptr;
  create_vb.pSharedHandle = nullptr;
  create_vb.pKmdAllocPrivateData = nullptr;
  create_vb.KmdAllocPrivateDataSize = 0;
  create_vb.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_vb);
  if (!Check(hr == S_OK, "CreateResource(control point VB)")) {
    return false;
  }
  cleanup.hVb = create_vb.hResource;
  cleanup.has_vb = true;

  D3D9DDIARG_LOCK lock{};
  lock.hResource = create_vb.hResource;
  lock.offset_bytes = 0;
  lock.size_bytes = 0;
  lock.flags = 0;
  D3DDDI_LOCKEDBOX box{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(VB)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock returns pData")) {
    return false;
  }
  std::memcpy(box.pData, cps, sizeof(cps));

  D3D9DDIARG_UNLOCK unlock{};
  unlock.hResource = create_vb.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(VB)")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnSetStreamSource(create_dev.hDevice, 0, create_vb.hResource, 0, sizeof(Vertex));
  if (!Check(hr == S_OK, "SetStreamSource")) {
    return false;
  }

  // Bind an app-provided index buffer so we can validate that DrawTriPatch
  // restores it after temporarily binding the scratch UP index buffer.
  const uint16_t app_indices[3] = {0, 1, 2};
  D3D9DDIARG_CREATERESOURCE create_ib{};
  create_ib.type = 0;
  create_ib.format = 0;
  create_ib.width = 0;
  create_ib.height = 0;
  create_ib.depth = 0;
  create_ib.mip_levels = 1;
  create_ib.usage = 0;
  create_ib.pool = 0;
  create_ib.size = sizeof(app_indices);
  create_ib.hResource.pDrvPrivate = nullptr;
  create_ib.pSharedHandle = nullptr;
  create_ib.pKmdAllocPrivateData = nullptr;
  create_ib.KmdAllocPrivateDataSize = 0;
  create_ib.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_ib);
  if (!Check(hr == S_OK, "CreateResource(app index buffer)")) {
    return false;
  }
  cleanup.hIb = create_ib.hResource;
  cleanup.has_ib = true;

  lock.hResource = create_ib.hResource;
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(IB)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock(IB) returns pData")) {
    return false;
  }
  std::memcpy(box.pData, app_indices, sizeof(app_indices));

  unlock.hResource = create_ib.hResource;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(IB)")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnSetIndices(create_dev.hDevice, create_ib.hResource, kD3dFmtIndex16, 0);
  if (!Check(hr == S_OK, "SetIndices")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  const Vertex strip[3] = {cps[0], cps[1], cps[2]};
  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(create_dev.hDevice, D3DDDIPT_TRIANGLESTRIP, 1, strip, sizeof(Vertex));
  if (!Check(hr == S_OK, "DrawPrimitiveUP(triangle strip prelude)")) {
    return false;
  }

  float segs[3] = {1.0f, 1.0f, 1.0f};
  D3DTRIPATCH_INFO info{};
  info.StartVertexOffset = 0;
  info.NumVertices = 10;
  info.Basis = D3DBASIS_BEZIER;
  info.Degree = D3DDEGREE_CUBIC;

  D3DDDIARG_DRAWTRIPATCH draw_tri{};
  draw_tri.Handle = 1;
  draw_tri.pNumSegs = segs;
  draw_tri.pTriPatchInfo = &info;

  hr = cleanup.device_funcs.pfnDrawTriPatch(create_dev.hDevice, &draw_tri);
  if (!Check(hr == S_OK, "DrawTriPatch")) {
    return false;
  }

  auto* vb_res = reinterpret_cast<Resource*>(create_vb.hResource.pDrvPrivate);
  auto* ib_res = reinterpret_cast<Resource*>(create_ib.hResource.pDrvPrivate);
  if (!Check(vb_res != nullptr, "VB resource pointer")) {
    return false;
  }
  if (!Check(ib_res != nullptr, "IB resource pointer")) {
    return false;
  }
  if (!Check(dev->streams[0].vb == vb_res, "DrawTriPatch restores stream source 0")) {
    return false;
  }
  if (!Check(dev->index_buffer == ib_res, "DrawTriPatch restores index buffer")) {
    return false;
  }

  if (!Check(dev->up_vertex_buffer != nullptr, "up_vertex_buffer allocated")) {
    return false;
  }
  if (!Check(dev->up_index_buffer != nullptr, "up_index_buffer allocated")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  const CmdLoc draw = FindLastOpcode(buf, len, AEROGPU_CMD_DRAW_INDEXED);
  if (!Check(draw.hdr != nullptr, "draw_indexed emitted")) {
    return false;
  }

  const CmdLoc topo = FindLastOpcodeBefore(buf, len, draw.offset, AEROGPU_CMD_SET_PRIMITIVE_TOPOLOGY);
  if (!Check(topo.hdr != nullptr, "set_primitive_topology emitted before draw")) {
    return false;
  }
  const auto* topo_cmd = reinterpret_cast<const aerogpu_cmd_set_primitive_topology*>(topo.hdr);
  if (!Check(topo_cmd->topology == AEROGPU_TOPOLOGY_TRIANGLELIST, "tri patch draw uses TRIANGLELIST topology")) {
    return false;
  }

  // Verify scratch VB/IB uploads targeting the UP buffers occurred before the draw.
  const uint32_t up_vb_handle = dev->up_vertex_buffer->handle;
  const uint32_t up_ib_handle = dev->up_index_buffer->handle;
  const CmdLoc vb_upload = FindLastUploadResourceBefore(buf, len, draw.offset, up_vb_handle);
  const CmdLoc ib_upload = FindLastUploadResourceBefore(buf, len, draw.offset, up_ib_handle);
  if (!Check(vb_upload.hdr != nullptr, "upload_resource targeting UP VB emitted before draw")) {
    return false;
  }
  if (!Check(ib_upload.hdr != nullptr, "upload_resource targeting UP IB emitted before draw")) {
    return false;
  }

  const auto* vb_upload_cmd = reinterpret_cast<const aerogpu_cmd_upload_resource*>(vb_upload.hdr);
  const auto* ib_upload_cmd = reinterpret_cast<const aerogpu_cmd_upload_resource*>(ib_upload.hdr);
  const uint32_t expected_vb_upload = 3u * sizeof(Vertex); // segs=1 produces 3 vertices
  const uint32_t expected_ib_upload = static_cast<uint32_t>(AlignUp(6u, 4u)); // 3 u16 indices (aligned)
  if (!Check(vb_upload_cmd->size_bytes == expected_vb_upload, "UP VB upload size matches tessellated vertex data")) {
    return false;
  }
  if (!Check(ib_upload_cmd->size_bytes == expected_ib_upload, "UP IB upload size matches tessellated index data (aligned)")) {
    return false;
  }

  const CmdLoc set_ib = FindLastOpcodeBefore(buf, len, draw.offset, AEROGPU_CMD_SET_INDEX_BUFFER);
  if (!Check(set_ib.hdr != nullptr, "set_index_buffer emitted before draw")) {
    return false;
  }
  const auto* set_ib_cmd = reinterpret_cast<const aerogpu_cmd_set_index_buffer*>(set_ib.hdr);
  if (!Check(set_ib_cmd->buffer == up_ib_handle, "tri patch draw binds UP IB")) {
    return false;
  }

  // Validate the restore commands after the draw.
  const CmdLoc restore_ib = FindLastOpcode(buf, len, AEROGPU_CMD_SET_INDEX_BUFFER);
  if (!Check(restore_ib.hdr != nullptr, "set_index_buffer restore emitted")) {
    return false;
  }
  if (!Check(restore_ib.offset > draw.offset, "set_index_buffer restore occurs after draw")) {
    return false;
  }
  const auto* restore_ib_cmd = reinterpret_cast<const aerogpu_cmd_set_index_buffer*>(restore_ib.hdr);
  if (!Check(restore_ib_cmd->buffer == ib_res->handle, "tri patch restores app IB binding")) {
    return false;
  }

  const CmdLoc restore_vb = FindLastOpcode(buf, len, AEROGPU_CMD_SET_VERTEX_BUFFERS);
  if (!Check(restore_vb.hdr != nullptr, "set_vertex_buffers restore emitted")) {
    return false;
  }
  if (!Check(restore_vb.offset > draw.offset, "set_vertex_buffers restore occurs after draw")) {
    return false;
  }
  const auto* restore_vb_cmd = reinterpret_cast<const aerogpu_cmd_set_vertex_buffers*>(restore_vb.hdr);
  if (!Check(restore_vb_cmd->start_slot == 0 && restore_vb_cmd->buffer_count == 1, "set_vertex_buffers restore binds slot 0")) {
    return false;
  }
  const auto* binding = reinterpret_cast<const aerogpu_vertex_buffer_binding*>(
      reinterpret_cast<const uint8_t*>(restore_vb_cmd) + sizeof(*restore_vb_cmd));
  if (!Check(binding->buffer == vb_res->handle, "tri patch restores app VB binding")) {
    return false;
  }
  if (!Check(binding->stride_bytes == sizeof(Vertex), "tri patch restores VB stride")) {
    return false;
  }
  return Check(binding->offset_bytes == 0, "tri patch restores VB offset");
}

bool TestDrawRectPatchTex1UploadsTexcoords() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hVb{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_vb = false;

    ~Cleanup() {
      if (has_vb && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hVb);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetStreamSource != nullptr, "SetStreamSource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawRectPatch != nullptr, "DrawRectPatch must be available")) {
    return false;
  }

  D3DDDIVIEWPORTINFO vp{};
  vp.X = 0.0f;
  vp.Y = 0.0f;
  vp.Width = 256.0f;
  vp.Height = 256.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }

  // D3DFVF_XYZRHW (0x4) | D3DFVF_DIFFUSE (0x40) | D3DFVF_TEX1 (0x100).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x144u);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|DIFFUSE|TEX1)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    float rhw;
    uint32_t color;
    float u;
    float v;
  };

  Vertex cps[16]{};
  for (uint32_t y = 0; y < 4; ++y) {
    for (uint32_t x = 0; x < 4; ++x) {
      const float fx = static_cast<float>(x) / 3.0f;
      const float fy = static_cast<float>(y) / 3.0f;
      cps[y * 4 + x] = {
          256.0f * (0.25f + 0.5f * fx),
          256.0f * (0.25f + 0.5f * fy),
          0.5f,
          1.0f,
          0xFF000000u,
          fx,
          fy,
      };
    }
  }

  D3D9DDIARG_CREATERESOURCE create_vb{};
  create_vb.type = 0;
  create_vb.format = 0;
  create_vb.width = 0;
  create_vb.height = 0;
  create_vb.depth = 0;
  create_vb.mip_levels = 1;
  create_vb.usage = 0;
  create_vb.pool = 0;
  create_vb.size = sizeof(cps);
  create_vb.hResource.pDrvPrivate = nullptr;
  create_vb.pSharedHandle = nullptr;
  create_vb.pKmdAllocPrivateData = nullptr;
  create_vb.KmdAllocPrivateDataSize = 0;
  create_vb.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_vb);
  if (!Check(hr == S_OK, "CreateResource(control point VB)")) {
    return false;
  }
  cleanup.hVb = create_vb.hResource;
  cleanup.has_vb = true;

  D3D9DDIARG_LOCK lock{};
  lock.hResource = create_vb.hResource;
  lock.offset_bytes = 0;
  lock.size_bytes = 0;
  lock.flags = 0;
  D3DDDI_LOCKEDBOX box{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(VB)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock returns pData")) {
    return false;
  }
  std::memcpy(box.pData, cps, sizeof(cps));

  D3D9DDIARG_UNLOCK unlock{};
  unlock.hResource = create_vb.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(VB)")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnSetStreamSource(create_dev.hDevice, 0, create_vb.hResource, 0, sizeof(Vertex));
  if (!Check(hr == S_OK, "SetStreamSource")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  const Vertex strip[3] = {cps[0], cps[1], cps[2]};
  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(create_dev.hDevice, D3DDDIPT_TRIANGLESTRIP, 1, strip, sizeof(Vertex));
  if (!Check(hr == S_OK, "DrawPrimitiveUP(triangle strip prelude)")) {
    return false;
  }

  float segs[4] = {1.0f, 1.0f, 1.0f, 1.0f};
  D3DRECTPATCH_INFO info{};
  info.StartVertexOffset = 0;
  info.NumVertices = 16;
  info.Basis = D3DBASIS_BEZIER;
  info.Degree = D3DDEGREE_CUBIC;

  D3DDDIARG_DRAWRECTPATCH draw_rect{};
  draw_rect.Handle = 1;
  draw_rect.pNumSegs = segs;
  draw_rect.pRectPatchInfo = &info;

  hr = cleanup.device_funcs.pfnDrawRectPatch(create_dev.hDevice, &draw_rect);
  if (!Check(hr == S_OK, "DrawRectPatch")) {
    return false;
  }

  if (!Check(dev->up_vertex_buffer != nullptr, "up_vertex_buffer allocated")) {
    return false;
  }
  if (!Check(dev->up_index_buffer != nullptr, "up_index_buffer allocated")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  const CmdLoc draw = FindLastOpcode(buf, len, AEROGPU_CMD_DRAW_INDEXED);
  if (!Check(draw.hdr != nullptr, "draw_indexed emitted")) {
    return false;
  }

  const uint32_t up_vb_handle = dev->up_vertex_buffer->handle;
  const CmdLoc vb_upload = FindLastUploadResourceBefore(buf, len, draw.offset, up_vb_handle);
  if (!Check(vb_upload.hdr != nullptr, "upload_resource targeting UP VB emitted before draw")) {
    return false;
  }

  const auto* upload_cmd = reinterpret_cast<const aerogpu_cmd_upload_resource*>(vb_upload.hdr);
  if (!Check(upload_cmd->size_bytes == 4u * sizeof(Vertex), "rect patch tex1 upload size matches tessellated vertex data")) {
    return false;
  }

  const uint8_t* payload = reinterpret_cast<const uint8_t*>(upload_cmd) + sizeof(*upload_cmd);
  float u0 = 0.0f;
  float v0 = 0.0f;
  float u1 = 0.0f;
  float v1 = 0.0f;
  float u3 = 0.0f;
  float v3 = 0.0f;
  std::memcpy(&u0, payload + 20, sizeof(float));
  std::memcpy(&v0, payload + 24, sizeof(float));
  std::memcpy(&u1, payload + sizeof(Vertex) + 20, sizeof(float));
  std::memcpy(&v1, payload + sizeof(Vertex) + 24, sizeof(float));
  std::memcpy(&u3, payload + 3 * sizeof(Vertex) + 20, sizeof(float));
  std::memcpy(&v3, payload + 3 * sizeof(Vertex) + 24, sizeof(float));

  if (!Check(std::fabs(u0 - cps[0].u) < 1e-6f, "rect patch tex1: u0 preserved")) {
    return false;
  }
  if (!Check(std::fabs(v0 - cps[0].v) < 1e-6f, "rect patch tex1: v0 preserved")) {
    return false;
  }
  if (!Check(std::fabs(u1 - cps[3].u) < 1e-6f, "rect patch tex1: u1 preserved")) {
    return false;
  }
  if (!Check(std::fabs(v1 - cps[3].v) < 1e-6f, "rect patch tex1: v1 preserved")) {
    return false;
  }
  if (!Check(std::fabs(u3 - cps[15].u) < 1e-6f, "rect patch tex1: u3 preserved")) {
    return false;
  }
  return Check(std::fabs(v3 - cps[15].v) < 1e-6f, "rect patch tex1: v3 preserved");
}

bool TestDrawTriPatchTex1UploadsTexcoords() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hVb{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_vb = false;

    ~Cleanup() {
      if (has_vb && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hVb);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetStreamSource != nullptr, "SetStreamSource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawPrimitiveUP != nullptr, "DrawPrimitiveUP must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawTriPatch != nullptr, "DrawTriPatch must be available")) {
    return false;
  }

  D3DDDIVIEWPORTINFO vp{};
  vp.X = 0.0f;
  vp.Y = 0.0f;
  vp.Width = 256.0f;
  vp.Height = 256.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }

  // D3DFVF_XYZRHW (0x4) | D3DFVF_DIFFUSE (0x40) | D3DFVF_TEX1 (0x100).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x144u);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|DIFFUSE|TEX1)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    float rhw;
    uint32_t color;
    float u;
    float v;
  };

  Vertex cps[10]{};
  for (uint32_t i = 0; i < 10; ++i) {
    cps[i].x = 64.0f + static_cast<float>(i);
    cps[i].y = 64.0f + static_cast<float>(i);
    cps[i].z = 0.5f;
    cps[i].rhw = 1.0f;
    cps[i].color = 0xFF000000u;
    cps[i].u = static_cast<float>(i) / 9.0f;
    cps[i].v = 1.0f - static_cast<float>(i) / 9.0f;
  }

  D3D9DDIARG_CREATERESOURCE create_vb{};
  create_vb.type = 0;
  create_vb.format = 0;
  create_vb.width = 0;
  create_vb.height = 0;
  create_vb.depth = 0;
  create_vb.mip_levels = 1;
  create_vb.usage = 0;
  create_vb.pool = 0;
  create_vb.size = sizeof(cps);
  create_vb.hResource.pDrvPrivate = nullptr;
  create_vb.pSharedHandle = nullptr;
  create_vb.pKmdAllocPrivateData = nullptr;
  create_vb.KmdAllocPrivateDataSize = 0;
  create_vb.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_vb);
  if (!Check(hr == S_OK, "CreateResource(control point VB)")) {
    return false;
  }
  cleanup.hVb = create_vb.hResource;
  cleanup.has_vb = true;

  D3D9DDIARG_LOCK lock{};
  lock.hResource = create_vb.hResource;
  lock.offset_bytes = 0;
  lock.size_bytes = 0;
  lock.flags = 0;
  D3DDDI_LOCKEDBOX box{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(VB)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock returns pData")) {
    return false;
  }
  std::memcpy(box.pData, cps, sizeof(cps));

  D3D9DDIARG_UNLOCK unlock{};
  unlock.hResource = create_vb.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(VB)")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnSetStreamSource(create_dev.hDevice, 0, create_vb.hResource, 0, sizeof(Vertex));
  if (!Check(hr == S_OK, "SetStreamSource")) {
    return false;
  }

  float segs[3] = {1.0f, 1.0f, 1.0f};
  D3DTRIPATCH_INFO info{};
  info.StartVertexOffset = 0;
  info.NumVertices = 10;
  info.Basis = D3DBASIS_BEZIER;
  info.Degree = D3DDEGREE_CUBIC;

  D3DDDIARG_DRAWTRIPATCH draw_tri{};
  draw_tri.Handle = 1;
  draw_tri.pNumSegs = segs;
  draw_tri.pTriPatchInfo = &info;

  hr = cleanup.device_funcs.pfnDrawTriPatch(create_dev.hDevice, &draw_tri);
  if (!Check(hr == S_OK, "DrawTriPatch")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  if (!Check(dev->up_vertex_buffer != nullptr, "up_vertex_buffer allocated")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  const CmdLoc draw = FindLastOpcode(buf, len, AEROGPU_CMD_DRAW_INDEXED);
  if (!Check(draw.hdr != nullptr, "draw_indexed emitted")) {
    return false;
  }

  const uint32_t up_vb_handle = dev->up_vertex_buffer->handle;
  const CmdLoc vb_upload = FindLastUploadResourceBefore(buf, len, draw.offset, up_vb_handle);
  if (!Check(vb_upload.hdr != nullptr, "upload_resource targeting UP VB emitted before draw")) {
    return false;
  }

  const auto* upload_cmd = reinterpret_cast<const aerogpu_cmd_upload_resource*>(vb_upload.hdr);
  if (!Check(upload_cmd->size_bytes == 3u * sizeof(Vertex), "tri patch tex1 upload size matches tessellated vertex data")) {
    return false;
  }

  const uint8_t* payload = reinterpret_cast<const uint8_t*>(upload_cmd) + sizeof(*upload_cmd);
  float u0 = 0.0f;
  float v0 = 0.0f;
  float u1 = 0.0f;
  float v1 = 0.0f;
  float u2 = 0.0f;
  float v2 = 0.0f;
  std::memcpy(&u0, payload + 20, sizeof(float));
  std::memcpy(&v0, payload + 24, sizeof(float));
  std::memcpy(&u1, payload + sizeof(Vertex) + 20, sizeof(float));
  std::memcpy(&v1, payload + sizeof(Vertex) + 24, sizeof(float));
  std::memcpy(&u2, payload + 2 * sizeof(Vertex) + 20, sizeof(float));
  std::memcpy(&v2, payload + 2 * sizeof(Vertex) + 24, sizeof(float));

  // For segs=1, the tessellator emits 3 vertices in this order: cp[9] (w corner), cp[3] (v corner), cp[0] (u corner).
  if (!Check(std::fabs(u0 - cps[9].u) < 1e-6f, "tri patch tex1: u0 preserved")) {
    return false;
  }
  if (!Check(std::fabs(v0 - cps[9].v) < 1e-6f, "tri patch tex1: v0 preserved")) {
    return false;
  }
  if (!Check(std::fabs(u1 - cps[3].u) < 1e-6f, "tri patch tex1: u1 preserved")) {
    return false;
  }
  if (!Check(std::fabs(v1 - cps[3].v) < 1e-6f, "tri patch tex1: v1 preserved")) {
    return false;
  }
  if (!Check(std::fabs(u2 - cps[0].u) < 1e-6f, "tri patch tex1: u2 preserved")) {
    return false;
  }
  return Check(std::fabs(v2 - cps[0].v) < 1e-6f, "tri patch tex1: v2 preserved");
}

bool TestDrawPatchInvalidInfoReturnsInvalidCall() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hVb{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_vb = false;
    ~Cleanup() {
      if (has_vb && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hVb);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetStreamSource != nullptr, "SetStreamSource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawRectPatch != nullptr, "DrawRectPatch must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawTriPatch != nullptr, "DrawTriPatch must be available")) {
    return false;
  }

  D3DDDIVIEWPORTINFO vp{};
  vp.X = 0.0f;
  vp.Y = 0.0f;
  vp.Width = 256.0f;
  vp.Height = 256.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }

  // D3DFVF_XYZRHW (0x4) | D3DFVF_DIFFUSE (0x40).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x44u);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|DIFFUSE)")) {
    return false;
  }

  struct Vertex {
    float x;
    float y;
    float z;
    float rhw;
    uint32_t color;
  };

  // 16 control points for rect patch (and enough bytes for any invalid NumVertices).
  Vertex cps[16]{};
  for (uint32_t i = 0; i < 16; ++i) {
    cps[i] = {64.0f, 64.0f, 0.5f, 1.0f, 0xFFFFFFFFu};
  }

  D3D9DDIARG_CREATERESOURCE create_vb{};
  create_vb.type = 0;
  create_vb.format = 0;
  create_vb.width = 0;
  create_vb.height = 0;
  create_vb.depth = 0;
  create_vb.mip_levels = 1;
  create_vb.usage = 0;
  create_vb.pool = 0;
  create_vb.size = sizeof(cps);
  create_vb.hResource.pDrvPrivate = nullptr;
  create_vb.pSharedHandle = nullptr;
  create_vb.pKmdAllocPrivateData = nullptr;
  create_vb.KmdAllocPrivateDataSize = 0;
  create_vb.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_vb);
  if (!Check(hr == S_OK, "CreateResource(control point VB)")) {
    return false;
  }
  cleanup.hVb = create_vb.hResource;
  cleanup.has_vb = true;

  D3D9DDIARG_LOCK lock{};
  lock.hResource = create_vb.hResource;
  lock.offset_bytes = 0;
  lock.size_bytes = 0;
  lock.flags = 0;
  D3DDDI_LOCKEDBOX box{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(VB)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock returns pData")) {
    return false;
  }
  std::memcpy(box.pData, cps, sizeof(cps));

  D3D9DDIARG_UNLOCK unlock{};
  unlock.hResource = create_vb.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(VB)")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnSetStreamSource(create_dev.hDevice, 0, create_vb.hResource, 0, sizeof(Vertex));
  if (!Check(hr == S_OK, "SetStreamSource")) {
    return false;
  }

  float rect_segs[4] = {1.0f, 1.0f, 1.0f, 1.0f};
  D3DRECTPATCH_INFO rect_info{};
  rect_info.StartVertexOffset = 0;
  rect_info.NumVertices = 15; // invalid (must be 16)
  rect_info.Basis = D3DBASIS_BEZIER;
  rect_info.Degree = D3DDEGREE_CUBIC;
  D3DDDIARG_DRAWRECTPATCH draw_rect{};
  draw_rect.Handle = 1;
  draw_rect.pNumSegs = rect_segs;
  draw_rect.pRectPatchInfo = &rect_info;

  hr = cleanup.device_funcs.pfnDrawRectPatch(create_dev.hDevice, &draw_rect);
  if (!Check(hr == kD3DErrInvalidCall, "DrawRectPatch invalid info returns D3DERR_INVALIDCALL")) {
    return false;
  }

  float tri_segs[3] = {1.0f, 1.0f, 1.0f};
  D3DTRIPATCH_INFO tri_info{};
  tri_info.StartVertexOffset = 0;
  tri_info.NumVertices = 9; // invalid (must be 10)
  tri_info.Basis = D3DBASIS_BEZIER;
  tri_info.Degree = D3DDEGREE_CUBIC;
  D3DDDIARG_DRAWTRIPATCH draw_tri{};
  draw_tri.Handle = 2;
  draw_tri.pNumSegs = tri_segs;
  draw_tri.pTriPatchInfo = &tri_info;

  hr = cleanup.device_funcs.pfnDrawTriPatch(create_dev.hDevice, &draw_tri);
  if (!Check(hr == kD3DErrInvalidCall, "DrawTriPatch invalid info returns D3DERR_INVALIDCALL")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  // Patch emulation only supports a small fixed-function FVF subset. Verify it
  // rejects valid patch info when an unsupported FVF is active.
  constexpr uint32_t kD3dFvfSpecular = 0x00000080u;
  constexpr uint32_t kUnsupportedFvf = kD3dFvfXyzRhw | kD3dFvfDiffuse | kD3dFvfSpecular;
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, kUnsupportedFvf);
  if (!Check(hr == S_OK, "SetFVF(unsupported FVF)")) {
    return false;
  }

  // Valid patch info, but unsupported FVF.
  D3DRECTPATCH_INFO rect_valid = rect_info;
  rect_valid.NumVertices = 16;
  D3DDDIARG_DRAWRECTPATCH draw_rect_valid = draw_rect;
  draw_rect_valid.Handle = 3;
  draw_rect_valid.pRectPatchInfo = &rect_valid;

  D3DTRIPATCH_INFO tri_valid = tri_info;
  tri_valid.NumVertices = 10;
  D3DDDIARG_DRAWTRIPATCH draw_tri_valid = draw_tri;
  draw_tri_valid.Handle = 4;
  draw_tri_valid.pTriPatchInfo = &tri_valid;

  const uint64_t tessellate_base = dev->patch_tessellate_count;
  if (!Check(dev->patch_cache.empty(), "patch cache starts empty")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnDrawRectPatch(create_dev.hDevice, &draw_rect_valid);
  if (!Check(hr == kD3DErrInvalidCall, "DrawRectPatch rejects unsupported FVF")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnDrawTriPatch(create_dev.hDevice, &draw_tri_valid);
  if (!Check(hr == kD3DErrInvalidCall, "DrawTriPatch rejects unsupported FVF")) {
    return false;
  }
  if (!Check(dev->patch_tessellate_count == tessellate_base, "unsupported FVF does not tessellate")) {
    return false;
  }
  if (!Check(dev->patch_cache.empty(), "unsupported FVF does not populate cache")) {
    return false;
  }
  return Check(dev->up_vertex_buffer == nullptr && dev->up_index_buffer == nullptr,
               "unsupported FVF does not allocate scratch UP buffers");
}

bool TestDrawTriPatchTex1ValidatesStrideAndPreservesTexcoords() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hVb{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_vb = false;
    ~Cleanup() {
      if (has_vb && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hVb);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetStreamSource != nullptr, "SetStreamSource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawTriPatch != nullptr, "DrawTriPatch must be available")) {
    return false;
  }

  D3DDDIVIEWPORTINFO vp{};
  vp.X = 0.0f;
  vp.Y = 0.0f;
  vp.Width = 256.0f;
  vp.Height = 256.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }

  // D3DFVF_XYZRHW (0x4) | D3DFVF_DIFFUSE (0x40) | D3DFVF_TEX1 (0x100).
  //
  // Include TEXCOORDSIZE bits for an *unused* texcoord set to validate we mask
  // out the per-set D3DFVF_TEXCOORDSIZE* bits for fixed-function patch paths.
  //
  // 0x40000 = D3DFVF_TEXCOORDSIZE3(1) (2-bit encoding at bits 18..19).
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, 0x40144u);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|DIFFUSE|TEX1)")) {
    return false;
  }

  struct VertexTex {
    float x;
    float y;
    float z;
    float rhw;
    uint32_t color;
    float u;
    float v;
  };

  constexpr float kU = 0.25f;
  constexpr float kV = 0.75f;

  // 10 control points (cubic triangular Bezier patch). Keep it simple with constant UVs.
  VertexTex cps[10]{};
  for (uint32_t i = 0; i < 10; ++i) {
    const float t = static_cast<float>(i) / 9.0f;
    cps[i].x = 256.0f * (0.25f + 0.5f * t);
    cps[i].y = 256.0f * (0.25f + 0.25f * t);
    cps[i].z = 0.5f;
    cps[i].rhw = 1.0f;
    const uint32_t r = static_cast<uint32_t>(t * 255.0f);
    cps[i].color = 0xFF000000u | (r << 16);
    cps[i].u = kU;
    cps[i].v = kV;
  }

  D3D9DDIARG_CREATERESOURCE create_vb{};
  create_vb.type = 0;
  create_vb.format = 0;
  create_vb.width = 0;
  create_vb.height = 0;
  create_vb.depth = 0;
  create_vb.mip_levels = 1;
  create_vb.usage = 0;
  create_vb.pool = 0;
  create_vb.size = sizeof(cps);
  create_vb.hResource.pDrvPrivate = nullptr;
  create_vb.pSharedHandle = nullptr;
  create_vb.pKmdAllocPrivateData = nullptr;
  create_vb.KmdAllocPrivateDataSize = 0;
  create_vb.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_vb);
  if (!Check(hr == S_OK, "CreateResource(control point VB)")) {
    return false;
  }
  cleanup.hVb = create_vb.hResource;
  cleanup.has_vb = true;

  D3D9DDIARG_LOCK lock{};
  lock.hResource = create_vb.hResource;
  lock.offset_bytes = 0;
  lock.size_bytes = 0;
  lock.flags = 0;
  D3DDDI_LOCKEDBOX box{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(VB)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock returns pData")) {
    return false;
  }
  std::memcpy(box.pData, cps, sizeof(cps));

  D3D9DDIARG_UNLOCK unlock{};
  unlock.hResource = create_vb.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(VB)")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  float segs[3] = {1.0f, 1.0f, 1.0f};
  D3DTRIPATCH_INFO info{};
  info.StartVertexOffset = 0;
  info.NumVertices = 10;
  info.Basis = D3DBASIS_BEZIER;
  info.Degree = D3DDEGREE_CUBIC;
  D3DDDIARG_DRAWTRIPATCH draw_tri{};
  draw_tri.Handle = 1;
  draw_tri.pNumSegs = segs;
  draw_tri.pTriPatchInfo = &info;

  // Stride too small for TEX1 should fail.
  hr = cleanup.device_funcs.pfnSetStreamSource(create_dev.hDevice, 0, create_vb.hResource, 0, /*stride=*/20u);
  if (!Check(hr == S_OK, "SetStreamSource(stride=20)")) {
    return false;
  }
  dev->cmd.reset();
  hr = cleanup.device_funcs.pfnDrawTriPatch(create_dev.hDevice, &draw_tri);
  if (!Check(hr == E_FAIL, "DrawTriPatch(TEX1 stride<28) fails")) {
    return false;
  }

  // Valid stride should succeed and preserve UVs in the uploaded scratch VB.
  hr = cleanup.device_funcs.pfnSetStreamSource(create_dev.hDevice, 0, create_vb.hResource, 0, sizeof(VertexTex));
  if (!Check(hr == S_OK, "SetStreamSource(stride=28)")) {
    return false;
  }

  const VertexTex strip[3] = {cps[0], cps[1], cps[2]};
  hr = cleanup.device_funcs.pfnDrawPrimitiveUP(create_dev.hDevice, D3DDDIPT_TRIANGLESTRIP, 1, strip, sizeof(VertexTex));
  if (!Check(hr == S_OK, "DrawPrimitiveUP(triangle strip prelude)")) {
    return false;
  }
  dev->cmd.reset();
  hr = cleanup.device_funcs.pfnDrawTriPatch(create_dev.hDevice, &draw_tri);
  if (!Check(hr == S_OK, "DrawTriPatch(TEX1 stride=28)")) {
    return false;
  }
  if (!Check(dev->up_vertex_buffer != nullptr, "up_vertex_buffer allocated")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  const CmdLoc draw = FindLastOpcode(buf, len, AEROGPU_CMD_DRAW_INDEXED);
  if (!Check(draw.hdr != nullptr, "draw_indexed emitted")) {
    return false;
  }

  const uint32_t up_vb_handle = dev->up_vertex_buffer->handle;
  const aerogpu_cmd_upload_resource* up_upload = nullptr;
  {
    const size_t stream_len = StreamBytesUsed(buf, len);
    size_t offset = sizeof(aerogpu_cmd_stream_header);
    while (offset + sizeof(aerogpu_cmd_hdr) <= stream_len) {
      const auto* hdr = reinterpret_cast<const aerogpu_cmd_hdr*>(buf + offset);
      if (hdr->opcode == AEROGPU_CMD_UPLOAD_RESOURCE) {
        const auto* upload = reinterpret_cast<const aerogpu_cmd_upload_resource*>(hdr);
        if (upload->resource_handle == up_vb_handle && upload->offset_bytes == 0 && offset < draw.offset) {
          up_upload = upload;
          break;
        }
      }
      if (hdr->size_bytes == 0 || hdr->size_bytes > stream_len - offset) {
        break;
      }
      offset += hdr->size_bytes;
    }
  }
  if (!Check(up_upload != nullptr, "upload_resource targeting UP VB emitted before draw")) {
    return false;
  }
  if (!Check(up_upload->size_bytes >= sizeof(VertexTex), "UP VB upload contains at least one vertex")) {
    return false;
  }

  const uint8_t* payload = reinterpret_cast<const uint8_t*>(up_upload) + sizeof(*up_upload);
  float u0 = 0.0f;
  float v0 = 0.0f;
  std::memcpy(&u0, payload + 20, sizeof(float));
  std::memcpy(&v0, payload + 24, sizeof(float));
  if (!Check(std::fabs(u0 - kU) < 1e-6f, "DrawTriPatch(TEX1): u preserved")) {
    return false;
  }
  if (!Check(std::fabs(v0 - kV) < 1e-6f, "DrawTriPatch(TEX1): v preserved")) {
    return false;
  }
  return true;
}

bool TestDrawTriPatchTex1TexcoordSize1ValidatesStrideAndPreservesTexcoords() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hVb{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_vb = false;
    ~Cleanup() {
      if (has_vb && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hVb);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetStreamSource != nullptr, "SetStreamSource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawTriPatch != nullptr, "DrawTriPatch must be available")) {
    return false;
  }

  D3DDDIVIEWPORTINFO vp{};
  vp.X = 0.0f;
  vp.Y = 0.0f;
  vp.Width = 256.0f;
  vp.Height = 256.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }

  // D3DFVF_XYZRHW (0x4) | D3DFVF_DIFFUSE (0x40) | D3DFVF_TEX1 (0x100) | D3DFVF_TEXCOORDSIZE1(0) (0x30000).
  constexpr uint32_t kTexcoordSize1Tex0 = 3u << 16u; // float1
  const uint32_t fvf = kD3dFvfXyzRhw | kD3dFvfDiffuse | kD3dFvfTex1 | kTexcoordSize1Tex0;
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, fvf);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|DIFFUSE|TEX1|TEXCOORDSIZE1(0))")) {
    return false;
  }

  struct VertexTex1 {
    float x;
    float y;
    float z;
    float rhw;
    uint32_t color;
    float u;
  };

  // 10 control points with varying u values so tessellation must compute them.
  VertexTex1 cps[10]{};
  for (uint32_t i = 0; i < 10; ++i) {
    const float t = static_cast<float>(i) / 9.0f;
    cps[i].x = 256.0f * (0.25f + 0.5f * t);
    cps[i].y = 256.0f * (0.25f + 0.25f * t);
    cps[i].z = 0.5f;
    cps[i].rhw = 1.0f;
    const uint32_t r = static_cast<uint32_t>(t * 255.0f);
    cps[i].color = 0xFF000000u | (r << 16);
    cps[i].u = t;
  }

  D3D9DDIARG_CREATERESOURCE create_vb{};
  create_vb.type = 0;
  create_vb.format = 0;
  create_vb.width = 0;
  create_vb.height = 0;
  create_vb.depth = 0;
  create_vb.mip_levels = 1;
  create_vb.usage = 0;
  create_vb.pool = 0;
  create_vb.size = sizeof(cps);
  create_vb.hResource.pDrvPrivate = nullptr;
  create_vb.pSharedHandle = nullptr;
  create_vb.pKmdAllocPrivateData = nullptr;
  create_vb.KmdAllocPrivateDataSize = 0;
  create_vb.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_vb);
  if (!Check(hr == S_OK, "CreateResource(control point VB)")) {
    return false;
  }
  cleanup.hVb = create_vb.hResource;
  cleanup.has_vb = true;

  D3D9DDIARG_LOCK lock{};
  lock.hResource = create_vb.hResource;
  lock.offset_bytes = 0;
  lock.size_bytes = 0;
  lock.flags = 0;
  D3DDDI_LOCKEDBOX box{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(VB)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock returns pData")) {
    return false;
  }
  std::memcpy(box.pData, cps, sizeof(cps));

  D3D9DDIARG_UNLOCK unlock{};
  unlock.hResource = create_vb.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(VB)")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  float segs[3] = {1.0f, 1.0f, 1.0f};
  D3DTRIPATCH_INFO info{};
  info.StartVertexOffset = 0;
  info.NumVertices = 10;
  info.Basis = D3DBASIS_BEZIER;
  info.Degree = D3DDEGREE_CUBIC;
  D3DDDIARG_DRAWTRIPATCH draw_tri{};
  draw_tri.Handle = 1;
  draw_tri.pNumSegs = segs;
  draw_tri.pTriPatchInfo = &info;

  // Stride too small for TEXCOORDSIZE1 should fail.
  hr = cleanup.device_funcs.pfnSetStreamSource(create_dev.hDevice, 0, create_vb.hResource, 0, /*stride=*/20u);
  if (!Check(hr == S_OK, "SetStreamSource(stride=20)")) {
    return false;
  }
  dev->cmd.reset();
  hr = cleanup.device_funcs.pfnDrawTriPatch(create_dev.hDevice, &draw_tri);
  if (!Check(hr == E_FAIL, "DrawTriPatch(TEXCOORDSIZE1 stride<24) fails")) {
    return false;
  }

  // Valid stride should succeed and preserve u values in the uploaded scratch VB.
  hr = cleanup.device_funcs.pfnSetStreamSource(create_dev.hDevice, 0, create_vb.hResource, 0, sizeof(VertexTex1));
  if (!Check(hr == S_OK, "SetStreamSource(stride=24)")) {
    return false;
  }

  dev->cmd.reset();
  hr = cleanup.device_funcs.pfnDrawTriPatch(create_dev.hDevice, &draw_tri);
  if (!Check(hr == S_OK, "DrawTriPatch(TEXCOORDSIZE1 stride=24)")) {
    return false;
  }
  if (!Check(dev->up_vertex_buffer != nullptr, "up_vertex_buffer allocated")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  const CmdLoc draw = FindLastOpcode(buf, len, AEROGPU_CMD_DRAW_INDEXED);
  if (!Check(draw.hdr != nullptr, "draw_indexed emitted")) {
    return false;
  }

  const uint32_t up_vb_handle = dev->up_vertex_buffer->handle;
  const CmdLoc vb_upload = FindLastUploadResourceBefore(buf, len, draw.offset, up_vb_handle);
  if (!Check(vb_upload.hdr != nullptr, "upload_resource targeting UP VB emitted before draw")) {
    return false;
  }
  const auto* up_upload = reinterpret_cast<const aerogpu_cmd_upload_resource*>(vb_upload.hdr);
  if (!Check(up_upload->offset_bytes == 0, "upload_resource UP VB offset is 0")) {
    return false;
  }
  if (!Check(up_upload->size_bytes == 3u * sizeof(VertexTex1), "UP VB upload size matches tessellated float1 vertex data")) {
    return false;
  }

  const uint8_t* payload = reinterpret_cast<const uint8_t*>(up_upload) + sizeof(*up_upload);
  float u0 = 0.0f;
  float u1 = 0.0f;
  float u2 = 0.0f;
  std::memcpy(&u0, payload + 20, sizeof(float));
  std::memcpy(&u1, payload + sizeof(VertexTex1) + 20, sizeof(float));
  std::memcpy(&u2, payload + 2 * sizeof(VertexTex1) + 20, sizeof(float));

  // For segs=1, the tessellator emits 3 vertices in this order: cp[9] (w corner), cp[3] (v corner), cp[0] (u corner).
  if (!Check(std::fabs(u0 - cps[9].u) < 1e-6f, "tri patch texcoordsize1: u0 preserved")) {
    return false;
  }
  if (!Check(std::fabs(u1 - cps[3].u) < 1e-6f, "tri patch texcoordsize1: u1 preserved")) {
    return false;
  }
  return Check(std::fabs(u2 - cps[0].u) < 1e-6f, "tri patch texcoordsize1: u2 preserved");
}

bool TestDrawTriPatchTex1TexcoordSize3ValidatesStrideAndPreservesTexcoords() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hVb{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_vb = false;
    ~Cleanup() {
      if (has_vb && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hVb);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetStreamSource != nullptr, "SetStreamSource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawTriPatch != nullptr, "DrawTriPatch must be available")) {
    return false;
  }

  D3DDDIVIEWPORTINFO vp{};
  vp.X = 0.0f;
  vp.Y = 0.0f;
  vp.Width = 256.0f;
  vp.Height = 256.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }

  // D3DFVF_XYZRHW (0x4) | D3DFVF_DIFFUSE (0x40) | D3DFVF_TEX1 (0x100) | D3DFVF_TEXCOORDSIZE3(0) (0x10000).
  constexpr uint32_t kTexcoordSize3Tex0 = 1u << 16u; // float3
  const uint32_t fvf = kD3dFvfXyzRhw | kD3dFvfDiffuse | kD3dFvfTex1 | kTexcoordSize3Tex0;
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, fvf);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|DIFFUSE|TEX1|TEXCOORDSIZE3(0))")) {
    return false;
  }

  struct VertexTex3 {
    float x;
    float y;
    float z;
    float rhw;
    uint32_t color;
    float u;
    float v;
    float w;
  };

  constexpr float kU = 0.25f;
  constexpr float kV = 0.75f;
  constexpr float kW = 0.5f;

  // 10 control points (cubic triangular Bezier patch). Keep it simple with constant UVs.
  VertexTex3 cps[10]{};
  for (uint32_t i = 0; i < 10; ++i) {
    const float t = static_cast<float>(i) / 9.0f;
    cps[i].x = 256.0f * (0.25f + 0.5f * t);
    cps[i].y = 256.0f * (0.25f + 0.25f * t);
    cps[i].z = 0.5f;
    cps[i].rhw = 1.0f;
    const uint32_t r = static_cast<uint32_t>(t * 255.0f);
    cps[i].color = 0xFF000000u | (r << 16);
    cps[i].u = kU;
    cps[i].v = kV;
    cps[i].w = kW;
  }

  D3D9DDIARG_CREATERESOURCE create_vb{};
  create_vb.type = 0;
  create_vb.format = 0;
  create_vb.width = 0;
  create_vb.height = 0;
  create_vb.depth = 0;
  create_vb.mip_levels = 1;
  create_vb.usage = 0;
  create_vb.pool = 0;
  create_vb.size = sizeof(cps);
  create_vb.hResource.pDrvPrivate = nullptr;
  create_vb.pSharedHandle = nullptr;
  create_vb.pKmdAllocPrivateData = nullptr;
  create_vb.KmdAllocPrivateDataSize = 0;
  create_vb.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_vb);
  if (!Check(hr == S_OK, "CreateResource(control point VB)")) {
    return false;
  }
  cleanup.hVb = create_vb.hResource;
  cleanup.has_vb = true;

  D3D9DDIARG_LOCK lock{};
  lock.hResource = create_vb.hResource;
  lock.offset_bytes = 0;
  lock.size_bytes = 0;
  lock.flags = 0;
  D3DDDI_LOCKEDBOX box{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(VB)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock returns pData")) {
    return false;
  }
  std::memcpy(box.pData, cps, sizeof(cps));

  D3D9DDIARG_UNLOCK unlock{};
  unlock.hResource = create_vb.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(VB)")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  float segs[3] = {1.0f, 1.0f, 1.0f};
  D3DTRIPATCH_INFO info{};
  info.StartVertexOffset = 0;
  info.NumVertices = 10;
  info.Basis = D3DBASIS_BEZIER;
  info.Degree = D3DDEGREE_CUBIC;
  D3DDDIARG_DRAWTRIPATCH draw_tri{};
  draw_tri.Handle = 1;
  draw_tri.pNumSegs = segs;
  draw_tri.pTriPatchInfo = &info;

  // Stride must account for TEXCOORDSIZE3(0).
  hr = cleanup.device_funcs.pfnSetStreamSource(create_dev.hDevice, 0, create_vb.hResource, 0, /*stride=*/28u);
  if (!Check(hr == S_OK, "SetStreamSource(stride=28)")) {
    return false;
  }
  dev->cmd.reset();
  hr = cleanup.device_funcs.pfnDrawTriPatch(create_dev.hDevice, &draw_tri);
  if (!Check(hr == E_FAIL, "DrawTriPatch(TEXCOORDSIZE3 stride<32) fails")) {
    return false;
  }

  // Valid stride should succeed and preserve UVs in the uploaded scratch VB.
  hr = cleanup.device_funcs.pfnSetStreamSource(create_dev.hDevice, 0, create_vb.hResource, 0, sizeof(VertexTex3));
  if (!Check(hr == S_OK, "SetStreamSource(stride=32)")) {
    return false;
  }

  dev->cmd.reset();
  hr = cleanup.device_funcs.pfnDrawTriPatch(create_dev.hDevice, &draw_tri);
  if (!Check(hr == S_OK, "DrawTriPatch(TEXCOORDSIZE3 stride=32)")) {
    return false;
  }
  if (!Check(dev->up_vertex_buffer != nullptr, "up_vertex_buffer allocated")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  const CmdLoc draw = FindLastOpcode(buf, len, AEROGPU_CMD_DRAW_INDEXED);
  if (!Check(draw.hdr != nullptr, "draw_indexed emitted")) {
    return false;
  }

  const uint32_t up_vb_handle = dev->up_vertex_buffer->handle;
  const CmdLoc vb_upload = FindLastUploadResourceBefore(buf, len, draw.offset, up_vb_handle);
  if (!Check(vb_upload.hdr != nullptr, "upload_resource targeting UP VB emitted before draw")) {
    return false;
  }
  const auto* up_upload = reinterpret_cast<const aerogpu_cmd_upload_resource*>(vb_upload.hdr);
  if (!Check(up_upload->offset_bytes == 0, "upload_resource UP VB offset is 0")) {
    return false;
  }
  // For segs=1, tessellation produces 3 vertices for a tri patch.
  if (!Check(up_upload->size_bytes == 3u * sizeof(VertexTex3), "UP VB upload size matches tessellated float3 vertex data")) {
    return false;
  }

  const uint8_t* payload = reinterpret_cast<const uint8_t*>(up_upload) + sizeof(*up_upload);
  float u0 = 0.0f;
  float v0 = 0.0f;
  std::memcpy(&u0, payload + 20, sizeof(float));
  std::memcpy(&v0, payload + 24, sizeof(float));
  if (!Check(std::fabs(u0 - kU) < 1e-6f, "DrawTriPatch(TEXCOORDSIZE3): u preserved")) {
    return false;
  }
  return Check(std::fabs(v0 - kV) < 1e-6f, "DrawTriPatch(TEXCOORDSIZE3): v preserved");
}

bool TestDrawTriPatchTex1TexcoordSize4ValidatesStrideAndPreservesTexcoords() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hVb{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_vb = false;
    ~Cleanup() {
      if (has_vb && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hVb);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetFVF != nullptr, "SetFVF must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetStreamSource != nullptr, "SetStreamSource must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDrawTriPatch != nullptr, "DrawTriPatch must be available")) {
    return false;
  }

  D3DDDIVIEWPORTINFO vp{};
  vp.X = 0.0f;
  vp.Y = 0.0f;
  vp.Width = 256.0f;
  vp.Height = 256.0f;
  vp.MinZ = 0.0f;
  vp.MaxZ = 1.0f;
  hr = cleanup.device_funcs.pfnSetViewport(create_dev.hDevice, &vp);
  if (!Check(hr == S_OK, "SetViewport")) {
    return false;
  }

  // D3DFVF_XYZRHW (0x4) | D3DFVF_DIFFUSE (0x40) | D3DFVF_TEX1 (0x100) | D3DFVF_TEXCOORDSIZE4(0) (0x20000).
  constexpr uint32_t kTexcoordSize4Tex0 = 2u << 16u; // float4
  const uint32_t fvf = kD3dFvfXyzRhw | kD3dFvfDiffuse | kD3dFvfTex1 | kTexcoordSize4Tex0;
  hr = cleanup.device_funcs.pfnSetFVF(create_dev.hDevice, fvf);
  if (!Check(hr == S_OK, "SetFVF(XYZRHW|DIFFUSE|TEX1|TEXCOORDSIZE4(0))")) {
    return false;
  }

  struct VertexTex4 {
    float x;
    float y;
    float z;
    float rhw;
    uint32_t color;
    float u;
    float v;
    float w;
    float q;
  };

  constexpr float kU = 0.25f;
  constexpr float kV = 0.75f;
  constexpr float kW = 0.5f;
  constexpr float kQ = 1.0f;

  // 10 control points (cubic triangular Bezier patch). Keep it simple with constant UVs and constant extra components.
  VertexTex4 cps[10]{};
  for (uint32_t i = 0; i < 10; ++i) {
    const float t = static_cast<float>(i) / 9.0f;
    cps[i].x = 256.0f * (0.25f + 0.5f * t);
    cps[i].y = 256.0f * (0.25f + 0.25f * t);
    cps[i].z = 0.5f;
    cps[i].rhw = 1.0f;
    const uint32_t r = static_cast<uint32_t>(t * 255.0f);
    cps[i].color = 0xFF000000u | (r << 16);
    cps[i].u = kU;
    cps[i].v = kV;
    cps[i].w = kW;
    cps[i].q = kQ;
  }

  D3D9DDIARG_CREATERESOURCE create_vb{};
  create_vb.type = 0;
  create_vb.format = 0;
  create_vb.width = 0;
  create_vb.height = 0;
  create_vb.depth = 0;
  create_vb.mip_levels = 1;
  create_vb.usage = 0;
  create_vb.pool = 0;
  create_vb.size = sizeof(cps);
  create_vb.hResource.pDrvPrivate = nullptr;
  create_vb.pSharedHandle = nullptr;
  create_vb.pKmdAllocPrivateData = nullptr;
  create_vb.KmdAllocPrivateDataSize = 0;
  create_vb.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_vb);
  if (!Check(hr == S_OK, "CreateResource(control point VB)")) {
    return false;
  }
  cleanup.hVb = create_vb.hResource;
  cleanup.has_vb = true;

  D3D9DDIARG_LOCK lock{};
  lock.hResource = create_vb.hResource;
  lock.offset_bytes = 0;
  lock.size_bytes = 0;
  lock.flags = 0;
  D3DDDI_LOCKEDBOX box{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &box);
  if (!Check(hr == S_OK, "Lock(VB)")) {
    return false;
  }
  if (!Check(box.pData != nullptr, "Lock returns pData")) {
    return false;
  }
  std::memcpy(box.pData, cps, sizeof(cps));

  D3D9DDIARG_UNLOCK unlock{};
  unlock.hResource = create_vb.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(VB)")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  float segs[3] = {1.0f, 1.0f, 1.0f};
  D3DTRIPATCH_INFO info{};
  info.StartVertexOffset = 0;
  info.NumVertices = 10;
  info.Basis = D3DBASIS_BEZIER;
  info.Degree = D3DDEGREE_CUBIC;
  D3DDDIARG_DRAWTRIPATCH draw_tri{};
  draw_tri.Handle = 1;
  draw_tri.pNumSegs = segs;
  draw_tri.pTriPatchInfo = &info;

  // Stride must account for TEXCOORDSIZE4(0).
  hr = cleanup.device_funcs.pfnSetStreamSource(create_dev.hDevice, 0, create_vb.hResource, 0, /*stride=*/32u);
  if (!Check(hr == S_OK, "SetStreamSource(stride=32)")) {
    return false;
  }
  dev->cmd.reset();
  hr = cleanup.device_funcs.pfnDrawTriPatch(create_dev.hDevice, &draw_tri);
  if (!Check(hr == E_FAIL, "DrawTriPatch(TEXCOORDSIZE4 stride<36) fails")) {
    return false;
  }

  // Valid stride should succeed and preserve UVs in the uploaded scratch VB.
  hr = cleanup.device_funcs.pfnSetStreamSource(create_dev.hDevice, 0, create_vb.hResource, 0, sizeof(VertexTex4));
  if (!Check(hr == S_OK, "SetStreamSource(stride=36)")) {
    return false;
  }

  dev->cmd.reset();
  hr = cleanup.device_funcs.pfnDrawTriPatch(create_dev.hDevice, &draw_tri);
  if (!Check(hr == S_OK, "DrawTriPatch(TEXCOORDSIZE4 stride=36)")) {
    return false;
  }
  if (!Check(dev->up_vertex_buffer != nullptr, "up_vertex_buffer allocated")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  const CmdLoc draw = FindLastOpcode(buf, len, AEROGPU_CMD_DRAW_INDEXED);
  if (!Check(draw.hdr != nullptr, "draw_indexed emitted")) {
    return false;
  }

  const uint32_t up_vb_handle = dev->up_vertex_buffer->handle;
  const CmdLoc vb_upload = FindLastUploadResourceBefore(buf, len, draw.offset, up_vb_handle);
  if (!Check(vb_upload.hdr != nullptr, "upload_resource targeting UP VB emitted before draw")) {
    return false;
  }
  const auto* up_upload = reinterpret_cast<const aerogpu_cmd_upload_resource*>(vb_upload.hdr);
  if (!Check(up_upload->offset_bytes == 0, "upload_resource UP VB offset is 0")) {
    return false;
  }
  // For segs=1, tessellation produces 3 vertices for a tri patch.
  if (!Check(up_upload->size_bytes == 3u * sizeof(VertexTex4), "UP VB upload size matches tessellated float4 vertex data")) {
    return false;
  }

  const uint8_t* payload = reinterpret_cast<const uint8_t*>(up_upload) + sizeof(*up_upload);
  float u0 = 0.0f;
  float v0 = 0.0f;
  float w0 = 0.0f;
  float q0 = 0.0f;
  std::memcpy(&u0, payload + 20, sizeof(float));
  std::memcpy(&v0, payload + 24, sizeof(float));
  std::memcpy(&w0, payload + 28, sizeof(float));
  std::memcpy(&q0, payload + 32, sizeof(float));
  if (!Check(std::fabs(u0 - kU) < 1e-6f, "DrawTriPatch(TEXCOORDSIZE4): u preserved")) {
    return false;
  }
  if (!Check(std::fabs(v0 - kV) < 1e-6f, "DrawTriPatch(TEXCOORDSIZE4): v preserved")) {
    return false;
  }
  if (!Check(std::fabs(w0 - kW) < 1e-6f, "DrawTriPatch(TEXCOORDSIZE4): w preserved from template")) {
    return false;
  }
  return Check(std::fabs(q0 - kQ) < 1e-6f, "DrawTriPatch(TEXCOORDSIZE4): q preserved from template");
}

bool TestResetShrinkUnbindsBackbuffer() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3D9DDI_HSWAPCHAIN hSwapChain{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_swapchain = false;

    ~Cleanup() {
      if (has_swapchain && device_funcs.pfnDestroySwapChain) {
        device_funcs.pfnDestroySwapChain(hDevice, hSwapChain);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  D3D9DDIARG_CREATESWAPCHAIN create_sc{};
  create_sc.present_params.backbuffer_width = 64;
  create_sc.present_params.backbuffer_height = 64;
  create_sc.present_params.backbuffer_format = 22u; // D3DFMT_X8R8G8B8
  create_sc.present_params.backbuffer_count = 2;
  create_sc.present_params.swap_effect = 1;
  create_sc.present_params.flags = 0;
  create_sc.present_params.hDeviceWindow = nullptr;
  create_sc.present_params.windowed = TRUE;
  create_sc.present_params.presentation_interval = 1;

  hr = cleanup.device_funcs.pfnCreateSwapChain(create_dev.hDevice, &create_sc);
  if (!Check(hr == S_OK, "CreateSwapChain")) {
    return false;
  }
  if (!Check(create_sc.hSwapChain.pDrvPrivate != nullptr, "CreateSwapChain returned swapchain handle")) {
    return false;
  }
  cleanup.hSwapChain = create_sc.hSwapChain;
  cleanup.has_swapchain = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  auto* sc = reinterpret_cast<SwapChain*>(create_sc.hSwapChain.pDrvPrivate);
  if (!Check(sc->backbuffers.size() == 2, "swapchain has 2 backbuffers")) {
    return false;
  }

  Resource* bb0 = sc->backbuffers[0];
  Resource* bb1 = sc->backbuffers[1];

  D3DDDI_HRESOURCE hRt{};
  hRt.pDrvPrivate = bb1;
  hr = cleanup.device_funcs.pfnSetRenderTarget(create_dev.hDevice, 0, hRt);
  if (!Check(hr == S_OK, "SetRenderTarget(backbuffer1)")) {
    return false;
  }
  if (!Check(dev->render_targets[0] == bb1, "render target points at backbuffer1")) {
    return false;
  }

  D3D9DDIARG_RESET reset{};
  reset.present_params = create_sc.present_params;
  reset.present_params.backbuffer_count = 1;

  hr = cleanup.device_funcs.pfnReset(create_dev.hDevice, &reset);
  if (!Check(hr == S_OK, "Reset shrink")) {
    return false;
  }

  if (!Check(sc->backbuffers.size() == 1, "swapchain shrink to 1 backbuffer")) {
    return false;
  }
  if (!Check(dev->render_targets[0] == bb0, "render target rebounds to backbuffer0")) {
    return false;
  }
  return Check(dev->render_targets[0] != bb1, "render target no longer points at removed backbuffer");
}

bool TestRotateResourceIdentitiesRebindsChangedHandles() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    std::vector<D3DDDI_HRESOURCE> resources;
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyResource) {
        for (auto& hRes : resources) {
          if (hRes.pDrvPrivate) {
            device_funcs.pfnDestroyResource(hDevice, hRes);
          }
        }
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  auto create_buffer = [&](uint32_t size_bytes) -> D3DDDI_HRESOURCE {
    D3D9DDIARG_CREATERESOURCE args{};
    args.type = 0;
    args.format = 0;
    args.width = 0;
    args.height = 0;
    args.depth = 0;
    args.mip_levels = 1;
    args.usage = 0;
    args.pool = 0;
    args.size = size_bytes;
    args.hResource.pDrvPrivate = nullptr;
    args.pSharedHandle = nullptr;
    args.pKmdAllocPrivateData = nullptr;
    args.KmdAllocPrivateDataSize = 0;

    HRESULT hr_local = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &args);
    if (hr_local != S_OK) {
      std::fprintf(stderr, "FAIL: CreateResource(buffer) hr=0x%08x\n", static_cast<unsigned>(hr_local));
      return {};
    }
    cleanup.resources.push_back(args.hResource);
    return args.hResource;
  };

  auto create_surface = [&](uint32_t w, uint32_t h) -> D3DDDI_HRESOURCE {
    D3D9DDIARG_CREATERESOURCE args{};
    args.type = kD3dRTypeTexture;
    args.format = 22u; // D3DFMT_X8R8G8B8
    args.width = w;
    args.height = h;
    args.depth = 1;
    args.mip_levels = 1;
    args.usage = 0;
    args.pool = 0;
    args.size = 0;
    args.hResource.pDrvPrivate = nullptr;
    args.pSharedHandle = nullptr;
    args.pKmdAllocPrivateData = nullptr;
    args.KmdAllocPrivateDataSize = 0;

    HRESULT hr_local = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &args);
    if (hr_local != S_OK) {
      std::fprintf(stderr, "FAIL: CreateResource(surface) hr=0x%08x\n", static_cast<unsigned>(hr_local));
      return {};
    }
    cleanup.resources.push_back(args.hResource);
    return args.hResource;
  };

  D3DDDI_HRESOURCE hVb0 = create_buffer(256);
  D3DDDI_HRESOURCE hVb1 = create_buffer(256);
  if (!Check(hVb0.pDrvPrivate != nullptr && hVb1.pDrvPrivate != nullptr, "vertex buffers created")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnSetStreamSource(create_dev.hDevice, 0, hVb0, 0, 16);
  if (!Check(hr == S_OK, "SetStreamSource")) {
    return false;
  }

  D3DDDI_HRESOURCE hTex0 = create_surface(32, 32);
  D3DDDI_HRESOURCE hTex1 = create_surface(32, 32);
  if (!Check(hTex0.pDrvPrivate != nullptr && hTex1.pDrvPrivate != nullptr, "textures created")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnSetTexture(create_dev.hDevice, 0, hTex0);
  if (!Check(hr == S_OK, "SetTexture")) {
    return false;
  }

  D3DDDI_HRESOURCE hIb0 = create_buffer(128);
  D3DDDI_HRESOURCE hIb1 = create_buffer(128);
  if (!Check(hIb0.pDrvPrivate != nullptr && hIb1.pDrvPrivate != nullptr, "index buffers created")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnSetIndices(create_dev.hDevice, hIb0, kD3dFmtIndex16, 4);
  if (!Check(hr == S_OK, "SetIndices")) {
    return false;
  }

  auto reset_stream = [&]() {
    std::lock_guard<std::mutex> lock(dev->mutex);
    dev->cmd.reset();
  };

  // Rotate vertex buffers: must re-emit SET_VERTEX_BUFFERS for stream 0 using the
  // new handle.
  reset_stream();
  auto* vb0 = reinterpret_cast<Resource*>(hVb0.pDrvPrivate);
  auto* vb1 = reinterpret_cast<Resource*>(hVb1.pDrvPrivate);
  hr = device_test_set_resource_backing(create_dev.hDevice, hVb0, /*alloc_id=*/101, /*offset_bytes=*/1, /*hAllocation=*/0x101);
  if (!Check(hr == S_OK, "device_test_set_resource_backing(vb0)")) {
    return false;
  }
  hr = device_test_set_resource_backing(create_dev.hDevice, hVb1, /*alloc_id=*/202, /*offset_bytes=*/2, /*hAllocation=*/0x202);
  if (!Check(hr == S_OK, "device_test_set_resource_backing(vb1)")) {
    return false;
  }
  vb0->storage[0] = 0xA0;
  vb1->storage[0] = 0xB0;
  const aerogpu_handle_t vb0_before = vb0->handle;
  const aerogpu_handle_t vb1_before = vb1->handle;
  D3DDDI_HRESOURCE vb_rotate[2] = {hVb0, hVb1};
  hr = cleanup.device_funcs.pfnRotateResourceIdentities(create_dev.hDevice, vb_rotate, 2);
  if (!Check(hr == S_OK, "RotateResourceIdentities(vb)")) {
    return false;
  }
  if (!Check(vb0->handle == vb1_before && vb1->handle == vb0_before, "vertex buffer handles rotated")) {
    return false;
  }
  if (!Check(vb0->backing_alloc_id == 202 && vb1->backing_alloc_id == 101, "vertex buffer alloc_id rotated")) {
    return false;
  }
  if (!Check(vb0->backing_offset_bytes == 2 && vb1->backing_offset_bytes == 1, "vertex buffer backing_offset_bytes rotated")) {
    return false;
  }
  if (!Check(vb0->wddm_hAllocation == 0x202 && vb1->wddm_hAllocation == 0x101, "vertex buffer hAllocation rotated")) {
    return false;
  }
  if (!Check(vb0->storage[0] == 0xB0 && vb1->storage[0] == 0xA0, "vertex buffer storage rotated")) {
    return false;
  }

  dev->cmd.finalize();
  {
    const CmdLoc loc = FindLastOpcode(dev->cmd.data(), dev->cmd.bytes_used(), AEROGPU_CMD_SET_VERTEX_BUFFERS);
    if (!Check(loc.hdr != nullptr, "SET_VERTEX_BUFFERS emitted after rotate")) {
      return false;
    }
    const auto* cmd = reinterpret_cast<const aerogpu_cmd_set_vertex_buffers*>(loc.hdr);
    if (!Check(cmd->start_slot == 0 && cmd->buffer_count == 1, "SET_VERTEX_BUFFERS header fields")) {
      return false;
    }
    const auto* binding = reinterpret_cast<const aerogpu_vertex_buffer_binding*>(
        reinterpret_cast<const uint8_t*>(cmd) + sizeof(*cmd));
    if (!Check(binding->buffer == vb0->handle, "SET_VERTEX_BUFFERS uses rotated handle")) {
      return false;
    }
  }

  // Rotate textures: must re-emit SET_TEXTURE for stage 0 using the new handle.
  reset_stream();
  auto* tex0 = reinterpret_cast<Resource*>(hTex0.pDrvPrivate);
  auto* tex1 = reinterpret_cast<Resource*>(hTex1.pDrvPrivate);
  hr = device_test_set_resource_backing(create_dev.hDevice, hTex0, /*alloc_id=*/303, /*offset_bytes=*/3, /*hAllocation=*/0x303);
  if (!Check(hr == S_OK, "device_test_set_resource_backing(tex0)")) {
    return false;
  }
  hr = device_test_set_resource_backing(create_dev.hDevice, hTex1, /*alloc_id=*/404, /*offset_bytes=*/4, /*hAllocation=*/0x404);
  if (!Check(hr == S_OK, "device_test_set_resource_backing(tex1)")) {
    return false;
  }
  tex0->storage[0] = 0xC0;
  tex1->storage[0] = 0xD0;
  const aerogpu_handle_t tex0_before = tex0->handle;
  const aerogpu_handle_t tex1_before = tex1->handle;
  D3DDDI_HRESOURCE tex_rotate[2] = {hTex0, hTex1};
  hr = cleanup.device_funcs.pfnRotateResourceIdentities(create_dev.hDevice, tex_rotate, 2);
  if (!Check(hr == S_OK, "RotateResourceIdentities(tex)")) {
    return false;
  }
  if (!Check(tex0->handle == tex1_before && tex1->handle == tex0_before, "texture handles rotated")) {
    return false;
  }
  if (!Check(tex0->backing_alloc_id == 404 && tex1->backing_alloc_id == 303, "texture alloc_id rotated")) {
    return false;
  }
  if (!Check(tex0->backing_offset_bytes == 4 && tex1->backing_offset_bytes == 3, "texture backing_offset_bytes rotated")) {
    return false;
  }
  if (!Check(tex0->wddm_hAllocation == 0x404 && tex1->wddm_hAllocation == 0x303, "texture hAllocation rotated")) {
    return false;
  }
  if (!Check(tex0->storage[0] == 0xD0 && tex1->storage[0] == 0xC0, "texture storage rotated")) {
    return false;
  }

  dev->cmd.finalize();
  {
    const CmdLoc loc = FindLastOpcode(dev->cmd.data(), dev->cmd.bytes_used(), AEROGPU_CMD_SET_TEXTURE);
    if (!Check(loc.hdr != nullptr, "SET_TEXTURE emitted after rotate")) {
      return false;
    }
    const auto* cmd = reinterpret_cast<const aerogpu_cmd_set_texture*>(loc.hdr);
    if (!Check(cmd->slot == 0 && cmd->texture == tex0->handle, "SET_TEXTURE uses rotated handle")) {
      return false;
    }
  }

  // Rotate index buffers: must re-emit SET_INDEX_BUFFER with the new handle.
  reset_stream();
  auto* ib0 = reinterpret_cast<Resource*>(hIb0.pDrvPrivate);
  auto* ib1 = reinterpret_cast<Resource*>(hIb1.pDrvPrivate);
  hr = device_test_set_resource_backing(create_dev.hDevice, hIb0, /*alloc_id=*/505, /*offset_bytes=*/5, /*hAllocation=*/0x505);
  if (!Check(hr == S_OK, "device_test_set_resource_backing(ib0)")) {
    return false;
  }
  hr = device_test_set_resource_backing(create_dev.hDevice, hIb1, /*alloc_id=*/606, /*offset_bytes=*/6, /*hAllocation=*/0x606);
  if (!Check(hr == S_OK, "device_test_set_resource_backing(ib1)")) {
    return false;
  }
  ib0->storage[0] = 0xE0;
  ib1->storage[0] = 0xF0;
  const aerogpu_handle_t ib0_before = ib0->handle;
  const aerogpu_handle_t ib1_before = ib1->handle;
  D3DDDI_HRESOURCE ib_rotate[2] = {hIb0, hIb1};
  hr = cleanup.device_funcs.pfnRotateResourceIdentities(create_dev.hDevice, ib_rotate, 2);
  if (!Check(hr == S_OK, "RotateResourceIdentities(ib)")) {
    return false;
  }
  if (!Check(ib0->handle == ib1_before && ib1->handle == ib0_before, "index buffer handles rotated")) {
    return false;
  }
  if (!Check(ib0->backing_alloc_id == 606 && ib1->backing_alloc_id == 505, "index buffer alloc_id rotated")) {
    return false;
  }
  if (!Check(ib0->backing_offset_bytes == 6 && ib1->backing_offset_bytes == 5, "index buffer backing_offset_bytes rotated")) {
    return false;
  }
  if (!Check(ib0->wddm_hAllocation == 0x606 && ib1->wddm_hAllocation == 0x505, "index buffer hAllocation rotated")) {
    return false;
  }
  if (!Check(ib0->storage[0] == 0xF0 && ib1->storage[0] == 0xE0, "index buffer storage rotated")) {
    return false;
  }

  dev->cmd.finalize();
  {
    const CmdLoc loc = FindLastOpcode(dev->cmd.data(), dev->cmd.bytes_used(), AEROGPU_CMD_SET_INDEX_BUFFER);
    if (!Check(loc.hdr != nullptr, "SET_INDEX_BUFFER emitted after rotate")) {
      return false;
    }
    const auto* cmd = reinterpret_cast<const aerogpu_cmd_set_index_buffer*>(loc.hdr);
    if (!Check(cmd->buffer == ib0->handle, "SET_INDEX_BUFFER uses rotated handle")) {
      return false;
    }
    if (!Check(cmd->offset_bytes == 4, "SET_INDEX_BUFFER preserves offset")) {
      return false;
    }
  }

  return true;
}

bool TestPresentBackbufferRotationUndoOnSmallCmdBuffer() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3D9DDI_HSWAPCHAIN hSwapChain{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_swapchain = false;

    ~Cleanup() {
      if (has_swapchain && device_funcs.pfnDestroySwapChain) {
        device_funcs.pfnDestroySwapChain(hDevice, hSwapChain);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  D3D9DDIARG_CREATESWAPCHAIN create_sc{};
  create_sc.present_params.backbuffer_width = 64;
  create_sc.present_params.backbuffer_height = 64;
  create_sc.present_params.backbuffer_format = 22u; // D3DFMT_X8R8G8B8
  create_sc.present_params.backbuffer_count = 2;
  create_sc.present_params.swap_effect = 1;
  create_sc.present_params.flags = 0;
  create_sc.present_params.hDeviceWindow = nullptr;
  create_sc.present_params.windowed = TRUE;
  create_sc.present_params.presentation_interval = 0;

  hr = cleanup.device_funcs.pfnCreateSwapChain(create_dev.hDevice, &create_sc);
  if (!Check(hr == S_OK, "CreateSwapChain")) {
    return false;
  }
  if (!Check(create_sc.hSwapChain.pDrvPrivate != nullptr, "CreateSwapChain returned swapchain handle")) {
    return false;
  }
  cleanup.hSwapChain = create_sc.hSwapChain;
  cleanup.has_swapchain = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  auto* sc = reinterpret_cast<SwapChain*>(create_sc.hSwapChain.pDrvPrivate);
  if (!Check(sc->backbuffers.size() == 2, "swapchain has 2 backbuffers")) {
    return false;
  }

  const aerogpu_handle_t h0 = sc->backbuffers[0]->handle;
  const aerogpu_handle_t h1 = sc->backbuffers[1]->handle;

  D3D9DDIARG_PRESENTEX present{};
  present.hSrc.pDrvPrivate = nullptr;
  present.hWnd = nullptr;
  present.sync_interval = 0;
  present.d3d9_present_flags = 0;

  // Small span-backed DMA buffer: PresentEx fits, but the post-submit render-target
  // rebind used by flip-style backbuffer rotation does not.
  uint8_t small_dma[sizeof(aerogpu_cmd_stream_header) + 32] = {};
  ScopedDeviceCmdVectorReset cmd_reset(dev);
  dev->cmd.set_span(small_dma, sizeof(small_dma));

  hr = cleanup.device_funcs.pfnPresentEx(create_dev.hDevice, &present);
  if (!Check(hr == S_OK, "PresentEx (small cmd buffer)")) {
    return false;
  }
  if (!Check(sc->backbuffers[0]->handle == h0 && sc->backbuffers[1]->handle == h1,
             "present rotation undone when RT rebind cannot be emitted")) {
    return false;
  }

  // Vector-backed buffer: rotation should succeed and swap handles.
  dev->cmd.set_vector();
  hr = cleanup.device_funcs.pfnPresentEx(create_dev.hDevice, &present);
  if (!Check(hr == S_OK, "PresentEx (vector cmd buffer)")) {
    return false;
  }
  return Check(sc->backbuffers[0]->handle == h1 && sc->backbuffers[1]->handle == h0,
               "present rotation occurs when RT rebind succeeds");
}

bool TestPresentBackbufferRotationUndoOnSmallAllocList() {
  // Backbuffer rotation rebinding can touch multiple guest-backed allocations
  // (render target + bound textures). If the allocation list cannot fit all
  // referenced allocations, the UMD must undo the rotation rather than emit
  // commands with an incomplete allocation table.
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3D9DDI_HSWAPCHAIN hSwapChain{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_swapchain = false;

    ~Cleanup() {
      if (has_swapchain && device_funcs.pfnDestroySwapChain) {
        device_funcs.pfnDestroySwapChain(hDevice, hSwapChain);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnPresentEx != nullptr, "PresentEx must be available")) {
    return false;
  }

  D3D9DDIARG_CREATESWAPCHAIN create_sc{};
  create_sc.present_params.backbuffer_width = 64;
  create_sc.present_params.backbuffer_height = 64;
  create_sc.present_params.backbuffer_format = 22u; // D3DFMT_X8R8G8B8
  create_sc.present_params.backbuffer_count = 2;
  create_sc.present_params.swap_effect = 1;
  create_sc.present_params.flags = 0;
  create_sc.present_params.hDeviceWindow = nullptr;
  create_sc.present_params.windowed = TRUE;
  create_sc.present_params.presentation_interval = 0;

  hr = cleanup.device_funcs.pfnCreateSwapChain(create_dev.hDevice, &create_sc);
  if (!Check(hr == S_OK, "CreateSwapChain")) {
    return false;
  }
  cleanup.hSwapChain = create_sc.hSwapChain;
  cleanup.has_swapchain = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  auto* sc = reinterpret_cast<SwapChain*>(create_sc.hSwapChain.pDrvPrivate);
  if (!Check(dev && sc, "swapchain/device pointers")) {
    return false;
  }
  if (!Check(sc->backbuffers.size() == 2, "swapchain has 2 backbuffers")) {
    return false;
  }

  const aerogpu_handle_t h0 = sc->backbuffers[0]->handle;
  const aerogpu_handle_t h1 = sc->backbuffers[1]->handle;

  hr = device_test_enable_wddm_context(create_dev.hDevice);
  if (!Check(hr == S_OK, "device_test_enable_wddm_context")) {
    return false;
  }
  D3DDDI_ALLOCATIONLIST alloc_list[1] = {};
  hr = device_test_rebind_alloc_list_tracker(create_dev.hDevice, alloc_list, 1, 0xFFFFu);
  if (!Check(hr == S_OK, "device_test_rebind_alloc_list_tracker")) {
    return false;
  }
  hr = device_test_reset_alloc_list_tracker(create_dev.hDevice);
  if (!Check(hr == S_OK, "device_test_reset_alloc_list_tracker")) {
    return false;
  }

  if (!Check(cleanup.device_funcs.pfnSetRenderTarget != nullptr, "SetRenderTarget must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetTexture != nullptr, "SetTexture must be available")) {
    return false;
  }

  D3DDDI_HRESOURCE hBb0{};
  hBb0.pDrvPrivate = sc->backbuffers[0];
  hr = device_test_set_resource_backing(create_dev.hDevice, hBb0, /*alloc_id=*/1, /*offset_bytes=*/0, /*hAllocation=*/0x1111u);
  if (!Check(hr == S_OK, "device_test_set_resource_backing(backbuffer0)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetRenderTarget(create_dev.hDevice, /*slot=*/0, hBb0);
  if (!Check(hr == S_OK, "SetRenderTarget(backbuffer0)")) {
    return false;
  }
  D3DDDI_HRESOURCE null_res{};
  hr = cleanup.device_funcs.pfnSetRenderTarget(create_dev.hDevice, /*slot=*/1, null_res);
  if (!Check(hr == S_OK, "SetRenderTarget(slot1=null)")) {
    return false;
  }
  D3DDDI_HRESOURCE hBb1{};
  hBb1.pDrvPrivate = sc->backbuffers[1];
  hr = device_test_set_resource_backing(create_dev.hDevice, hBb1, /*alloc_id=*/2, /*offset_bytes=*/0, /*hAllocation=*/0x2222u);
  if (!Check(hr == S_OK, "device_test_set_resource_backing(backbuffer1)")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetTexture(create_dev.hDevice, /*stage=*/0, hBb1);
  if (!Check(hr == S_OK, "SetTexture(stage0=backbuffer1)")) {
    return false;
  }
  // Keep the command stream empty: PresentEx may need to undo rotation without
  // submitting any of the setup packets above.
  {
    std::lock_guard<std::mutex> lock(dev->mutex);
    dev->cmd.reset();
  }

  D3D9DDIARG_PRESENTEX present{};
  present.hSrc.pDrvPrivate = nullptr;
  present.hWnd = nullptr;
  present.sync_interval = 0;
  present.d3d9_present_flags = 0;

  hr = cleanup.device_funcs.pfnPresentEx(create_dev.hDevice, &present);
  if (!Check(hr == S_OK, "PresentEx (small alloc list)")) {
    return false;
  }

  if (!Check(sc->backbuffers[0]->handle == h0 && sc->backbuffers[1]->handle == h1,
             "present rotation undone when alloc list cannot fit rebind deps")) {
    return false;
  }
  {
    std::lock_guard<std::mutex> lock(dev->mutex);
    if (!Check(dev->alloc_list_tracker.list_len() == 0, "allocation list cleared when present rotation undone")) {
      return false;
    }
  }
  return true;
}

bool TestPresentBackbufferRotationRebindsBackbufferTexture() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3D9DDI_HSWAPCHAIN hSwapChain{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_swapchain = false;

    ~Cleanup() {
      if (has_swapchain && device_funcs.pfnDestroySwapChain) {
        device_funcs.pfnDestroySwapChain(hDevice, hSwapChain);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  D3D9DDIARG_CREATESWAPCHAIN create_sc{};
  create_sc.present_params.backbuffer_width = 64;
  create_sc.present_params.backbuffer_height = 64;
  create_sc.present_params.backbuffer_format = 22u; // D3DFMT_X8R8G8B8
  create_sc.present_params.backbuffer_count = 2;
  create_sc.present_params.swap_effect = 1;
  create_sc.present_params.flags = 0;
  create_sc.present_params.hDeviceWindow = nullptr;
  create_sc.present_params.windowed = TRUE;
  create_sc.present_params.presentation_interval = 0;

  hr = cleanup.device_funcs.pfnCreateSwapChain(create_dev.hDevice, &create_sc);
  if (!Check(hr == S_OK, "CreateSwapChain")) {
    return false;
  }
  cleanup.hSwapChain = create_sc.hSwapChain;
  cleanup.has_swapchain = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  auto* sc = reinterpret_cast<SwapChain*>(create_sc.hSwapChain.pDrvPrivate);
  if (!Check(dev && sc, "swapchain/device pointers")) {
    return false;
  }
  if (!Check(sc->backbuffers.size() == 2, "swapchain has 2 backbuffers")) {
    return false;
  }

  const aerogpu_handle_t h0 = sc->backbuffers[0]->handle;
  const aerogpu_handle_t h1 = sc->backbuffers[1]->handle;

  D3DDDI_HRESOURCE hTex{};
  hTex.pDrvPrivate = sc->backbuffers[0];

  D3D9DDIARG_PRESENTEX present{};
  present.hSrc.pDrvPrivate = nullptr;
  present.hWnd = nullptr;
  present.sync_interval = 0;
  present.d3d9_present_flags = 0;

  // Small span-backed DMA buffer. PresentEx itself fits, and SET_RENDER_TARGETS
  // fits, but SET_RENDER_TARGETS + the required SET_TEXTURE rebind does not.
  uint8_t small_dma[sizeof(aerogpu_cmd_stream_header) + 64] = {};
  ScopedDeviceCmdVectorReset cmd_reset(dev);
  dev->cmd.set_span(small_dma, sizeof(small_dma));

  hr = cleanup.device_funcs.pfnSetTexture(create_dev.hDevice, 0, hTex);
  if (!Check(hr == S_OK, "SetTexture(backbuffer)")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnPresentEx(create_dev.hDevice, &present);
  if (!Check(hr == S_OK, "PresentEx (small cmd buffer)")) {
    return false;
  }

  if (!Check(sc->backbuffers[0]->handle == h0 && sc->backbuffers[1]->handle == h1,
             "present rotation undone when texture rebind cannot be emitted")) {
    return false;
  }

  // Vector-backed buffer: rotation should succeed and emit a SET_TEXTURE rebind
  // that references the rotated handle.
  dev->cmd.set_vector();
  hr = cleanup.device_funcs.pfnSetTexture(create_dev.hDevice, 0, hTex);
  if (!Check(hr == S_OK, "SetTexture(backbuffer) (vector)")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnPresentEx(create_dev.hDevice, &present);
  if (!Check(hr == S_OK, "PresentEx (vector cmd buffer)")) {
    return false;
  }

  if (!Check(sc->backbuffers[0]->handle == h1 && sc->backbuffers[1]->handle == h0,
             "present rotation occurs when rebind succeeds")) {
    return false;
  }

  dev->cmd.finalize();
  const CmdLoc loc = FindLastOpcode(dev->cmd.data(), dev->cmd.bytes_used(), AEROGPU_CMD_SET_TEXTURE);
  if (!Check(loc.hdr != nullptr, "SET_TEXTURE emitted after present rotation")) {
    return false;
  }
  const auto* cmd = reinterpret_cast<const aerogpu_cmd_set_texture*>(loc.hdr);
  if (!Check(cmd->slot == 0, "SET_TEXTURE slot 0")) {
    return false;
  }
  return Check(cmd->texture == sc->backbuffers[0]->handle, "SET_TEXTURE uses rotated backbuffer handle");
}

bool TestSetRenderTargetRejectsGaps() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3D9DDI_HSWAPCHAIN hSwapChain{};
    D3DDDI_HRESOURCE hResource{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_swapchain = false;
    bool has_resource = false;

    ~Cleanup() {
      if (has_resource && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hResource);
      }
      if (has_swapchain && device_funcs.pfnDestroySwapChain) {
        device_funcs.pfnDestroySwapChain(hDevice, hSwapChain);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  D3D9DDIARG_CREATESWAPCHAIN create_sc{};
  create_sc.present_params.backbuffer_width = 64;
  create_sc.present_params.backbuffer_height = 64;
  create_sc.present_params.backbuffer_format = 22u; // D3DFMT_X8R8G8B8
  create_sc.present_params.backbuffer_count = 1;
  create_sc.present_params.swap_effect = 1;
  create_sc.present_params.flags = 0;
  create_sc.present_params.hDeviceWindow = nullptr;
  create_sc.present_params.windowed = TRUE;
  create_sc.present_params.presentation_interval = 1;

  hr = cleanup.device_funcs.pfnCreateSwapChain(create_dev.hDevice, &create_sc);
  if (!Check(hr == S_OK, "CreateSwapChain")) {
    return false;
  }
  cleanup.hSwapChain = create_sc.hSwapChain;
  cleanup.has_swapchain = true;

  D3D9DDIARG_CREATERESOURCE create_rt{};
  create_rt.type = kD3dRTypeSurface;
  create_rt.format = 22u; // D3DFMT_X8R8G8B8
  create_rt.width = 16;
  create_rt.height = 16;
  create_rt.depth = 1;
  create_rt.mip_levels = 1;
  create_rt.usage = 1u; // D3DUSAGE_RENDERTARGET
  create_rt.pool = 0;
  create_rt.size = 0;
  create_rt.hResource.pDrvPrivate = nullptr;
  create_rt.pSharedHandle = nullptr;
  create_rt.pKmdAllocPrivateData = nullptr;
  create_rt.KmdAllocPrivateDataSize = 0;
  create_rt.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_rt);
  if (!Check(hr == S_OK, "CreateResource(render target)")) {
    return false;
  }
  cleanup.hResource = create_rt.hResource;
  cleanup.has_resource = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  {
    std::lock_guard<std::mutex> lock(dev->mutex);
    if (!Check(dev->render_targets[0] != nullptr, "render target 0 bound by swapchain")) {
      return false;
    }
    if (!Check(dev->render_targets[1] == nullptr, "render target 1 initially null")) {
      return false;
    }
    if (!Check(dev->render_targets[2] == nullptr, "render target 2 initially null")) {
      return false;
    }
    dev->cmd.reset();
  }

  // Binding slot 2 while slot 1 is null creates a gap. The host rejects gapped
  // SET_RENDER_TARGETS commands, so the UMD should reject this call.
  hr = cleanup.device_funcs.pfnSetRenderTarget(create_dev.hDevice, 2, create_rt.hResource);
  if (!Check(hr == kD3DErrInvalidCall, "SetRenderTarget rejects gaps")) {
    return false;
  }

  {
    std::lock_guard<std::mutex> lock(dev->mutex);
    if (!Check(dev->render_targets[2] == nullptr, "render target 2 not cached on invalid call")) {
      return false;
    }
  }

  dev->cmd.finalize();
  const CmdLoc loc = FindLastOpcode(dev->cmd.data(), dev->cmd.bytes_used(), AEROGPU_CMD_SET_RENDER_TARGETS);
  return Check(loc.hdr == nullptr, "no SET_RENDER_TARGETS emitted for invalid gap binding");
}

bool TestRotateResourceIdentitiesUndoOnSmallCmdBuffer() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE resources[2]{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_resources = false;

    ~Cleanup() {
      if (has_resources && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, resources[0]);
        device_funcs.pfnDestroyResource(hDevice, resources[1]);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  D3D9DDIARG_CREATERESOURCE create_res{};
  create_res.type = kD3dRTypeSurface;
  create_res.format = 22u; // D3DFMT_X8R8G8B8
  create_res.width = 16;
  create_res.height = 16;
  create_res.depth = 1;
  create_res.mip_levels = 1;
  create_res.usage = 0;
  create_res.pool = 0;
  create_res.size = 0;
  create_res.hResource.pDrvPrivate = nullptr;
  create_res.pSharedHandle = nullptr;
  create_res.pPrivateDriverData = nullptr;
  create_res.PrivateDriverDataSize = 0;
  create_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == S_OK, "CreateResource(0)")) {
    return false;
  }
  cleanup.resources[0] = create_res.hResource;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_res);
  if (!Check(hr == S_OK, "CreateResource(1)")) {
    return false;
  }
  cleanup.resources[1] = create_res.hResource;
  cleanup.has_resources = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  auto* res0 = reinterpret_cast<Resource*>(cleanup.resources[0].pDrvPrivate);
  auto* res1 = reinterpret_cast<Resource*>(cleanup.resources[1].pDrvPrivate);
  ScopedDeviceCmdVectorReset cmd_reset(dev);

  const aerogpu_handle_t h0 = res0->handle;
  const aerogpu_handle_t h1 = res1->handle;
  hr = device_test_set_resource_backing(create_dev.hDevice, cleanup.resources[0], /*alloc_id=*/111, /*offset_bytes=*/4, /*hAllocation=*/0xABC);
  if (!Check(hr == S_OK, "device_test_set_resource_backing(res0)")) {
    return false;
  }
  hr = device_test_set_resource_backing(create_dev.hDevice, cleanup.resources[1], /*alloc_id=*/222, /*offset_bytes=*/8, /*hAllocation=*/0xDEF);
  if (!Check(hr == S_OK, "device_test_set_resource_backing(res1)")) {
    return false;
  }
  if (!res0->storage.empty()) {
    res0->storage[0] = 0xA1;
  }
  if (!res1->storage.empty()) {
    res1->storage[0] = 0xB2;
  }
  res0->shared_private_driver_data = {0x01, 0x02, 0x03};
  res1->shared_private_driver_data = {0x04, 0x05};

  // Too small for SET_RENDER_TARGETS (48 bytes), so rotate should fail and restore.
  uint8_t small_dma[sizeof(aerogpu_cmd_stream_header) + 32] = {};
  dev->cmd.set_span(small_dma, sizeof(small_dma));

  hr = cleanup.device_funcs.pfnRotateResourceIdentities(create_dev.hDevice, cleanup.resources, 2);
  if (!Check(hr == E_OUTOFMEMORY, "RotateResourceIdentities returns E_OUTOFMEMORY on small cmd buffer")) {
    return false;
  }
  if (!Check(res0->handle == h0 && res1->handle == h1, "rotate identities restored handles on failure")) {
    return false;
  }
  if (!Check(res0->backing_alloc_id == 111 && res1->backing_alloc_id == 222, "rotate identities restored alloc_id on failure")) {
    return false;
  }
  if (!Check(res0->backing_offset_bytes == 4 && res1->backing_offset_bytes == 8,
             "rotate identities restored backing_offset_bytes on failure")) {
    return false;
  }
  if (!Check(res0->wddm_hAllocation == 0xABC && res1->wddm_hAllocation == 0xDEF, "rotate identities restored hAllocation on failure")) {
    return false;
  }
  if (!Check(!res0->storage.empty() && res0->storage[0] == 0xA1, "rotate identities restored storage[0] for res0 on failure")) {
    return false;
  }
  if (!Check(!res1->storage.empty() && res1->storage[0] == 0xB2, "rotate identities restored storage[0] for res1 on failure")) {
    return false;
  }
  if (!Check(res0->shared_private_driver_data.size() == 3 && res0->shared_private_driver_data[0] == 0x01,
             "rotate identities restored shared_private_driver_data for res0 on failure")) {
    return false;
  }
  if (!Check(res1->shared_private_driver_data.size() == 2 && res1->shared_private_driver_data[0] == 0x04,
             "rotate identities restored shared_private_driver_data for res1 on failure")) {
    return false;
  }

  dev->cmd.set_vector();
  hr = cleanup.device_funcs.pfnRotateResourceIdentities(create_dev.hDevice, cleanup.resources, 2);
  if (!Check(hr == S_OK, "RotateResourceIdentities succeeds with vector cmd buffer")) {
    return false;
  }
  if (!Check(res0->handle == h1 && res1->handle == h0, "rotate identities swaps handles on success")) {
    return false;
  }
  if (!Check(res0->backing_alloc_id == 222 && res1->backing_alloc_id == 111, "rotate identities swaps alloc_id on success")) {
    return false;
  }
  if (!Check(res0->backing_offset_bytes == 8 && res1->backing_offset_bytes == 4,
             "rotate identities swaps backing_offset_bytes on success")) {
    return false;
  }
  if (!Check(res0->wddm_hAllocation == 0xDEF && res1->wddm_hAllocation == 0xABC, "rotate identities swaps hAllocation on success")) {
    return false;
  }
  if (!Check(!res0->storage.empty() && res0->storage[0] == 0xB2, "rotate identities swaps storage[0] for res0 on success")) {
    return false;
  }
  if (!Check(!res1->storage.empty() && res1->storage[0] == 0xA1, "rotate identities swaps storage[0] for res1 on success")) {
    return false;
  }
  if (!Check(res0->shared_private_driver_data.size() == 2 && res0->shared_private_driver_data[0] == 0x04,
             "rotate identities swaps shared_private_driver_data for res0 on success")) {
    return false;
  }
  return Check(res1->shared_private_driver_data.size() == 3 && res1->shared_private_driver_data[0] == 0x01,
               "rotate identities swaps shared_private_driver_data for res1 on success");
}

bool TestResetRebindsBackbufferTexture() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3D9DDI_HSWAPCHAIN hSwapChain{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_swapchain = false;

    ~Cleanup() {
      if (has_swapchain && device_funcs.pfnDestroySwapChain) {
        device_funcs.pfnDestroySwapChain(hDevice, hSwapChain);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  D3D9DDIARG_CREATESWAPCHAIN create_sc{};
  create_sc.present_params.backbuffer_width = 64;
  create_sc.present_params.backbuffer_height = 64;
  create_sc.present_params.backbuffer_format = 22u; // D3DFMT_X8R8G8B8
  create_sc.present_params.backbuffer_count = 1;
  create_sc.present_params.swap_effect = 1;
  create_sc.present_params.flags = 0;
  create_sc.present_params.hDeviceWindow = nullptr;
  create_sc.present_params.windowed = TRUE;
  create_sc.present_params.presentation_interval = 1;

  hr = cleanup.device_funcs.pfnCreateSwapChain(create_dev.hDevice, &create_sc);
  if (!Check(hr == S_OK, "CreateSwapChain")) {
    return false;
  }
  cleanup.hSwapChain = create_sc.hSwapChain;
  cleanup.has_swapchain = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  auto* sc = reinterpret_cast<SwapChain*>(create_sc.hSwapChain.pDrvPrivate);
  auto* bb = reinterpret_cast<Resource*>(create_sc.hBackBuffer.pDrvPrivate);
  if (!Check(dev && sc && bb, "swapchain/device pointers")) {
    return false;
  }
  if (!Check(!sc->backbuffers.empty() && sc->backbuffers[0] == bb, "backbuffer[0]")) {
    return false;
  }

  const aerogpu_handle_t old_handle = bb->handle;

  D3DDDI_HRESOURCE hTex{};
  hTex.pDrvPrivate = bb;
  hr = cleanup.device_funcs.pfnSetTexture(create_dev.hDevice, 0, hTex);
  if (!Check(hr == S_OK, "SetTexture(backbuffer)")) {
    return false;
  }

  D3D9DDIARG_RESET reset{};
  reset.present_params = create_sc.present_params;
  hr = cleanup.device_funcs.pfnReset(create_dev.hDevice, &reset);
  if (!Check(hr == S_OK, "Reset")) {
    return false;
  }

  const aerogpu_handle_t new_handle = bb->handle;
  if (!Check(new_handle != old_handle, "Reset recreates backbuffer handle")) {
    return false;
  }

  dev->cmd.finalize();
  const CmdLoc loc = FindLastOpcode(dev->cmd.data(), dev->cmd.bytes_used(), AEROGPU_CMD_SET_TEXTURE);
  if (!Check(loc.hdr != nullptr, "SET_TEXTURE emitted after reset")) {
    return false;
  }
  const auto* cmd = reinterpret_cast<const aerogpu_cmd_set_texture*>(loc.hdr);
  if (!Check(cmd->slot == 0, "SET_TEXTURE slot 0")) {
    return false;
  }
  return Check(cmd->texture == new_handle, "SET_TEXTURE uses recreated backbuffer handle");
}

bool TestOpenResourceTracksWddmAllocationHandle() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hResource{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_resource = false;

    ~Cleanup() {
      if (has_resource && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hResource);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  if (!Check(create_dev.hDevice.pDrvPrivate != nullptr, "CreateDevice returned device handle")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  // Simulate a WDDM-enabled device so allocation-list tracking is active in
  // portable builds.
  hr = device_test_enable_wddm_context(create_dev.hDevice);
  if (!Check(hr == S_OK, "device_test_enable_wddm_context")) {
    return false;
  }
  D3DDDI_ALLOCATIONLIST list[4] = {};
  hr = device_test_rebind_alloc_list_tracker(create_dev.hDevice, list, 4, 0xFFFFu);
  if (!Check(hr == S_OK, "device_test_rebind_alloc_list_tracker")) {
    return false;
  }

  aerogpu_wddm_alloc_priv priv{};
  priv.magic = AEROGPU_WDDM_ALLOC_PRIV_MAGIC;
  priv.version = AEROGPU_WDDM_ALLOC_PRIV_VERSION;
  priv.alloc_id = 0x1234u;
  priv.flags = AEROGPU_WDDM_ALLOC_PRIV_FLAG_IS_SHARED;
  priv.share_token = 0x1122334455667788ull;
  priv.size_bytes = 64ull * 64ull * 4ull;
  priv.reserved0 = AEROGPU_WDDM_ALLOC_PRIV_DESC_PACK(/*format=*/22u, /*width=*/64u, /*height=*/64u);

  D3D9DDIARG_OPENRESOURCE open_res{};
  open_res.pPrivateDriverData = &priv;
  open_res.private_driver_data_size = sizeof(priv);
  open_res.type = 0;
  open_res.format = 0; // reconstructed from alloc priv desc
  open_res.width = 0;
  open_res.height = 0;
  open_res.depth = 1;
  open_res.mip_levels = 1;
  open_res.usage = 0;
  open_res.size = 0;
  open_res.hResource.pDrvPrivate = nullptr;
  open_res.wddm_hAllocation = 0xABCDu;

  hr = cleanup.device_funcs.pfnOpenResource(create_dev.hDevice, &open_res);
  if (!Check(hr == S_OK, "OpenResource")) {
    return false;
  }
  if (!Check(open_res.hResource.pDrvPrivate != nullptr, "OpenResource returned resource handle")) {
    return false;
  }

  cleanup.hResource = open_res.hResource;
  cleanup.has_resource = true;

  auto* res = reinterpret_cast<Resource*>(open_res.hResource.pDrvPrivate);
  if (!Check(res != nullptr, "resource pointer")) {
    return false;
  }
  if (!Check(res->backing_alloc_id == priv.alloc_id, "OpenResource preserves alloc_id from private data")) {
    return false;
  }
  if (!Check(res->wddm_hAllocation == open_res.wddm_hAllocation, "OpenResource captures WDDM hAllocation")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnSetRenderTarget(create_dev.hDevice, 0, open_res.hResource);
  if (!Check(hr == S_OK, "SetRenderTarget(opened resource)")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnClear(create_dev.hDevice,
                                     /*flags=*/0x1u,
                                     /*color_rgba8=*/0xFF00FF00u,
                                     /*depth=*/1.0f,
                                     /*stencil=*/0);
  if (!Check(hr == S_OK, "Clear tracks allocation list")) {
    return false;
  }

  if (!Check(dev->alloc_list_tracker.list_len() == 1, "allocation list has 1 entry")) {
    return false;
  }
  if (!Check(list[0].hAllocation == open_res.wddm_hAllocation, "allocation list carries hAllocation")) {
    return false;
  }
  if (!Check(list[0].WriteOperation == 1, "allocation list entry is write")) {
    return false;
  }
  return Check(list[0].AllocationListSlotId == 0, "allocation list slot id == 0");
}

bool TestOpenResourceAcceptsAllocPrivV2() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hResource{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_resource = false;

    ~Cleanup() {
      if (has_resource && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hResource);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  if (!Check(create_dev.hDevice.pDrvPrivate != nullptr, "CreateDevice returned device handle")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  // Simulate a WDDM-enabled device so allocation-list tracking is active in
  // portable builds.
  hr = device_test_enable_wddm_context(create_dev.hDevice);
  if (!Check(hr == S_OK, "device_test_enable_wddm_context")) {
    return false;
  }
  D3DDDI_ALLOCATIONLIST list[4] = {};
  hr = device_test_rebind_alloc_list_tracker(create_dev.hDevice, list, 4, 0xFFFFu);
  if (!Check(hr == S_OK, "device_test_rebind_alloc_list_tracker")) {
    return false;
  }

  aerogpu_wddm_alloc_priv_v2 priv{};
  std::memset(&priv, 0, sizeof(priv));
  priv.magic = AEROGPU_WDDM_ALLOC_PRIV_MAGIC;
  priv.version = AEROGPU_WDDM_ALLOC_PRIV_VERSION_2;
  priv.alloc_id = 0x1234u;
  priv.flags = AEROGPU_WDDM_ALLOC_PRIV_FLAG_IS_SHARED;
  priv.share_token = 0x1122334455667788ull;
  priv.size_bytes = 64ull * 64ull * 4ull;
  priv.reserved0 = AEROGPU_WDDM_ALLOC_PRIV_DESC_PACK(/*format=*/22u, /*width=*/64u, /*height=*/64u);

  D3D9DDIARG_OPENRESOURCE open_res{};
  open_res.pPrivateDriverData = &priv;
  open_res.private_driver_data_size = sizeof(priv);
  open_res.type = 0;
  open_res.format = 0; // reconstructed from alloc priv desc
  open_res.width = 0;
  open_res.height = 0;
  open_res.depth = 1;
  open_res.mip_levels = 1;
  open_res.usage = 0;
  open_res.size = 0;
  open_res.hResource.pDrvPrivate = nullptr;
  open_res.wddm_hAllocation = 0xABCDu;

  hr = cleanup.device_funcs.pfnOpenResource(create_dev.hDevice, &open_res);
  if (!Check(hr == S_OK, "OpenResource(v2)")) {
    return false;
  }
  if (!Check(open_res.hResource.pDrvPrivate != nullptr, "OpenResource(v2) returned resource handle")) {
    return false;
  }

  cleanup.hResource = open_res.hResource;
  cleanup.has_resource = true;

  auto* res = reinterpret_cast<Resource*>(open_res.hResource.pDrvPrivate);
  if (!Check(res != nullptr, "resource pointer")) {
    return false;
  }
  if (!Check(res->backing_alloc_id == priv.alloc_id, "OpenResource(v2) preserves alloc_id from private data")) {
    return false;
  }
  if (!Check(res->wddm_hAllocation == open_res.wddm_hAllocation, "OpenResource(v2) captures WDDM hAllocation")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnSetRenderTarget(create_dev.hDevice, 0, open_res.hResource);
  if (!Check(hr == S_OK, "SetRenderTarget(opened resource)")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnClear(create_dev.hDevice,
                                     /*flags=*/0x1u,
                                     /*color_rgba8=*/0xFF00FF00u,
                                     /*depth=*/1.0f,
                                     /*stencil=*/0);
  if (!Check(hr == S_OK, "Clear tracks allocation list")) {
    return false;
  }

  if (!Check(dev->alloc_list_tracker.list_len() == 1, "allocation list has 1 entry")) {
    return false;
  }
  if (!Check(list[0].hAllocation == open_res.wddm_hAllocation, "allocation list carries hAllocation")) {
    return false;
  }
  if (!Check(list[0].WriteOperation == 1, "allocation list entry is write")) {
    return false;
  }
  return Check(list[0].AllocationListSlotId == 0, "allocation list slot id == 0");
}

bool TestOpenResourceReconstructsDxgiSharedSurfaceFromAllocPrivV2() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    std::vector<D3DDDI_HRESOURCE> resources;
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyResource) {
        for (auto& hResource : resources) {
          if (hResource.pDrvPrivate) {
            device_funcs.pfnDestroyResource(hDevice, hResource);
          }
        }
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  if (!Check(create_dev.hDevice.pDrvPrivate != nullptr, "CreateDevice returned device handle")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  // Simulate a WDDM-enabled device so allocation-list tracking is active in
  // portable builds.
  hr = device_test_enable_wddm_context(create_dev.hDevice);
  if (!Check(hr == S_OK, "device_test_enable_wddm_context")) {
    return false;
  }
  D3DDDI_ALLOCATIONLIST list[4] = {};
  hr = device_test_rebind_alloc_list_tracker(create_dev.hDevice, list, 4, 0xFFFFu);
  if (!Check(hr == S_OK, "device_test_rebind_alloc_list_tracker")) {
    return false;
  }

  auto run_case = [&](uint32_t dxgi_format, uint32_t expected_d3d9_format, const char* label) -> bool {
    // Simulate a DXGI/D3D10/11 shared surface opened via D3D9Ex (DWM-style).
    //
    // In this case, reserved0 is typically used for a pitch encoding (not a D3D9
    // descriptor marker), and the v2 blob carries DXGI format + width/height.
    aerogpu_wddm_alloc_priv_v2 priv{};
    std::memset(&priv, 0, sizeof(priv));
    priv.magic = AEROGPU_WDDM_ALLOC_PRIV_MAGIC;
    priv.version = AEROGPU_WDDM_ALLOC_PRIV_VERSION_2;
    priv.alloc_id = 0x2345u;
    priv.flags = AEROGPU_WDDM_ALLOC_PRIV_FLAG_IS_SHARED;
    priv.share_token = 0x0102030405060708ull;
    priv.size_bytes = 512ull * 3ull;
    priv.reserved0 = 512ull; // pitch encoding (no desc marker bit)
    priv.kind = AEROGPU_WDDM_ALLOC_KIND_TEXTURE2D;
    priv.width = 100u;
    priv.height = 3u;
    priv.format = dxgi_format;
    priv.row_pitch_bytes = 512u;
    priv.reserved1 = 0;

    D3D9DDIARG_OPENRESOURCE open_res{};
    open_res.pPrivateDriverData = &priv;
    open_res.private_driver_data_size = sizeof(priv);
    open_res.type = 0;
    open_res.format = 0; // reconstructed from v2 metadata (DXGI->D3D9 mapping)
    open_res.width = 0;
    open_res.height = 0;
    open_res.depth = 1;
    open_res.mip_levels = 1;
    open_res.usage = 0;
    open_res.size = 0;
    open_res.hResource.pDrvPrivate = nullptr;
    open_res.wddm_hAllocation = 0xBCDEu;

    hr = cleanup.device_funcs.pfnOpenResource(create_dev.hDevice, &open_res);
    if (!Check(hr == S_OK, label)) {
      return false;
    }
    if (!Check(open_res.hResource.pDrvPrivate != nullptr, "OpenResource returned resource handle")) {
      return false;
    }

    cleanup.resources.push_back(open_res.hResource);

    auto* res = reinterpret_cast<Resource*>(open_res.hResource.pDrvPrivate);
    if (!Check(res != nullptr, "resource pointer")) {
      return false;
    }

    if (!Check(static_cast<uint32_t>(res->format) == expected_d3d9_format, "DXGI format mapped to D3D9 format")) {
      return false;
    }
    if (!Check(res->width == 100u, "width reconstructed")) {
      return false;
    }
    if (!Check(res->height == 3u, "height reconstructed")) {
      return false;
    }
    if (!Check(res->row_pitch == 512u, "row_pitch uses reserved0 pitch encoding")) {
      return false;
    }
    if (!Check(res->slice_pitch == 512u * 3u, "slice_pitch matches pitch*height")) {
      return false;
    }
    if (!Check(res->size_bytes == 512u * 3u, "size_bytes uses alloc priv size")) {
      return false;
    }

    // Verify Lock returns the reconstructed pitch for portable builds.
    D3D9DDIARG_LOCK lock{};
    lock.hResource = open_res.hResource;
    lock.offset_bytes = 0;
    lock.size_bytes = 0;
    lock.flags = 0;
    D3DDDI_LOCKEDBOX locked{};
    hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &locked);
    if (!Check(hr == S_OK, "Lock(opened resource)")) {
      return false;
    }
    if (!Check(locked.RowPitch == 512u, "Lock reports reconstructed RowPitch")) {
      return false;
    }

    D3D9DDIARG_UNLOCK unlock{};
    unlock.hResource = open_res.hResource;
    unlock.offset_bytes = 0;
    unlock.size_bytes = 0;
    hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
    if (!Check(hr == S_OK, "Unlock(opened resource)")) {
      return false;
    }

    return true;
  };

  // DXGI B8G8R8A8 -> D3D9 A8R8G8B8 (numeric value 21).
  if (!run_case(/*DXGI_FORMAT_B8G8R8A8_UNORM=*/87u, /*D3DFMT_A8R8G8B8=*/21u, "OpenResource(DXGI BGRA8 v2)")) {
    return false;
  }
  // DXGI B5G6R5 -> D3D9 R5G6B5 (numeric value 23).
  if (!run_case(/*DXGI_FORMAT_B5G6R5_UNORM=*/85u, /*D3DFMT_R5G6B5=*/23u, "OpenResource(DXGI B5G6R5 v2)")) {
    return false;
  }
  // DXGI B5G5R5A1 -> D3D9 A1R5G5B5 (numeric value 25).
  if (!run_case(/*DXGI_FORMAT_B5G5R5A1_UNORM=*/86u, /*D3DFMT_A1R5G5B5=*/25u, "OpenResource(DXGI B5G5R5A1 v2)")) {
    return false;
  }

  return true;
}

bool TestOpenResourceDecodesD3D9SharedSurfaceDescAndComputesTightPitch() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hResource{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_resource = false;

    ~Cleanup() {
      if (has_resource && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hResource);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  if (!Check(create_dev.hDevice.pDrvPrivate != nullptr, "CreateDevice returned device handle")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  if (!Check(dev->wddm_context.hContext == 0, "portable decode test expects no WDDM context")) {
    return false;
  }

  // D3D9 shared-surface metadata: reserved0 carries an encoded D3D9 descriptor.
  constexpr uint32_t kFormat = 22u; // D3DFMT_X8R8G8B8
  constexpr uint32_t kWidth = 17u;
  constexpr uint32_t kHeight = 9u;

  aerogpu_wddm_alloc_priv priv{};
  std::memset(&priv, 0, sizeof(priv));
  priv.magic = AEROGPU_WDDM_ALLOC_PRIV_MAGIC;
  priv.version = AEROGPU_WDDM_ALLOC_PRIV_VERSION;
  priv.alloc_id = 0xCAFEu;
  priv.flags = AEROGPU_WDDM_ALLOC_PRIV_FLAG_IS_SHARED;
  priv.share_token = 0x0102030405060708ull;
  priv.size_bytes = 0; // OpenResource should compute the tight size from desc.
  priv.reserved0 = AEROGPU_WDDM_ALLOC_PRIV_DESC_PACK(kFormat, kWidth, kHeight);

  D3D9DDIARG_OPENRESOURCE open_res{};
  open_res.pPrivateDriverData = &priv;
  open_res.private_driver_data_size = sizeof(priv);
  open_res.type = 0;
  open_res.format = 0; // reconstructed from reserved0 descriptor
  open_res.width = 0;
  open_res.height = 0;
  open_res.depth = 1;
  open_res.mip_levels = 1;
  open_res.usage = 0;
  open_res.size = 0;
  open_res.hResource.pDrvPrivate = nullptr;
  open_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnOpenResource(create_dev.hDevice, &open_res);
  if (!Check(hr == S_OK, "OpenResource(desc v1)")) {
    return false;
  }
  if (!Check(open_res.hResource.pDrvPrivate != nullptr, "OpenResource returned resource handle")) {
    return false;
  }

  cleanup.hResource = open_res.hResource;
  cleanup.has_resource = true;

  auto* res = reinterpret_cast<Resource*>(open_res.hResource.pDrvPrivate);
  if (!Check(res != nullptr, "resource pointer")) {
    return false;
  }

  if (!Check(static_cast<uint32_t>(res->format) == kFormat, "format reconstructed from desc")) {
    return false;
  }
  if (!Check(res->width == kWidth, "width reconstructed from desc")) {
    return false;
  }
  if (!Check(res->height == kHeight, "height reconstructed from desc")) {
    return false;
  }

  const uint32_t expected_row_pitch = kWidth * bytes_per_pixel(static_cast<D3DDDIFORMAT>(kFormat));
  if (!Check(res->row_pitch == expected_row_pitch, "row_pitch computed from bytes_per_pixel (tight)")) {
    return false;
  }
  const uint32_t expected_slice_pitch = expected_row_pitch * kHeight;
  if (!Check(res->slice_pitch == expected_slice_pitch, "slice_pitch matches tight pitch*height")) {
    return false;
  }
  return Check(res->size_bytes == expected_slice_pitch, "size_bytes matches tight slice_pitch");
}

bool TestOpenResourceReconstructsDxgiSharedSurfaceFromAllocPrivV2UsesRowPitchBytes() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    std::vector<D3DDDI_HRESOURCE> resources;
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyResource) {
        for (auto& hRes : resources) {
          if (hRes.pDrvPrivate) {
            device_funcs.pfnDestroyResource(hDevice, hRes);
          }
        }
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  if (!Check(create_dev.hDevice.pDrvPrivate != nullptr, "CreateDevice returned device handle")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  if (!Check(dev->wddm_context.hContext == 0, "portable decode test expects no WDDM context")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnLock != nullptr && cleanup.device_funcs.pfnUnlock != nullptr, "Lock/Unlock must be available")) {
    return false;
  }

  struct Case {
    uint32_t dxgi_format;
    uint32_t expected_d3d9_format;
    const char* name;
  };

  // DXGI_FORMAT numeric values from dxgiformat.h (duplicated locally so host
  // tests do not require any DXGI headers).
  constexpr uint32_t kDxgiFmtB8G8R8A8Unorm = 87u;
  constexpr uint32_t kDxgiFmtB8G8R8X8Unorm = 88u;

  const Case cases[] = {
      {kDxgiFmtB8G8R8A8Unorm, 21u, "DXGI B8G8R8A8 -> D3D9 A8R8G8B8"},
      {kDxgiFmtB8G8R8X8Unorm, 22u, "DXGI B8G8R8X8 -> D3D9 X8R8G8B8"},
  };

  for (const Case& tc : cases) {
    constexpr uint32_t kWidth = 17u;
    constexpr uint32_t kHeight = 9u;

    const uint32_t tight_pitch = kWidth * bytes_per_pixel(static_cast<D3DDDIFORMAT>(tc.expected_d3d9_format));
    const uint32_t row_pitch = tight_pitch + 64u;
    const uint32_t slice_pitch = row_pitch * kHeight;
    const uint32_t size_bytes = slice_pitch + 128u;

    aerogpu_wddm_alloc_priv_v2 priv{};
    std::memset(&priv, 0, sizeof(priv));
    priv.magic = AEROGPU_WDDM_ALLOC_PRIV_MAGIC;
    priv.version = AEROGPU_WDDM_ALLOC_PRIV_VERSION_2;
    priv.alloc_id = 0x1000u + tc.dxgi_format;
    priv.flags = AEROGPU_WDDM_ALLOC_PRIV_FLAG_IS_SHARED;
    priv.share_token = 0x1111111111111111ull + static_cast<uint64_t>(tc.dxgi_format);
    priv.size_bytes = size_bytes;
    priv.reserved0 = 0; // no desc marker, no pitch hint; use priv2.row_pitch_bytes.
    priv.kind = AEROGPU_WDDM_ALLOC_KIND_TEXTURE2D;
    priv.width = kWidth;
    priv.height = kHeight;
    priv.format = tc.dxgi_format;
    priv.row_pitch_bytes = row_pitch;
    priv.reserved1 = 0;

    D3D9DDIARG_OPENRESOURCE open_res{};
    open_res.pPrivateDriverData = &priv;
    open_res.private_driver_data_size = sizeof(priv);
    open_res.type = 0;
    open_res.format = 0; // reconstructed from v2 DXGI format mapping
    open_res.width = 0;
    open_res.height = 0;
    open_res.depth = 1;
    open_res.mip_levels = 1;
    open_res.usage = 0;
    open_res.size = 0;
    open_res.hResource.pDrvPrivate = nullptr;
    open_res.wddm_hAllocation = 0;

    hr = cleanup.device_funcs.pfnOpenResource(create_dev.hDevice, &open_res);
    if (!Check(hr == S_OK, tc.name)) {
      return false;
    }
    if (!Check(open_res.hResource.pDrvPrivate != nullptr, "OpenResource returned resource handle")) {
      return false;
    }

    cleanup.resources.push_back(open_res.hResource);

    auto* res = reinterpret_cast<Resource*>(open_res.hResource.pDrvPrivate);
    if (!Check(res != nullptr, "resource pointer")) {
      return false;
    }
    if (!Check(static_cast<uint32_t>(res->format) == tc.expected_d3d9_format, "DXGI format mapped to D3D9 format")) {
      return false;
    }
    if (!Check(res->width == kWidth && res->height == kHeight, "width/height reconstructed from v2 metadata")) {
      return false;
    }
    if (!Check(res->row_pitch == row_pitch, "row_pitch uses priv2.row_pitch_bytes")) {
      return false;
    }
    if (!Check(res->slice_pitch == slice_pitch, "slice_pitch matches row_pitch*height")) {
      return false;
    }
    if (!Check(res->size_bytes == size_bytes, "size_bytes uses alloc priv size when consistent")) {
      return false;
    }

    // Verify Lock reports the reconstructed pitch.
    D3D9DDIARG_LOCK lock{};
    lock.hResource = open_res.hResource;
    lock.offset_bytes = 0;
    lock.size_bytes = 0;
    lock.flags = 0;
    D3DDDI_LOCKEDBOX locked{};
    hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &locked);
    if (!Check(hr == S_OK, "Lock(opened resource)")) {
      return false;
    }
    if (!Check(locked.RowPitch == row_pitch, "Lock reports priv2.row_pitch_bytes")) {
      return false;
    }

    D3D9DDIARG_UNLOCK unlock{};
    unlock.hResource = open_res.hResource;
    unlock.offset_bytes = 0;
    unlock.size_bytes = 0;
    hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
    if (!Check(hr == S_OK, "Unlock(opened resource)")) {
      return false;
    }
  }

  return true;
}

bool TestOpenResourceUsesReserved0PitchHintForUncompressedSingleMipSurface() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3DDDI_HRESOURCE hResource{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_resource = false;

    ~Cleanup() {
      if (has_resource && device_funcs.pfnDestroyResource) {
        device_funcs.pfnDestroyResource(hDevice, hResource);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  if (!Check(create_dev.hDevice.pDrvPrivate != nullptr, "CreateDevice returned device handle")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  if (!Check(dev->wddm_context.hContext == 0, "portable decode test expects no WDDM context")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnLock != nullptr && cleanup.device_funcs.pfnUnlock != nullptr, "Lock/Unlock must be available")) {
    return false;
  }

  constexpr uint32_t kFormat = 21u; // D3DFMT_A8R8G8B8
  constexpr uint32_t kWidth = 100u;
  constexpr uint32_t kHeight = 3u;
  constexpr uint32_t kPitchHint = 512u; // larger than tight pitch (100*4=400)

  aerogpu_wddm_alloc_priv priv{};
  std::memset(&priv, 0, sizeof(priv));
  priv.magic = AEROGPU_WDDM_ALLOC_PRIV_MAGIC;
  priv.version = AEROGPU_WDDM_ALLOC_PRIV_VERSION;
  priv.alloc_id = 0xBEEFu;
  priv.flags = AEROGPU_WDDM_ALLOC_PRIV_FLAG_IS_SHARED;
  priv.share_token = 0x8877665544332211ull;
  priv.size_bytes = 0;
  priv.reserved0 = static_cast<uint64_t>(kPitchHint); // legacy reserved0 pitch encoding

  D3D9DDIARG_OPENRESOURCE open_res{};
  open_res.pPrivateDriverData = &priv;
  open_res.private_driver_data_size = sizeof(priv);
  open_res.type = 0;
  open_res.format = kFormat;
  open_res.width = kWidth;
  open_res.height = kHeight;
  open_res.depth = 1;
  open_res.mip_levels = 1;
  open_res.usage = 0;
  open_res.size = 0;
  open_res.hResource.pDrvPrivate = nullptr;
  open_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnOpenResource(create_dev.hDevice, &open_res);
  if (!Check(hr == S_OK, "OpenResource(reserved0 pitch hint)")) {
    return false;
  }
  if (!Check(open_res.hResource.pDrvPrivate != nullptr, "OpenResource returned resource handle")) {
    return false;
  }

  cleanup.hResource = open_res.hResource;
  cleanup.has_resource = true;

  auto* res = reinterpret_cast<Resource*>(open_res.hResource.pDrvPrivate);
  if (!Check(res != nullptr, "resource pointer")) {
    return false;
  }

  if (!Check(res->row_pitch == kPitchHint, "row_pitch uses reserved0 pitch hint")) {
    return false;
  }
  if (!Check(res->slice_pitch == kPitchHint * kHeight, "slice_pitch matches pitch hint * height")) {
    return false;
  }

  D3D9DDIARG_LOCK lock{};
  lock.hResource = open_res.hResource;
  lock.offset_bytes = 0;
  lock.size_bytes = 0;
  lock.flags = 0;
  D3DDDI_LOCKEDBOX locked{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &locked);
  if (!Check(hr == S_OK, "Lock(opened resource)")) {
    return false;
  }
  if (!Check(locked.RowPitch == kPitchHint, "Lock reports pitch hint RowPitch")) {
    return false;
  }

  D3D9DDIARG_UNLOCK unlock{};
  unlock.hResource = open_res.hResource;
  unlock.offset_bytes = 0;
  unlock.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(opened resource)")) {
    return false;
  }

  return true;
}

bool TestGuestBackedUnlockEmitsDirtyRangeNotUpload() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    std::vector<D3DDDI_HRESOURCE> resources;
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyResource) {
        for (auto& hRes : resources) {
          if (hRes.pDrvPrivate) {
            device_funcs.pfnDestroyResource(hDevice, hRes);
          }
        }
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  if (!Check(create_dev.hDevice.pDrvPrivate != nullptr, "CreateDevice returned device handle")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  aerogpu_wddm_alloc_priv priv{};
  priv.magic = AEROGPU_WDDM_ALLOC_PRIV_MAGIC;
  priv.version = AEROGPU_WDDM_ALLOC_PRIV_VERSION;
  priv.alloc_id = 0x1234u;
  priv.flags = AEROGPU_WDDM_ALLOC_PRIV_FLAG_IS_SHARED;
  priv.share_token = 0x1122334455667788ull;
  priv.size_bytes = 64;
  priv.reserved0 = 0;

  D3D9DDIARG_OPENRESOURCE open_res{};
  open_res.pPrivateDriverData = &priv;
  open_res.private_driver_data_size = sizeof(priv);
  open_res.type = 0;
  open_res.format = 0;
  open_res.width = 0;
  open_res.height = 0;
  open_res.depth = 1;
  open_res.mip_levels = 1;
  open_res.usage = 0;
  open_res.size = 64;
  open_res.hResource.pDrvPrivate = nullptr;
  open_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnOpenResource(create_dev.hDevice, &open_res);
  if (!Check(hr == S_OK, "OpenResource(guest-backed buffer)")) {
    return false;
  }
  if (!Check(open_res.hResource.pDrvPrivate != nullptr, "OpenResource returned resource handle")) {
    return false;
  }
  cleanup.resources.push_back(open_res.hResource);

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  auto* res = reinterpret_cast<Resource*>(open_res.hResource.pDrvPrivate);
  if (!Check(dev != nullptr && res != nullptr, "device/resource pointers")) {
    return false;
  }
  if (!Check(res->backing_alloc_id == priv.alloc_id, "resource backing_alloc_id populated from private data")) {
    return false;
  }
  if (!Check(res->handle != 0, "guest-backed resource has non-zero handle")) {
    return false;
  }

  D3D9DDIARG_LOCK lock{};
  lock.hResource = open_res.hResource;
  lock.offset_bytes = 8;
  lock.size_bytes = 16;
  lock.flags = 0;

  D3DDDI_LOCKEDBOX locked{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock, &locked);
  if (!Check(hr == S_OK, "Lock(guest-backed)")) {
    return false;
  }
  if (!Check(locked.pData != nullptr, "Lock returns non-null pData")) {
    return false;
  }

  std::memset(locked.pData, 0xAB, lock.size_bytes);

  D3D9DDIARG_UNLOCK unlock{};
  unlock.hResource = open_res.hResource;
  unlock.offset_bytes = lock.offset_bytes;
  unlock.size_bytes = lock.size_bytes;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock);
  if (!Check(hr == S_OK, "Unlock(guest-backed)")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  const CmdLoc upload = FindLastOpcode(buf, len, AEROGPU_CMD_UPLOAD_RESOURCE);
  if (!Check(upload.hdr == nullptr, "guest-backed unlock must not emit UPLOAD_RESOURCE")) {
    return false;
  }

  const CmdLoc dirty = FindLastOpcode(buf, len, AEROGPU_CMD_RESOURCE_DIRTY_RANGE);
  if (!Check(dirty.hdr != nullptr, "guest-backed unlock emits RESOURCE_DIRTY_RANGE")) {
    return false;
  }
  const auto* cmd = reinterpret_cast<const aerogpu_cmd_resource_dirty_range*>(dirty.hdr);
  if (!Check(cmd->hdr.size_bytes == sizeof(aerogpu_cmd_resource_dirty_range), "dirty_range packet size_bytes")) {
    return false;
  }
  if (!Check(cmd->resource_handle == res->handle, "dirty_range resource_handle matches")) {
    return false;
  }
  if (!Check(cmd->offset_bytes == lock.offset_bytes, "dirty_range offset_bytes matches")) {
    return false;
  }
  if (!Check(cmd->size_bytes == lock.size_bytes, "dirty_range size_bytes matches")) {
    return false;
  }

  return ValidateStream(buf, len);
}

bool TestProcessVerticesCopiesBytesAndUploadsHostBuffer() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    std::vector<D3DDDI_HRESOURCE> resources;
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyResource) {
        for (auto& hRes : resources) {
          if (hRes.pDrvPrivate) {
            device_funcs.pfnDestroyResource(hDevice, hRes);
          }
        }
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  if (!Check(create_dev.hDevice.pDrvPrivate != nullptr, "CreateDevice returned device handle")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  constexpr uint32_t kStride = 16;
  constexpr uint32_t kBufSize = 64;

  D3D9DDIARG_CREATERESOURCE create_src{};
  create_src.type = kD3dRTypeSurface;
  create_src.format = 0;
  create_src.width = 0;
  create_src.height = 0;
  create_src.depth = 1;
  create_src.mip_levels = 1;
  create_src.usage = 0;
  create_src.pool = 0;
  create_src.size = kBufSize;
  create_src.hResource.pDrvPrivate = nullptr;
  create_src.pSharedHandle = nullptr;
  create_src.pPrivateDriverData = nullptr;
  create_src.PrivateDriverDataSize = 0;
  create_src.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_src);
  if (!Check(hr == S_OK, "CreateResource(src buffer)")) {
    return false;
  }
  if (!Check(create_src.hResource.pDrvPrivate != nullptr, "CreateResource returned src buffer handle")) {
    return false;
  }
  cleanup.resources.push_back(create_src.hResource);

  D3D9DDIARG_CREATERESOURCE create_dst = create_src;
  create_dst.hResource.pDrvPrivate = nullptr;
  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_dst);
  if (!Check(hr == S_OK, "CreateResource(dst buffer)")) {
    return false;
  }
  if (!Check(create_dst.hResource.pDrvPrivate != nullptr, "CreateResource returned dst buffer handle")) {
    return false;
  }
  cleanup.resources.push_back(create_dst.hResource);

  auto* src_res = reinterpret_cast<Resource*>(create_src.hResource.pDrvPrivate);
  auto* dst_res = reinterpret_cast<Resource*>(create_dst.hResource.pDrvPrivate);
  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(src_res && dst_res && dev, "device/resource pointers")) {
    return false;
  }
  if (!Check(src_res->storage.size() >= kBufSize, "src buffer has CPU storage")) {
    return false;
  }
  if (!Check(dst_res->storage.size() >= kBufSize, "dst buffer has CPU storage")) {
    return false;
  }

  for (uint32_t i = 0; i < kBufSize; ++i) {
    src_res->storage[i] = static_cast<uint8_t>(i ^ 0x5Au);
    dst_res->storage[i] = 0;
  }

  hr = cleanup.device_funcs.pfnSetStreamSource(create_dev.hDevice,
                                               /*stream=*/0,
                                               create_src.hResource,
                                               /*offset_bytes=*/0,
                                               /*stride_bytes=*/kStride);
  if (!Check(hr == S_OK, "SetStreamSource(stream0=src)")) {
    return false;
  }

  D3DDDIARG_PROCESSVERTICES pv{};
  pv.SrcStartIndex = 1;
  pv.DestIndex = 2;
  pv.VertexCount = 2;
  pv.hDestBuffer = create_dst.hResource;
  pv.hVertexDecl.pDrvPrivate = nullptr;
  pv.Flags = 0;
  pv.DestStride = 0; // exercise default-to-stream0 stride behavior
  hr = cleanup.device_funcs.pfnProcessVertices(create_dev.hDevice, &pv);
  if (!Check(hr == S_OK, "ProcessVertices")) {
    return false;
  }

  const uint32_t expected_src_offset = pv.SrcStartIndex * kStride;
  const uint32_t expected_dst_offset = pv.DestIndex * kStride;
  const uint32_t expected_bytes = pv.VertexCount * kStride;

  if (!Check(std::memcmp(dst_res->storage.data() + expected_dst_offset,
                         src_res->storage.data() + expected_src_offset,
                         expected_bytes) == 0,
             "ProcessVertices copied bytes into dst storage")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  const CmdLoc upload = FindLastOpcode(buf, len, AEROGPU_CMD_UPLOAD_RESOURCE);
  if (!Check(upload.hdr != nullptr, "ProcessVertices emits UPLOAD_RESOURCE")) {
    return false;
  }
  const auto* upload_cmd = reinterpret_cast<const aerogpu_cmd_upload_resource*>(upload.hdr);
  if (!Check(upload_cmd->resource_handle == dst_res->handle, "UPLOAD_RESOURCE targets dst buffer")) {
    return false;
  }
  if (!Check(upload_cmd->offset_bytes == expected_dst_offset, "UPLOAD_RESOURCE offset matches dst byte offset")) {
    return false;
  }
  if (!Check(upload_cmd->size_bytes == expected_bytes, "UPLOAD_RESOURCE size matches copied byte count")) {
    return false;
  }

  return ValidateStream(buf, len);
}

bool TestProcessVerticesInPlaceOverlapSafeWithStrides() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    std::vector<D3DDDI_HRESOURCE> resources;
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyResource) {
        for (auto& hRes : resources) {
          if (hRes.pDrvPrivate) {
            device_funcs.pfnDestroyResource(hDevice, hRes);
          }
        }
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  if (!Check(create_dev.hDevice.pDrvPrivate != nullptr, "CreateDevice returned device handle")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  constexpr uint32_t kSrcStride = 8;
  constexpr uint32_t kDstStride = 4;
  constexpr uint32_t kVertexCount = 4;
  constexpr uint32_t kDestIndex = 1;
  constexpr uint32_t kBufSize = 64;

  D3D9DDIARG_CREATERESOURCE create_buf{};
  create_buf.type = 0;
  create_buf.format = 0;
  create_buf.width = 0;
  create_buf.height = 0;
  create_buf.depth = 1;
  create_buf.mip_levels = 1;
  create_buf.usage = 0;
  create_buf.pool = 0;
  create_buf.size = kBufSize;
  create_buf.hResource.pDrvPrivate = nullptr;
  create_buf.pSharedHandle = nullptr;
  create_buf.pPrivateDriverData = nullptr;
  create_buf.PrivateDriverDataSize = 0;
  create_buf.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_buf);
  if (!Check(hr == S_OK, "CreateResource(host buffer)")) {
    return false;
  }
  if (!Check(create_buf.hResource.pDrvPrivate != nullptr, "CreateResource returned buffer handle")) {
    return false;
  }
  cleanup.resources.push_back(create_buf.hResource);

  auto* res = reinterpret_cast<Resource*>(create_buf.hResource.pDrvPrivate);
  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(res && dev, "device/resource pointers")) {
    return false;
  }
  if (!Check(res->storage.size() >= kBufSize, "buffer has CPU storage")) {
    return false;
  }

  for (uint32_t i = 0; i < kBufSize; ++i) {
    res->storage[i] = static_cast<uint8_t>(i ^ 0xA5u);
  }
  const std::vector<uint8_t> original = res->storage;

  hr = cleanup.device_funcs.pfnSetStreamSource(create_dev.hDevice,
                                               /*stream=*/0,
                                               create_buf.hResource,
                                               /*offset_bytes=*/0,
                                               /*stride_bytes=*/kSrcStride);
  if (!Check(hr == S_OK, "SetStreamSource(stream0=buf)")) {
    return false;
  }

  D3DDDIARG_PROCESSVERTICES pv{};
  pv.SrcStartIndex = 0;
  pv.DestIndex = kDestIndex;
  pv.VertexCount = kVertexCount;
  pv.hDestBuffer = create_buf.hResource;
  pv.hVertexDecl.pDrvPrivate = nullptr;
  pv.Flags = 0;
  pv.DestStride = kDstStride;
  hr = cleanup.device_funcs.pfnProcessVertices(create_dev.hDevice, &pv);
  if (!Check(hr == S_OK, "ProcessVertices(in-place stride conversion)")) {
    return false;
  }

  // In-place aliasing with differing strides can overlap in ways that defeat a
  // simple forward/backward copy heuristic. Verify the destination bytes reflect
  // the original source bytes, not clobbered bytes from later vertices.
  if (!Check(std::memcmp(res->storage.data() + 4, original.data() + 0, 4) == 0, "dst[4..7] == original src[0..3]")) {
    return false;
  }
  if (!Check(std::memcmp(res->storage.data() + 8, original.data() + 8, 4) == 0, "dst[8..11] == original src[8..11]")) {
    return false;
  }
  if (!Check(std::memcmp(res->storage.data() + 12, original.data() + 16, 4) == 0, "dst[12..15] == original src[16..19]")) {
    return false;
  }
  if (!Check(std::memcmp(res->storage.data() + 16, original.data() + 24, 4) == 0, "dst[16..19] == original src[24..27]")) {
    return false;
  }

  dev->cmd.finalize();
  return ValidateStream(dev->cmd.data(), dev->cmd.bytes_used());
}

bool TestProcessVerticesInPlaceOverlapSafeWithStridesDestBeforeSrc() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    std::vector<D3DDDI_HRESOURCE> resources;
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyResource) {
        for (auto& hRes : resources) {
          if (hRes.pDrvPrivate) {
            device_funcs.pfnDestroyResource(hDevice, hRes);
          }
        }
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  if (!Check(create_dev.hDevice.pDrvPrivate != nullptr, "CreateDevice returned device handle")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  constexpr uint32_t kSrcStride = 4;
  constexpr uint32_t kDstStride = 8;
  constexpr uint32_t kSrcStartIndex = 1;
  constexpr uint32_t kVertexCount = 4;
  constexpr uint32_t kDestIndex = 0;
  constexpr uint32_t kBufSize = 64;

  D3D9DDIARG_CREATERESOURCE create_buf{};
  create_buf.type = 0;
  create_buf.format = 0;
  create_buf.width = 0;
  create_buf.height = 0;
  create_buf.depth = 1;
  create_buf.mip_levels = 1;
  create_buf.usage = 0;
  create_buf.pool = 0;
  create_buf.size = kBufSize;
  create_buf.hResource.pDrvPrivate = nullptr;
  create_buf.pSharedHandle = nullptr;
  create_buf.pPrivateDriverData = nullptr;
  create_buf.PrivateDriverDataSize = 0;
  create_buf.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_buf);
  if (!Check(hr == S_OK, "CreateResource(host buffer)")) {
    return false;
  }
  if (!Check(create_buf.hResource.pDrvPrivate != nullptr, "CreateResource returned buffer handle")) {
    return false;
  }
  cleanup.resources.push_back(create_buf.hResource);

  auto* res = reinterpret_cast<Resource*>(create_buf.hResource.pDrvPrivate);
  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(res && dev, "device/resource pointers")) {
    return false;
  }
  if (!Check(res->storage.size() >= kBufSize, "buffer has CPU storage")) {
    return false;
  }

  for (uint32_t i = 0; i < kBufSize; ++i) {
    res->storage[i] = static_cast<uint8_t>(i ^ 0xA5u);
  }
  const std::vector<uint8_t> original = res->storage;

  hr = cleanup.device_funcs.pfnSetStreamSource(create_dev.hDevice,
                                               /*stream=*/0,
                                               create_buf.hResource,
                                               /*offset_bytes=*/0,
                                               /*stride_bytes=*/kSrcStride);
  if (!Check(hr == S_OK, "SetStreamSource(stream0=buf)")) {
    return false;
  }

  D3DDDIARG_PROCESSVERTICES pv{};
  pv.SrcStartIndex = kSrcStartIndex;
  pv.DestIndex = kDestIndex;
  pv.VertexCount = kVertexCount;
  pv.hDestBuffer = create_buf.hResource;
  pv.hVertexDecl.pDrvPrivate = nullptr;
  pv.Flags = 0;
  pv.DestStride = kDstStride;
  hr = cleanup.device_funcs.pfnProcessVertices(create_dev.hDevice, &pv);
  if (!Check(hr == S_OK, "ProcessVertices(in-place stride conversion, dst before src)")) {
    return false;
  }

  // Cover the opposite failure mode from TestProcessVerticesInPlaceOverlapSafeWithStrides:
  // when the destination starts *before* the source, a naive forward copy can
  // still clobber a future source vertex when dst_stride > src_stride.
  if (!Check(std::memcmp(res->storage.data() + 0, original.data() + 4, 4) == 0, "dst[0..3] == original src[4..7]")) {
    return false;
  }
  if (!Check(std::memcmp(res->storage.data() + 8, original.data() + 8, 4) == 0, "dst[8..11] == original src[8..11]")) {
    return false;
  }
  if (!Check(std::memcmp(res->storage.data() + 16, original.data() + 12, 4) == 0, "dst[16..19] == original src[12..15]")) {
    return false;
  }
  if (!Check(std::memcmp(res->storage.data() + 24, original.data() + 16, 4) == 0, "dst[24..27] == original src[16..19]")) {
    return false;
  }

  dev->cmd.finalize();
  return ValidateStream(dev->cmd.data(), dev->cmd.bytes_used());
}

bool TestProcessVerticesInPlaceOverlapSafeWithEqualStrides() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    std::vector<D3DDDI_HRESOURCE> resources;
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyResource) {
        for (auto& hRes : resources) {
          if (hRes.pDrvPrivate) {
            device_funcs.pfnDestroyResource(hDevice, hRes);
          }
        }
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  if (!Check(create_dev.hDevice.pDrvPrivate != nullptr, "CreateDevice returned device handle")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  constexpr uint32_t kStride = 8;
  constexpr uint32_t kVertexCount = 4;
  constexpr uint32_t kDestIndex = 1;
  constexpr uint32_t kBufSize = 64;

  D3D9DDIARG_CREATERESOURCE create_buf{};
  create_buf.type = 0;
  create_buf.format = 0;
  create_buf.width = 0;
  create_buf.height = 0;
  create_buf.depth = 1;
  create_buf.mip_levels = 1;
  create_buf.usage = 0;
  create_buf.pool = 0;
  create_buf.size = kBufSize;
  create_buf.hResource.pDrvPrivate = nullptr;
  create_buf.pSharedHandle = nullptr;
  create_buf.pPrivateDriverData = nullptr;
  create_buf.PrivateDriverDataSize = 0;
  create_buf.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_buf);
  if (!Check(hr == S_OK, "CreateResource(host buffer)")) {
    return false;
  }
  if (!Check(create_buf.hResource.pDrvPrivate != nullptr, "CreateResource returned buffer handle")) {
    return false;
  }
  cleanup.resources.push_back(create_buf.hResource);

  auto* res = reinterpret_cast<Resource*>(create_buf.hResource.pDrvPrivate);
  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(res && dev, "device/resource pointers")) {
    return false;
  }
  if (!Check(res->storage.size() >= kBufSize, "buffer has CPU storage")) {
    return false;
  }

  for (uint32_t i = 0; i < kBufSize; ++i) {
    res->storage[i] = static_cast<uint8_t>(i ^ 0x3Cu);
  }
  const std::vector<uint8_t> original = res->storage;

  hr = cleanup.device_funcs.pfnSetStreamSource(create_dev.hDevice,
                                               /*stream=*/0,
                                               create_buf.hResource,
                                               /*offset_bytes=*/0,
                                               /*stride_bytes=*/kStride);
  if (!Check(hr == S_OK, "SetStreamSource(stream0=buf)")) {
    return false;
  }

  D3DDDIARG_PROCESSVERTICES pv{};
  pv.SrcStartIndex = 0;
  pv.DestIndex = kDestIndex;
  pv.VertexCount = kVertexCount;
  pv.hDestBuffer = create_buf.hResource;
  pv.hVertexDecl.pDrvPrivate = nullptr;
  pv.Flags = 0;
  pv.DestStride = kStride;
  hr = cleanup.device_funcs.pfnProcessVertices(create_dev.hDevice, &pv);
  if (!Check(hr == S_OK, "ProcessVertices(in-place equal-stride overlap)")) {
    return false;
  }

  // Ensure the equal-stride in-place overlap path (directional per-vertex memmove)
  // preserves memmove-like semantics.
  if (!Check(std::memcmp(res->storage.data() + 0, original.data() + 0, 8) == 0, "src prefix untouched")) {
    return false;
  }
  if (!Check(std::memcmp(res->storage.data() + 8, original.data() + 0, 8) == 0, "dst[8..15] == original src[0..7]")) {
    return false;
  }
  if (!Check(std::memcmp(res->storage.data() + 16, original.data() + 8, 8) == 0, "dst[16..23] == original src[8..15]")) {
    return false;
  }
  if (!Check(std::memcmp(res->storage.data() + 24, original.data() + 16, 8) == 0, "dst[24..31] == original src[16..23]")) {
    return false;
  }
  if (!Check(std::memcmp(res->storage.data() + 32, original.data() + 24, 8) == 0, "dst[32..39] == original src[24..31]")) {
    return false;
  }

  dev->cmd.finalize();
  return ValidateStream(dev->cmd.data(), dev->cmd.bytes_used());
}

bool TestProcessVerticesEmitsDirtyRangeForGuestBackedDest() {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    std::vector<D3DDDI_HRESOURCE> resources;
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyResource) {
        for (auto& hRes : resources) {
          if (hRes.pDrvPrivate) {
            device_funcs.pfnDestroyResource(hDevice, hRes);
          }
        }
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  if (!Check(open.hAdapter.pDrvPrivate != nullptr, "OpenAdapter2 returned adapter handle")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  if (!Check(create_dev.hDevice.pDrvPrivate != nullptr, "CreateDevice returned device handle")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  constexpr uint32_t kStride = 16;
  constexpr uint32_t kBufSize = 64;

  // Source buffer is host-backed.
  D3D9DDIARG_CREATERESOURCE create_src{};
  create_src.type = kD3dRTypeSurface;
  create_src.format = 0;
  create_src.width = 0;
  create_src.height = 0;
  create_src.depth = 1;
  create_src.mip_levels = 1;
  create_src.usage = 0;
  create_src.pool = 0;
  create_src.size = kBufSize;
  create_src.hResource.pDrvPrivate = nullptr;
  create_src.pSharedHandle = nullptr;
  create_src.pPrivateDriverData = nullptr;
  create_src.PrivateDriverDataSize = 0;
  create_src.wddm_hAllocation = 0;
  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_src);
  if (!Check(hr == S_OK, "CreateResource(src buffer)")) {
    return false;
  }
  if (!Check(create_src.hResource.pDrvPrivate != nullptr, "CreateResource returned src buffer handle")) {
    return false;
  }
  cleanup.resources.push_back(create_src.hResource);

  // Destination buffer is guest-backed via OpenResource.
  aerogpu_wddm_alloc_priv priv{};
  priv.magic = AEROGPU_WDDM_ALLOC_PRIV_MAGIC;
  priv.version = AEROGPU_WDDM_ALLOC_PRIV_VERSION;
  priv.alloc_id = 0x1234u;
  priv.flags = AEROGPU_WDDM_ALLOC_PRIV_FLAG_IS_SHARED;
  priv.share_token = 0x1122334455667788ull;
  priv.size_bytes = kBufSize;
  priv.reserved0 = 0;

  D3D9DDIARG_OPENRESOURCE open_res{};
  open_res.pPrivateDriverData = &priv;
  open_res.private_driver_data_size = sizeof(priv);
  open_res.type = 0;
  open_res.format = 0;
  open_res.width = 0;
  open_res.height = 0;
  open_res.depth = 1;
  open_res.mip_levels = 1;
  open_res.usage = 0;
  open_res.size = kBufSize;
  open_res.hResource.pDrvPrivate = nullptr;
  open_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnOpenResource(create_dev.hDevice, &open_res);
  if (!Check(hr == S_OK, "OpenResource(dst guest-backed buffer)")) {
    return false;
  }
  if (!Check(open_res.hResource.pDrvPrivate != nullptr, "OpenResource returned dst buffer handle")) {
    return false;
  }
  cleanup.resources.push_back(open_res.hResource);

  auto* src_res = reinterpret_cast<Resource*>(create_src.hResource.pDrvPrivate);
  auto* dst_res = reinterpret_cast<Resource*>(open_res.hResource.pDrvPrivate);
  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(src_res && dst_res && dev, "device/resource pointers")) {
    return false;
  }
  if (!Check(dst_res->backing_alloc_id == priv.alloc_id, "dst backing_alloc_id propagated from priv")) {
    return false;
  }

  for (uint32_t i = 0; i < kBufSize; ++i) {
    src_res->storage[i] = static_cast<uint8_t>(i);
  }

  hr = cleanup.device_funcs.pfnSetStreamSource(create_dev.hDevice,
                                               /*stream=*/0,
                                               create_src.hResource,
                                               /*offset_bytes=*/0,
                                               /*stride_bytes=*/kStride);
  if (!Check(hr == S_OK, "SetStreamSource(stream0=src)")) {
    return false;
  }

  D3DDDIARG_PROCESSVERTICES pv{};
  pv.SrcStartIndex = 0;
  pv.DestIndex = 1;
  pv.VertexCount = 2;
  pv.hDestBuffer = open_res.hResource;
  pv.hVertexDecl.pDrvPrivate = nullptr;
  pv.Flags = 0;
  pv.DestStride = 0;
  hr = cleanup.device_funcs.pfnProcessVertices(create_dev.hDevice, &pv);
  if (!Check(hr == S_OK, "ProcessVertices(guest-backed dest)")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  const CmdLoc upload = FindLastOpcode(buf, len, AEROGPU_CMD_UPLOAD_RESOURCE);
  if (!Check(upload.hdr == nullptr, "guest-backed ProcessVertices must not emit UPLOAD_RESOURCE")) {
    return false;
  }

  const CmdLoc dirty = FindLastOpcode(buf, len, AEROGPU_CMD_RESOURCE_DIRTY_RANGE);
  if (!Check(dirty.hdr != nullptr, "guest-backed ProcessVertices emits RESOURCE_DIRTY_RANGE")) {
    return false;
  }

  const uint32_t expected_offset = pv.DestIndex * kStride;
  const uint32_t expected_size = (pv.VertexCount - 1) * kStride + kStride;
  const auto* dirty_cmd = reinterpret_cast<const aerogpu_cmd_resource_dirty_range*>(dirty.hdr);
  if (!Check(dirty_cmd->resource_handle == dst_res->handle, "dirty_range targets dst buffer")) {
    return false;
  }
  if (!Check(dirty_cmd->offset_bytes == expected_offset, "dirty_range offset matches")) {
    return false;
  }
  if (!Check(dirty_cmd->size_bytes == expected_size, "dirty_range size matches")) {
    return false;
  }

  return ValidateStream(buf, len);
}

bool TestGuestBackedDirtyRangeSubmitsWhenCmdBufferFull() {
#if defined(_WIN32)
  // Portable CI builds do not exercise the WDDM DMA-buffer split behavior.
  // Skip this test on Windows where the D3D9 UMD is expected to run in the real
  // WDDM DMA-buffer path.
  return true;
#else
  std::vector<uint8_t> dma_buf(64, 0xCD);

  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    std::vector<D3DDDI_HRESOURCE> resources;
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyResource) {
        for (auto& hRes : resources) {
          if (hRes.pDrvPrivate) {
            device_funcs.pfnDestroyResource(hDevice, hRes);
          }
        }
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  aerogpu_wddm_alloc_priv priv{};
  priv.magic = AEROGPU_WDDM_ALLOC_PRIV_MAGIC;
  priv.version = AEROGPU_WDDM_ALLOC_PRIV_VERSION;
  priv.alloc_id = 0x4242u;
  priv.flags = AEROGPU_WDDM_ALLOC_PRIV_FLAG_IS_SHARED;
  priv.share_token = 0x1122334455667788ull;
  priv.size_bytes = 32;
  priv.reserved0 = 0;

  D3D9DDIARG_OPENRESOURCE open_res{};
  open_res.pPrivateDriverData = &priv;
  open_res.private_driver_data_size = sizeof(priv);
  open_res.type = 0;
  open_res.format = 0;
  open_res.width = 0;
  open_res.height = 0;
  open_res.depth = 1;
  open_res.mip_levels = 1;
  open_res.usage = 0;
  open_res.size = 32;
  open_res.hResource.pDrvPrivate = nullptr;
  open_res.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnOpenResource(create_dev.hDevice, &open_res);
  if (!Check(hr == S_OK, "OpenResource(guest-backed buffer)")) {
    return false;
  }
  cleanup.resources.push_back(open_res.hResource);

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  auto* res = reinterpret_cast<Resource*>(open_res.hResource.pDrvPrivate);
  if (!Check(dev != nullptr && res != nullptr, "device/resource pointers")) {
    return false;
  }
  ScopedDeviceCmdVectorReset cmd_reset(dev);

  {
    std::lock_guard<std::mutex> lock(dev->mutex);
    dev->cmd.set_span(dma_buf.data(), dma_buf.size());
    dev->cmd.reset();

    auto* filler = dev->cmd.TryAppendFixed<unknown_cmd_fixed>(0xDEADBEEFu);
    if (!Check(filler != nullptr, "append filler cmd")) {
      return false;
    }
    filler->value = 0xDEAD1234u;
  }

  D3D9DDIARG_LOCK lock_args{};
  lock_args.hResource = open_res.hResource;
  lock_args.offset_bytes = 0;
  lock_args.size_bytes = 4;
  lock_args.flags = 0;

  D3DDDI_LOCKEDBOX locked{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock_args, &locked);
  if (!Check(hr == S_OK, "Lock(guest-backed)")) {
    return false;
  }
  std::memset(locked.pData, 0xEF, lock_args.size_bytes);

  D3D9DDIARG_UNLOCK unlock_args{};
  unlock_args.hResource = open_res.hResource;
  unlock_args.offset_bytes = lock_args.offset_bytes;
  unlock_args.size_bytes = lock_args.size_bytes;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock_args);
  if (!Check(hr == S_OK, "Unlock(guest-backed)")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  const size_t expected_len = sizeof(aerogpu_cmd_stream_header) + sizeof(aerogpu_cmd_resource_dirty_range);
  if (!Check(len == expected_len, "dirty range flush leaves a single packet in the command buffer")) {
    return false;
  }

  if (!Check(ValidateStream(buf, len), "dirty-range stream validates")) {
    return false;
  }

  if (!Check(CountOpcode(buf, len, 0xDEADBEEFu) == 0, "filler packet was flushed")) {
    return false;
  }
  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_UPLOAD_RESOURCE) == 0, "no upload_resource emitted")) {
    return false;
  }

  const CmdLoc dirty = FindLastOpcode(buf, len, AEROGPU_CMD_RESOURCE_DIRTY_RANGE);
  if (!Check(dirty.hdr != nullptr, "dirty_range emitted")) {
    return false;
  }
  const auto* cmd = reinterpret_cast<const aerogpu_cmd_resource_dirty_range*>(dirty.hdr);
  if (!Check(cmd->resource_handle == res->handle, "dirty_range resource_handle matches")) {
    return false;
  }

  {
    std::lock_guard<std::mutex> lock(dev->mutex);
    dev->cmd.set_vector();
  }

  return true;
#endif
}

bool TestGuestBackedUpdateSurfaceEmitsDirtyRangeNotUpload() {
#if defined(_WIN32)
  // Portable tests exercise the non-WDK code paths; skip on Windows where this
  // D3D9 UMD is expected to run against the real WDDM runtime.
  return true;
#else
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    std::vector<D3DDDI_HRESOURCE> resources;
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyResource) {
        for (auto& hRes : resources) {
          if (hRes.pDrvPrivate) {
            device_funcs.pfnDestroyResource(hDevice, hRes);
          }
        }
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  D3DDDI_ALLOCATIONLIST alloc_list[8] = {};

  // Create a CPU-only system-memory source surface.
  D3D9DDIARG_CREATERESOURCE create_src{};
  create_src.type = kD3dRTypeSurface;
  create_src.format = 22u; // D3DFMT_X8R8G8B8
  create_src.width = 4;
  create_src.height = 4;
  create_src.depth = 1;
  create_src.mip_levels = 1;
  create_src.usage = 0;
  create_src.pool = 2u; // D3DPOOL_SYSTEMMEM
  create_src.size = 0;
  create_src.hResource.pDrvPrivate = nullptr;
  create_src.pSharedHandle = nullptr;
  create_src.pKmdAllocPrivateData = nullptr;
  create_src.KmdAllocPrivateDataSize = 0;
  create_src.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_src);
  if (!Check(hr == S_OK, "CreateResource(systemmem src surface)")) {
    return false;
  }
  if (!Check(create_src.hResource.pDrvPrivate != nullptr, "CreateResource returned src resource")) {
    return false;
  }
  cleanup.resources.push_back(create_src.hResource);

  // Enable allocation-list tracking after creating the systemmem resource. The
  // portable build does not emulate WDDM allocation mapping for systemmem
  // surfaces, but we still want to validate allocation tracking for the
  // guest-backed destination below.
  hr = device_test_enable_wddm_context(create_dev.hDevice);
  if (!Check(hr == S_OK, "device_test_enable_wddm_context")) {
    return false;
  }
  hr = device_test_rebind_alloc_list_tracker(create_dev.hDevice, alloc_list, 8, 0xFFFFu);
  if (!Check(hr == S_OK, "device_test_rebind_alloc_list_tracker")) {
    return false;
  }
  hr = device_test_reset_alloc_list_tracker(create_dev.hDevice);
  if (!Check(hr == S_OK, "device_test_reset_alloc_list_tracker")) {
    return false;
  }

  // Fill the source surface with some bytes.
  auto* src_res = reinterpret_cast<Resource*>(create_src.hResource.pDrvPrivate);
  if (!Check(src_res != nullptr && src_res->handle == 0, "systemmem src surface has no GPU handle")) {
    return false;
  }
  if (!Check(src_res->backing_alloc_id == 0, "systemmem src surface backing_alloc_id == 0")) {
    return false;
  }
  D3D9DDIARG_LOCK lock_src{};
  lock_src.hResource = create_src.hResource;
  lock_src.offset_bytes = 0;
  lock_src.size_bytes = 0;
  lock_src.flags = 0;

  D3DDDI_LOCKEDBOX locked_src{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock_src, &locked_src);
  if (!Check(hr == S_OK, "Lock(src systemmem)")) {
    return false;
  }
  if (!Check(locked_src.pData != nullptr, "Lock returns src pointer")) {
    return false;
  }
  if (!Check(src_res != nullptr && src_res->size_bytes != 0, "src resource size")) {
    return false;
  }
  std::memset(locked_src.pData, 0x7E, src_res->size_bytes);

  D3D9DDIARG_UNLOCK unlock_src{};
  unlock_src.hResource = create_src.hResource;
  unlock_src.offset_bytes = 0;
  unlock_src.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock_src);
  if (!Check(hr == S_OK, "Unlock(src systemmem)")) {
    return false;
  }

  // Create a guest-backed destination surface via OpenResource.
  aerogpu_wddm_alloc_priv priv{};
  priv.magic = AEROGPU_WDDM_ALLOC_PRIV_MAGIC;
  priv.version = AEROGPU_WDDM_ALLOC_PRIV_VERSION;
  priv.alloc_id = 0x7777u;
  priv.flags = AEROGPU_WDDM_ALLOC_PRIV_FLAG_IS_SHARED;
  priv.share_token = 0xAABBCCDDEEFF0011ull;
  priv.size_bytes = 4ull * 4ull * 4ull;
  priv.reserved0 = 0;

  D3D9DDIARG_OPENRESOURCE open_dst{};
  open_dst.pPrivateDriverData = &priv;
  open_dst.private_driver_data_size = sizeof(priv);
  open_dst.type = 0;
  open_dst.format = 22u; // D3DFMT_X8R8G8B8
  open_dst.width = 4;
  open_dst.height = 4;
  open_dst.depth = 1;
  open_dst.mip_levels = 1;
  open_dst.usage = 0;
  open_dst.size = 0;
  open_dst.hResource.pDrvPrivate = nullptr;
  open_dst.wddm_hAllocation = 0x1234u;

  hr = cleanup.device_funcs.pfnOpenResource(create_dev.hDevice, &open_dst);
  if (!Check(hr == S_OK, "OpenResource(guest-backed dst surface)")) {
    return false;
  }
  if (!Check(open_dst.hResource.pDrvPrivate != nullptr, "OpenResource returned dst resource")) {
    return false;
  }
  cleanup.resources.push_back(open_dst.hResource);

  auto* dst_res = reinterpret_cast<Resource*>(open_dst.hResource.pDrvPrivate);
  if (!Check(dst_res != nullptr && dst_res->backing_alloc_id == priv.alloc_id, "dst backing_alloc_id")) {
    return false;
  }

  RECT src_rect{};
  src_rect.left = 0;
  src_rect.top = 0;
  src_rect.right = 4;
  src_rect.bottom = 2;
  POINT dst_point{};
  dst_point.x = 0;
  dst_point.y = 1;

  D3D9DDIARG_UPDATESURFACE update{};
  update.hSrc = create_src.hResource;
  update.pSrcRect = &src_rect;
  update.hDst = open_dst.hResource;
  update.pDstPoint = &dst_point;
  update.flags = 0;

  hr = cleanup.device_funcs.pfnUpdateSurface(create_dev.hDevice, &update);
  if (!Check(hr == S_OK, "UpdateSurface(guest-backed dst)")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_UPLOAD_RESOURCE) == 0, "UpdateSurface must not emit UPLOAD_RESOURCE")) {
    return false;
  }

  const CmdLoc dirty = FindLastOpcode(buf, len, AEROGPU_CMD_RESOURCE_DIRTY_RANGE);
  if (!Check(dirty.hdr != nullptr, "UpdateSurface emits RESOURCE_DIRTY_RANGE")) {
    return false;
  }
  const auto* cmd = reinterpret_cast<const aerogpu_cmd_resource_dirty_range*>(dirty.hdr);
  if (!Check(cmd->resource_handle == dst_res->handle, "dirty_range handle")) {
    return false;
  }
  const uint64_t expected_offset = 1ull * 16ull; // dst_point.y * row_pitch (4*4)
  const uint64_t expected_size = 2ull * 16ull;   // 2 rows
  if (!Check(cmd->offset_bytes == expected_offset, "dirty_range offset")) {
    return false;
  }
  if (!Check(cmd->size_bytes == expected_size, "dirty_range size")) {
    return false;
  }

  if (!Check(dev->alloc_list_tracker.list_len() == 1, "allocation list contains dst mapping")) {
    return false;
  }
  if (!Check(alloc_list[0].hAllocation == open_dst.wddm_hAllocation, "allocation list hAllocation matches")) {
    return false;
  }
  if (!Check(alloc_list[0].WriteOperation == 0, "dirty range tracks allocation as read")) {
    return false;
  }

  return ValidateStream(buf, len);
#endif
}

bool TestGuestBackedUpdateSurface16BitEmitsDirtyRangeNotUpload() {
#if defined(_WIN32)
  // Portable tests exercise the non-WDK code paths; skip on Windows where this
  // D3D9 UMD is expected to run against the real WDDM runtime.
  return true;
#else
  constexpr uint32_t kD3dFmtR5G6B5 = 23u;
  constexpr D3DDDIFORMAT kFmtR5G6B5 = static_cast<D3DDDIFORMAT>(kD3dFmtR5G6B5);

  if (aerogpu::d3d9_format_to_aerogpu(kD3dFmtR5G6B5) == AEROGPU_FORMAT_INVALID) {
    std::fprintf(stderr, "INFO: skipping UpdateSurface 16-bit test (R5G6B5 not enabled)\n");
    return true;
  }

  const uint32_t bpp = aerogpu::bytes_per_pixel(kFmtR5G6B5);
  if (!Check(bpp == 2u, "bytes_per_pixel(R5G6B5) must be 2 when enabled")) {
    return false;
  }

  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    std::vector<D3DDDI_HRESOURCE> resources;
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyResource) {
        for (auto& hRes : resources) {
          if (hRes.pDrvPrivate) {
            device_funcs.pfnDestroyResource(hDevice, hRes);
          }
        }
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  D3DDDI_ALLOCATIONLIST alloc_list[8] = {};

  // Create a CPU-only system-memory source surface.
  D3D9DDIARG_CREATERESOURCE create_src{};
  create_src.type = kD3dRTypeSurface;
  create_src.format = kD3dFmtR5G6B5;
  create_src.width = 4;
  create_src.height = 4;
  create_src.depth = 1;
  create_src.mip_levels = 1;
  create_src.usage = 0;
  create_src.pool = 2u; // D3DPOOL_SYSTEMMEM
  create_src.size = 0;
  create_src.hResource.pDrvPrivate = nullptr;
  create_src.pSharedHandle = nullptr;
  create_src.pKmdAllocPrivateData = nullptr;
  create_src.KmdAllocPrivateDataSize = 0;
  create_src.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_src);
  if (!Check(hr == S_OK, "CreateResource(systemmem src surface)")) {
    return false;
  }
  if (!Check(create_src.hResource.pDrvPrivate != nullptr, "CreateResource returned src resource")) {
    return false;
  }
  cleanup.resources.push_back(create_src.hResource);

  // Enable allocation-list tracking after creating the systemmem resource. The
  // portable build does not emulate WDDM allocation mapping for systemmem
  // surfaces, but we still want to validate allocation tracking for the
  // guest-backed destination below.
  hr = device_test_enable_wddm_context(create_dev.hDevice);
  if (!Check(hr == S_OK, "device_test_enable_wddm_context")) {
    return false;
  }
  hr = device_test_rebind_alloc_list_tracker(create_dev.hDevice, alloc_list, 8, 0xFFFFu);
  if (!Check(hr == S_OK, "device_test_rebind_alloc_list_tracker")) {
    return false;
  }
  hr = device_test_reset_alloc_list_tracker(create_dev.hDevice);
  if (!Check(hr == S_OK, "device_test_reset_alloc_list_tracker")) {
    return false;
  }

  // Fill the source surface with some bytes.
  auto* src_res = reinterpret_cast<Resource*>(create_src.hResource.pDrvPrivate);
  if (!Check(src_res != nullptr && src_res->handle == 0, "systemmem src surface has no GPU handle")) {
    return false;
  }
  if (!Check(src_res->backing_alloc_id == 0, "systemmem src surface backing_alloc_id == 0")) {
    return false;
  }
  D3D9DDIARG_LOCK lock_src{};
  lock_src.hResource = create_src.hResource;
  lock_src.offset_bytes = 0;
  lock_src.size_bytes = 0;
  lock_src.flags = 0;

  D3DDDI_LOCKEDBOX locked_src{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock_src, &locked_src);
  if (!Check(hr == S_OK, "Lock(src systemmem)")) {
    return false;
  }
  if (!Check(locked_src.pData != nullptr, "Lock returns src pointer")) {
    return false;
  }
  if (!Check(src_res != nullptr && src_res->size_bytes != 0, "src resource size")) {
    return false;
  }
  std::memset(locked_src.pData, 0x7E, src_res->size_bytes);

  D3D9DDIARG_UNLOCK unlock_src{};
  unlock_src.hResource = create_src.hResource;
  unlock_src.offset_bytes = 0;
  unlock_src.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock_src);
  if (!Check(hr == S_OK, "Unlock(src systemmem)")) {
    return false;
  }

  // Create a guest-backed destination surface via OpenResource.
  aerogpu_wddm_alloc_priv priv{};
  priv.magic = AEROGPU_WDDM_ALLOC_PRIV_MAGIC;
  priv.version = AEROGPU_WDDM_ALLOC_PRIV_VERSION;
  priv.alloc_id = 0x7777u;
  priv.flags = AEROGPU_WDDM_ALLOC_PRIV_FLAG_IS_SHARED;
  priv.share_token = 0xAABBCCDDEEFF0011ull;
  priv.size_bytes = 4ull * 4ull * 2ull;
  priv.reserved0 = 0;

  D3D9DDIARG_OPENRESOURCE open_dst{};
  open_dst.pPrivateDriverData = &priv;
  open_dst.private_driver_data_size = sizeof(priv);
  open_dst.type = 0;
  open_dst.format = kD3dFmtR5G6B5;
  open_dst.width = 4;
  open_dst.height = 4;
  open_dst.depth = 1;
  open_dst.mip_levels = 1;
  open_dst.usage = 0;
  open_dst.size = 0;
  open_dst.hResource.pDrvPrivate = nullptr;
  open_dst.wddm_hAllocation = 0x1234u;

  hr = cleanup.device_funcs.pfnOpenResource(create_dev.hDevice, &open_dst);
  if (!Check(hr == S_OK, "OpenResource(guest-backed dst surface)")) {
    return false;
  }
  if (!Check(open_dst.hResource.pDrvPrivate != nullptr, "OpenResource returned dst resource")) {
    return false;
  }
  cleanup.resources.push_back(open_dst.hResource);

  auto* dst_res = reinterpret_cast<Resource*>(open_dst.hResource.pDrvPrivate);
  if (!Check(dst_res != nullptr && dst_res->backing_alloc_id == priv.alloc_id, "dst backing_alloc_id")) {
    return false;
  }

  RECT src_rect{};
  src_rect.left = 1;
  src_rect.top = 0;
  src_rect.right = 4;
  src_rect.bottom = 2;
  POINT dst_point{};
  dst_point.x = 1;
  dst_point.y = 1;

  D3D9DDIARG_UPDATESURFACE update{};
  update.hSrc = create_src.hResource;
  update.pSrcRect = &src_rect;
  update.hDst = open_dst.hResource;
  update.pDstPoint = &dst_point;
  update.flags = 0;

  hr = cleanup.device_funcs.pfnUpdateSurface(create_dev.hDevice, &update);
  if (!Check(hr == S_OK, "UpdateSurface(R5G6B5 guest-backed dst)")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_UPLOAD_RESOURCE) == 0, "UpdateSurface must not emit UPLOAD_RESOURCE")) {
    return false;
  }

  const CmdLoc dirty = FindLastOpcode(buf, len, AEROGPU_CMD_RESOURCE_DIRTY_RANGE);
  if (!Check(dirty.hdr != nullptr, "UpdateSurface emits RESOURCE_DIRTY_RANGE")) {
    return false;
  }
  const auto* cmd = reinterpret_cast<const aerogpu_cmd_resource_dirty_range*>(dirty.hdr);
  if (!Check(cmd->resource_handle == dst_res->handle, "dirty_range handle")) {
    return false;
  }

  const uint64_t expected_offset =
      static_cast<uint64_t>(dst_point.y) * dst_res->row_pitch + static_cast<uint64_t>(dst_point.x) * bpp;
  const uint64_t expected_row_bytes =
      static_cast<uint64_t>(src_rect.right - src_rect.left) * static_cast<uint64_t>(bpp);
  const uint64_t expected_size = static_cast<uint64_t>(src_rect.bottom - src_rect.top - 1) * dst_res->row_pitch + expected_row_bytes;

  if (!Check(cmd->offset_bytes == expected_offset, "dirty_range offset")) {
    return false;
  }
  if (!Check(cmd->size_bytes == expected_size, "dirty_range size")) {
    return false;
  }

  if (!Check(dev->alloc_list_tracker.list_len() == 1, "allocation list contains dst mapping")) {
    return false;
  }
  if (!Check(alloc_list[0].hAllocation == open_dst.wddm_hAllocation, "allocation list hAllocation matches")) {
    return false;
  }
  if (!Check(alloc_list[0].WriteOperation == 0, "dirty range tracks allocation as read")) {
    return false;
  }

  return ValidateStream(buf, len);
#endif
}

bool TestUpdateSurface16BitToHostBackedResourceEmitsUpload() {
#if defined(_WIN32)
  // Portable tests exercise the non-WDK code paths; skip on Windows where this
  // D3D9 UMD is expected to run against the real WDDM runtime.
  return true;
#else
  constexpr uint32_t kD3dFmtR5G6B5 = 23u;
  constexpr D3DDDIFORMAT kFmtR5G6B5 = static_cast<D3DDDIFORMAT>(kD3dFmtR5G6B5);

  if (aerogpu::d3d9_format_to_aerogpu(kD3dFmtR5G6B5) == AEROGPU_FORMAT_INVALID) {
    std::fprintf(stderr, "INFO: skipping UpdateSurface host-backed 16-bit test (R5G6B5 not enabled)\n");
    return true;
  }

  const uint32_t bpp = aerogpu::bytes_per_pixel(kFmtR5G6B5);
  if (!Check(bpp == 2u, "bytes_per_pixel(R5G6B5) must be 2 when enabled")) {
    return false;
  }

  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    std::vector<D3DDDI_HRESOURCE> resources;
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyResource) {
        for (auto& hRes : resources) {
          if (hRes.pDrvPrivate) {
            device_funcs.pfnDestroyResource(hDevice, hRes);
          }
        }
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  if (!Check(cleanup.device_funcs.pfnCreateResource != nullptr, "pfnCreateResource")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnUpdateSurface != nullptr, "pfnUpdateSurface")) {
    return false;
  }

  // Create system-memory source surface.
  //
  // D3DRESOURCETYPE::D3DRTYPE_SURFACE == 1.
  constexpr uint32_t kD3dRTypeSurface = 1u;
  D3D9DDIARG_CREATERESOURCE create_src{};
  create_src.type = kD3dRTypeSurface;
  create_src.format = kD3dFmtR5G6B5;
  create_src.width = 4;
  create_src.height = 4;
  create_src.depth = 1;
  create_src.mip_levels = 1;
  create_src.usage = 0;
  create_src.pool = 2u; // D3DPOOL_SYSTEMMEM
  create_src.size = 0;
  create_src.hResource.pDrvPrivate = nullptr;
  create_src.pSharedHandle = nullptr;
  create_src.pKmdAllocPrivateData = nullptr;
  create_src.KmdAllocPrivateDataSize = 0;
  create_src.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_src);
  if (!Check(hr == S_OK, "CreateResource(systemmem src)")) {
    return false;
  }
  if (!Check(create_src.hResource.pDrvPrivate != nullptr, "CreateResource returned src resource")) {
    return false;
  }
  cleanup.resources.push_back(create_src.hResource);

  // Create host-backed destination surface.
  D3D9DDIARG_CREATERESOURCE create_dst = create_src;
  create_dst.pool = 0; // D3DPOOL_DEFAULT
  create_dst.hResource.pDrvPrivate = nullptr;
  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_dst);
  if (!Check(hr == S_OK, "CreateResource(host-backed dst)")) {
    return false;
  }
  if (!Check(create_dst.hResource.pDrvPrivate != nullptr, "CreateResource returned dst resource")) {
    return false;
  }
  cleanup.resources.push_back(create_dst.hResource);

  auto* src_res = reinterpret_cast<Resource*>(create_src.hResource.pDrvPrivate);
  auto* dst_res = reinterpret_cast<Resource*>(create_dst.hResource.pDrvPrivate);
  if (!Check(src_res != nullptr && dst_res != nullptr, "resource pointers")) {
    return false;
  }
  if (!Check(src_res->handle == 0, "systemmem src has no GPU handle")) {
    return false;
  }
  if (!Check(dst_res->handle != 0, "host-backed dst has GPU handle")) {
    return false;
  }
  if (!Check(dst_res->backing_alloc_id == 0, "host-backed dst backing_alloc_id == 0")) {
    return false;
  }

  // Fill the systemmem source surface with a deterministic pattern.
  D3D9DDIARG_LOCK lock_src{};
  lock_src.hResource = create_src.hResource;
  lock_src.offset_bytes = 0;
  lock_src.size_bytes = 0;
  lock_src.flags = 0;

  D3DDDI_LOCKEDBOX locked_src{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock_src, &locked_src);
  if (!Check(hr == S_OK, "Lock(src)")) {
    return false;
  }
  if (!Check(locked_src.pData != nullptr, "Lock returns src pointer")) {
    return false;
  }
  if (!Check(src_res->size_bytes != 0, "src size_bytes")) {
    return false;
  }
  for (uint32_t i = 0; i < src_res->size_bytes; ++i) {
    static_cast<uint8_t*>(locked_src.pData)[i] = static_cast<uint8_t>(i);
  }

  D3D9DDIARG_UNLOCK unlock_src{};
  unlock_src.hResource = create_src.hResource;
  unlock_src.offset_bytes = 0;
  unlock_src.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock_src);
  if (!Check(hr == S_OK, "Unlock(src)")) {
    return false;
  }

  if (!Check(dst_res->storage.size() >= dst_res->size_bytes, "dst storage allocated")) {
    return false;
  }
  std::fill(dst_res->storage.begin(), dst_res->storage.end(), 0x00);

  RECT src_rect{};
  src_rect.left = 1;
  src_rect.top = 0;
  src_rect.right = 4;
  src_rect.bottom = 2;
  POINT dst_point{};
  dst_point.x = 1;
  dst_point.y = 1;

  D3D9DDIARG_UPDATESURFACE update{};
  update.hSrc = create_src.hResource;
  update.pSrcRect = &src_rect;
  update.hDst = create_dst.hResource;
  update.pDstPoint = &dst_point;
  update.flags = 0;

  // Clear any prior CREATE_RESOURCE packets so we only inspect UpdateSurface.
  dev->cmd.set_vector();
  dev->cmd.reset();

  hr = cleanup.device_funcs.pfnUpdateSurface(create_dev.hDevice, &update);
  if (!Check(hr == S_OK, "UpdateSurface(R5G6B5 host-backed dst)")) {
    return false;
  }

  // Validate dst storage updated by the CPU copy.
  const uint32_t row_pitch = dst_res->row_pitch;
  const uint32_t row_bytes = static_cast<uint32_t>(src_rect.right - src_rect.left) * bpp;
  const uint32_t upload_row_bytes = row_pitch;
  for (uint32_t row = 0; row < 2; ++row) {
    const size_t dst_off =
        static_cast<size_t>(dst_point.y + row) * row_pitch + static_cast<size_t>(dst_point.x) * bpp;
    const size_t src_off =
        static_cast<size_t>(src_rect.top + row) * src_res->row_pitch + static_cast<size_t>(src_rect.left) * bpp;
    if (!Check(std::memcmp(dst_res->storage.data() + dst_off, src_res->storage.data() + src_off, row_bytes) == 0,
               "dst storage row matches src bytes")) {
      return false;
    }
  }
  if (!Check(std::memcmp(dst_res->storage.data(), "\0\0\0\0\0\0\0\0", 8) == 0,
             "dst row 0 (untouched) remains zero")) {
    return false;
  }
  if (!Check(std::memcmp(dst_res->storage.data() + 24, "\0\0\0\0\0\0\0\0", 8) == 0,
             "dst row 3 (untouched) remains zero")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  const size_t expected_len =
      sizeof(aerogpu_cmd_stream_header) + 2 * align_up(sizeof(aerogpu_cmd_upload_resource) + upload_row_bytes, 4);
  if (!Check(len == expected_len, "UpdateSurface emits exactly 2 UPLOAD_RESOURCE packets")) {
    return false;
  }

  if (!Check(ValidateStream(buf, len), "command stream validation")) {
    return false;
  }
  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_UPLOAD_RESOURCE) == 2, "UpdateSurface emits 2 UPLOAD_RESOURCE")) {
    return false;
  }

  // Validate both row uploads.
  size_t offset = sizeof(aerogpu_cmd_stream_header);
  uint32_t upload_idx = 0;
  while (offset + sizeof(aerogpu_cmd_hdr) <= len) {
    const auto* hdr = reinterpret_cast<const aerogpu_cmd_hdr*>(buf + offset);
    if (hdr->opcode == AEROGPU_CMD_UPLOAD_RESOURCE) {
      const auto* cmd = reinterpret_cast<const aerogpu_cmd_upload_resource*>(hdr);
      const uint64_t expected_off = static_cast<uint64_t>(dst_point.y + upload_idx) * row_pitch;
      if (!Check(cmd->resource_handle == dst_res->handle, "UPLOAD_RESOURCE dst handle")) {
        return false;
      }
      if (!Check(cmd->offset_bytes == expected_off, "UPLOAD_RESOURCE offset")) {
        return false;
      }
      if (!Check(cmd->size_bytes == upload_row_bytes, "UPLOAD_RESOURCE size")) {
        return false;
      }
      const uint8_t* payload = reinterpret_cast<const uint8_t*>(cmd) + sizeof(*cmd);
      if (!Check(std::memcmp(payload, dst_res->storage.data() + static_cast<size_t>(expected_off), upload_row_bytes) == 0,
                 "UPLOAD_RESOURCE payload matches dst row bytes")) {
        return false;
      }
      upload_idx++;
    }
    if (hdr->size_bytes == 0 || hdr->size_bytes > len - offset) {
      break;
    }
    offset += hdr->size_bytes;
  }
  return Check(upload_idx == 2, "saw 2 UPLOAD_RESOURCE packets");
#endif
}

bool TestGuestBackedUpdateTextureEmitsDirtyRangeNotUpload() {
#if defined(_WIN32)
  return true;
#else
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    std::vector<D3DDDI_HRESOURCE> resources;
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyResource) {
        for (auto& hRes : resources) {
          if (hRes.pDrvPrivate) {
            device_funcs.pfnDestroyResource(hDevice, hRes);
          }
        }
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  D3DDDI_ALLOCATIONLIST alloc_list[8] = {};

  // Source: system-memory pool texture-like surface.
  D3D9DDIARG_CREATERESOURCE create_src{};
  create_src.type = kD3dRTypeTexture;
  create_src.format = 22u; // D3DFMT_X8R8G8B8
  create_src.width = 4;
  create_src.height = 4;
  create_src.depth = 1;
  create_src.mip_levels = 1;
  create_src.usage = 0;
  create_src.pool = 2u; // D3DPOOL_SYSTEMMEM
  create_src.size = 0;
  create_src.hResource.pDrvPrivate = nullptr;
  create_src.pSharedHandle = nullptr;
  create_src.pKmdAllocPrivateData = nullptr;
  create_src.KmdAllocPrivateDataSize = 0;
  create_src.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_src);
  if (!Check(hr == S_OK, "CreateResource(systemmem src)")) {
    return false;
  }
  cleanup.resources.push_back(create_src.hResource);

  // Enable allocation-list tracking after creating the systemmem resource. The
  // portable build does not emulate WDDM allocation mapping for systemmem
  // surfaces, but we still want to validate allocation tracking for the
  // guest-backed destination below.
  hr = device_test_enable_wddm_context(create_dev.hDevice);
  if (!Check(hr == S_OK, "device_test_enable_wddm_context")) {
    return false;
  }
  hr = device_test_rebind_alloc_list_tracker(create_dev.hDevice, alloc_list, 8, 0xFFFFu);
  if (!Check(hr == S_OK, "device_test_rebind_alloc_list_tracker")) {
    return false;
  }
  hr = device_test_reset_alloc_list_tracker(create_dev.hDevice);
  if (!Check(hr == S_OK, "device_test_reset_alloc_list_tracker")) {
    return false;
  }

  auto* src_res = reinterpret_cast<Resource*>(create_src.hResource.pDrvPrivate);
  if (!Check(src_res != nullptr && src_res->handle == 0, "systemmem src has no GPU handle")) {
    return false;
  }
  if (!Check(src_res->backing_alloc_id == 0, "systemmem src backing_alloc_id == 0")) {
    return false;
  }
  if (!Check(src_res != nullptr && src_res->size_bytes != 0, "src size")) {
    return false;
  }

  D3D9DDIARG_LOCK lock_src{};
  lock_src.hResource = create_src.hResource;
  lock_src.offset_bytes = 0;
  lock_src.size_bytes = 0;
  lock_src.flags = 0;

  D3DDDI_LOCKEDBOX locked_src{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock_src, &locked_src);
  if (!Check(hr == S_OK, "Lock(src)")) {
    return false;
  }
  std::memset(locked_src.pData, 0x3C, src_res->size_bytes);

  D3D9DDIARG_UNLOCK unlock_src{};
  unlock_src.hResource = create_src.hResource;
  unlock_src.offset_bytes = 0;
  unlock_src.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock_src);
  if (!Check(hr == S_OK, "Unlock(src)")) {
    return false;
  }

  // Destination: guest-backed surface via OpenResource.
  aerogpu_wddm_alloc_priv priv{};
  priv.magic = AEROGPU_WDDM_ALLOC_PRIV_MAGIC;
  priv.version = AEROGPU_WDDM_ALLOC_PRIV_VERSION;
  priv.alloc_id = 0x8888u;
  priv.flags = AEROGPU_WDDM_ALLOC_PRIV_FLAG_IS_SHARED;
  priv.share_token = 0xCAFEBABEDEADBEEFull;
  priv.size_bytes = 4ull * 4ull * 4ull;
  priv.reserved0 = 0;

  D3D9DDIARG_OPENRESOURCE open_dst{};
  open_dst.pPrivateDriverData = &priv;
  open_dst.private_driver_data_size = sizeof(priv);
  open_dst.type = 0;
  open_dst.format = 22u;
  open_dst.width = 4;
  open_dst.height = 4;
  open_dst.depth = 1;
  open_dst.mip_levels = 1;
  open_dst.usage = 0;
  open_dst.size = 0;
  open_dst.hResource.pDrvPrivate = nullptr;
  open_dst.wddm_hAllocation = 0x4321u;

  hr = cleanup.device_funcs.pfnOpenResource(create_dev.hDevice, &open_dst);
  if (!Check(hr == S_OK, "OpenResource(dst guest-backed)")) {
    return false;
  }
  cleanup.resources.push_back(open_dst.hResource);

  auto* dst_res = reinterpret_cast<Resource*>(open_dst.hResource.pDrvPrivate);
  if (!Check(dst_res != nullptr && dst_res->backing_alloc_id == priv.alloc_id, "dst backing_alloc_id")) {
    return false;
  }

  D3D9DDIARG_UPDATETEXTURE update{};
  update.hSrc = create_src.hResource;
  update.hDst = open_dst.hResource;
  update.flags = 0;

  hr = cleanup.device_funcs.pfnUpdateTexture(create_dev.hDevice, &update);
  if (!Check(hr == S_OK, "UpdateTexture(guest-backed dst)")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_UPLOAD_RESOURCE) == 0, "UpdateTexture must not emit UPLOAD_RESOURCE")) {
    return false;
  }

  const CmdLoc dirty = FindLastOpcode(buf, len, AEROGPU_CMD_RESOURCE_DIRTY_RANGE);
  if (!Check(dirty.hdr != nullptr, "UpdateTexture emits RESOURCE_DIRTY_RANGE")) {
    return false;
  }
  const auto* cmd = reinterpret_cast<const aerogpu_cmd_resource_dirty_range*>(dirty.hdr);
  if (!Check(cmd->resource_handle == dst_res->handle, "dirty_range handle")) {
    return false;
  }
  if (!Check(cmd->offset_bytes == 0, "dirty_range offset 0")) {
    return false;
  }
  if (!Check(cmd->size_bytes == dst_res->size_bytes, "dirty_range size matches dst size")) {
    return false;
  }

  if (!Check(dev->alloc_list_tracker.list_len() == 1, "allocation list contains dst mapping")) {
    return false;
  }
  if (!Check(alloc_list[0].hAllocation == open_dst.wddm_hAllocation, "allocation list hAllocation matches")) {
    return false;
  }
  if (!Check(alloc_list[0].WriteOperation == 0, "dirty range tracks allocation as read")) {
    return false;
  }

  return ValidateStream(buf, len);
#endif
}

bool TestGuestBackedUpdateTexture16BitEmitsDirtyRangeNotUpload() {
#if defined(_WIN32)
  return true;
#else
  constexpr uint32_t kD3dFmtR5G6B5 = 23u;
  constexpr D3DDDIFORMAT kFmtR5G6B5 = static_cast<D3DDDIFORMAT>(kD3dFmtR5G6B5);

  if (aerogpu::d3d9_format_to_aerogpu(kD3dFmtR5G6B5) == AEROGPU_FORMAT_INVALID) {
    std::fprintf(stderr, "INFO: skipping UpdateTexture 16-bit test (R5G6B5 not enabled)\n");
    return true;
  }

  const uint32_t bpp = aerogpu::bytes_per_pixel(kFmtR5G6B5);
  if (!Check(bpp == 2u, "bytes_per_pixel(R5G6B5) must be 2 when enabled")) {
    return false;
  }

  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    std::vector<D3DDDI_HRESOURCE> resources;
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyResource) {
        for (auto& hRes : resources) {
          if (hRes.pDrvPrivate) {
            device_funcs.pfnDestroyResource(hDevice, hRes);
          }
        }
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  D3DDDI_ALLOCATIONLIST alloc_list[8] = {};

  // Source: system-memory pool surface.
  D3D9DDIARG_CREATERESOURCE create_src{};
  create_src.type = kD3dRTypeTexture;
  create_src.format = kD3dFmtR5G6B5;
  create_src.width = 4;
  create_src.height = 4;
  create_src.depth = 1;
  create_src.mip_levels = 1;
  create_src.usage = 0;
  create_src.pool = 2u; // D3DPOOL_SYSTEMMEM
  create_src.size = 0;
  create_src.hResource.pDrvPrivate = nullptr;
  create_src.pSharedHandle = nullptr;
  create_src.pKmdAllocPrivateData = nullptr;
  create_src.KmdAllocPrivateDataSize = 0;
  create_src.wddm_hAllocation = 0;

  hr = cleanup.device_funcs.pfnCreateResource(create_dev.hDevice, &create_src);
  if (!Check(hr == S_OK, "CreateResource(systemmem src)")) {
    return false;
  }
  cleanup.resources.push_back(create_src.hResource);

  // Enable allocation-list tracking after creating the systemmem resource. The
  // portable build does not emulate WDDM allocation mapping for systemmem
  // surfaces, but we still want to validate allocation tracking for the
  // guest-backed destination below.
  hr = device_test_enable_wddm_context(create_dev.hDevice);
  if (!Check(hr == S_OK, "device_test_enable_wddm_context")) {
    return false;
  }
  hr = device_test_rebind_alloc_list_tracker(create_dev.hDevice, alloc_list, 8, 0xFFFFu);
  if (!Check(hr == S_OK, "device_test_rebind_alloc_list_tracker")) {
    return false;
  }
  hr = device_test_reset_alloc_list_tracker(create_dev.hDevice);
  if (!Check(hr == S_OK, "device_test_reset_alloc_list_tracker")) {
    return false;
  }

  auto* src_res = reinterpret_cast<Resource*>(create_src.hResource.pDrvPrivate);
  if (!Check(src_res != nullptr && src_res->handle == 0, "systemmem src has no GPU handle")) {
    return false;
  }
  if (!Check(src_res->backing_alloc_id == 0, "systemmem src backing_alloc_id == 0")) {
    return false;
  }
  if (!Check(src_res->size_bytes != 0, "src size")) {
    return false;
  }

  D3D9DDIARG_LOCK lock_src{};
  lock_src.hResource = create_src.hResource;
  lock_src.offset_bytes = 0;
  lock_src.size_bytes = 0;
  lock_src.flags = 0;

  D3DDDI_LOCKEDBOX locked_src{};
  hr = cleanup.device_funcs.pfnLock(create_dev.hDevice, &lock_src, &locked_src);
  if (!Check(hr == S_OK, "Lock(src)")) {
    return false;
  }
  if (!Check(locked_src.pData != nullptr, "Lock returns src pointer")) {
    return false;
  }
  for (uint32_t i = 0; i < src_res->size_bytes; ++i) {
    static_cast<uint8_t*>(locked_src.pData)[i] = static_cast<uint8_t>(0x5Au ^ static_cast<uint8_t>(i));
  }

  D3D9DDIARG_UNLOCK unlock_src{};
  unlock_src.hResource = create_src.hResource;
  unlock_src.offset_bytes = 0;
  unlock_src.size_bytes = 0;
  hr = cleanup.device_funcs.pfnUnlock(create_dev.hDevice, &unlock_src);
  if (!Check(hr == S_OK, "Unlock(src)")) {
    return false;
  }

  // Destination: guest-backed surface via OpenResource.
  aerogpu_wddm_alloc_priv priv{};
  priv.magic = AEROGPU_WDDM_ALLOC_PRIV_MAGIC;
  priv.version = AEROGPU_WDDM_ALLOC_PRIV_VERSION;
  priv.alloc_id = 0x9999u;
  priv.flags = AEROGPU_WDDM_ALLOC_PRIV_FLAG_IS_SHARED;
  priv.share_token = 0xCAFEBABEDEADBEEFull;
  priv.size_bytes = 4ull * 4ull * 2ull;
  priv.reserved0 = 0;

  D3D9DDIARG_OPENRESOURCE open_dst{};
  open_dst.pPrivateDriverData = &priv;
  open_dst.private_driver_data_size = sizeof(priv);
  open_dst.type = 0;
  open_dst.format = kD3dFmtR5G6B5;
  open_dst.width = 4;
  open_dst.height = 4;
  open_dst.depth = 1;
  open_dst.mip_levels = 1;
  open_dst.usage = 0;
  open_dst.size = 0;
  open_dst.hResource.pDrvPrivate = nullptr;
  open_dst.wddm_hAllocation = 0x5678u;

  hr = cleanup.device_funcs.pfnOpenResource(create_dev.hDevice, &open_dst);
  if (!Check(hr == S_OK, "OpenResource(dst guest-backed)")) {
    return false;
  }
  cleanup.resources.push_back(open_dst.hResource);

  auto* dst_res = reinterpret_cast<Resource*>(open_dst.hResource.pDrvPrivate);
  if (!Check(dst_res != nullptr && dst_res->backing_alloc_id == priv.alloc_id, "dst backing_alloc_id")) {
    return false;
  }

  D3D9DDIARG_UPDATETEXTURE update{};
  update.hSrc = create_src.hResource;
  update.hDst = open_dst.hResource;
  update.flags = 0;

  dev->cmd.set_vector();
  dev->cmd.reset();

  hr = cleanup.device_funcs.pfnUpdateTexture(create_dev.hDevice, &update);
  if (!Check(hr == S_OK, "UpdateTexture(R5G6B5 guest-backed dst)")) {
    return false;
  }

  if (!Check(dst_res->storage.size() == src_res->storage.size(), "dst storage size matches src")) {
    return false;
  }
  if (!Check(std::memcmp(dst_res->storage.data(), src_res->storage.data(), dst_res->storage.size()) == 0,
             "UpdateTexture copied bytes into alloc-backed dst storage")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_UPLOAD_RESOURCE) == 0, "UpdateTexture must not emit UPLOAD_RESOURCE")) {
    return false;
  }

  const CmdLoc dirty = FindLastOpcode(buf, len, AEROGPU_CMD_RESOURCE_DIRTY_RANGE);
  if (!Check(dirty.hdr != nullptr, "UpdateTexture emits RESOURCE_DIRTY_RANGE")) {
    return false;
  }
  const auto* cmd = reinterpret_cast<const aerogpu_cmd_resource_dirty_range*>(dirty.hdr);
  if (!Check(cmd->resource_handle == dst_res->handle, "dirty_range handle")) {
    return false;
  }
  if (!Check(cmd->offset_bytes == 0, "dirty_range offset 0")) {
    return false;
  }
  if (!Check(cmd->size_bytes == dst_res->size_bytes, "dirty_range size matches dst size")) {
    return false;
  }

  if (!Check(dev->alloc_list_tracker.list_len() == 1, "allocation list contains dst mapping")) {
    return false;
  }
  if (!Check(alloc_list[0].hAllocation == open_dst.wddm_hAllocation, "allocation list hAllocation matches")) {
    return false;
  }
  if (!Check(alloc_list[0].WriteOperation == 0, "dirty range tracks allocation as read")) {
    return false;
  }

  return ValidateStream(buf, len);
#endif
}

bool TestGetRenderTargetData16BitEmitsDirtyRangeOrUpload() {
#if defined(_WIN32)
  // Portable tests exercise the non-WDK code paths; skip on Windows where this
  // D3D9 UMD is expected to run against the real WDDM runtime.
  return true;
#else
  constexpr uint32_t kD3dFmtR5G6B5 = 23u;
  constexpr D3DDDIFORMAT kFmtR5G6B5 = static_cast<D3DDDIFORMAT>(kD3dFmtR5G6B5);

  // This test only runs when the driver enables R5G6B5 support.
  if (aerogpu::d3d9_format_to_aerogpu(kD3dFmtR5G6B5) == AEROGPU_FORMAT_INVALID) {
    std::fprintf(stderr, "INFO: skipping GetRenderTargetData 16-bit test (R5G6B5 not enabled)\n");
    return true;
  }

  const uint32_t bpp = aerogpu::bytes_per_pixel(kFmtR5G6B5);
  if (!Check(bpp == 2u, "bytes_per_pixel(R5G6B5) must be 2 when enabled")) {
    return false;
  }

  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnGetRenderTargetData != nullptr, "pfnGetRenderTargetData")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }
  dev->cmd.set_vector();
  dev->cmd.reset();

  constexpr uint32_t kWidth = 4;
  constexpr uint32_t kHeight = 4;
  const uint32_t row_pitch = kWidth * bpp;
  const uint32_t size_bytes = row_pitch * kHeight;

  Resource src{};
  src.kind = ResourceKind::Surface;
  src.handle = 0x1000u;
  src.format = kFmtR5G6B5;
  src.width = kWidth;
  src.height = kHeight;
  src.depth = 1;
  src.mip_levels = 1;
  src.pool = 0;
  src.size_bytes = size_bytes;
  src.row_pitch = row_pitch;
  src.slice_pitch = size_bytes;
  src.storage.resize(size_bytes);
  for (uint32_t i = 0; i < size_bytes; ++i) {
    src.storage[i] = static_cast<uint8_t>(0xA5u ^ static_cast<uint8_t>(i));
  }

  Resource dst{};
  dst.kind = ResourceKind::Surface;
  dst.handle = 0x2000u;
  dst.format = kFmtR5G6B5;
  dst.width = kWidth;
  dst.height = kHeight;
  dst.depth = 1;
  dst.mip_levels = 1;
  dst.pool = 2u; // D3DPOOL_SYSTEMMEM
  dst.size_bytes = size_bytes;
  dst.row_pitch = row_pitch;
  dst.slice_pitch = size_bytes;
  dst.storage.resize(size_bytes, 0);

  D3DDDI_HRESOURCE hSrc{};
  hSrc.pDrvPrivate = &src;
  D3DDDI_HRESOURCE hDst{};
  hDst.pDrvPrivate = &dst;

  D3D9DDIARG_GETRENDERTARGETDATA args{};
  args.hSrcResource = hSrc;
  args.hDstResource = hDst;

  // Case 1: host-allocated destination (backing_alloc_id==0) should emit
  // UPLOAD_RESOURCE after the CPU fallback copy.
  dst.backing_alloc_id = 0;
  dst.wddm_hAllocation = 0;
  std::memset(dst.storage.data(), 0, dst.storage.size());
  dev->cmd.reset();

  hr = cleanup.device_funcs.pfnGetRenderTargetData(create_dev.hDevice, &args);
  if (!Check(hr == S_OK, "GetRenderTargetData(R5G6B5 host-allocated dst)")) {
    return false;
  }
  if (!Check(dst.storage.size() == src.storage.size(), "dst storage size matches src")) {
    return false;
  }
  if (!Check(std::memcmp(dst.storage.data(), src.storage.data(), dst.storage.size()) == 0,
             "GetRenderTargetData copied bytes into dst storage")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dev->cmd.data();
  const size_t len = dev->cmd.bytes_used();

  const CmdLoc upload = FindLastOpcode(buf, len, AEROGPU_CMD_UPLOAD_RESOURCE);
  if (!Check(upload.hdr != nullptr, "GetRenderTargetData(host-allocated) emits UPLOAD_RESOURCE")) {
    return false;
  }
  if (!Check(CountOpcode(buf, len, AEROGPU_CMD_UPLOAD_RESOURCE) == 1, "expected one UPLOAD_RESOURCE packet")) {
    return false;
  }

  const auto* upload_cmd = reinterpret_cast<const aerogpu_cmd_upload_resource*>(upload.hdr);
  if (!Check(upload_cmd->resource_handle == dst.handle, "UPLOAD_RESOURCE handle matches dst")) {
    return false;
  }
  if (!Check(upload_cmd->offset_bytes == 0, "UPLOAD_RESOURCE offset 0")) {
    return false;
  }
  if (!Check(upload_cmd->size_bytes == dst.size_bytes, "UPLOAD_RESOURCE size matches dst size")) {
    return false;
  }
  const uint8_t* payload = reinterpret_cast<const uint8_t*>(upload_cmd) + sizeof(*upload_cmd);
  if (!Check(std::memcmp(payload, src.storage.data(), dst.size_bytes) == 0, "UPLOAD_RESOURCE payload matches src bytes")) {
    return false;
  }
  if (!Check(ValidateStream(buf, len), "command stream validation")) {
    return false;
  }

  // Case 2: allocation-backed destination should emit RESOURCE_DIRTY_RANGE (not
  // UPLOAD_RESOURCE) after the CPU fallback copy.
  dst.backing_alloc_id = 0x4321u;
  dst.wddm_hAllocation = 0x1111u;
  std::memset(dst.storage.data(), 0, dst.storage.size());
  dev->cmd.reset();

  hr = cleanup.device_funcs.pfnGetRenderTargetData(create_dev.hDevice, &args);
  if (!Check(hr == S_OK, "GetRenderTargetData(R5G6B5 alloc-backed dst)")) {
    return false;
  }
  if (!Check(std::memcmp(dst.storage.data(), src.storage.data(), dst.storage.size()) == 0,
             "GetRenderTargetData copied bytes into alloc-backed dst storage")) {
    return false;
  }

  dev->cmd.finalize();
  buf = dev->cmd.data();
  const size_t len2 = dev->cmd.bytes_used();

  if (!Check(CountOpcode(buf, len2, AEROGPU_CMD_UPLOAD_RESOURCE) == 0,
             "alloc-backed GetRenderTargetData must not emit UPLOAD_RESOURCE")) {
    return false;
  }

  const CmdLoc dirty = FindLastOpcode(buf, len2, AEROGPU_CMD_RESOURCE_DIRTY_RANGE);
  if (!Check(dirty.hdr != nullptr, "GetRenderTargetData(alloc-backed) emits RESOURCE_DIRTY_RANGE")) {
    return false;
  }
  const auto* dirty_cmd = reinterpret_cast<const aerogpu_cmd_resource_dirty_range*>(dirty.hdr);
  if (!Check(dirty_cmd->resource_handle == dst.handle, "dirty_range handle matches dst")) {
    return false;
  }
  if (!Check(dirty_cmd->offset_bytes == 0, "dirty_range offset 0")) {
    return false;
  }
  if (!Check(dirty_cmd->size_bytes == dst.size_bytes, "dirty_range size matches dst size")) {
    return false;
  }

  return ValidateStream(buf, len2);
#endif
}

bool TestGetRenderTargetData16BitTransferEmitsCopyTexture2D() {
#if defined(_WIN32)
  // Portable tests exercise the non-WDK code paths; skip on Windows where this
  // D3D9 UMD is expected to run against the real WDDM runtime.
  return true;
#else
  constexpr uint32_t kD3dFmtR5G6B5 = 23u;
  constexpr D3DDDIFORMAT kFmtR5G6B5 = static_cast<D3DDDIFORMAT>(kD3dFmtR5G6B5);

  // This test only runs when the driver enables R5G6B5 support.
  if (aerogpu::d3d9_format_to_aerogpu(kD3dFmtR5G6B5) == AEROGPU_FORMAT_INVALID) {
    std::fprintf(stderr, "INFO: skipping GetRenderTargetData transfer 16-bit test (R5G6B5 not enabled)\n");
    return true;
  }

  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnGetRenderTargetData != nullptr, "pfnGetRenderTargetData")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev && dev->adapter, "device+adapter pointers")) {
    return false;
  }

  // Force the transfer-supported path in portable tests by stubbing the
  // UMDRIVERPRIVATE discovery blob.
  hr = device_test_force_umd_private_features(create_dev.hDevice, AEROGPU_UMDPRIV_FEATURE_TRANSFER);
  if (!Check(hr == S_OK, "device_test_force_umd_private_features(TRANSFER)")) {
    return false;
  }

  // Use a span-backed command buffer so submit()'s rewind preserves the finalized
  // bytes for inspection.
  uint8_t stream_buf[256] = {};
  dev->cmd.set_span(stream_buf, sizeof(stream_buf));
  dev->cmd.reset();
  struct CmdModeGuard {
    Device* dev = nullptr;
    ~CmdModeGuard() {
      if (dev) {
        // Cleanup destructors may submit, so ensure we don't reference the
        // stack-backed command buffer after this test completes.
        dev->cmd.set_vector();
      }
    }
  } cmd_guard{dev};

  const uint32_t bpp = aerogpu::bytes_per_pixel(kFmtR5G6B5);
  if (!Check(bpp == 2u, "bytes_per_pixel(R5G6B5) must be 2 when enabled")) {
    return false;
  }

  constexpr uint32_t kWidth = 4;
  constexpr uint32_t kHeight = 4;
  const uint32_t row_pitch = kWidth * bpp;
  const uint32_t size_bytes = row_pitch * kHeight;

  Resource src{};
  src.kind = ResourceKind::Surface;
  src.handle = 0x1000u;
  src.format = kFmtR5G6B5;
  src.width = kWidth;
  src.height = kHeight;
  src.depth = 1;
  src.mip_levels = 1;
  src.pool = 0;
  src.size_bytes = size_bytes;
  src.row_pitch = row_pitch;
  src.slice_pitch = size_bytes;

  Resource dst{};
  dst.kind = ResourceKind::Surface;
  dst.handle = 0x2000u;
  dst.format = kFmtR5G6B5;
  dst.width = kWidth;
  dst.height = kHeight;
  dst.depth = 1;
  dst.mip_levels = 1;
  dst.pool = 2u; // D3DPOOL_SYSTEMMEM
  dst.size_bytes = size_bytes;
  dst.row_pitch = row_pitch;
  dst.slice_pitch = size_bytes;
  dst.backing_alloc_id = 0x1234u; // required for WRITEBACK_DST
  dst.wddm_hAllocation = 0; // not used in portable path

  D3DDDI_HRESOURCE hSrc{};
  hSrc.pDrvPrivate = &src;
  D3DDDI_HRESOURCE hDst{};
  hDst.pDrvPrivate = &dst;

  D3D9DDIARG_GETRENDERTARGETDATA args{};
  args.hSrcResource = hSrc;
  args.hDstResource = hDst;

  hr = cleanup.device_funcs.pfnGetRenderTargetData(create_dev.hDevice, &args);
  if (!Check(hr == S_OK, "GetRenderTargetData(R5G6B5 transfer-supported)")) {
    return false;
  }

  if (!Check(ValidateStream(stream_buf, sizeof(stream_buf)), "command stream validation")) {
    return false;
  }

  if (!Check(CountOpcode(stream_buf, sizeof(stream_buf), AEROGPU_CMD_COPY_TEXTURE2D) == 1,
             "GetRenderTargetData emits COPY_TEXTURE2D")) {
    return false;
  }
  if (!Check(CountOpcode(stream_buf, sizeof(stream_buf), AEROGPU_CMD_UPLOAD_RESOURCE) == 0,
             "transfer GetRenderTargetData must not emit UPLOAD_RESOURCE")) {
    return false;
  }
  if (!Check(CountOpcode(stream_buf, sizeof(stream_buf), AEROGPU_CMD_RESOURCE_DIRTY_RANGE) == 0,
             "transfer GetRenderTargetData must not emit RESOURCE_DIRTY_RANGE")) {
    return false;
  }

  const CmdLoc copy = FindLastOpcode(stream_buf, sizeof(stream_buf), AEROGPU_CMD_COPY_TEXTURE2D);
  if (!Check(copy.hdr != nullptr, "COPY_TEXTURE2D location")) {
    return false;
  }
  const auto* cmd = reinterpret_cast<const aerogpu_cmd_copy_texture2d*>(copy.hdr);
  if (!Check(cmd->src_texture == src.handle, "COPY_TEXTURE2D src_texture matches")) {
    return false;
  }
  if (!Check(cmd->dst_texture == dst.handle, "COPY_TEXTURE2D dst_texture matches")) {
    return false;
  }
  if (!Check(cmd->width == kWidth && cmd->height == kHeight, "COPY_TEXTURE2D width/height match surface")) {
    return false;
  }
  if (!Check(cmd->flags == AEROGPU_COPY_FLAG_WRITEBACK_DST, "COPY_TEXTURE2D has WRITEBACK_DST flag")) {
    return false;
  }

  return true;
#endif
}

bool TestGetRenderTargetDataTransferRetracksAllocationsAfterFlush() {
#if defined(_WIN32)
  return true;
#else
  constexpr uint32_t kD3dFmtR5G6B5 = 23u;
  constexpr D3DDDIFORMAT kFmtR5G6B5 = static_cast<D3DDDIFORMAT>(kD3dFmtR5G6B5);

  if (aerogpu::d3d9_format_to_aerogpu(kD3dFmtR5G6B5) == AEROGPU_FORMAT_INVALID) {
    std::fprintf(stderr, "INFO: skipping GetRenderTargetData alloc-list split test (R5G6B5 not enabled)\n");
    return true;
  }

  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev && dev->adapter, "device+adapter pointers")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnGetRenderTargetData != nullptr, "pfnGetRenderTargetData")) {
    return false;
  }

  hr = device_test_force_umd_private_features(create_dev.hDevice, AEROGPU_UMDPRIV_FEATURE_TRANSFER);
  if (!Check(hr == S_OK, "device_test_force_umd_private_features(TRANSFER)")) {
    return false;
  }

  // Enable allocation list tracking with a tiny capacity so tracking `src`
  // forces a submission split, requiring `dst` to be re-tracked.
  D3DDDI_ALLOCATIONLIST alloc_list[2] = {};
  hr = device_test_enable_wddm_context(create_dev.hDevice);
  if (!Check(hr == S_OK, "device_test_enable_wddm_context")) {
    return false;
  }
  hr = device_test_rebind_alloc_list_tracker(create_dev.hDevice, alloc_list, 2, 0xFFFFu);
  if (!Check(hr == S_OK, "device_test_rebind_alloc_list_tracker")) {
    return false;
  }
  hr = device_test_reset_alloc_list_tracker(create_dev.hDevice);
  if (!Check(hr == S_OK, "device_test_reset_alloc_list_tracker")) {
    return false;
  }
  // Pre-fill one entry so tracking the two copy resources requires a flush.
  const auto pre =
      device_test_track_texture_read(create_dev.hDevice, /*hAllocation=*/0xAAAAu, /*alloc_id=*/0xAAAAu, /*share_token=*/0);
  if (!Check(pre.status == AllocRefStatus::kOk, "pre-fill allocation list")) {
    return false;
  }
  if (!Check(dev->alloc_list_tracker.list_len() == 1, "pre-fill list_len==1")) {
    return false;
  }

  // Use a span-backed buffer so submit()'s rewind preserves the bytes.
  uint8_t stream_buf[256] = {};
  dev->cmd.set_span(stream_buf, sizeof(stream_buf));
  dev->cmd.reset();
  struct CmdModeGuard {
    Device* dev = nullptr;
    ~CmdModeGuard() {
      if (dev) {
        dev->cmd.set_vector();
      }
    }
  } cmd_guard{dev};

  const uint32_t bpp = aerogpu::bytes_per_pixel(kFmtR5G6B5);
  if (!Check(bpp == 2u, "bytes_per_pixel(R5G6B5)")) {
    return false;
  }

  constexpr uint32_t kWidth = 4;
  constexpr uint32_t kHeight = 4;

  Resource src{};
  src.kind = ResourceKind::Surface;
  src.handle = 0x1000u;
  src.format = kFmtR5G6B5;
  src.width = kWidth;
  src.height = kHeight;
  src.depth = 1;
  src.mip_levels = 1;
  src.pool = 0;
  src.row_pitch = kWidth * bpp;
  src.slice_pitch = src.row_pitch * kHeight;
  src.size_bytes = src.slice_pitch;
  src.backing_alloc_id = 0x2000u;
  src.wddm_hAllocation = 0x2000u;

  Resource dst{};
  dst.kind = ResourceKind::Surface;
  dst.handle = 0x2000u;
  dst.format = kFmtR5G6B5;
  dst.width = kWidth;
  dst.height = kHeight;
  dst.depth = 1;
  dst.mip_levels = 1;
  dst.pool = 2u; // D3DPOOL_SYSTEMMEM
  dst.row_pitch = src.row_pitch;
  dst.slice_pitch = src.slice_pitch;
  dst.size_bytes = src.size_bytes;
  dst.backing_alloc_id = 0x3000u;
  dst.wddm_hAllocation = 0x3000u;

  D3DDDI_HRESOURCE hSrc{};
  hSrc.pDrvPrivate = &src;
  D3DDDI_HRESOURCE hDst{};
  hDst.pDrvPrivate = &dst;

  D3D9DDIARG_GETRENDERTARGETDATA args{};
  args.hSrcResource = hSrc;
  args.hDstResource = hDst;

  hr = cleanup.device_funcs.pfnGetRenderTargetData(create_dev.hDevice, &args);
  if (!Check(hr == S_OK, "GetRenderTargetData(transfer + alloc tracking)")) {
    return false;
  }

  if (!Check(ValidateStream(stream_buf, sizeof(stream_buf)), "command stream validation")) {
    return false;
  }
  if (!Check(CountOpcode(stream_buf, sizeof(stream_buf), AEROGPU_CMD_COPY_TEXTURE2D) == 1,
             "expected one COPY_TEXTURE2D")) {
    return false;
  }

  // The copy path should have flushed once when tracking `src`, then re-tracked
  // both allocations so the final submission's allocation list contains src+dst
  // (not the pre-fill entry).
  if (!Check(alloc_list[0].hAllocation == src.wddm_hAllocation, "alloc_list[0] == src allocation")) {
    return false;
  }
  if (!Check(alloc_list[1].hAllocation == dst.wddm_hAllocation, "alloc_list[1] == dst allocation")) {
    return false;
  }
  if (!Check(alloc_list[0].WriteOperation == 0, "src tracked as read")) {
    return false;
  }
  return Check(alloc_list[1].WriteOperation == 1, "dst tracked as write");
#endif
}

bool TestGetRenderTargetData16BitTransferRejectsHostAllocatedDst() {
#if defined(_WIN32)
  return true;
#else
  constexpr uint32_t kD3dFmtR5G6B5 = 23u;
  constexpr D3DDDIFORMAT kFmtR5G6B5 = static_cast<D3DDDIFORMAT>(kD3dFmtR5G6B5);

  if (aerogpu::d3d9_format_to_aerogpu(kD3dFmtR5G6B5) == AEROGPU_FORMAT_INVALID) {
    std::fprintf(stderr, "INFO: skipping GetRenderTargetData transfer reject test (R5G6B5 not enabled)\n");
    return true;
  }

  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    D3D9DDI_DEVICEFUNCS device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;

    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;
  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev && dev->adapter, "device+adapter pointers")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnGetRenderTargetData != nullptr, "pfnGetRenderTargetData")) {
    return false;
  }

  hr = device_test_force_umd_private_features(create_dev.hDevice, AEROGPU_UMDPRIV_FEATURE_TRANSFER);
  if (!Check(hr == S_OK, "device_test_force_umd_private_features(TRANSFER)")) {
    return false;
  }

  uint8_t stream_buf[256] = {};
  dev->cmd.set_span(stream_buf, sizeof(stream_buf));
  dev->cmd.reset();
  struct CmdModeGuard {
    Device* dev = nullptr;
    ~CmdModeGuard() {
      if (dev) {
        dev->cmd.set_vector();
      }
    }
  } cmd_guard{dev};

  const uint32_t bpp = aerogpu::bytes_per_pixel(kFmtR5G6B5);
  if (!Check(bpp == 2u, "bytes_per_pixel(R5G6B5)")) {
    return false;
  }

  constexpr uint32_t kWidth = 4;
  constexpr uint32_t kHeight = 4;
  const uint32_t row_pitch = kWidth * bpp;
  const uint32_t size_bytes = row_pitch * kHeight;

  Resource src{};
  src.kind = ResourceKind::Surface;
  src.handle = 0x1000u;
  src.format = kFmtR5G6B5;
  src.width = kWidth;
  src.height = kHeight;
  src.depth = 1;
  src.mip_levels = 1;
  src.pool = 0;
  src.size_bytes = size_bytes;
  src.row_pitch = row_pitch;
  src.slice_pitch = size_bytes;

  Resource dst{};
  dst.kind = ResourceKind::Surface;
  dst.handle = 0x2000u;
  dst.format = kFmtR5G6B5;
  dst.width = kWidth;
  dst.height = kHeight;
  dst.depth = 1;
  dst.mip_levels = 1;
  dst.pool = 2u; // D3DPOOL_SYSTEMMEM
  dst.size_bytes = size_bytes;
  dst.row_pitch = row_pitch;
  dst.slice_pitch = size_bytes;
  dst.backing_alloc_id = 0; // host-allocated systemmem: transfer path should reject

  D3DDDI_HRESOURCE hSrc{};
  hSrc.pDrvPrivate = &src;
  D3DDDI_HRESOURCE hDst{};
  hDst.pDrvPrivate = &dst;

  D3D9DDIARG_GETRENDERTARGETDATA args{};
  args.hSrcResource = hSrc;
  args.hDstResource = hDst;

  hr = cleanup.device_funcs.pfnGetRenderTargetData(create_dev.hDevice, &args);
  if (!Check(hr == D3DERR_INVALIDCALL, "GetRenderTargetData(transfer, host-allocated dst) rejects")) {
    return false;
  }

  if (!Check(ValidateStream(stream_buf, sizeof(stream_buf)), "command stream validation")) {
    return false;
  }
  if (!Check(CountOpcode(stream_buf, sizeof(stream_buf), AEROGPU_CMD_COPY_TEXTURE2D) == 0,
             "rejected GetRenderTargetData must not emit COPY_TEXTURE2D")) {
    return false;
  }
  if (!Check(CountOpcode(stream_buf, sizeof(stream_buf), AEROGPU_CMD_UPLOAD_RESOURCE) == 0,
             "rejected GetRenderTargetData must not emit UPLOAD_RESOURCE")) {
    return false;
  }
  return Check(CountOpcode(stream_buf, sizeof(stream_buf), AEROGPU_CMD_RESOURCE_DIRTY_RANGE) == 0,
               "rejected GetRenderTargetData must not emit RESOURCE_DIRTY_RANGE");
#endif
}

bool TestKmdQueryGetScanLineClearsOutputsOnFailure() {
  AerogpuKmdQuery query;
  bool in_vblank = true;
  uint32_t scan_line = 123;

  const bool ok = query.GetScanLine(/*vid_pn_source_id=*/0, &in_vblank, &scan_line);
  if (!Check(!ok, "GetScanLine returns false when adapter is not initialized")) {
    return false;
  }
  if (!Check(in_vblank == false, "GetScanLine clears in_vblank on failure")) {
    return false;
  }
  return Check(scan_line == 0, "GetScanLine clears scan_line on failure");
}

bool TestBlitAlphaLockedUsesSrcAlphaBlend() {
  Adapter adapter{};
  Device dev(&adapter);

  Resource dst{};
  dst.handle = allocate_global_handle(&adapter);
  dst.kind = ResourceKind::Texture2D;
  dst.format = static_cast<D3DDDIFORMAT>(21u); // D3DFMT_A8R8G8B8
  dst.width = 64;
  dst.height = 64;

  Resource src{};
  src.handle = allocate_global_handle(&adapter);
  src.kind = ResourceKind::Texture2D;
  src.format = static_cast<D3DDDIFORMAT>(21u); // D3DFMT_A8R8G8B8
  src.width = 32;
  src.height = 32;

  RECT dst_rect{0, 0, 32, 32};
  RECT src_rect{0, 0, 32, 32};

  HRESULT hr = S_OK;
  {
    std::lock_guard<std::mutex> lock(dev.mutex);
    hr = blit_alpha_locked(&dev, &dst, &dst_rect, &src, &src_rect, /*filter=*/1u);
  }
  if (!Check(hr == S_OK, "blit_alpha_locked")) {
    return false;
  }

  dev.cmd.finalize();
  const uint8_t* buf = dev.cmd.data();
  const size_t len = dev.cmd.bytes_used();
  if (!Check(ValidateStream(buf, len), "ValidateStream(blit_alpha_locked)")) {
    return false;
  }

  // D3D9 render state IDs (numeric values from d3d9types.h).
  constexpr uint32_t kRsAlphaBlendEnable = 27;
  constexpr uint32_t kRsSrcBlend = 19;
  constexpr uint32_t kRsDestBlend = 20;
  constexpr uint32_t kRsBlendOp = 171;

  // D3DBLEND / D3DBLENDOP (numeric values from d3d9types.h).
  constexpr uint32_t kBlendSrcAlpha = 5;
  constexpr uint32_t kBlendInvSrcAlpha = 6;
  constexpr uint32_t kBlendOpAdd = 1;

  bool saw_alpha_enable = false;
  bool saw_src_blend = false;
  bool saw_dst_blend = false;
  bool saw_blend_op = false;
  uint32_t alpha_enable_val = 0;
  uint32_t src_blend_val = 0;
  uint32_t dst_blend_val = 0;
  uint32_t blend_op_val = 0;

  size_t offset = sizeof(aerogpu_cmd_stream_header);
  while (offset + sizeof(aerogpu_cmd_hdr) <= len) {
    const auto* hdr = reinterpret_cast<const aerogpu_cmd_hdr*>(buf + offset);
    if (hdr->opcode == AEROGPU_CMD_SET_RENDER_STATE && hdr->size_bytes >= sizeof(aerogpu_cmd_set_render_state)) {
      const auto* cmd = reinterpret_cast<const aerogpu_cmd_set_render_state*>(hdr);
      if (cmd->state == kRsAlphaBlendEnable && !saw_alpha_enable) {
        saw_alpha_enable = true;
        alpha_enable_val = cmd->value;
      }
      if (cmd->state == kRsSrcBlend && !saw_src_blend) {
        saw_src_blend = true;
        src_blend_val = cmd->value;
      }
      if (cmd->state == kRsDestBlend && !saw_dst_blend) {
        saw_dst_blend = true;
        dst_blend_val = cmd->value;
      }
      if (cmd->state == kRsBlendOp && !saw_blend_op) {
        saw_blend_op = true;
        blend_op_val = cmd->value;
      }
    }

    if (hdr->size_bytes == 0 || hdr->size_bytes > len - offset) {
      break;
    }
    offset += hdr->size_bytes;
  }

  if (!Check(saw_alpha_enable, "blit_alpha_locked emits D3DRS_ALPHABLENDENABLE")) {
    return false;
  }
  if (!Check(saw_src_blend, "blit_alpha_locked emits D3DRS_SRCBLEND")) {
    return false;
  }
  if (!Check(saw_dst_blend, "blit_alpha_locked emits D3DRS_DESTBLEND")) {
    return false;
  }
  if (!Check(saw_blend_op, "blit_alpha_locked emits D3DRS_BLENDOP")) {
    return false;
  }

  if (!Check(alpha_enable_val == 1u, "D3DRS_ALPHABLENDENABLE == TRUE")) {
    return false;
  }
  if (!Check(src_blend_val == kBlendSrcAlpha, "D3DRS_SRCBLEND == SRCALPHA")) {
    return false;
  }
  if (!Check(dst_blend_val == kBlendInvSrcAlpha, "D3DRS_DESTBLEND == INVSRCALPHA")) {
    return false;
  }
  return Check(blend_op_val == kBlendOpAdd, "D3DRS_BLENDOP == ADD");
}

template <typename DeviceFuncsT>
bool TestSetShaderConstIEmitsPacketImpl() {
  if constexpr (!HasPfnSetShaderConstI<DeviceFuncsT>::value) {
    // Some D3D9 DDI header variants do not expose the I/B constant entrypoints in the device
    // function table. In those builds we cannot exercise the DDI surface area; treat the test as a
    // no-op.
    return true;
  } else {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    DeviceFuncsT device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;
    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetShaderConstI != nullptr, "SetShaderConstI must be available")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  std::vector<uint8_t> dma(4096, 0);
  dev->cmd.set_span(dma.data(), dma.size());
  dev->cmd.reset();
  ScopedDeviceCmdVectorReset cmd_reset(dev);

  // Write i10..i11 (2 vec4 registers).
  std::array<int32_t, 8> data = {1, 2, 3, 4, -5, -6, -7, -8};
  hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, kD3d9ShaderStageVs, 10, data.data(), 2);
  if (!Check(hr == S_OK, "SetShaderConstI(VS, i10..i11)")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dma.data();
  const size_t len = dev->cmd.bytes_used();
  if (!Check(ValidateStream(buf, dma.size()), "command stream validates")) {
    return false;
  }

  const CmdLoc loc = FindLastOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_I);
  if (!Check(loc.hdr != nullptr, "SET_SHADER_CONSTANTS_I packet emitted")) {
    return false;
  }

  const auto* cmd = reinterpret_cast<const aerogpu_cmd_set_shader_constants_i*>(loc.hdr);
  if (!Check(cmd->stage == AEROGPU_SHADER_STAGE_VERTEX, "SET_SHADER_CONSTANTS_I stage == VERTEX")) {
    return false;
  }
  if (!Check(cmd->start_register == 10u, "SET_SHADER_CONSTANTS_I start_register")) {
    return false;
  }
  if (!Check(cmd->vec4_count == 2u, "SET_SHADER_CONSTANTS_I vec4_count")) {
    return false;
  }
  if (!Check(cmd->reserved0 == 0u, "SET_SHADER_CONSTANTS_I reserved0 == 0")) {
    return false;
  }

  if (!Check(loc.hdr->size_bytes >= sizeof(*cmd) + data.size() * sizeof(int32_t), "SET_SHADER_CONSTANTS_I payload size")) {
    return false;
  }
  const int32_t* payload = reinterpret_cast<const int32_t*>(reinterpret_cast<const uint8_t*>(cmd) + sizeof(*cmd));
  if (!Check(std::memcmp(payload, data.data(), data.size() * sizeof(int32_t)) == 0, "SET_SHADER_CONSTANTS_I payload matches")) {
    return false;
  }

  return true;
  }
}

bool TestSetShaderConstIEmitsPacket() {
  return TestSetShaderConstIEmitsPacketImpl<D3D9DDI_DEVICEFUNCS>();
}

template <typename DeviceFuncsT>
bool TestSetShaderConstBEmitsPacketImpl() {
  if constexpr (!HasPfnSetShaderConstB<DeviceFuncsT>::value) {
    return true;
  } else {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    DeviceFuncsT device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    bool has_adapter = false;
    bool has_device = false;
    ~Cleanup() {
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnSetShaderConstB != nullptr, "SetShaderConstB must be available")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  std::vector<uint8_t> dma(4096, 0);
  dev->cmd.set_span(dma.data(), dma.size());
  dev->cmd.reset();
  ScopedDeviceCmdVectorReset cmd_reset(dev);

  // Write b7..b9 with non-canonical input values; the packet payload must be normalized to 0/1.
  std::array<int32_t, 3> data = {0, 123, -1};
  hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, kD3d9ShaderStagePs, 7, data.data(), 3);
  if (!Check(hr == S_OK, "SetShaderConstB(PS, b7..b9)")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dma.data();
  const size_t len = dev->cmd.bytes_used();
  if (!Check(ValidateStream(buf, dma.size()), "command stream validates")) {
    return false;
  }

  const CmdLoc loc = FindLastOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_B);
  if (!Check(loc.hdr != nullptr, "SET_SHADER_CONSTANTS_B packet emitted")) {
    return false;
  }

  const auto* cmd = reinterpret_cast<const aerogpu_cmd_set_shader_constants_b*>(loc.hdr);
  if (!Check(cmd->stage == AEROGPU_SHADER_STAGE_PIXEL, "SET_SHADER_CONSTANTS_B stage == PIXEL")) {
    return false;
  }
  if (!Check(cmd->start_register == 7u, "SET_SHADER_CONSTANTS_B start_register")) {
    return false;
  }
  if (!Check(cmd->bool_count == 3u, "SET_SHADER_CONSTANTS_B bool_count")) {
    return false;
  }
  if (!Check(cmd->reserved0 == 0u, "SET_SHADER_CONSTANTS_B reserved0 == 0")) {
    return false;
  }

  std::array<uint32_t, 3> expected = {0u, 1u, 1u};
  if (!Check(loc.hdr->size_bytes >= sizeof(*cmd) + expected.size() * sizeof(uint32_t), "SET_SHADER_CONSTANTS_B payload size")) {
    return false;
  }
  const uint32_t* payload = reinterpret_cast<const uint32_t*>(reinterpret_cast<const uint8_t*>(cmd) + sizeof(*cmd));
  if (!Check(std::memcmp(payload, expected.data(), expected.size() * sizeof(uint32_t)) == 0, "SET_SHADER_CONSTANTS_B payload normalized to 0/1")) {
    return false;
  }

  return true;
  }
}

bool TestSetShaderConstBEmitsPacket() {
  return TestSetShaderConstBEmitsPacketImpl<D3D9DDI_DEVICEFUNCS>();
}

template <typename DeviceFuncsT>
bool TestApplyStateBlockEmitsShaderConstIBPacketsImpl() {
  if constexpr (!HasPfnSetShaderConstI<DeviceFuncsT>::value ||
                !HasPfnSetShaderConstB<DeviceFuncsT>::value) {
    return true;
  } else {
  struct Cleanup {
    D3D9DDI_ADAPTERFUNCS adapter_funcs{};
    DeviceFuncsT device_funcs{};
    D3DDDI_HADAPTER hAdapter{};
    D3DDDI_HDEVICE hDevice{};
    D3D9DDI_HSTATEBLOCK hStateBlock{};
    bool has_adapter = false;
    bool has_device = false;
    bool has_stateblock = false;
    ~Cleanup() {
      if (has_stateblock && device_funcs.pfnDeleteStateBlock) {
        device_funcs.pfnDeleteStateBlock(hDevice, hStateBlock);
      }
      if (has_device && device_funcs.pfnDestroyDevice) {
        device_funcs.pfnDestroyDevice(hDevice);
      }
      if (has_adapter && adapter_funcs.pfnCloseAdapter) {
        adapter_funcs.pfnCloseAdapter(hAdapter);
      }
    }
  } cleanup;

  D3DDDIARG_OPENADAPTER2 open{};
  open.Interface = 1;
  open.Version = 1;
  D3DDDI_ADAPTERCALLBACKS callbacks{};
  D3DDDI_ADAPTERCALLBACKS2 callbacks2{};
  open.pAdapterCallbacks = &callbacks;
  open.pAdapterCallbacks2 = &callbacks2;
  open.pAdapterFuncs = &cleanup.adapter_funcs;

  HRESULT hr = ::OpenAdapter2(&open);
  if (!Check(hr == S_OK, "OpenAdapter2")) {
    return false;
  }
  cleanup.hAdapter = open.hAdapter;
  cleanup.has_adapter = true;

  D3D9DDIARG_CREATEDEVICE create_dev{};
  create_dev.hAdapter = open.hAdapter;
  create_dev.Flags = 0;

  hr = cleanup.adapter_funcs.pfnCreateDevice(&create_dev, &cleanup.device_funcs);
  if (!Check(hr == S_OK, "CreateDevice")) {
    return false;
  }
  cleanup.hDevice = create_dev.hDevice;
  cleanup.has_device = true;

  if (!Check(cleanup.device_funcs.pfnBeginStateBlock != nullptr, "BeginStateBlock must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnEndStateBlock != nullptr, "EndStateBlock must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnApplyStateBlock != nullptr, "ApplyStateBlock must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnDeleteStateBlock != nullptr, "DeleteStateBlock must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetShaderConstI != nullptr, "SetShaderConstI must be available")) {
    return false;
  }
  if (!Check(cleanup.device_funcs.pfnSetShaderConstB != nullptr, "SetShaderConstB must be available")) {
    return false;
  }

  auto* dev = reinterpret_cast<Device*>(create_dev.hDevice.pDrvPrivate);
  if (!Check(dev != nullptr, "device pointer")) {
    return false;
  }

  std::vector<uint8_t> dma(4096, 0);
  dev->cmd.set_span(dma.data(), dma.size());
  dev->cmd.reset();
  ScopedDeviceCmdVectorReset cmd_reset(dev);

  hr = cleanup.device_funcs.pfnBeginStateBlock(create_dev.hDevice);
  if (!Check(hr == S_OK, "BeginStateBlock")) {
    return false;
  }

  std::array<int32_t, 4> ints = {10, 20, 30, 40};
  std::array<BOOL, 2> bools = {TRUE, FALSE};
  hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, kD3d9ShaderStagePs, 5, ints.data(), 1);
  if (!Check(hr == S_OK, "SetShaderConstI during recording")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, kD3d9ShaderStagePs, 9, bools.data(), 2);
  if (!Check(hr == S_OK, "SetShaderConstB during recording")) {
    return false;
  }

  hr = cleanup.device_funcs.pfnEndStateBlock(create_dev.hDevice, &cleanup.hStateBlock);
  if (!Check(hr == S_OK, "EndStateBlock")) {
    return false;
  }
  if (!Check(cleanup.hStateBlock.pDrvPrivate != nullptr, "EndStateBlock returns handle")) {
    return false;
  }
  cleanup.has_stateblock = true;

  // Change the constants to different values so ApplyStateBlock must re-upload.
  std::array<int32_t, 4> ints_b = {-1, -2, -3, -4};
  std::array<BOOL, 2> bools_b = {FALSE, TRUE};
  hr = cleanup.device_funcs.pfnSetShaderConstI(create_dev.hDevice, kD3d9ShaderStagePs, 5, ints_b.data(), 1);
  if (!Check(hr == S_OK, "SetShaderConstI clobber-to-B")) {
    return false;
  }
  hr = cleanup.device_funcs.pfnSetShaderConstB(create_dev.hDevice, kD3d9ShaderStagePs, 9, bools_b.data(), 2);
  if (!Check(hr == S_OK, "SetShaderConstB clobber-to-B")) {
    return false;
  }

  // Reset command stream so we only inspect ApplyStateBlock emissions (and not the clobber commands
  // above).
  dev->cmd.reset();

  hr = cleanup.device_funcs.pfnApplyStateBlock(create_dev.hDevice, cleanup.hStateBlock);
  if (!Check(hr == S_OK, "ApplyStateBlock")) {
    return false;
  }

  dev->cmd.finalize();
  const uint8_t* buf = dma.data();
  const size_t len = dev->cmd.bytes_used();
  if (!Check(ValidateStream(buf, dma.size()), "command stream validates")) {
    return false;
  }

  const CmdLoc loc_i = FindLastOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_I);
  if (!Check(loc_i.hdr != nullptr, "ApplyStateBlock emits SET_SHADER_CONSTANTS_I")) {
    return false;
  }
  const auto* cmd_i = reinterpret_cast<const aerogpu_cmd_set_shader_constants_i*>(loc_i.hdr);
  if (!Check(cmd_i->stage == AEROGPU_SHADER_STAGE_PIXEL, "ApplyStateBlock constants_i stage")) {
    return false;
  }
  if (!Check(cmd_i->start_register == 5u, "ApplyStateBlock constants_i start_register")) {
    return false;
  }
  if (!Check(cmd_i->vec4_count == 1u, "ApplyStateBlock constants_i vec4_count")) {
    return false;
  }
  const int32_t* payload_i = reinterpret_cast<const int32_t*>(reinterpret_cast<const uint8_t*>(cmd_i) + sizeof(*cmd_i));
  if (!Check(std::memcmp(payload_i, ints.data(), ints.size() * sizeof(int32_t)) == 0, "ApplyStateBlock constants_i payload")) {
    return false;
  }

  const CmdLoc loc_b = FindLastOpcode(buf, len, AEROGPU_CMD_SET_SHADER_CONSTANTS_B);
  if (!Check(loc_b.hdr != nullptr, "ApplyStateBlock emits SET_SHADER_CONSTANTS_B")) {
    return false;
  }
  const auto* cmd_b = reinterpret_cast<const aerogpu_cmd_set_shader_constants_b*>(loc_b.hdr);
  if (!Check(cmd_b->stage == AEROGPU_SHADER_STAGE_PIXEL, "ApplyStateBlock constants_b stage")) {
    return false;
  }
  if (!Check(cmd_b->start_register == 9u, "ApplyStateBlock constants_b start_register")) {
    return false;
  }
  if (!Check(cmd_b->bool_count == 2u, "ApplyStateBlock constants_b bool_count")) {
    return false;
  }
  const uint32_t* payload_b = reinterpret_cast<const uint32_t*>(reinterpret_cast<const uint8_t*>(cmd_b) + sizeof(*cmd_b));
  const std::array<uint32_t, 2> expected_b = {1u, 0u};
  if (!Check(std::memcmp(payload_b, expected_b.data(), expected_b.size() * sizeof(uint32_t)) == 0, "ApplyStateBlock constants_b payload normalized")) {
    return false;
  }

  return true;
  }
}

bool TestApplyStateBlockEmitsShaderConstIBPackets() {
  return TestApplyStateBlockEmitsShaderConstIBPacketsImpl<D3D9DDI_DEVICEFUNCS>();
}

} // namespace

void SetCurrentTestName(const char* name) {
  g_current_test_name = name;
}

} // namespace aerogpu

int main() {
#define RUN_TEST(fn)                           \
  do {                                         \
    aerogpu::SetCurrentTestName(#fn);          \
    failures += !aerogpu::fn();                \
  } while (0)

  int failures = 0;
  RUN_TEST(TestHeaderFieldsAndFinalize);
  RUN_TEST(TestAlignmentAndPadding);
  RUN_TEST(TestUnknownOpcodeSkipBySize);
  RUN_TEST(TestOutOfSpaceReturnsNullptrAndSetsError);
  RUN_TEST(TestCmdStreamWriterOverflowReturnsNullAndSetsError);
  RUN_TEST(TestFixedPacketPadding);
  RUN_TEST(TestBindShadersHelpers);
  RUN_TEST(TestOwnedAndBorrowedStreamsMatch);
  RUN_TEST(TestEventQueryGetDataSemantics);
  RUN_TEST(TestDeviceFuncsIncludePatchAndProcessVertices);
  RUN_TEST(TestAdapterCapsAndQueryAdapterInfo);
  RUN_TEST(TestAdapterMultisampleQualityLevels);
  RUN_TEST(TestAdapterCachingUpdatesCallbacks);
  RUN_TEST(TestCreateResourceRejectsUnsupportedGpuFormat);
  RUN_TEST(TestCreateResourceRejectsUnknownNonBufferType);
  RUN_TEST(TestCreateResourceRejectsNon2dDepth);
  RUN_TEST(TestCreateResourceMipLevelsZeroOverflowReturnsOutOfMemory);
  RUN_TEST(TestCreateResourceComputesBcTexturePitchAndSize);
  RUN_TEST(TestCreateResourceMipmappedTextureEmitsMipLevels);
  RUN_TEST(TestLockMipmappedTextureReportsSubresourcePitch);
  RUN_TEST(TestCreateResourceMipLevelsZeroAllocatesFullMipChainForNonShared);
  RUN_TEST(TestCreateResourceMipLevelsZeroAllocatesFullMipChain);
  RUN_TEST(TestLockSizeZeroClampsToMipSubresource);
  RUN_TEST(TestLockSizeZeroClampsToMipSubresourceFromInteriorOffset);
  RUN_TEST(TestLockSizeZeroClampsToBcMipSubresourceFromInteriorOffset);
  RUN_TEST(TestLockSizeZeroClampsToBc2MipSubresourceFromInteriorOffset);
  RUN_TEST(TestLockSizeZeroClampsToBc3MipSubresourceFromInteriorOffset);
  RUN_TEST(TestLockSizeZeroClampsTo16BitMipSubresourceFromInteriorOffset);
  RUN_TEST(TestLockSizeZeroClampsToArraySubresource);
  RUN_TEST(TestLockSizeZeroClampsToArraySubresourceFromInteriorOffset);
  RUN_TEST(TestCreateResourceArrayTextureEmitsArrayLayers);
  RUN_TEST(TestCreateResourceCubeTextureTypeEmitsArrayLayers);
  RUN_TEST(TestCreateResourceCubeTextureRequiresSquare);
  RUN_TEST(TestCreateResourceMipLevelsZeroAllocatesFullMipChainForArrayTexture);
  RUN_TEST(TestLockInfersMipLevelPitchFromOffsetBytes);
  RUN_TEST(TestRgb16FormatMappingAndLayout);
  RUN_TEST(TestCreateResourceComputes16BitTexturePitchAndFormat);
  RUN_TEST(TestCreateSwapChainComputes16BitBackbufferPitchAndFormat);
  RUN_TEST(TestUnlockX1R5G5B5ForcesAlphaBitAndUploadsFixedBytes);
  RUN_TEST(TestX1R5G5B5UnlockForcesOpaqueAlphaForMisalignedWrites);
  RUN_TEST(TestGenerateMipSubLevelsBoxFilter2d);
  RUN_TEST(TestGenerateMipSubLevelsBoxFilter2dA8R8G8B8PreservesAlpha);
  RUN_TEST(TestGenerateMipSubLevelsBoxFilter1x1ClampsSourceCoords);
  RUN_TEST(TestGenerateMipSubLevelsBoxFilter2dA8B8G8R8ChannelOrder);
  RUN_TEST(TestGenerateMipSubLevelsRejectsSingleMipTexture);
  RUN_TEST(TestGenerateMipSubLevelsRejectsLockedTexture);
  RUN_TEST(TestGenerateMipSubLevelsRejectsDepthStencilFormat);
  RUN_TEST(TestGenerateMipSubLevelsBoxFilterCubeTexture);
  RUN_TEST(TestGenerateMipSubLevelsBoxFilter2dArrayTexture);
  RUN_TEST(TestGenerateMipSubLevelsBoxFilter2dX1R5G5B5);
  RUN_TEST(TestGenerateMipSubLevelsBoxFilter2dR5G6B5);
  RUN_TEST(TestGenerateMipSubLevelsBoxFilter2dA1R5G5B5);
  RUN_TEST(TestGenerateMipSubLevelsBoxFilter2dBcUniform);
  RUN_TEST(TestGenerateMipSubLevelsAllocBackedEmitsDirtyRange);
  RUN_TEST(TestCreateResourceIgnoresStaleAllocPrivDataForNonShared);
  RUN_TEST(TestCreateResourceAllowsNullPrivateDataWhenNotAllocBacked);
  RUN_TEST(TestAllocBackedUnlockEmitsDirtyRange);
  RUN_TEST(TestCopyRectsToHostBackedResourceEmitsUpload);
  RUN_TEST(TestCopyRects16BitToHostBackedResourceEmitsUpload);
  RUN_TEST(TestCopyRects16BitToGuestBackedResourceEmitsDirtyRange);
  RUN_TEST(TestCopyRects16BitTransferEmitsCopyTexture2D);
  RUN_TEST(TestSharedResourceCreateAndOpenEmitsExportImport);
  RUN_TEST(TestPresentStatsAndFrameLatency);
  RUN_TEST(TestPresentExSubmitsOnceWhenNoPendingRenderWork);
  RUN_TEST(TestPresentSubmitsOnceWhenNoPendingRenderWork);
  RUN_TEST(TestPresentExSplitsRenderAndPresentSubmissions);
  RUN_TEST(TestConcurrentPresentExReturnsDistinctFences);
  RUN_TEST(TestPresentSplitsRenderAndPresentSubmissions);
  RUN_TEST(TestFlushNoopsOnEmptyCommandBuffer);
  RUN_TEST(TestGetDisplayModeExReturnsPrimaryMode);
  RUN_TEST(TestCheckDeviceStateNullHwndReturnsOk);
  RUN_TEST(TestDeviceMiscExApisSucceed);
  RUN_TEST(TestAllocationListSplitResetsOnEmptySubmit);
  RUN_TEST(TestDrawStateTrackingPreSplitRetainsAllocs);
  RUN_TEST(TestBlitStateTrackingPreSplitRetainsAllocs);
  RUN_TEST(TestRenderTargetTrackingPreSplitRetainsAllocs);
  RUN_TEST(TestDrawStateTrackingDedupsSharedAllocIds);
  RUN_TEST(TestRotateResourceIdentitiesTrackingPreSplitRetainsAllocs);
  RUN_TEST(TestOpenResourceCapturesWddmAllocationForTracking);
  RUN_TEST(TestOpenResourceRejectsUnsupportedNon2dType);
  RUN_TEST(TestOpenResourceRejectsNonSquareCubeTexture);
  RUN_TEST(TestOpenResourceArrayTextureEmitsArrayLayers);
  RUN_TEST(TestOpenResourceCubeTextureTypeNormalizesDepthTo6);
  RUN_TEST(TestOpenResourceCubeTextureRequiresSquare);
  RUN_TEST(TestOpenResourceAcceptsAllocPrivV2);
  RUN_TEST(TestOpenResourceReconstructsDxgiSharedSurfaceFromAllocPrivV2);
  RUN_TEST(TestOpenResourceDecodesD3D9SharedSurfaceDescAndComputesTightPitch);
  RUN_TEST(TestOpenResourceReconstructsDxgiSharedSurfaceFromAllocPrivV2UsesRowPitchBytes);
  RUN_TEST(TestOpenResourceUsesReserved0PitchHintForUncompressedSingleMipSurface);
  RUN_TEST(TestInvalidPayloadArgs);
  RUN_TEST(TestSetShaderConstIBEmitsCommands);
  RUN_TEST(TestSetShaderConstIBSkipsRedundantCommands);
  RUN_TEST(TestSetShaderConstIBNormalizesStage);
  RUN_TEST(TestSetShaderConstIBInvalidRangeNoops);
  RUN_TEST(TestGetShaderConstIBRoundTrip);
  RUN_TEST(TestSetShaderConstIEmitsPacket);
  RUN_TEST(TestSetShaderConstBEmitsPacket);
  RUN_TEST(TestApplyStateBlockSkipsRedundantShaderConstF);
  RUN_TEST(TestApplyStateBlockSkipsRedundantShaderConstFVs);
  RUN_TEST(TestApplyStateBlockEmitsShaderConstIB);
  RUN_TEST(TestApplyStateBlockEmitsShaderConstIBPackets);
  RUN_TEST(TestApplyStateBlockEmitsShaderConstIBVs);
  RUN_TEST(TestApplyStateBlockSplitsShaderConstIB);
  RUN_TEST(TestApplyStateBlockSplitsShaderConstIBVs);
  RUN_TEST(TestApplyStateBlockSkipsRedundantShaderConstIB);
  RUN_TEST(TestApplyStateBlockSkipsRedundantShaderConstIBVs);
  RUN_TEST(TestApplyStateBlockNormalizesShaderConstIBStage);
  RUN_TEST(TestApplyStateBlockRecordsShaderConstIB);
  RUN_TEST(TestApplyStateBlockRecordsShaderConstIBVs);
  RUN_TEST(TestCaptureStateBlockUpdatesCreateStateBlockShaderConstIB);
  RUN_TEST(TestCaptureStateBlockUpdatesCreateStateBlockShaderConstIBVs);
  RUN_TEST(TestCaptureStateBlockUpdatesCreateStateBlockAllShaderConstIB);
  RUN_TEST(TestCreateStateBlockUnknownTypeTreatsAsAllShaderConstIB);
  RUN_TEST(TestCaptureStateBlockUpdatesShaderConstIB);
  RUN_TEST(TestCaptureStateBlockUpdatesShaderConstIBVs);
  RUN_TEST(TestCaptureStateBlockSplitsShaderConstIB);
  RUN_TEST(TestCaptureStateBlockSplitsShaderConstIBVs);
  RUN_TEST(TestCreateStateBlockRestoresShaderConstIB);
  RUN_TEST(TestCreateStateBlockRestoresShaderConstIBVs);
  RUN_TEST(TestCreateStateBlockAllRestoresShaderConstIB);
  RUN_TEST(TestDestroyBoundShaderUnbinds);
  RUN_TEST(TestPartialShaderStageBindingVsOnlyBindsFixedfuncPsAndDraws);
  RUN_TEST(TestPartialShaderStageBindingPsOnlyBindsFixedfuncVsAndDraws);
  RUN_TEST(TestPartialShaderStageBindingPsOnlyXyzDiffuseUploadsWvpConstants);
  RUN_TEST(TestDestroyBoundVertexDeclUnbinds);
  RUN_TEST(TestSetVertexDeclDerivesFixedFunctionFvf);
  RUN_TEST(TestFvfXyzrhwDiffuseDrawPrimitiveUpEmitsFixedfuncCommands);
  RUN_TEST(TestFvfXyzrhwDiffuseTex1DrawPrimitiveUpEmitsFixedfuncCommands);
  RUN_TEST(TestFvfXyzrhwTex1TexcoordSize1DrawPrimitiveUpEmitsFixedfuncCommands);
  RUN_TEST(TestSetFvfIgnoresUnusedTexcoordSizeBitsForDeclCache);
  RUN_TEST(TestFvfXyzDiffuseDrawPrimitiveUpEmitsFixedfuncCommands);
  RUN_TEST(TestFixedfuncStage0TextureStageStateRebindsPixelShader);
  RUN_TEST(TestFixedfuncTextureFactorDoesNotClobberPsConst0);
  RUN_TEST(TestFixedfuncStage0ApplyStateBlockRebindsInteropPixelShader);
  RUN_TEST(TestFixedfuncStage0ApplyStateBlockTextureBindRebindsPixelShader);
  RUN_TEST(TestVsOnlyInteropSetShaderSucceedsWhenStage0Unsupported);
  RUN_TEST(TestFixedfuncStage0DestroyDedupsSharedPixelShaders);
  RUN_TEST(TestFvfXyzDiffuseTex1DrawPrimitiveUpEmitsFixedfuncCommands);
  RUN_TEST(TestFvfXyzDiffuseTex1SetTransformDrawPrimitiveUpEmitsWvpConstants);
  RUN_TEST(TestFvfXyzDiffuseTex1ReuploadsWvpAfterUserVsClobbersConstants);
  RUN_TEST(TestSetShaderConstIEmitsSetShaderConstantsI);
  RUN_TEST(TestSetShaderConstBEmitsSetShaderConstantsB);
  RUN_TEST(TestFvfXyzDiffuseDrawPrimitiveUpEmitsWvpConstants);
  RUN_TEST(TestFixedFuncXyzStateBlockApplyReuploadsWvpConstants);
  RUN_TEST(TestFixedFuncXyzNormalStateBlockApplyReuploadsLightingConstants);
  RUN_TEST(TestFvfXyzDiffuseTex1DrawIndexedPrimitiveUpAppliesWvpTransform);
  RUN_TEST(TestVertexDeclXyzrhwDiffuseTex1DrawPrimitiveUpEmitsFixedfuncCommands);
  RUN_TEST(TestSetFvfIdempotentRebindsInternalXyzrhwInputLayout);
  RUN_TEST(TestVertexDeclXyzDiffuseDrawPrimitiveUpEmitsFixedfuncCommands);
  RUN_TEST(TestVertexDeclXyzDiffuseTex1DrawPrimitiveUpEmitsFixedfuncCommands);
  RUN_TEST(TestStage0TextureStageStateRebindsFixedfuncPsForXyz);
  RUN_TEST(TestFixedFuncPsSelectionNoTextureColorOpDisableUsesColorOnly);
  RUN_TEST(TestFixedFuncPsSelectionTextureBoundColorOpDisableIgnoresAlphaTextureUsesColorOnly);
  RUN_TEST(TestFixedFuncPsSelectionSetTextureUpdatesBoundPsToModulateWithoutDraw);
  RUN_TEST(TestFixedFuncPsSelectionUnsetTextureUpdatesBoundPsToColorOnlyWithoutDraw);
  RUN_TEST(TestFixedFuncPsSelectionTex1OnlyFvfSetTextureUpdatesBoundPsToModulateWithoutDraw);
  RUN_TEST(TestFixedFuncPsSelectionTex1OnlyFvfSelectArg1TextureUsesTextureOnly);
  RUN_TEST(TestFixedFuncPsSelectionTextureBoundDefaultModulateUsesModulate);
  RUN_TEST(TestFixedFuncPsSelectionTextureBoundSelectArg1TextureUsesTextureOnly);
  RUN_TEST(TestFixedFuncPsSelectionTextureBoundSelectArg2TextureUsesTextureOnly);
  RUN_TEST(TestFixedFuncPsSelectionTextureBoundSelectArg2DiffuseColorSelectArg2TextureAlphaUsesDiffuseTexture);
  RUN_TEST(TestFixedFuncPsSelectionTextureBoundModulateDiffuseDiffuseUsesColorOnly);
  RUN_TEST(TestFixedFuncPsSelectionTextureBoundUnknownColorOpDiffuseArgsUsesColorOnly);
  RUN_TEST(TestFixedFuncPsSelectionTextureBoundUnknownColorOpFallsBackToModulate);
  RUN_TEST(TestFvfXyzrhwDiffuseDrawPrimitiveEmulationConvertsVertices);
  RUN_TEST(TestFvfXyzrhwDiffuseTex1DrawPrimitiveEmulationConvertsVertices);
  RUN_TEST(TestFvfXyzrhwTex1DrawPrimitiveEmulationConvertsVertices);
  RUN_TEST(TestFvfXyzrhwDiffuseTex1DrawPrimitiveUpEmulationConvertsVertices);
  RUN_TEST(TestFvfXyzrhwTex1DrawPrimitiveUpEmulationConvertsVertices);
  RUN_TEST(TestFvfXyzrhwTex1DrawPrimitiveUpEmulationAppliesViewportOffsetAndRhw);
  RUN_TEST(TestFvfXyzDiffuseDrawPrimitiveNoScratchVbConversion);
  RUN_TEST(TestFvfXyzDiffuseTex1DrawPrimitiveNoScratchVbConversion);
  RUN_TEST(TestFvfXyzTex1DrawPrimitiveNoScratchVbConversion);
  RUN_TEST(TestFvfXyzTex1DrawPrimitiveUpDoesNotConvertVertices);
  RUN_TEST(TestFvfXyzDiffuseDrawPrimitiveUpDoesNotConvertVertices);
  RUN_TEST(TestFixedfuncStrideTooSmallFailsAndDoesNotEmitDraw);
  RUN_TEST(TestFixedfuncIndexedStrideTooSmallFailsAndDoesNotEmitDraw);
  RUN_TEST(TestDrawRectPatchReusesTessellationCache);
  RUN_TEST(TestDrawTriPatchReusesTessellationCache);
  RUN_TEST(TestPatchCacheDistinguishesTexcoordSizeBetweenFloat1AndFloat2);
  RUN_TEST(TestDrawIndexedPrimitiveUpEmitsIndexBufferCommands);
  RUN_TEST(TestFvfXyzrhwDiffuseDrawIndexedPrimitiveEmulationConvertsVertices);
  RUN_TEST(TestFvfXyzrhwDiffuseTex1DrawIndexedPrimitiveEmulationConvertsVertices);
  RUN_TEST(TestFvfXyzrhwTex1DrawIndexedPrimitiveEmulationConvertsVertices);
  RUN_TEST(TestFvfXyzrhwDiffuseTex1DrawIndexedPrimitiveEmulationAppliesBaseVertexAndRhw);
  RUN_TEST(TestFvfXyzrhwDiffuseTex1DrawIndexedPrimitiveEmulationSupportsIndex32AndIndexOffset);
  RUN_TEST(TestFvfXyzTex1DrawIndexedPrimitiveNoScratchVbConversion);
  RUN_TEST(TestFvfXyzDiffuseTex1DrawIndexedPrimitiveNoScratchVbConversion);
  RUN_TEST(TestDrawRectPatchEmitsDrawIndexedAndUploadsScratchVb);
  RUN_TEST(TestDrawRectPatchTex1ValidatesStrideAndPreservesTexcoords);
  RUN_TEST(TestDrawRectPatchTex1TexcoordSize1ValidatesStrideAndPreservesTexcoords);
  RUN_TEST(TestDrawRectPatchTex1TexcoordSize3ValidatesStrideAndPreservesTexcoords);
  RUN_TEST(TestDrawRectPatchTex1TexcoordSize4ValidatesStrideAndPreservesTexcoords);
  RUN_TEST(TestDrawTriPatchEmitsDrawIndexedAndUploadsScratchVb);
  RUN_TEST(TestDrawRectPatchTex1UploadsTexcoords);
  RUN_TEST(TestDrawTriPatchTex1UploadsTexcoords);
  RUN_TEST(TestDrawPatchInvalidInfoReturnsInvalidCall);
  RUN_TEST(TestDrawTriPatchTex1ValidatesStrideAndPreservesTexcoords);
  RUN_TEST(TestDrawTriPatchTex1TexcoordSize1ValidatesStrideAndPreservesTexcoords);
  RUN_TEST(TestDrawTriPatchTex1TexcoordSize3ValidatesStrideAndPreservesTexcoords);
  RUN_TEST(TestDrawTriPatchTex1TexcoordSize4ValidatesStrideAndPreservesTexcoords);
  RUN_TEST(TestResetShrinkUnbindsBackbuffer);
  RUN_TEST(TestRotateResourceIdentitiesRebindsChangedHandles);
  RUN_TEST(TestPresentBackbufferRotationUndoOnSmallCmdBuffer);
  RUN_TEST(TestPresentBackbufferRotationUndoOnSmallAllocList);
  RUN_TEST(TestPresentBackbufferRotationRebindsBackbufferTexture);
  RUN_TEST(TestSetRenderTargetRejectsGaps);
  RUN_TEST(TestRotateResourceIdentitiesUndoOnSmallCmdBuffer);
  RUN_TEST(TestResetRebindsBackbufferTexture);
  RUN_TEST(TestOpenResourceTracksWddmAllocationHandle);
  RUN_TEST(TestGuestBackedUnlockEmitsDirtyRangeNotUpload);
  RUN_TEST(TestProcessVerticesCopiesBytesAndUploadsHostBuffer);
  RUN_TEST(TestProcessVerticesInPlaceOverlapSafeWithStrides);
  RUN_TEST(TestProcessVerticesInPlaceOverlapSafeWithStridesDestBeforeSrc);
  RUN_TEST(TestProcessVerticesInPlaceOverlapSafeWithEqualStrides);
  RUN_TEST(TestProcessVerticesEmitsDirtyRangeForGuestBackedDest);
  RUN_TEST(TestGuestBackedDirtyRangeSubmitsWhenCmdBufferFull);
  RUN_TEST(TestGuestBackedUpdateSurfaceEmitsDirtyRangeNotUpload);
  RUN_TEST(TestGuestBackedUpdateSurface16BitEmitsDirtyRangeNotUpload);
  RUN_TEST(TestUpdateSurface16BitToHostBackedResourceEmitsUpload);
  RUN_TEST(TestGuestBackedUpdateTextureEmitsDirtyRangeNotUpload);
  RUN_TEST(TestGuestBackedUpdateTexture16BitEmitsDirtyRangeNotUpload);
  RUN_TEST(TestGetRenderTargetData16BitEmitsDirtyRangeOrUpload);
  RUN_TEST(TestGetRenderTargetData16BitTransferEmitsCopyTexture2D);
  RUN_TEST(TestGetRenderTargetDataTransferRetracksAllocationsAfterFlush);
  RUN_TEST(TestGetRenderTargetData16BitTransferRejectsHostAllocatedDst);
  RUN_TEST(TestBlitAlphaLockedUsesSrcAlphaBlend);
  RUN_TEST(TestKmdQueryGetScanLineClearsOutputsOnFailure);
  return failures ? 1 : 0;
}
