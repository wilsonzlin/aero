import fs from 'node:fs/promises';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const SCRIPT_DIR = path.dirname(fileURLToPath(import.meta.url));
const REPO_ROOT = path.resolve(SCRIPT_DIR, '../..');

const INPUT_PATH = path.join(SCRIPT_DIR, 'scancodes.json');
const OUT_TS_PATHS = [
  path.join(REPO_ROOT, 'src/input/scancodes.ts'),
  path.join(REPO_ROOT, 'web/src/input/scancodes.ts'),
];
const OUT_RS_PATHS = [
  path.join(REPO_ROOT, 'crates/aero-devices-input/src/scancodes_generated.rs'),
];

/**
 * @param {string} hex
 * @returns {number}
 */
function parseHexByte(hex) {
  if (typeof hex !== 'string') {
    throw new Error(`Expected hex string byte, got ${typeof hex}`);
  }
  if (!/^[0-9A-Fa-f]{2}$/.test(hex)) {
    throw new Error(`Invalid hex byte string: ${JSON.stringify(hex)}`);
  }
  return Number.parseInt(hex, 16);
}

/**
 * @param {number} byte
 * @returns {string}
 */
function fmtHex(byte) {
  return `0x${byte.toString(16).toUpperCase().padStart(2, '0')}`;
}

/**
 * @param {string} code
 * @returns {string}
 */
function rustConstName(code) {
  return code
    .replace(/([a-z0-9])([A-Z])/g, '$1_$2')
    .replace(/[^A-Za-z0-9]/g, '_')
    .toUpperCase();
}

/**
 * @param {number[]} bytes
 * @returns {string}
 */
function fmtTsArray(bytes) {
  return `[${bytes.map(fmtHex).join(', ')}]`;
}

/**
 * @param {number[]} bytes
 * @returns {string}
 */
function fmtRsArray(bytes) {
  return `[${bytes.map(fmtHex).join(', ')}]`;
}

/**
 * @param {number[]} makeBytes
 * @returns {{kind: 'simple', make: number, extended: boolean} | {kind: 'sequence'}}
 */
function classify(makeBytes) {
  if (makeBytes.length === 1) {
    return { kind: 'simple', make: makeBytes[0], extended: false };
  }
  if (makeBytes.length === 2 && makeBytes[0] === 0xE0) {
    return { kind: 'simple', make: makeBytes[1], extended: true };
  }
  return { kind: 'sequence' };
}

/**
 * @param {any} obj
 */
function assertPlainObject(obj) {
  if (!obj || typeof obj !== 'object' || Array.isArray(obj)) {
    throw new Error(`Expected object, got ${obj === null ? 'null' : typeof obj}`);
  }
}

async function main() {
  const raw = JSON.parse(await fs.readFile(INPUT_PATH, 'utf8'));
  assertPlainObject(raw);
  assertPlainObject(raw.ps2_set2);

  /** @type {Record<string, {make: number[], break?: number[]}>} */
  const entries = {};
  for (const [code, entry] of Object.entries(raw.ps2_set2)) {
    assertPlainObject(entry);
    if (!Array.isArray(entry.make)) {
      throw new Error(`ps2_set2.${code}.make must be an array`);
    }
    const makeBytes = entry.make.map(parseHexByte);
    const breakBytes = entry.break ? entry.break.map(parseHexByte) : undefined;

    const c = classify(makeBytes);
    if (c.kind === 'sequence' && breakBytes === undefined) {
      throw new Error(
        `ps2_set2.${code} uses a multi-byte make sequence; it must define an explicit break sequence (may be empty)`,
      );
    }

    entries[code] = { make: makeBytes, break: breakBytes };
  }

  const codes = Object.keys(entries).sort((a, b) => a.localeCompare(b));

  // --- Generate TypeScript --------------------------------------------------
  for (const outPath of OUT_TS_PATHS) {
    await fs.mkdir(path.dirname(outPath), { recursive: true });
  }

  let ts = '';
  ts += `// This file is auto-generated by tools/gen_scancodes/gen_scancodes.mjs.\n`;
  ts += `// Source of truth: tools/gen_scancodes/scancodes.json\n`;
  ts += `//\n`;
  ts += `// Regenerate:\n`;
  ts += `//   npm run gen:scancodes\n\n`;
  ts += `export type Ps2Set2Scancode =\n`;
  ts += `  | { kind: 'simple'; make: number; extended: boolean }\n`;
  ts += `  | { kind: 'sequence'; make: readonly number[]; break: readonly number[] };\n\n`;
  ts += `export const PS2_SET2_CODE_TO_SCANCODE: Record<string, Ps2Set2Scancode> = {\n`;

  for (const code of codes) {
    const entry = entries[code];
    const c = classify(entry.make);
    if (c.kind === 'simple') {
      ts += `  ${JSON.stringify(code)}: { kind: 'simple', make: ${fmtHex(c.make)}, extended: ${
        c.extended ? 'true' : 'false'
      } },\n`;
    } else {
      ts += `  ${JSON.stringify(code)}: { kind: 'sequence', make: ${fmtTsArray(entry.make)}, break: ${fmtTsArray(
        entry.break ?? [],
      )} },\n`;
    }
  }

  ts += `};\n\n`;

  ts += `export function ps2Set2ScancodeForCode(\n`;
  ts += `  code: string,\n`;
  ts += `  overrides?: Partial<Record<string, Ps2Set2Scancode>>,\n`;
  ts += `): Ps2Set2Scancode | undefined {\n`;
  ts += `  return overrides?.[code] ?? PS2_SET2_CODE_TO_SCANCODE[code];\n`;
  ts += `}\n\n`;

  ts += `export function ps2Set2BytesForKeyEvent(\n`;
  ts += `  code: string,\n`;
  ts += `  pressed: boolean,\n`;
  ts += `  overrides?: Partial<Record<string, Ps2Set2Scancode>>,\n`;
  ts += `): number[] | undefined {\n`;
  ts += `  const sc = ps2Set2ScancodeForCode(code, overrides);\n`;
  ts += `  if (!sc) return undefined;\n`;
  ts += `  if (sc.kind === 'sequence') return pressed ? [...sc.make] : [...sc.break];\n`;
  ts += `  if (pressed) return sc.extended ? [0xE0, sc.make] : [sc.make];\n`;
  ts += `  return sc.extended ? [0xE0, 0xF0, sc.make] : [0xF0, sc.make];\n`;
  ts += `}\n`;

  for (const outPath of OUT_TS_PATHS) {
    await fs.writeFile(outPath, ts, 'utf8');
  }

  // --- Generate Rust --------------------------------------------------------
  for (const outPath of OUT_RS_PATHS) {
    await fs.mkdir(path.dirname(outPath), { recursive: true });
  }

  let rs = '';
  rs += `// This file is auto-generated by tools/gen_scancodes/gen_scancodes.mjs.\n`;
  rs += `// Source of truth: tools/gen_scancodes/scancodes.json\n`;
  rs += `//\n`;
  rs += `// Regenerate:\n`;
  rs += `//   npm run gen:scancodes\n\n`;

  rs += `#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n`;
  rs += `pub enum Ps2Set2Scancode {\n`;
  rs += `    Simple {\n`;
  rs += `        make: u8,\n`;
  rs += `        extended: bool,\n`;
  rs += `    },\n`;
  rs += `    Sequence {\n`;
  rs += `        make: &'static [u8],\n`;
  rs += `        break_seq: &'static [u8],\n`;
  rs += `    },\n`;
  rs += `}\n\n`;

  rs += `impl Ps2Set2Scancode {\n`;
  rs += `    pub fn bytes(&self, pressed: bool) -> Vec<u8> {\n`;
  rs += `        match *self {\n`;
  rs += `            Ps2Set2Scancode::Simple { make, extended } => {\n`;
  rs += `                if pressed {\n`;
  rs += `                    if extended {\n`;
  rs += `                        vec![0xE0, make]\n`;
  rs += `                    } else {\n`;
  rs += `                        vec![make]\n`;
  rs += `                    }\n`;
  rs += `                } else if extended {\n`;
  rs += `                    vec![0xE0, 0xF0, make]\n`;
  rs += `                } else {\n`;
  rs += `                    vec![0xF0, make]\n`;
  rs += `                }\n`;
  rs += `            }\n`;
  rs += `            Ps2Set2Scancode::Sequence { make, break_seq } => {\n`;
  rs += `                if pressed {\n`;
  rs += `                    make.to_vec()\n`;
  rs += `                } else {\n`;
  rs += `                    break_seq.to_vec()\n`;
  rs += `                }\n`;
  rs += `            }\n`;
  rs += `        }\n`;
  rs += `    }\n`;
  rs += `}\n\n`;

  // const arrays for multi-byte sequences
  for (const code of codes) {
    const entry = entries[code];
    const c = classify(entry.make);
    if (c.kind !== 'sequence') continue;
    const name = rustConstName(code);
    rs += `const ${name}_MAKE: [u8; ${entry.make.length}] = ${fmtRsArray(entry.make)};\n`;
    rs += `const ${name}_BREAK: [u8; ${(entry.break ?? []).length}] = ${fmtRsArray(entry.break ?? [])};\n`;
  }
  if (codes.some((code) => classify(entries[code].make).kind === 'sequence')) {
    rs += `\n`;
  }

  rs += `pub fn ps2_set2_scancode_for_code(code: &str) -> Option<Ps2Set2Scancode> {\n`;
  rs += `    match code {\n`;
  for (const code of codes) {
    const entry = entries[code];
    const c = classify(entry.make);
    if (c.kind === 'simple') {
      rs += `        ${JSON.stringify(code)} => Some(Ps2Set2Scancode::Simple {\n`;
      rs += `            make: ${fmtHex(c.make)},\n`;
      rs += `            extended: ${c.extended ? 'true' : 'false'},\n`;
      rs += `        }),\n`;
    } else {
      const name = rustConstName(code);
      rs += `        ${JSON.stringify(code)} => Some(Ps2Set2Scancode::Sequence {\n`;
      rs += `            make: &${name}_MAKE,\n`;
      rs += `            break_seq: &${name}_BREAK,\n`;
      rs += `        }),\n`;
    }
  }
  rs += `        _ => None,\n`;
  rs += `    }\n`;
  rs += `}\n\n`;

  rs += `pub fn ps2_set2_bytes_for_key_event(code: &str, pressed: bool) -> Option<Vec<u8>> {\n`;
  rs += `    ps2_set2_scancode_for_code(code).map(|sc| sc.bytes(pressed))\n`;
  rs += `}\n`;

  for (const outPath of OUT_RS_PATHS) {
    await fs.writeFile(outPath, rs, 'utf8');
  }
}

await main();
