#!/usr/bin/env python3
"""
cert-to-reg.py

Generate a Windows Registry Editor v5 `.reg` file that installs a signing certificate
into an OFFLINE Windows 7 SOFTWARE hive (machine-wide certificate stores):

  - Microsoft\\SystemCertificates\\ROOT\\Certificates\\<SHA1_THUMBPRINT>
  - Microsoft\\SystemCertificates\\TrustedPublisher\\Certificates\\<SHA1_THUMBPRINT>

The registry key name is the SHA-1 thumbprint of the certificate DER bytes.

Note: For `HKLM\\...\\Microsoft\\SystemCertificates\\...`, the `Blob` value is
written by CryptoAPI's registry-backed cert store provider and is **not guaranteed
to be raw DER** (it may include additional serialized metadata/properties).

This script writes the certificate's raw DER bytes into `Blob`. That may work in
some environments, but for an exact/portable representation you should generate
the patch on Windows using:

  tools/win-certstore-regblob-export

and then apply the resulting `.reg`/JSON patch to the offline hive.

This script is intentionally dependency-free (Python stdlib only).
"""

from __future__ import annotations

import argparse
import base64
import hashlib
import re
import sys
from pathlib import Path


def _read_cert_der(cert_path: Path) -> bytes:
    raw = cert_path.read_bytes()

    # Heuristic: treat anything starting with ASCII PEM header as PEM.
    if raw.startswith(b"-----BEGIN"):
        text = raw.decode("ascii", errors="strict")
        m = re.search(
            r"-----BEGIN CERTIFICATE-----\s*(?P<b64>[A-Za-z0-9+/=\s]+?)\s*-----END CERTIFICATE-----",
            text,
            flags=re.MULTILINE,
        )
        if not m:
            raise ValueError("PEM file does not contain a CERTIFICATE block")
        b64 = re.sub(r"\s+", "", m.group("b64"))
        return base64.b64decode(b64, validate=True)

    # Otherwise assume DER. This supports .cer exported from Windows and raw DER bytes.
    return raw


def _sha1_thumbprint_hex(der: bytes) -> str:
    return hashlib.sha1(der).hexdigest().upper()


def _reg_hex_bytes(data: bytes, *, bytes_per_line: int = 25, indent: str = "  ") -> str:
    """
    Format bytes as a `.reg` hex: payload with line continuations that `reg import` accepts.

    Example:
      hex:01,02,03,04,05,\
        06,07
    """
    if not data:
        return "hex:"

    parts = [f"{b:02x}" for b in data]
    chunks = [",".join(parts[i : i + bytes_per_line]) for i in range(0, len(parts), bytes_per_line)]

    if len(chunks) == 1:
        return "hex:" + chunks[0]

    # The delimiter includes ",\" to continue the hex list onto the next line.
    delim = ",\\\n" + indent
    return "hex:" + delim.join(chunks)


def _render_reg(*, mount_key: str, thumbprint: str, blob_hex: str) -> str:
    mount_key = mount_key.strip("\\")
    if not mount_key:
        raise ValueError("--mount-key must be non-empty")

    root = rf"HKEY_LOCAL_MACHINE\{mount_key}"
    k1 = rf"{root}\Microsoft\SystemCertificates\ROOT\Certificates\{thumbprint}"
    k2 = rf"{root}\Microsoft\SystemCertificates\TrustedPublisher\Certificates\{thumbprint}"

    return "\n".join(
        [
            "Windows Registry Editor Version 5.00",
            "",
            f"; Generated by cert-to-reg.py from a certificate file.",
            f"; SHA1 thumbprint: {thumbprint}",
            f"; Target HKLM mount key: {mount_key}",
            "",
            f"[{k1}]",
            f"\"Blob\"={blob_hex}",
            "",
            f"[{k2}]",
            f"\"Blob\"={blob_hex}",
            "",
        ]
    )


def main(argv: list[str]) -> int:
    ap = argparse.ArgumentParser(description="Convert a .cer (DER or PEM) into an offline Win7 SOFTWARE hive .reg patch.")
    ap.add_argument("cert", type=Path, help="Path to certificate (.cer), DER or PEM")
    ap.add_argument(
        "--mount-key",
        default="OFFSOFT",
        help=(
            "HKLM subkey where the offline SOFTWARE hive is loaded. "
            "Use OFFSOFT for reg.exe workflows; SOFTWARE is convenient for some hivexregedit workflows."
        ),
    )
    ap.add_argument("--out", type=Path, default=None, help="Write output to this file (default: stdout)")
    ns = ap.parse_args(argv)

    der = _read_cert_der(ns.cert)
    thumb = _sha1_thumbprint_hex(der)
    blob_hex = _reg_hex_bytes(der)
    reg_text = _render_reg(mount_key=ns.mount_key, thumbprint=thumb, blob_hex=blob_hex)

    if ns.out is None:
        sys.stdout.write(reg_text)
    else:
        ns.out.write_text(reg_text, encoding="utf-8", newline="\n")

    return 0


if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))
