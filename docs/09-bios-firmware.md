# 09 - BIOS & Firmware

## What exists today (canonical stack)

Aero’s canonical boot path is **legacy BIOS**, implemented in Rust as **HLE firmware**:

- **BIOS implementation:** `crates/firmware::bios`
  - Builds a 64 KiB ROM image (`build_bios_rom()`) containing interrupt stubs.
  - Implements POST + a minimal INT service surface (video, disk, E820, keyboard, time, …).
- **Machine integration / wiring:** `crates/aero-machine` (see [ADR 0014](./adr/0014-canonical-machine-stack.md))
  - Maps the BIOS ROM, runs POST, and dispatches BIOS interrupt “hypercalls”.
- **ACPI tables:** generated by `crates/aero-acpi` (used by `firmware::bios` during POST).

For CD-ROM boot (El Torito) and the minimal INT 13h extensions required for Windows install media,
see [`docs/09b-eltorito-cd-boot.md`](./09b-eltorito-cd-boot.md).

### INT 13h expectations (HDD/floppy vs CD-ROM)

BIOS disk I/O has two relevant sector sizes:

- **HDD/floppy:** 512-byte sectors (traditional INT 13h semantics).
- **CD-ROM:** 2048-byte logical blocks (ISO9660 / El Torito).

For CD boot and CD reads, Aero’s BIOS expects **El Torito (no-emulation)** boot and requires **INT
13h Extensions (EDD)** for CD drive numbers (recommend `DL=0xE0` for the first CD). At minimum,
Windows-style bootloaders expect `AH=41h` (extensions check), `AH=42h` (extended read), and `AH=48h`
(extended drive parameters) to work for CD, with `AH=48h` reporting `bytes_per_sector = 2048`.
Legacy CHS reads like `AH=02h` are HDD/floppy-oriented and are **not required** for CD media (as long
as the EDD path works).

See [`docs/09b-eltorito-cd-boot.md`](./09b-eltorito-cd-boot.md) for the exact structures and call
contracts.

UEFI is **not** the canonical path today. If you see older docs implying an external BIOS blob or a
still-unimplemented firmware stack, treat those as outdated.

## Deterministic firmware fixtures

This repo keeps a handful of **tiny, deterministic, in-repo** firmware blobs for tests and CI:

- `assets/bios.bin` (BIOS ROM image; generated from `firmware::bios::build_bios_rom()`)
- `crates/firmware/acpi/dsdt.aml` (ACPI DSDT AML; generated from `aero-acpi`)

Regenerate or verify all in-repo fixtures with:

```bash
cargo xtask fixtures [--check]
```

---

## BIOS dispatch contract (HLT-in-ROM-stub “hypercall”)

The BIOS does **not** rely on the CPU core trapping `INT xx` directly. Instead, BIOS services are
implemented on the host side, and the guest reaches them via tiny real-mode ROM stubs.

### ROM mapping

`firmware::bios::build_bios_rom()` returns a 64 KiB image that the machine maps at:

- `firmware::bios::BIOS_BASE` (`0x000F_0000`)
- and (optionally/typically) also aliases at `firmware::bios::BIOS_ALIAS_BASE` (`0xFFFF_0000`) so the
  architectural reset vector at `0xFFFF_FFF0` works.

The ROM contains:

- a reset vector FAR JMP, and
- per-interrupt stubs (plus a default handler).

### Interrupt stub shape

During POST, the BIOS initializes the IVT so that important vectors point into the ROM. Each INT
handler stub is:

```text
HLT
IRET
```

Execution flow:

1. Guest executes `INT imm8` architecturally (push FLAGS/CS/IP, clear IF/TF, load CS:IP from IVT).
2. CS:IP now points at the ROM stub for that vector.
3. Stub executes `HLT`.
4. Tier-0 treats this specific `HLT` (reached from an INT stub) as a VM-exit:
   `BatchExit::BiosInterrupt(vector)`.
5. The machine calls `firmware::bios::Bios::dispatch_interrupt(vector, …)`.
6. Guest resumes at the next instruction in the stub: `IRET`, returning to the original caller.

This keeps the CPU core generic (important for a future JIT), while still implementing BIOS
services in Rust.

**Source of truth:** `crates/firmware/README.md` and `crates/firmware/src/bios/mod.rs` (module docs).

---

## How `aero_machine::Machine` wires BIOS interrupts

`aero_machine::Machine` owns the canonical “BIOS integration loop”:

- On reset, it:
   - constructs a `firmware::bios::Bios`,
   - maps the ROM returned by `build_bios_rom()` into guest physical memory,
   - runs `Bios::post_with_pci(...)`, which performs POST and then loads/jumps to boot code based on
     `firmware::bios::BiosConfig::boot_drive` (configured via `aero_machine::MachineConfig::boot_drive`
     at construction time, or updated via `aero_machine::Machine::set_boot_drive(...)` before reset):
     - **HDD/floppy boot:** reads LBA0 into `0000:7C00` and jumps to `0000:7C00`.
     - **CD-ROM boot:** when `boot_drive` is in `0xE0..=0xEF`, parses the El Torito boot catalog and
       loads the **no-emulation** boot image to `load_segment:0000` (commonly `07C0:0000`), then
       jumps there (see [`docs/05-storage-topology-win7.md`](./05-storage-topology-win7.md) for the
      canonical Windows 7 install/recovery flow).
- During execution, Tier-0 returns `BatchExit::BiosInterrupt(vector)` when a BIOS stub `HLT` is hit.
  The machine handles it by calling:

  - `Machine::handle_bios_interrupt(vector)` → `bios.dispatch_interrupt(vector, ...)`

Relevant code:

- BIOS interrupt exit handling: `crates/aero-machine/src/lib.rs::handle_bios_interrupt`
- BIOS implementation: `crates/firmware/src/bios/interrupts.rs` (dispatch table) and `post.rs`

Note: some BIOS services are HLE and update guest memory / BIOS internal state without touching
device registers directly. For example, VGA/VBE mode changes are mirrored into the emulated VGA
device by `Machine::handle_bios_interrupt` so the host-visible display updates immediately.

---

## ACPI tables (generated by `aero-acpi`)

ACPI is generated by the `aero-acpi` crate and written into guest RAM during BIOS POST.

High-level contract:

- `firmware::bios` builds ACPI tables via `aero_acpi::AcpiTables::build(...)`.
- Tables are written at a fixed placement (`aero_acpi::AcpiPlacement`), configured via
  `firmware::bios::BiosConfig::acpi_placement`.
- The BIOS also reports the reclaimable + NVS regions so the E820 map can mark them with the correct
  types (ACPI reclaimable vs ACPI NVS).

### Regenerating the checked-in DSDT fixture

The runtime uses the **Rust generator**; the repo also keeps a checked-in DSDT AML blob for
validation/diffing:

- Fixture: `crates/firmware/acpi/dsdt.aml` (used by tests and `scripts/validate-acpi.sh`)

Regenerate the repo fixtures (recommended; this also refreshes `assets/bios.bin`):

```bash
cargo xtask fixtures
```

Or regenerate just the DSDT fixture directly:

```bash
cargo run -p firmware --bin gen_dsdt --locked
```

---

## Current limitations / known gaps

- **SMP / multi-vCPU execution:** `MachineConfig::cpu_count` accepts values `>= 1`. When
  `cpu_count > 1`, firmware will publish the configured CPU topology for **guest enumeration** via
  **ACPI MADT + SMBIOS**. However, the canonical `aero_machine::Machine` execution loop is still
  BSP-only today: AP bring-up (INIT/SIPI/IPIs), APIC IPI delivery, and the scheduler/vCPU threading
  needed for true SMP are not wired end-to-end yet.

---

## Tests to run while iterating on firmware/integration

```bash
# Firmware unit tests (BIOS services, ACPI/SMBIOS publication, ROM layout).
bash ./scripts/safe-run.sh cargo test -p firmware --locked

# Canonical machine integration tests (BIOS POST, devices, interrupts, snapshots).
bash ./scripts/safe-run.sh cargo test -p aero-machine --locked
```
