# 09 - BIOS & Firmware

## What exists today (canonical stack)

Aero’s canonical boot path is **legacy BIOS**, implemented in Rust as **HLE firmware**:

- **BIOS implementation:** `crates/firmware::bios`
  - Builds a 64 KiB ROM image (`build_bios_rom()`) containing interrupt stubs.
  - Implements POST + a minimal INT service surface (video, disk, E820, keyboard, time, …).
- **Machine integration / wiring:** `crates/aero-machine` (see [ADR 0014](./adr/0014-canonical-machine-stack.md))
  - Maps the BIOS ROM, runs POST, and dispatches BIOS interrupt “hypercalls”.
- **ACPI tables:** generated by `crates/aero-acpi` (used by `firmware::bios` during POST).

For CD-ROM boot (El Torito) and the minimal INT 13h extensions required for Windows install media,
see [`docs/09b-eltorito-cd-boot.md`](./09b-eltorito-cd-boot.md).

### INT 13h expectations (HDD/floppy vs CD-ROM)

BIOS disk I/O has two relevant sector sizes:

- **HDD/floppy:** 512-byte sectors (traditional INT 13h semantics).
- **CD-ROM:** 2048-byte logical blocks (ISO9660 / El Torito).

For CD boot and CD reads, Aero’s BIOS expects **El Torito (no-emulation)** boot and requires **INT
13h Extensions (EDD)** for CD drive numbers (recommend `DL=0xE0` for the first CD). At minimum,
Windows-style bootloaders expect `AH=41h` (extensions check), `AH=42h` (extended read), and `AH=48h`
(extended drive parameters) to work for CD, with `AH=48h` reporting `bytes_per_sector = 2048`.
Legacy CHS reads like `AH=02h` are HDD/floppy-oriented and are **not required** for CD media (as long
as the EDD path works).

See [`docs/09b-eltorito-cd-boot.md`](./09b-eltorito-cd-boot.md) for the exact structures and call
contracts.

### Canonical BIOS drive numbers (HDD0 + CD0)

In the canonical `aero_machine::Machine` Win7 storage topology, both an AHCI HDD and an IDE/ATAPI
CD-ROM may be attached. However, Aero’s BIOS currently exposes only the **selected boot drive**
(`BiosConfig::boot_drive` / `DL`) as “present” to INT 13h; other drive numbers are treated as not
present.

Drive-number conventions still follow common PC/BIOS ranges:

| Device | BIOS drive number (`DL`) | Sector size exposed via INT 13h | Notes |
|---|---:|---:|---|
| HDD0 (primary disk) | `0x80` | 512 bytes | Traditional HDD semantics. |
| CD0 (install ISO) | `0xE0` | 2048 bytes | Via INT 13h Extensions (EDD); `AH=48h` reports 2048. |

Sector units by drive class:

- For HDD drive numbers (`DL=0x80..=0xDF`), EDD DAP `lba`/`count` are in **512-byte sectors**.
- For CD drive numbers (`DL=0xE0..=0xEF`), EDD DAP `lba`/`count` are in **2048-byte logical blocks**
  (ISO LBAs).

Implementation note: in `firmware::bios`, this is expressed by the BIOS interrupt entrypoint taking
both:

- a 512-byte-sector `BlockDevice` backend (for HDD drive numbers `0x80..=0xDF`), and
- an optional 2048-byte-sector `CdromDevice` backend (for CD drive numbers `0xE0..=0xEF`).

To boot install media, the host must select CD boot (`boot_drive=0xE0`) before reset (see
[`docs/05-storage-topology-win7.md`](./05-storage-topology-win7.md)). When booting install media,
early Windows boot code reads ISO9660 logical blocks from the CD via the EDD path (`AH=42h`/`48h`).

UEFI is **not** the canonical path today. If you see older docs implying an external BIOS blob or a
still-unimplemented firmware stack, treat those as outdated.

## Deterministic firmware fixtures

This repo keeps a handful of **tiny, deterministic, in-repo** firmware blobs for tests and CI:

- `assets/bios.bin` (BIOS ROM image; generated from `firmware::bios::build_bios_rom()`)
- `crates/firmware/acpi/dsdt.aml` (ACPI DSDT AML; legacy PCI root bridge; generated from `aero-acpi`)
- `crates/firmware/acpi/dsdt_pcie.aml` (ACPI DSDT AML; PCIe ECAM/MMCONFIG-enabled variant; generated from `aero-acpi`; matches the canonical PC platform config)

Human-readable references live alongside as `crates/firmware/acpi/dsdt*.asl` and are kept in sync
with the shipped AML blobs (see `scripts/verify_dsdt.sh`).

Regenerate or verify all in-repo fixtures with:

```bash
cargo xtask fixtures [--check]
```

To regenerate/check just the BIOS ROM fixture:

```bash
cargo xtask bios-rom [--check]
```

---

## BIOS dispatch contract (HLT-in-ROM-stub “hypercall”)

The BIOS does **not** rely on the CPU core trapping `INT xx` directly. Instead, BIOS services are
implemented on the host side, and the guest reaches them via tiny real-mode ROM stubs.

### ROM mapping

`firmware::bios::build_bios_rom()` returns a 64 KiB image that the machine maps at:

- `firmware::bios::BIOS_BASE` (`0x000F_0000`)
- and (optionally/typically) also aliases at `firmware::bios::BIOS_ALIAS_BASE` (`0xFFFF_0000`) so the
  architectural reset vector at `0xFFFF_FFF0` works.

The ROM contains:

- a reset vector FAR JMP, and
- per-interrupt stubs (plus a default handler).

### Interrupt stub shape

During POST, the BIOS initializes the IVT so that important vectors point into the ROM. Each INT
handler stub is:

```text
HLT
IRET
```

Execution flow:

1. Guest executes `INT imm8` architecturally (push FLAGS/CS/IP, clear IF/TF, load CS:IP from IVT).
2. CS:IP now points at the ROM stub for that vector.
3. Stub executes `HLT`.
4. Tier-0 treats this specific `HLT` (reached from an INT stub) as a VM-exit:
   `BatchExit::BiosInterrupt(vector)`.
5. The machine calls `firmware::bios::Bios::dispatch_interrupt(vector, …)`.
6. Guest resumes at the next instruction in the stub: `IRET`, returning to the original caller.

This keeps the CPU core generic (important for a future JIT), while still implementing BIOS
services in Rust.

**Source of truth:** `crates/firmware/README.md` and `crates/firmware/src/bios/mod.rs` (module docs).

---

## How `aero_machine::Machine` wires BIOS interrupts

`aero_machine::Machine` owns the canonical “BIOS integration loop”:

- On reset, it:
  - constructs a `firmware::bios::Bios`,
  - maps the ROM returned by `build_bios_rom()` into guest physical memory,
  - runs `Bios::post_with_pci(...)`, which performs POST and then loads/jumps to boot code based on
    `firmware::bios::BiosConfig::boot_drive` (configured via `aero_machine::MachineConfig::boot_drive`
    at construction time, or updated via `aero_machine::Machine::set_boot_drive(...)` before reset):
    - **HDD/floppy boot:** reads LBA0 into `0000:7C00` and jumps to `0000:7C00`.
    - **CD-ROM boot:** when `boot_drive` is in `0xE0..=0xEF`, parses the El Torito boot catalog and
      loads the **no-emulation** boot image to `load_segment:0000` (commonly `07C0:0000`), then
      jumps there (see [`docs/05-storage-topology-win7.md`](./05-storage-topology-win7.md) for the
      canonical Windows 7 install/recovery flow).
- During execution, Tier-0 returns `BatchExit::BiosInterrupt(vector)` when a BIOS stub `HLT` is hit.
  The machine handles it by calling:

  - `Machine::handle_bios_interrupt(vector)` → `bios.dispatch_interrupt(vector, ...)`

In the canonical machine, BIOS INT 13h is wired to a **single selected boot medium**:

- If `boot_drive` is an HDD drive number (`DL=0x80..=0xDF`), INT 13h routes to the primary HDD
  backend (also attached to AHCI port 0).
- If `boot_drive` is a CD drive number (`DL=0xE0..=0xEF`), INT 13h routes to the install-media ISO
  backend (also attached to IDE secondary master ATAPI).

Note: the BIOS currently models only the selected boot drive as “present” to INT 13h; other drive
numbers are treated as not present. The host selects which medium firmware sees by setting
`boot_drive` (via `MachineConfig::boot_drive` at construction time, or via
`Machine::set_boot_drive(...)` + `Machine::reset()`).

For CD boots/reads, the BIOS supports two backend shapes:

- Prefer a 2048-byte-sector `CdromDevice` backend when servicing `DL=0xE0..=0xEF`.
- Or use the legacy fallback where the raw ISO bytes are exposed via the 512-byte-sector
  `BlockDevice` interface and the BIOS performs the 2048↔512 conversions internally.

Boot selection note: `Machine` defaults to `boot_drive=0x80`. For install-media boot, callers
should attach an ISO and select CD boot (`boot_drive=0xE0`) either:

- at construction time via `MachineConfig::boot_drive` / `MachineConfig::win7_install_defaults(...)`, or
- at runtime via `Machine::set_boot_drive(0xE0)` **before** invoking `Machine::reset()`.

Relevant code:

- BIOS interrupt exit handling: `crates/aero-machine/src/lib.rs::handle_bios_interrupt`
- BIOS implementation: `crates/firmware/src/bios/interrupts.rs` (dispatch table) and `post.rs`

Note: some BIOS services are HLE and update guest memory / BIOS internal state without touching
device registers directly. For example, VGA/VBE mode changes are mirrored into the emulated VGA
device by `Machine::handle_bios_interrupt` so the host-visible display updates immediately.

---

## ACPI tables (generated by `aero-acpi`)

ACPI is generated by the `aero-acpi` crate and written into guest RAM during BIOS POST.

High-level contract:

- `firmware::bios` builds ACPI tables via `aero_acpi::AcpiTables::build(...)`.
- Tables are written at a fixed placement (`aero_acpi::AcpiPlacement`), configured via
  `firmware::bios::BiosConfig::acpi_placement`.
- The BIOS also reports the reclaimable + NVS regions so the E820 map can mark them with the correct
  types (ACPI reclaimable vs ACPI NVS).

### Regenerating the checked-in DSDT fixtures

The runtime uses the **Rust generator**; the repo also keeps checked-in DSDT AML blobs for
validation/diffing:

- Fixtures (used by tests and `scripts/validate-acpi.sh`):
  - `crates/firmware/acpi/dsdt.aml` (legacy PCI root bridge; ECAM/MMCONFIG disabled)
  - `crates/firmware/acpi/dsdt_pcie.aml` (PCIe root bridge; ECAM/MMCONFIG enabled)

Note: the canonical PC platform enables PCIe ECAM/MMCONFIG, so `firmware::bios` typically emits
DSDT content matching `dsdt_pcie.aml` (and also publishes an `MCFG` table describing the ECAM
window). The `dsdt.aml` fixture is kept as a legacy/no-ECAM reference.

Regenerate the repo fixtures (recommended; this also refreshes `assets/bios.bin`):

```bash
cargo xtask fixtures
```

Or regenerate just the legacy `dsdt.aml` fixture directly:

```bash
cargo run -p firmware --bin gen_dsdt --locked
```

Note: `gen_dsdt` only regenerates `dsdt.aml`. To refresh `dsdt_pcie.aml`, use `cargo xtask fixtures`.

---

## Current limitations / known gaps

- **SMP / multi-vCPU execution is still bring-up only (not a full SMP guest yet):**
  `MachineConfig::cpu_count` accepts values `>= 1`. When `cpu_count > 1`, firmware publishes the
  configured CPU topology for **guest enumeration** via **ACPI MADT + SMBIOS**.
  `aero_machine::Machine` includes basic SMP plumbing (per-vCPU LAPIC state/MMIO + INIT/SIPI AP
  bring-up + a cooperative AP run loop inside `Machine::run_slice`), but it is still **not** a full
  SMP scheduler (no parallel execution, limited AP scheduling, many OS-level SMP paths untested).
  See [`docs/21-smp.md`](./21-smp.md).

---

## SMP boot (BSP + APs)

On x86, application processors (APs) start in a reset/halted state and are brought online by the
bootstrap processor (BSP) using **INIT + SIPI** (via the local APIC ICR).

In Aero today:

- Firmware publishes the CPU topology (MADT + SMBIOS) for `cpu_count >= 1`.
- `aero_machine::Machine` instantiates a BSP (vCPU0) and AP `CpuCore`s and routes LAPIC MMIO
  per-vCPU. The BSP can start APs by writing INIT/SIPI to the LAPIC ICR, and `Machine::run_slice`
  will execute runnable APs in a simple bounded cooperative loop.

Useful references/tests:

- AP INIT/SIPI bring-up smoke test: `crates/aero-machine/tests/ap_tsc_sipi_sync.rs`
- Per-vCPU LAPIC MMIO routing: `crates/aero-machine/tests/lapic_mmio_per_vcpu.rs`
- IOAPIC destination routing to a non-BSP LAPIC: `crates/aero-machine/tests/ioapic_routes_to_apic1.rs`

## Tests to run while iterating on firmware/integration

```bash
# Firmware unit tests (BIOS services, ACPI/SMBIOS publication, ROM layout).
bash ./scripts/safe-run.sh cargo test -p firmware --locked

# Canonical machine integration tests (BIOS POST, devices, interrupts, snapshots).
bash ./scripts/safe-run.sh cargo test -p aero-machine --locked
```
