import { formatOneLineError } from "../text";

export type JitWasmVariant = "threaded" | "single";

export type Tier1BlockCompilation = {
  wasm_bytes: Uint8Array;
  code_byte_len: number;
  exit_to_interpreter: boolean;
};

// The Tier-1 wasm-bindgen ABI has evolved. Older builds returned raw `Uint8Array` bytes, while newer
// ones return a small object with `{ wasm_bytes, code_byte_len, exit_to_interpreter }`.
export type Tier1CompileResult = Tier1BlockCompilation | Uint8Array;

export interface JitWasmApi {
  /**
   * Compile a Tier-1 x86 basic block into a standalone WASM module.
   */
  compile_tier1_block: (
    entryRip: bigint,
    codeBytes: Uint8Array,
    maxInsts: number,
    maxBytes: number,
    inlineTlb: boolean,
    memoryShared: boolean,
    /**
     * Guest code bitness (16/32/64). Optional for backwards compatibility; when omitted, the
     * compiler defaults to 64-bit.
     */
    bitness?: number,
  ) => Tier1CompileResult;
}

type RawJitWasmModule = any;

// `wasm-pack` outputs into `web/src/wasm/pkg-jit-single` and `web/src/wasm/pkg-jit-threaded`.
//
// These directories are generated (see `web/scripts/build_wasm.mjs`) and are not
// necessarily present in a fresh checkout. Use `import.meta.glob` so:
//  - Vite builds don't fail when the generated output is missing.
//  - When the output *is* present, it is bundled as usual.
const wasmImporters = import.meta.glob("../wasm/pkg-jit-*/aero_jit_wasm.js");

declare global {
  // eslint-disable-next-line no-var
  var __aeroJitWasmJsImporterOverride:
    | Partial<Record<JitWasmVariant, () => Promise<RawJitWasmModule>>>
    | undefined;
}

function resolveWasmImporter(
  variant: JitWasmVariant,
): { importer: () => Promise<RawJitWasmModule>; wasmUrl: URL } | undefined {
  const override = globalThis.__aeroJitWasmJsImporterOverride?.[variant];
  if (override) {
    // The override is primarily for tests; avoid hard-coding a file:// URL which would
    // trigger Node-specific file reads in `resolveWasmInputForInit`.
    return { importer: override, wasmUrl: new URL("about:blank") };
  }

  const candidates: Array<{ js: string; wasm: string }> = [];

  // Note: Today the Tier-1 compiler package is always built as single-threaded (private memory),
  // even when `build_wasm.mjs` is invoked in `threaded` mode. Some developer workflows build only
  // the threaded wasm-pack outputs, which means `pkg-jit-threaded` may exist without
  // `pkg-jit-single`. To keep the JIT worker robust, allow `single` initialization to fall back
  // to `pkg-jit-threaded` if needed.
  if (variant === "single") {
    candidates.push(
      { js: "../wasm/pkg-jit-single/aero_jit_wasm.js", wasm: "../wasm/pkg-jit-single/aero_jit_wasm_bg.wasm" },
      { js: "../wasm/pkg-jit-single-dev/aero_jit_wasm.js", wasm: "../wasm/pkg-jit-single-dev/aero_jit_wasm_bg.wasm" },
      { js: "../wasm/pkg-jit-threaded/aero_jit_wasm.js", wasm: "../wasm/pkg-jit-threaded/aero_jit_wasm_bg.wasm" },
      { js: "../wasm/pkg-jit-threaded-dev/aero_jit_wasm.js", wasm: "../wasm/pkg-jit-threaded-dev/aero_jit_wasm_bg.wasm" },
    );
  } else {
    candidates.push(
      { js: "../wasm/pkg-jit-threaded/aero_jit_wasm.js", wasm: "../wasm/pkg-jit-threaded/aero_jit_wasm_bg.wasm" },
      { js: "../wasm/pkg-jit-threaded-dev/aero_jit_wasm.js", wasm: "../wasm/pkg-jit-threaded-dev/aero_jit_wasm_bg.wasm" },
      { js: "../wasm/pkg-jit-single/aero_jit_wasm.js", wasm: "../wasm/pkg-jit-single/aero_jit_wasm_bg.wasm" },
      { js: "../wasm/pkg-jit-single-dev/aero_jit_wasm.js", wasm: "../wasm/pkg-jit-single-dev/aero_jit_wasm_bg.wasm" },
    );
  }

  for (const candidate of candidates) {
    const importer = wasmImporters[candidate.js];
    if (!importer) continue;

    // The wasm binary is generated by `wasm-pack` and may not exist in a fresh checkout.
    // Suppress Vite's build-time warning about `new URL(..., import.meta.url)` paths that cannot
    // be resolved statically.
    const wasmUrl = new URL(/* @vite-ignore */ candidate.wasm, import.meta.url);
    return { importer: importer as () => Promise<RawJitWasmModule>, wasmUrl };
  }

  return undefined;
}

function toApi(mod: RawJitWasmModule): JitWasmApi {
  // wasm-bindgen historically produced different naming conventions for exports depending on
  // configuration/tooling (snake_case vs camelCase). Prefer snake_case but accept camelCase for
  // backwards compatibility with older wasm-pack outputs.
  const compileTier1Block: unknown = mod.compile_tier1_block ?? mod.compileTier1Block;
  if (typeof compileTier1Block !== "function") {
    throw new Error("aero-jit-wasm did not export `compile_tier1_block` (or `compileTier1Block`).");
  }
  return { compile_tier1_block: compileTier1Block as JitWasmApi["compile_tier1_block"] };
}

async function resolveWasmInputForInit(wasmUrl: URL): Promise<unknown> {
  // wasm-bindgen's `--target web` glue uses `fetch(new URL(..., import.meta.url))`.
  // In Node (Vitest) `fetch(file://...)` is not supported, so we pre-read the
  // `.wasm` bytes from disk and pass them to the init function directly.
  if (wasmUrl.protocol === "file:") {
    // Keep the dynamic imports opaque to Vite/Rollup so browser builds don't
    // try to resolve Node builtins.
    const fsPromises = "node:fs/promises";
    const nodeUrl = "node:url";
    const { readFile } = await import(/* @vite-ignore */ fsPromises);
    const { fileURLToPath } = await import(/* @vite-ignore */ nodeUrl);
    return await readFile(fileURLToPath(wasmUrl));
  }
  return undefined;
}

async function initWasmBindgenModule(
  mod: RawJitWasmModule,
  wasmUrl: URL,
  options: { variant: JitWasmVariant; module?: WebAssembly.Module },
): Promise<void> {
  const initFn = mod.default;
  if (typeof initFn !== "function") {
    throw new Error("WASM package does not export a default wasm-bindgen init function.");
  }

  const { module, variant } = options;
  let urlInputPromise: Promise<unknown> | null = null;
  const resolveUrlInput = async (): Promise<unknown> => {
    if (!urlInputPromise) {
      urlInputPromise = resolveWasmInputForInit(wasmUrl);
    }
    return await urlInputPromise;
  };

  const doInit = async (input: unknown): Promise<void> => {
    await initFn(input);
  };

  if (module) {
    try {
      await doInit(module);
      return;
    } catch (err) {
      const message = formatOneLineError(err, 512);
      console.warn(
        `[jit-wasm] ${variant} init with precompiled module failed; falling back to default loader. Error: ${message}`,
      );
      await doInit(await resolveUrlInput());
      return;
    }
  }

  await doInit(await resolveUrlInput());
}

async function loadVariant(variant: JitWasmVariant, options: { module?: WebAssembly.Module }): Promise<{ api: JitWasmApi }> {
  const resolved = resolveWasmImporter(variant);
  if (!resolved) {
    throw new Error(
      [
        `Missing ${variant} aero-jit-wasm package.`,
        "",
        "Note: The JIT compiler loader intentionally prefers the single-threaded package (pkg-jit-single)",
        "even when WASM threads are available. The threaded/shared-memory build can allocate an enormous",
        "SharedArrayBuffer during instantiation if the module's max memory is large (e.g. 4GiB).",
        "",
        "Build it with (from the repo root):",
        `  npm -w web run wasm:build:${variant}`,
        "",
        "Or build both variants:",
        "  npm -w web run wasm:build",
      ].join("\n"),
    );
  }

  const mod = (await resolved.importer()) as RawJitWasmModule;
  await initWasmBindgenModule(mod, resolved.wasmUrl, { variant, module: options.module });
  return { api: toApi(mod) };
}

let initPromise: Promise<{ api: JitWasmApi }> | null = null;

export async function initJitWasm(options: { module?: WebAssembly.Module } = {}): Promise<{ api: JitWasmApi }> {
  if (initPromise) return await initPromise;

  initPromise = (async () => {
    // The Tier-1 compiler itself is single-threaded and does not benefit from WASM threads. More
    // importantly, a shared-memory wasm-bindgen build + a large module `--max-memory` can cause
    // the glue code to eagerly allocate a multi-GiB SharedArrayBuffer when it auto-creates the
    // module's `WebAssembly.Memory`. Prefer the single-threaded build unconditionally so the JIT
    // worker stays reliable in COOP/COEP (crossOriginIsolated) environments.
    return await loadVariant("single", options);
  })();

  try {
    return await initPromise;
  } catch (err) {
    // Allow retries if initialization fails (e.g. CSP blocks wasm compilation).
    initPromise = null;
    throw err;
  }
}

/**
 * Initialize the JIT compiler WASM package in whichever JS context we are running in
 * (main thread or DedicatedWorkerGlobalScope).
 *
 * This mirrors the naming convention of {@link initWasmForContext} and exists for
 * symmetry/ergonomics: the JIT compiler is context-local anyway, so this currently
 * forwards to {@link initJitWasm}.
 */
export async function initJitWasmForContext(
  options: { module?: WebAssembly.Module } = {},
): Promise<{ api: JitWasmApi }> {
  return await initJitWasm(options);
}
