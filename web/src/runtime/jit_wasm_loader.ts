export type JitWasmVariant = "threaded" | "single";

export interface JitWasmApi {
  /**
   * Compile a Tier-1 x86 basic block into a standalone WASM module.
   *
   * This intentionally uses a permissive signature until the WASM ABI is stabilized.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  compile_tier1_block: (...args: any[]) => Uint8Array;
}

interface ThreadSupport {
  supported: boolean;
  reason: string;
}

function detectThreadSupport(): ThreadSupport {
  // `crossOriginIsolated` is required for SharedArrayBuffer on the web, but Node-like
  // runtimes may not expose the flag while still supporting shared memories.
  const hasCrossOriginIsolated = (globalThis as any).crossOriginIsolated === true;
  const crossOriginIsolatedKnown = typeof (globalThis as any).crossOriginIsolated === "boolean";
  if (crossOriginIsolatedKnown && !hasCrossOriginIsolated) {
    return {
      supported: false,
      reason: "crossOriginIsolated is false (missing COOP/COEP headers); SharedArrayBuffer is unavailable",
    };
  }

  if (typeof SharedArrayBuffer === "undefined") {
    return { supported: false, reason: "SharedArrayBuffer is undefined (not supported or not enabled)" };
  }

  if (typeof Atomics === "undefined") {
    return { supported: false, reason: "Atomics is undefined (WASM threads are not supported)" };
  }

  if (typeof WebAssembly === "undefined" || typeof WebAssembly.Memory === "undefined") {
    return { supported: false, reason: "WebAssembly.Memory is unavailable in this environment" };
  }

  try {
    // Even with SAB present, some environments may not support shared WebAssembly.Memory.
    // This is the most direct capability probe.
    // eslint-disable-next-line no-new
    new WebAssembly.Memory({ initial: 1, maximum: 1, shared: true });
  } catch (err) {
    const message = err instanceof Error ? err.message : String(err);
    return { supported: false, reason: `Shared WebAssembly.Memory is not supported: ${message}` };
  }

  return {
    supported: true,
    reason: hasCrossOriginIsolated
      ? "crossOriginIsolated + SharedArrayBuffer + Atomics + shared WebAssembly.Memory"
      : "SharedArrayBuffer + Atomics + shared WebAssembly.Memory",
  };
}

type RawJitWasmModule = any;

// `wasm-pack` outputs into `web/src/wasm/pkg-jit-single` and `web/src/wasm/pkg-jit-threaded`.
//
// These directories are generated (see `web/scripts/build_wasm.mjs`) and are not
// necessarily present in a fresh checkout. Use `import.meta.glob` so:
//  - Vite builds don't fail when the generated output is missing.
//  - When the output *is* present, it is bundled as usual.
const wasmImporters = import.meta.glob("../wasm/pkg-jit-*/aero_jit_wasm.js");

declare global {
  // eslint-disable-next-line no-var
  var __aeroJitWasmJsImporterOverride:
    | Partial<Record<JitWasmVariant, () => Promise<RawJitWasmModule>>>
    | undefined;
}

function resolveWasmImporter(
  variant: JitWasmVariant,
): { importer: () => Promise<RawJitWasmModule>; wasmUrl: URL } | undefined {
  const override = globalThis.__aeroJitWasmJsImporterOverride?.[variant];
  if (override) {
    // The override is primarily for tests; avoid hard-coding a file:// URL which would
    // trigger Node-specific file reads in `resolveWasmInputForInit`.
    return { importer: override, wasmUrl: new URL("about:blank") };
  }

  const releasePath =
    variant === "threaded"
      ? "../wasm/pkg-jit-threaded/aero_jit_wasm.js"
      : "../wasm/pkg-jit-single/aero_jit_wasm.js";
  const devPath =
    variant === "threaded"
      ? "../wasm/pkg-jit-threaded-dev/aero_jit_wasm.js"
      : "../wasm/pkg-jit-single-dev/aero_jit_wasm.js";

  const importer = wasmImporters[releasePath] ?? wasmImporters[devPath];
  if (!importer) return undefined;

  const wasmPath =
    importer === wasmImporters[releasePath]
      ? variant === "threaded"
        ? "../wasm/pkg-jit-threaded/aero_jit_wasm_bg.wasm"
        : "../wasm/pkg-jit-single/aero_jit_wasm_bg.wasm"
      : variant === "threaded"
        ? "../wasm/pkg-jit-threaded-dev/aero_jit_wasm_bg.wasm"
        : "../wasm/pkg-jit-single-dev/aero_jit_wasm_bg.wasm";

  // The wasm binary is generated by `wasm-pack` and may not exist in a fresh checkout.
  // Suppress Vite's build-time warning about `new URL(..., import.meta.url)` paths that cannot
  // be resolved statically.
  const wasmUrl = new URL(/* @vite-ignore */ wasmPath, import.meta.url);
  return { importer: importer as () => Promise<RawJitWasmModule>, wasmUrl };
}

function toApi(mod: RawJitWasmModule): JitWasmApi {
  if (typeof mod.compile_tier1_block !== "function") {
    throw new Error("aero-jit-wasm did not export `compile_tier1_block`.");
  }
  return { compile_tier1_block: mod.compile_tier1_block };
}

async function resolveWasmInputForInit(wasmUrl: URL): Promise<unknown> {
  // wasm-bindgen's `--target web` glue uses `fetch(new URL(..., import.meta.url))`.
  // In Node (Vitest) `fetch(file://...)` is not supported, so we pre-read the
  // `.wasm` bytes from disk and pass them to the init function directly.
  if (wasmUrl.protocol === "file:") {
    // Keep the dynamic imports opaque to Vite/Rollup so browser builds don't
    // try to resolve Node builtins.
    const fsPromises = "node:fs/promises";
    const nodeUrl = "node:url";
    const { readFile } = await import(/* @vite-ignore */ fsPromises);
    const { fileURLToPath } = await import(/* @vite-ignore */ nodeUrl);
    return await readFile(fileURLToPath(wasmUrl));
  }
  return undefined;
}

async function initWasmBindgenModule(
  mod: RawJitWasmModule,
  wasmUrl: URL,
  options: { variant: JitWasmVariant; module?: WebAssembly.Module },
): Promise<void> {
  const initFn = mod.default;
  if (typeof initFn !== "function") {
    throw new Error("WASM package does not export a default wasm-bindgen init function.");
  }

  const { module, variant } = options;
  let urlInputPromise: Promise<unknown> | null = null;
  const resolveUrlInput = async (): Promise<unknown> => {
    if (!urlInputPromise) {
      urlInputPromise = resolveWasmInputForInit(wasmUrl);
    }
    return await urlInputPromise;
  };

  const doInit = async (input: unknown): Promise<void> => {
    await initFn(input);
  };

  if (module) {
    try {
      await doInit(module);
      return;
    } catch (err) {
      const message = err instanceof Error ? err.message : String(err);
      console.warn(
        `[jit-wasm] ${variant} init with precompiled module failed; falling back to default loader. Error: ${message}`,
      );
      await doInit(await resolveUrlInput());
      return;
    }
  }

  await doInit(await resolveUrlInput());
}

async function loadVariant(variant: JitWasmVariant, options: { module?: WebAssembly.Module }): Promise<{ api: JitWasmApi }> {
  const resolved = resolveWasmImporter(variant);
  if (!resolved) {
    throw new Error(
      [
        `Missing ${variant} aero-jit-wasm package.`,
        "",
        "Build it with (from the repo root):",
        `  npm -w web run wasm:build:${variant}`,
        "",
        "Or build both variants:",
        "  npm -w web run wasm:build",
      ].join("\n"),
    );
  }

  const mod = (await resolved.importer()) as RawJitWasmModule;
  await initWasmBindgenModule(mod, resolved.wasmUrl, { variant, module: options.module });
  return { api: toApi(mod) };
}

let initPromise: Promise<{ api: JitWasmApi }> | null = null;

export async function initJitWasm(options: { module?: WebAssembly.Module } = {}): Promise<{ api: JitWasmApi }> {
  if (initPromise) return await initPromise;

  initPromise = (async () => {
    const threadSupport = detectThreadSupport();
    if (threadSupport.supported) {
      try {
        return await loadVariant("threaded", options);
      } catch {
        // Fall back to single if the threaded build isn't present or fails to init.
      }
    }

    return await loadVariant("single", options);
  })();

  try {
    return await initPromise;
  } catch (err) {
    // Allow retries if initialization fails (e.g. CSP blocks wasm compilation).
    initPromise = null;
    throw err;
  }
}

