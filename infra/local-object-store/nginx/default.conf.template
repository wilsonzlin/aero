server {
    listen 80;
    server_name _;

    # When validating Range behavior, it's helpful to avoid proxy buffering/caching.
    proxy_buffering off;
    proxy_request_buffering off;
    client_max_body_size 0;

    # Docker DNS resolver for dynamic upstream resolution.
    resolver 127.0.0.11 valid=10s;

    location / {
        # Apply CORS headers at the proxy to emulate CDN/edge behavior.
        add_header 'Access-Control-Allow-Origin' '${CORS_ALLOWED_ORIGIN}' always;
        add_header 'Access-Control-Allow-Methods' 'GET,HEAD,PUT,POST,DELETE,OPTIONS' always;
        add_header 'Access-Control-Allow-Headers' 'Authorization,Content-Type,Range,Origin,Accept,X-Amz-Date,X-Amz-Content-Sha256,X-Amz-Security-Token' always;
        add_header 'Access-Control-Expose-Headers' 'ETag,Content-Length,Content-Range,Accept-Ranges,Content-Type' always;
        add_header 'Access-Control-Max-Age' 86400 always;
        add_header 'Vary' 'Origin' always;

        # Handle preflight directly at the proxy.
        if ($request_method = OPTIONS) {
            return 204;
        }

        set $s3_upstream '${S3_UPSTREAM}';
        proxy_pass http://$s3_upstream;

        # Preserve the original host. This matters if you test SigV4 signing via the proxy.
        proxy_set_header Host $http_host;

        # Be explicit: forward Range headers through the proxy.
        proxy_set_header Range $http_range;
        proxy_set_header If-Range $http_if_range;

        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # Emulate a CDN "edge override" by stripping upstream CORS headers and injecting ours.
        proxy_hide_header Access-Control-Allow-Origin;
        proxy_hide_header Access-Control-Allow-Credentials;
        proxy_hide_header Access-Control-Allow-Headers;
        proxy_hide_header Access-Control-Allow-Methods;
        proxy_hide_header Access-Control-Expose-Headers;
        proxy_hide_header Access-Control-Max-Age;
    }
}
