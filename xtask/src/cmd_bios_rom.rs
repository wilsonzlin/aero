use crate::error::{Result, XtaskError};
use crate::paths;
use std::fs;
use std::io;
use std::path::Path;

const BIOS_ROM_LEN: usize = 0x10000; // 64KiB

pub fn print_help() {
    println!(
        "\
Generate/check the 64KiB BIOS ROM fixture at `assets/bios.bin`.

Usage:
  cargo xtask bios-rom [--check]

Flags:
  --check    Fail if `assets/bios.bin` is missing or differs from the generated bytes.
"
    );
}

pub fn cmd(args: Vec<String>) -> Result<()> {
    let Some(check) = parse_args(args)? else {
        return Ok(());
    };

    let repo_root = paths::repo_root()?;
    let out_path = repo_root.join("assets/bios.bin");

    let rom = firmware::bios::build_bios_rom();
    if rom.len() != BIOS_ROM_LEN {
        return Err(XtaskError::Message(format!(
            "firmware::bios::build_bios_rom() returned {} bytes (expected {BIOS_ROM_LEN})",
            rom.len()
        )));
    }

    ensure_file(&out_path, &rom, check)
}

fn parse_args(args: Vec<String>) -> Result<Option<bool>> {
    if args.iter().any(|a| a == "-h" || a == "--help") {
        print_help();
        return Ok(None);
    }

    let mut check = false;
    for arg in args {
        match arg.as_str() {
            "--check" => check = true,
            other => {
                return Err(XtaskError::Message(format!(
                    "unknown flag for `bios-rom`: `{other}` (run `cargo xtask bios-rom --help`)"
                )))
            }
        }
    }

    Ok(Some(check))
}

fn ensure_file(path: &Path, expected: &[u8], check: bool) -> Result<()> {
    let existing = match fs::read(path) {
        Ok(bytes) => Some(bytes),
        Err(err) if err.kind() == io::ErrorKind::NotFound => None,
        Err(err) => {
            return Err(XtaskError::Message(format!("read {path:?}: {err}")));
        }
    };

    if check {
        let Some(existing) = existing else {
            return Err(XtaskError::Message(format!(
                "{path:?} is missing (run `cargo xtask bios-rom`)"
            )));
        };
        if existing != expected {
            return Err(XtaskError::Message(format!(
                "{path:?} is out of date (run `cargo xtask bios-rom`)"
            )));
        }
        return Ok(());
    }

    if existing.as_deref() != Some(expected) {
        if let Some(parent) = path.parent() {
            fs::create_dir_all(parent)
                .map_err(|e| XtaskError::Message(format!("create {parent:?}: {e}")))?;
        }
        fs::write(path, expected)
            .map_err(|e| XtaskError::Message(format!("write {path:?}: {e}")))?;
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parse_args_accepts_check_flag() {
        assert_eq!(parse_args(Vec::new()).unwrap(), Some(false));
        assert_eq!(parse_args(vec!["--check".to_string()]).unwrap(), Some(true));
    }

    #[test]
    fn parse_args_rejects_unknown_flag() {
        let err = parse_args(vec!["--nope".to_string()]).unwrap_err();
        let msg = err.to_string();
        assert!(msg.contains("unknown flag for `bios-rom`"));
        assert!(msg.contains("--nope"));
    }

    #[test]
    fn ensure_file_writes_and_checks() {
        let tmp = tempfile::tempdir().unwrap();
        let nested = tmp.path().join("a").join("b").join("bios.bin");
        let expected = vec![0xAA, 0xBB, 0xCC];

        // Write mode should create parent dirs and write the file.
        ensure_file(&nested, &expected, false).unwrap();
        assert_eq!(std::fs::read(&nested).unwrap(), expected);

        // Check mode should succeed when bytes match.
        ensure_file(&nested, &expected, true).unwrap();

        // Out-of-date should fail in check mode.
        std::fs::write(&nested, &[0x00]).unwrap();
        let err = ensure_file(&nested, &expected, true).unwrap_err();
        assert!(err.to_string().contains("out of date"));

        // Missing should fail in check mode.
        std::fs::remove_file(&nested).unwrap();
        let err = ensure_file(&nested, &expected, true).unwrap_err();
        assert!(err.to_string().contains("is missing"));
    }
}
