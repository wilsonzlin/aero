use crate::error::{Result, XtaskError};
use crate::paths;
use std::fs;
use std::io;
use std::path::Path;

const BIOS_ROM_LEN: usize = 0x10000; // 64KiB
const RESET_VECTOR_OFF: usize = 0xFFF0;

pub fn print_help() {
    println!(
        "\
Generate/check the 64KiB BIOS ROM fixture at `assets/bios.bin`.

Usage:
  cargo xtask bios-rom [--check]

Flags:
  --check    Fail if `assets/bios.bin` is missing or differs from the generated bytes.
"
    );
}

pub fn cmd(args: Vec<String>) -> Result<()> {
    let Some(check) = parse_args(args)? else {
        return Ok(());
    };

    let repo_root = paths::repo_root()?;
    let out_path = repo_root.join("assets/bios.bin");

    let rom = firmware::bios::build_bios_rom();
    validate_bios_rom(&rom)?;

    ensure_file(&out_path, &rom, check)
}

pub(crate) fn validate_bios_rom(rom: &[u8]) -> Result<()> {
    // Keep these checks in-sync with `crates/firmware/src/bios/mod.rs` tests.
    if firmware::bios::BIOS_SIZE != BIOS_ROM_LEN {
        return Err(XtaskError::Message(format!(
            "firmware::bios::BIOS_SIZE is {} bytes but xtask expects {BIOS_ROM_LEN} bytes",
            firmware::bios::BIOS_SIZE
        )));
    }

    if rom.len() != BIOS_ROM_LEN {
        return Err(XtaskError::Message(format!(
            "generated BIOS ROM has incorrect length: {} bytes (expected {BIOS_ROM_LEN})",
            rom.len()
        )));
    }

    if rom.get(RESET_VECTOR_OFF..RESET_VECTOR_OFF + 5) != Some(&[0xEA, 0x00, 0xE0, 0x00, 0xF0]) {
        let got = rom
            .get(RESET_VECTOR_OFF..RESET_VECTOR_OFF + 5)
            .unwrap_or(&[]);
        return Err(XtaskError::Message(format!(
            "generated BIOS ROM reset vector is invalid at 0x{RESET_VECTOR_OFF:04x}: expected [ea, 00, e0, 00, f0], got {got:02x?}"
        )));
    }

    if rom.get(BIOS_ROM_LEN - 2..) != Some(&[0x55, 0xAA]) {
        let got = rom.get(BIOS_ROM_LEN - 2..).unwrap_or(&[]);
        return Err(XtaskError::Message(format!(
            "generated BIOS ROM signature is invalid: expected [55, aa], got {got:02x?}"
        )));
    }

    Ok(())
}

fn parse_args(args: Vec<String>) -> Result<Option<bool>> {
    if args.iter().any(|a| a == "-h" || a == "--help") {
        print_help();
        return Ok(None);
    }

    let mut check = false;
    for arg in args {
        match arg.as_str() {
            "--check" => check = true,
            other => {
                return Err(XtaskError::Message(format!(
                    "unknown flag for `bios-rom`: `{other}` (run `cargo xtask bios-rom --help`)"
                )))
            }
        }
    }

    Ok(Some(check))
}

fn ensure_file(path: &Path, expected: &[u8], check: bool) -> Result<()> {
    let path_display = paths::display_rel_path(path);
    let existing = match fs::read(path) {
        Ok(bytes) => Some(bytes),
        Err(err) if err.kind() == io::ErrorKind::NotFound => None,
        Err(err) => {
            return Err(XtaskError::Message(format!("read {path_display}: {err}")));
        }
    };

    if check {
        let Some(existing) = existing else {
            return Err(XtaskError::Message(format!(
                "{path_display} is missing (run `cargo xtask bios-rom`)"
            )));
        };
        if existing != expected {
            return Err(XtaskError::Message(format!(
                "{path_display} is out of date (run `cargo xtask bios-rom`)"
            )));
        }
        return Ok(());
    }

    if existing.as_deref() != Some(expected) {
        if let Some(parent) = path.parent() {
            fs::create_dir_all(parent).map_err(|e| {
                XtaskError::Message(format!("create {}: {e}", paths::display_rel_path(parent)))
            })?;
        }
        fs::write(path, expected)
            .map_err(|e| XtaskError::Message(format!("write {path_display}: {e}")))?;
    }

    Ok(())
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use super::*;

    #[test]
    fn parse_args_accepts_check_flag() {
        assert_eq!(parse_args(Vec::new()).unwrap(), Some(false));
        assert_eq!(parse_args(vec!["--check".to_string()]).unwrap(), Some(true));
    }

    #[test]
    fn parse_args_rejects_unknown_flag() {
        let err = parse_args(vec!["--nope".to_string()]).unwrap_err();
        let msg = err.to_string();
        assert!(msg.contains("unknown flag for `bios-rom`"));
        assert!(msg.contains("--nope"));
    }

    #[test]
    fn ensure_file_writes_and_checks() {
        let tmp = tempfile::tempdir().unwrap();
        let nested = tmp.path().join("a").join("b").join("bios.bin");
        let expected = vec![0xAA, 0xBB, 0xCC];

        // Write mode should create parent dirs and write the file.
        ensure_file(&nested, &expected, false).unwrap();
        assert_eq!(std::fs::read(&nested).unwrap(), expected);

        // Check mode should succeed when bytes match.
        ensure_file(&nested, &expected, true).unwrap();

        // Out-of-date should fail in check mode.
        std::fs::write(&nested, [0x00]).unwrap();
        let err = ensure_file(&nested, &expected, true).unwrap_err();
        assert!(err.to_string().contains("out of date"));

        // Missing should fail in check mode.
        std::fs::remove_file(&nested).unwrap();
        let err = ensure_file(&nested, &expected, true).unwrap_err();
        assert!(err.to_string().contains("is missing"));
    }
}
