#![cfg(not(target_arch = "wasm32"))]

use assert_cmd::Command;
use predicates::prelude::*;
use std::fs;
use std::path::{Path, PathBuf};

#[cfg(unix)]
use std::os::unix::fs::PermissionsExt;
#[cfg(unix)]
use std::os::unix::io::AsRawFd;

/// Verify `cargo xtask input` fails with a helpful hint when `node_modules` is missing.
///
/// This is important for sandboxed environments (CI, minimal dev shells) where `node_modules` is
/// often not present; the error should suggest using `--rust-only`.
#[test]
#[cfg(unix)]
fn input_reports_missing_node_modules_with_rust_only_hint() {
    let repo_root = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .parent()
        .expect("xtask/CARGO_MANIFEST_DIR should have a parent")
        .to_path_buf();

    let _node_modules_lock = acquire_node_modules_lock(&repo_root).expect("acquire node_modules lock");
    let _guard = hide_node_modules(&repo_root).expect("hide node_modules");

    let tmp = tempfile::tempdir().expect("create tempdir");
    let bin_dir = tmp.path().join("bin");
    fs::create_dir(&bin_dir).expect("create bin dir");
    let log_path = tmp.path().join("argv.log");

    write_fake_argv_logger(&bin_dir.join("cargo"), "cargo").expect("write fake cargo");
    write_fake_argv_logger(&bin_dir.join("node"), "node").expect("write fake node");
    write_fake_argv_logger(&bin_dir.join("npm"), "npm").expect("write fake npm");

    let orig_path = std::env::var("PATH").unwrap_or_default();
    let path = format!("{}:{}", bin_dir.display(), orig_path);

    Command::new(env!("CARGO_BIN_EXE_xtask"))
        .args(["input"])
        .env("AERO_XTASK_TEST_LOG", &log_path)
        .env("PATH", path)
        .assert()
        .failure()
        .code(1)
        .stderr(predicate::str::contains("node_modules is missing"))
        .stderr(predicate::str::contains("cargo xtask input --rust-only"));

    let log = fs::read_to_string(&log_path).unwrap_or_default();
    let invocations = parse_invocations(&log);

    assert!(
        invocations
            .iter()
            .any(|argv| argv.first().map(|s| s.as_str()) == Some("node")),
        "expected node version check to run before reporting missing node_modules; invocations={invocations:?}"
    );
    assert!(
        !invocations
            .iter()
            .any(|argv| argv.first().map(|s| s.as_str()) == Some("npm")),
        "expected npm not to be invoked when node_modules is missing; invocations={invocations:?}"
    );
}

#[cfg(unix)]
fn acquire_node_modules_lock(repo_root: &Path) -> std::io::Result<std::fs::File> {
    fs::create_dir_all(repo_root.join("target"))?;
    let lock_path = repo_root.join("target/xtask-test-node-modules.lock");
    let file = std::fs::OpenOptions::new()
        .create(true)
        .read(true)
        .write(true)
        .truncate(false)
        .open(lock_path)?;

    let rc = unsafe { libc::flock(file.as_raw_fd(), libc::LOCK_EX) };
    if rc == 0 {
        Ok(file)
    } else {
        Err(std::io::Error::last_os_error())
    }
}

#[cfg(unix)]
fn hide_node_modules(repo_root: &Path) -> std::io::Result<NodeModulesHideGuard> {
    let root_node_modules = repo_root.join("node_modules");
    let web_node_modules = repo_root.join("web/node_modules");

    let root_backup = rename_if_dir(&root_node_modules)?;
    let web_backup = rename_if_dir(&web_node_modules)?;

    Ok(NodeModulesHideGuard {
        root_node_modules,
        web_node_modules,
        root_backup,
        web_backup,
    })
}

#[cfg(unix)]
fn rename_if_dir(path: &Path) -> std::io::Result<Option<PathBuf>> {
    if !path.is_dir() {
        return Ok(None);
    }

    let unique = format!(
        "{}.xtask-test-hide.{}.{}",
        path.file_name()
            .and_then(|s| s.to_str())
            .unwrap_or("node_modules"),
        std::process::id(),
        std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap_or_default()
            .as_nanos()
    );
    let backup = path
        .parent()
        .expect("node_modules path should have a parent")
        .join(unique);

    fs::rename(path, &backup)?;
    Ok(Some(backup))
}

#[cfg(unix)]
struct NodeModulesHideGuard {
    root_node_modules: PathBuf,
    web_node_modules: PathBuf,
    root_backup: Option<PathBuf>,
    web_backup: Option<PathBuf>,
}

#[cfg(unix)]
impl Drop for NodeModulesHideGuard {
    fn drop(&mut self) {
        if let Some(backup) = &self.root_backup {
            let _ = fs::rename(backup, &self.root_node_modules);
        }
        if let Some(backup) = &self.web_backup {
            let _ = fs::rename(backup, &self.web_node_modules);
        }
    }
}

#[cfg(unix)]
fn write_fake_argv_logger(path: &Path, name: &str) -> std::io::Result<()> {
    let script = format!(
        r#"#!/bin/bash
set -euo pipefail
log="${{AERO_XTASK_TEST_LOG:?}}"
echo "{name}" >> "$log"
for arg in "$@"; do
  echo "$arg" >> "$log"
done
echo "__END__" >> "$log"
exit 0
"#
    );
    fs::write(path, script)?;
    let mut perms = fs::metadata(path)?.permissions();
    perms.set_mode(0o755);
    fs::set_permissions(path, perms)?;
    Ok(())
}

fn parse_invocations(log: &str) -> Vec<Vec<String>> {
    let mut invocations = Vec::new();
    let mut current = Vec::new();

    for line in log.lines() {
        if line == "__END__" {
            if !current.is_empty() {
                invocations.push(std::mem::take(&mut current));
            }
            continue;
        }
        current.push(line.to_string());
    }

    if !current.is_empty() {
        invocations.push(current);
    }

    invocations
}
