#![cfg(not(target_arch = "wasm32"))]

use assert_cmd::Command;
use predicates::prelude::*;
use std::fs;
use std::path::{Path, PathBuf};

#[cfg(unix)]
use std::os::unix::fs::PermissionsExt;
#[cfg(unix)]
use std::os::unix::io::AsRawFd;

/// Keep this in sync with `WEB_UNIT_TEST_PATHS` in `xtask/src/cmd_input.rs`.
///
/// We intentionally assert ordering so `cargo xtask input` stays stable and predictable for
/// sandboxed runs (and so additions must update the wiring tests).
const EXPECTED_WEB_UNIT_TEST_PATHS: &[&str] = &[
    "src/input",
    "src/hid",
    "src/platform/hid_passthrough_protocol.test.ts",
    "src/platform/webhid_passthrough.test.ts",
    "src/platform/webhid_passthrough_broker.test.ts",
    "src/platform/webusb_protection.test.ts",
    "src/platform/webusb_troubleshooting.test.ts",
    "src/usb/usb_guest_controller.test.ts",
    "src/usb/webusb_backend.test.ts",
    "src/usb/webusb_executor.test.ts",
    "src/usb/webusb_passthrough_runtime.test.ts",
    "src/usb/webhid_passthrough_runtime.test.ts",
    "src/usb/usb_proxy_protocol.test.ts",
    "src/usb/usb_proxy_ring.test.ts",
    "src/usb/usb_proxy_ring_dispatcher.test.ts",
    "src/usb/usb_proxy_ring_integration.test.ts",
    "src/usb/xhci_webusb_bridge.test.ts",
    "src/usb/xhci_webusb_passthrough_runtime.test.ts",
    "src/usb/uhci_machine_topology_rust_drift.test.ts",
    "src/usb/uhci_webusb_root_port_rust_drift.test.ts",
    "src/usb/ehci_webusb_root_port_rust_drift.test.ts",
    "src/usb/xhci_webusb_root_port_rust_drift.test.ts",
];

/// Verify `cargo xtask input` fails with a helpful hint when `node_modules` is missing.
///
/// This is important for sandboxed environments (CI, minimal dev shells) where `node_modules` is
/// often not present; the error should suggest using `--rust-only`.
#[test]
#[cfg(unix)]
fn input_reports_missing_node_modules_with_rust_only_hint() {
    let repo_root = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .parent()
        .expect("xtask/CARGO_MANIFEST_DIR should have a parent")
        .to_path_buf();

    let _node_modules_lock =
        acquire_node_modules_lock(&repo_root).expect("acquire node_modules lock");
    let _guard = hide_node_modules(&repo_root).expect("hide node_modules");

    let tmp = tempfile::tempdir().expect("create tempdir");
    let bin_dir = tmp.path().join("bin");
    fs::create_dir(&bin_dir).expect("create bin dir");
    let log_path = tmp.path().join("argv.log");

    write_fake_argv_logger(&bin_dir.join("cargo"), "cargo").expect("write fake cargo");
    write_fake_argv_logger(&bin_dir.join("node"), "node").expect("write fake node");
    write_fake_argv_logger(&bin_dir.join("npm"), "npm").expect("write fake npm");

    let orig_path = std::env::var("PATH").unwrap_or_default();
    let path = format!("{}:{}", bin_dir.display(), orig_path);

    Command::new(env!("CARGO_BIN_EXE_xtask"))
        .args(["input"])
        .env_remove("AERO_NODE_DIR")
        .env_remove("AERO_WEB_DIR")
        .env("AERO_XTASK_TEST_LOG", &log_path)
        .env("PATH", path)
        .assert()
        .failure()
        .code(1)
        .stderr(predicate::str::contains("node_modules is missing"))
        .stderr(predicate::str::contains("cargo xtask input --rust-only"));

    let log = fs::read_to_string(&log_path).unwrap_or_default();
    let invocations = parse_invocations(&log);

    assert!(
        invocations
            .iter()
            .any(|argv| argv.first().map(|s| s.as_str()) == Some("node")),
        "expected node version check to run before reporting missing node_modules; invocations={invocations:?}"
    );
    assert!(
        !invocations
            .iter()
            .any(|argv| argv.first().map(|s| s.as_str()) == Some("npm")),
        "expected npm not to be invoked when node_modules is missing; invocations={invocations:?}"
    );
}

/// Verify `cargo xtask input --wasm` still reports a helpful `--rust-only` hint when `node_modules`
/// is missing, and preserves the `--wasm` flag in the suggested command.
#[test]
#[cfg(unix)]
fn input_wasm_reports_missing_node_modules_with_wasm_rust_only_hint() {
    let repo_root = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .parent()
        .expect("xtask/CARGO_MANIFEST_DIR should have a parent")
        .to_path_buf();

    let _node_modules_lock =
        acquire_node_modules_lock(&repo_root).expect("acquire node_modules lock");
    let _guard = hide_node_modules(&repo_root).expect("hide node_modules");

    let tmp = tempfile::tempdir().expect("create tempdir");
    let bin_dir = tmp.path().join("bin");
    fs::create_dir(&bin_dir).expect("create bin dir");
    let log_path = tmp.path().join("argv.log");

    write_fake_argv_logger(&bin_dir.join("cargo"), "cargo").expect("write fake cargo");
    write_fake_argv_logger(&bin_dir.join("node"), "node").expect("write fake node");
    write_fake_argv_logger(&bin_dir.join("npm"), "npm").expect("write fake npm");
    write_fake_argv_logger(&bin_dir.join("wasm-pack"), "wasm-pack").expect("write fake wasm-pack");

    // Avoid inheriting the real PATH: all invoked tools should be stubbed.
    let path = bin_dir.display().to_string();

    Command::new(env!("CARGO_BIN_EXE_xtask"))
        .args(["input", "--wasm"])
        .env_remove("AERO_NODE_DIR")
        .env_remove("AERO_WEB_DIR")
        .env("AERO_XTASK_TEST_LOG", &log_path)
        .env("PATH", path)
        .assert()
        .failure()
        .code(1)
        .stderr(predicate::str::contains("node_modules is missing"))
        .stderr(predicate::str::contains(
            "cargo xtask input --wasm --rust-only",
        ));

    let log = fs::read_to_string(&log_path).unwrap_or_default();
    let invocations = parse_invocations(&log);

    assert!(
        invocations
            .iter()
            .any(|argv| argv.first().map(|s| s.as_str()) == Some("wasm-pack")),
        "expected wasm-pack invocation before node_modules check; invocations={invocations:?}"
    );
    assert!(
        !invocations
            .iter()
            .any(|argv| argv.first().map(|s| s.as_str()) == Some("npm")),
        "expected npm not to be invoked when node_modules is missing; invocations={invocations:?}"
    );
}

/// Verify `cargo xtask input` suggests `--rust-only` when Node itself is missing.
#[test]
#[cfg(unix)]
fn input_reports_missing_node_with_rust_only_hint() {
    let tmp = tempfile::tempdir().expect("create tempdir");
    let bin_dir = tmp.path().join("bin");
    fs::create_dir(&bin_dir).expect("create bin dir");
    let log_path = tmp.path().join("argv.log");

    write_fake_argv_logger(&bin_dir.join("cargo"), "cargo").expect("write fake cargo");
    write_fake_argv_logger(&bin_dir.join("npm"), "npm").expect("write fake npm");

    // Do not provide a `node` stub, and avoid inheriting the real PATH, so Node is guaranteed to be
    // missing for this test even on developer machines.
    let path = bin_dir.display().to_string();

    Command::new(env!("CARGO_BIN_EXE_xtask"))
        .args(["input"])
        .env_remove("AERO_NODE_DIR")
        .env_remove("AERO_WEB_DIR")
        .env("AERO_XTASK_TEST_LOG", &log_path)
        .env("PATH", path)
        .assert()
        .failure()
        .code(1)
        .stderr(predicate::str::contains("missing required command: node"))
        .stderr(predicate::str::contains("cargo xtask input --rust-only"));
}

/// Verify the missing-Node hint preserves `--machine` so developers can still run the machine tests
/// in rust-only mode on a Node-less environment.
#[test]
#[cfg(unix)]
fn input_machine_reports_missing_node_with_machine_rust_only_hint() {
    let tmp = tempfile::tempdir().expect("create tempdir");
    let bin_dir = tmp.path().join("bin");
    fs::create_dir(&bin_dir).expect("create bin dir");
    let log_path = tmp.path().join("argv.log");

    write_fake_argv_logger(&bin_dir.join("cargo"), "cargo").expect("write fake cargo");

    // Do not provide a `node` stub, and avoid inheriting the real PATH, so Node is guaranteed to be
    // missing for this test even on developer machines.
    let path = bin_dir.display().to_string();

    Command::new(env!("CARGO_BIN_EXE_xtask"))
        .args(["input", "--machine"])
        .env_remove("AERO_NODE_DIR")
        .env_remove("AERO_WEB_DIR")
        .env("AERO_XTASK_TEST_LOG", &log_path)
        .env("PATH", path)
        .assert()
        .failure()
        .code(1)
        .stderr(predicate::str::contains("missing required command: node"))
        .stderr(predicate::str::contains(
            "cargo xtask input --machine --rust-only",
        ));
}

/// Verify the missing-Node hint preserves `--usb-all` + `--with-wasm` so developers can still run
/// the full Rust USB suite + aero-wasm smoke tests in rust-only mode on a Node-less environment.
#[test]
#[cfg(unix)]
fn input_usb_all_with_wasm_reports_missing_node_with_preserved_rust_only_hint() {
    let tmp = tempfile::tempdir().expect("create tempdir");
    let bin_dir = tmp.path().join("bin");
    fs::create_dir(&bin_dir).expect("create bin dir");
    let log_path = tmp.path().join("argv.log");

    write_fake_argv_logger(&bin_dir.join("cargo"), "cargo").expect("write fake cargo");

    // Do not provide a `node` stub, and avoid inheriting the real PATH, so Node is guaranteed to be
    // missing for this test even on developer machines.
    let path = bin_dir.display().to_string();

    Command::new(env!("CARGO_BIN_EXE_xtask"))
        .args(["input", "--usb-all", "--with-wasm"])
        .env_remove("AERO_NODE_DIR")
        .env_remove("AERO_WEB_DIR")
        .env("AERO_XTASK_TEST_LOG", &log_path)
        .env("PATH", path)
        .assert()
        .failure()
        .code(1)
        .stderr(predicate::str::contains("missing required command: node"))
        .stderr(predicate::str::contains(
            "cargo xtask input --usb-all --with-wasm --rust-only",
        ));
}

/// Verify `cargo xtask input --wasm` fails with a "Node is required" message when Node is missing
/// (unlike the non-wasm case, where `--rust-only` is a viable escape hatch).
#[test]
#[cfg(unix)]
fn input_reports_missing_node_when_wasm_enabled() {
    let tmp = tempfile::tempdir().expect("create tempdir");
    let bin_dir = tmp.path().join("bin");
    fs::create_dir(&bin_dir).expect("create bin dir");
    let log_path = tmp.path().join("argv.log");

    write_fake_argv_logger(&bin_dir.join("cargo"), "cargo").expect("write fake cargo");

    // Do not provide a `node` stub, and avoid inheriting the real PATH, so Node is guaranteed to be
    // missing for this test even on developer machines.
    let path = bin_dir.display().to_string();

    Command::new(env!("CARGO_BIN_EXE_xtask"))
        .args(["input", "--wasm", "--rust-only"])
        .env_remove("AERO_NODE_DIR")
        .env_remove("AERO_WEB_DIR")
        .env("AERO_XTASK_TEST_LOG", &log_path)
        .env("PATH", path)
        .assert()
        .failure()
        .code(1)
        .stderr(predicate::str::contains("missing required command: node"))
        .stderr(predicate::str::contains(
            "Node is required for `cargo xtask input --wasm`",
        ));
}

/// Verify `cargo xtask input` suggests `--rust-only` when npm is missing (but Node is present).
#[test]
#[cfg(unix)]
fn input_reports_missing_npm_with_rust_only_hint() {
    let repo_root = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .parent()
        .expect("xtask/CARGO_MANIFEST_DIR should have a parent")
        .to_path_buf();

    let _node_modules_lock =
        acquire_node_modules_lock(&repo_root).expect("acquire node_modules lock");
    let _node_modules_guard = ensure_node_modules_dir(&repo_root).expect("ensure node_modules dir");

    let tmp = tempfile::tempdir().expect("create tempdir");
    let bin_dir = tmp.path().join("bin");
    fs::create_dir(&bin_dir).expect("create bin dir");
    let log_path = tmp.path().join("argv.log");

    write_fake_argv_logger(&bin_dir.join("cargo"), "cargo").expect("write fake cargo");
    write_fake_argv_logger(&bin_dir.join("node"), "node").expect("write fake node");

    // Do not provide an npm stub, and avoid inheriting the real PATH, so npm is guaranteed to be
    // missing for this test even on developer machines.
    let path = bin_dir.display().to_string();

    Command::new(env!("CARGO_BIN_EXE_xtask"))
        .args(["input"])
        .env_remove("AERO_NODE_DIR")
        .env_remove("AERO_WEB_DIR")
        .env("AERO_XTASK_TEST_LOG", &log_path)
        .env("PATH", path)
        .assert()
        .failure()
        .code(1)
        .stderr(predicate::str::contains("missing required command: npm"))
        .stderr(predicate::str::contains("cargo xtask input --rust-only"));
}

/// Verify `cargo xtask input` runs the expected web unit tests when `node_modules` is present.
///
/// This is a stubbed argv-wiring test (no real Node deps required); it ensures we keep the unit test
/// scope focused on input/USB-related paths.
#[test]
#[cfg(unix)]
fn input_invokes_expected_web_unit_test_subset() {
    let repo_root = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .parent()
        .expect("xtask/CARGO_MANIFEST_DIR should have a parent")
        .to_path_buf();

    let _node_modules_lock =
        acquire_node_modules_lock(&repo_root).expect("acquire node_modules lock");
    let _node_modules_guard = ensure_node_modules_dir(&repo_root).expect("ensure node_modules dir");

    let tmp = tempfile::tempdir().expect("create tempdir");
    let bin_dir = tmp.path().join("bin");
    fs::create_dir(&bin_dir).expect("create bin dir");
    let log_path = tmp.path().join("argv.log");

    write_fake_argv_logger(&bin_dir.join("cargo"), "cargo").expect("write fake cargo");
    write_fake_argv_logger(&bin_dir.join("node"), "node").expect("write fake node");
    write_fake_argv_logger(&bin_dir.join("npm"), "npm").expect("write fake npm");

    // Avoid inheriting the real PATH: all invoked tools should be stubbed.
    let path = bin_dir.display().to_string();

    Command::new(env!("CARGO_BIN_EXE_xtask"))
        .args(["input"])
        .env_remove("AERO_NODE_DIR")
        .env_remove("AERO_WEB_DIR")
        .env("AERO_XTASK_TEST_LOG", &log_path)
        .env("PATH", path)
        .assert()
        .success();

    let log = fs::read_to_string(&log_path).expect("read argv log");
    let invocations = parse_invocations(&log);

    assert!(
        !invocations
            .iter()
            .any(|argv| argv.iter().any(|arg| arg == "test:e2e")),
        "expected no Playwright invocation without --e2e; invocations={invocations:?}"
    );

    let npm_unit = invocations
        .iter()
        .find(|argv| {
            argv.first().map(|s| s.as_str()) == Some("npm")
                && argv.contains(&"test:unit".to_string())
        })
        .expect("expected an npm test:unit invocation");

    fn idx(args: &[String], needle: &str) -> usize {
        args.iter()
            .position(|arg| arg == needle)
            .unwrap_or_else(|| panic!("expected `{needle}` in argv={args:?}"))
    }

    let idx_w = idx(npm_unit, "-w");
    let idx_web = idx(npm_unit, "web");
    let idx_run = idx(npm_unit, "run");
    let idx_test_unit = idx(npm_unit, "test:unit");
    let idx_sep = idx(npm_unit, "--");

    assert!(
        idx_w < idx_web && idx_web < idx_run && idx_run < idx_test_unit && idx_test_unit < idx_sep,
        "unexpected npm argument ordering: argv={npm_unit:?}"
    );

    for (i, expected) in EXPECTED_WEB_UNIT_TEST_PATHS.iter().enumerate() {
        let actual = npm_unit
            .get(idx_sep + 1 + i)
            .unwrap_or_else(|| panic!("missing `{expected}` in npm argv={npm_unit:?}"));
        assert_eq!(
            actual, expected,
            "unexpected npm test subset ordering; argv={npm_unit:?}"
        );
    }
}

/// Verify `AERO_NODE_DIR=web` switches the npm unit test step to run directly inside the `web/`
/// package (rather than using `npm -w web` from the repo root).
///
/// This keeps `cargo xtask input` usable for developers who run Node tooling from `web/` directly.
#[test]
#[cfg(unix)]
fn input_invokes_expected_web_unit_test_subset_when_node_dir_is_web() {
    let repo_root = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .parent()
        .expect("xtask/CARGO_MANIFEST_DIR should have a parent")
        .to_path_buf();

    let _node_modules_lock =
        acquire_node_modules_lock(&repo_root).expect("acquire node_modules lock");
    let _node_modules_guard = ensure_node_modules_dir(&repo_root).expect("ensure node_modules dir");

    let tmp = tempfile::tempdir().expect("create tempdir");
    let bin_dir = tmp.path().join("bin");
    fs::create_dir(&bin_dir).expect("create bin dir");
    let log_path = tmp.path().join("argv.log");

    write_fake_argv_logger(&bin_dir.join("cargo"), "cargo").expect("write fake cargo");
    write_fake_argv_logger(&bin_dir.join("node"), "node").expect("write fake node");
    write_fake_argv_logger(&bin_dir.join("npm"), "npm").expect("write fake npm");

    // Avoid inheriting the real PATH: all invoked tools should be stubbed.
    let path = bin_dir.display().to_string();

    Command::new(env!("CARGO_BIN_EXE_xtask"))
        .args(["input"])
        .env("AERO_NODE_DIR", "web")
        .env("AERO_XTASK_TEST_LOG", &log_path)
        .env("PATH", path)
        .assert()
        .success();

    let log = fs::read_to_string(&log_path).expect("read argv log");
    let invocations = parse_invocations(&log);

    let npm_unit = invocations
        .iter()
        .find(|argv| {
            argv.first().map(|s| s.as_str()) == Some("npm")
                && argv.contains(&"test:unit".to_string())
        })
        .expect("expected an npm test:unit invocation");

    assert!(
        !npm_unit.iter().any(|arg| arg == "-w"),
        "expected AERO_NODE_DIR=web to avoid `npm -w web`; argv={npm_unit:?}"
    );
    assert!(
        !npm_unit.iter().any(|arg| arg == "web"),
        "expected AERO_NODE_DIR=web to avoid a literal `web` workspace arg; argv={npm_unit:?}"
    );

    fn idx(args: &[String], needle: &str) -> usize {
        args.iter()
            .position(|arg| arg == needle)
            .unwrap_or_else(|| panic!("expected `{needle}` in argv={args:?}"))
    }

    let idx_run = idx(npm_unit, "run");
    let idx_test_unit = idx(npm_unit, "test:unit");
    let idx_sep = idx(npm_unit, "--");

    assert!(
        idx_run < idx_test_unit && idx_test_unit < idx_sep,
        "unexpected npm argument ordering: argv={npm_unit:?}"
    );

    for (i, expected) in EXPECTED_WEB_UNIT_TEST_PATHS.iter().enumerate() {
        let actual = npm_unit
            .get(idx_sep + 1 + i)
            .unwrap_or_else(|| panic!("missing `{expected}` in npm argv={npm_unit:?}"));
        assert_eq!(
            actual, expected,
            "unexpected npm test subset ordering; argv={npm_unit:?}"
        );
    }
}

#[cfg(unix)]
fn acquire_node_modules_lock(repo_root: &Path) -> std::io::Result<std::fs::File> {
    fs::create_dir_all(repo_root.join("target"))?;
    let lock_path = repo_root.join("target/xtask-test-node-modules.lock");
    let file = std::fs::OpenOptions::new()
        .create(true)
        .read(true)
        .write(true)
        .truncate(false)
        .open(lock_path)?;

    let rc = unsafe { libc::flock(file.as_raw_fd(), libc::LOCK_EX) };
    if rc == 0 {
        Ok(file)
    } else {
        Err(std::io::Error::last_os_error())
    }
}

#[cfg(unix)]
fn hide_node_modules(repo_root: &Path) -> std::io::Result<NodeModulesHideGuard> {
    let root_node_modules = repo_root.join("node_modules");
    let web_node_modules = repo_root.join("web/node_modules");

    let root_backup = rename_if_dir(&root_node_modules)?;
    let web_backup = rename_if_dir(&web_node_modules)?;

    Ok(NodeModulesHideGuard {
        root_node_modules,
        web_node_modules,
        root_backup,
        web_backup,
    })
}

#[cfg(unix)]
fn ensure_node_modules_dir(repo_root: &Path) -> std::io::Result<NodeModulesEnsureGuard> {
    let node_modules_dir = repo_root.join("node_modules");
    let created = if node_modules_dir.is_dir() {
        false
    } else {
        fs::create_dir(&node_modules_dir)?;
        true
    };
    Ok(NodeModulesEnsureGuard {
        path: node_modules_dir,
        created,
    })
}

#[cfg(unix)]
fn rename_if_dir(path: &Path) -> std::io::Result<Option<PathBuf>> {
    if !path.is_dir() {
        return Ok(None);
    }

    let unique = format!(
        "{}.xtask-test-hide.{}.{}",
        path.file_name()
            .and_then(|s| s.to_str())
            .unwrap_or("node_modules"),
        std::process::id(),
        std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap_or_default()
            .as_nanos()
    );
    let backup = path
        .parent()
        .expect("node_modules path should have a parent")
        .join(unique);

    fs::rename(path, &backup)?;
    Ok(Some(backup))
}

#[cfg(unix)]
struct NodeModulesHideGuard {
    root_node_modules: PathBuf,
    web_node_modules: PathBuf,
    root_backup: Option<PathBuf>,
    web_backup: Option<PathBuf>,
}

#[cfg(unix)]
impl Drop for NodeModulesHideGuard {
    fn drop(&mut self) {
        if let Some(backup) = &self.root_backup {
            let _ = fs::rename(backup, &self.root_node_modules);
        }
        if let Some(backup) = &self.web_backup {
            let _ = fs::rename(backup, &self.web_node_modules);
        }
    }
}

#[cfg(unix)]
struct NodeModulesEnsureGuard {
    path: PathBuf,
    created: bool,
}

#[cfg(unix)]
impl Drop for NodeModulesEnsureGuard {
    fn drop(&mut self) {
        if self.created {
            let _ = fs::remove_dir_all(&self.path);
        }
    }
}

#[cfg(unix)]
fn write_fake_argv_logger(path: &Path, name: &str) -> std::io::Result<()> {
    let script = format!(
        r#"#!/bin/bash
set -euo pipefail
log="${{AERO_XTASK_TEST_LOG:?}}"
echo "{name}" >> "$log"
for arg in "$@"; do
  echo "$arg" >> "$log"
done
echo "__END__" >> "$log"
exit 0
"#
    );
    fs::write(path, script)?;
    let mut perms = fs::metadata(path)?.permissions();
    perms.set_mode(0o755);
    fs::set_permissions(path, perms)?;
    Ok(())
}

fn parse_invocations(log: &str) -> Vec<Vec<String>> {
    let mut invocations = Vec::new();
    let mut current = Vec::new();

    for line in log.lines() {
        if line == "__END__" {
            if !current.is_empty() {
                invocations.push(std::mem::take(&mut current));
            }
            continue;
        }
        current.push(line.to_string());
    }

    if !current.is_empty() {
        invocations.push(current);
    }

    invocations
}
