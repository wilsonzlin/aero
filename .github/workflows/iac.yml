name: IaC (Terraform + Helm/K8s)

on:
  pull_request:
    paths:
      - infra/**
      - deploy/k8s/**
      - deploy/docker-compose.yml
      - docker-compose.yml
      - compose.yaml
      - scripts/headers.json
      - scripts/ci/check-security-headers.mjs
      - scripts/ci/check-deploy-manifests.mjs
      - .github/workflows/iac.yml
  push:
    branches:
      - main
    paths:
      - infra/**
      - deploy/k8s/**
      - deploy/docker-compose.yml
      - docker-compose.yml
      - compose.yaml
      - scripts/headers.json
      - scripts/ci/check-security-headers.mjs
      - scripts/ci/check-deploy-manifests.mjs
      - .github/workflows/iac.yml
  merge_group:
    paths:
      - infra/**
      - deploy/k8s/**
      - deploy/docker-compose.yml
      - docker-compose.yml
      - compose.yaml
      - scripts/headers.json
      - scripts/ci/check-security-headers.mjs
      - scripts/ci/check-deploy-manifests.mjs
      - .github/workflows/iac.yml
  schedule:
    # Weekly safety net: catch drift (Helm/K8s API changes, Terraform/provider updates, etc).
    - cron: "17 3 * * 1"
  workflow_dispatch:

concurrency:
  group: iac-${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

permissions:
  contents: read

jobs:
  terraform:
    name: Terraform (fmt + validate)
    runs-on: ubuntu-latest
    timeout-minutes: 10
    env:
      TERRAFORM_VERSION: "1.7.5"
      TFLINT_VERSION: "v0.53.0"
      TF_PLUGIN_CACHE_DIR: ~/.terraform.d/plugin-cache
      TF_IN_AUTOMATION: "1"
    steps:
      - uses: actions/checkout@v6

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false

      - name: Prepare Terraform plugin cache
        shell: bash
        run: mkdir -p "$TF_PLUGIN_CACHE_DIR"

      - name: Cache Terraform plugins
        uses: actions/cache@v4
        with:
          path: ~/.terraform.d/plugin-cache
          key: ${{ runner.os }}-terraform-${{ env.TERRAFORM_VERSION }}-${{ hashFiles('infra/**/.terraform.lock.hcl') }}
          restore-keys: |
            ${{ runner.os }}-terraform-

      - name: Setup TFLint
        uses: terraform-linters/setup-tflint@v4
        with:
          tflint_version: ${{ env.TFLINT_VERSION }}

      - name: Cache TFLint plugins
        uses: actions/cache@v4
        with:
          path: ~/.tflint.d/plugins
          key: ${{ runner.os }}-tflint-${{ env.TFLINT_VERSION }}-${{ hashFiles('infra/**/.tflint.hcl') }}
          restore-keys: |
            ${{ runner.os }}-tflint-

      - name: terraform fmt (check)
        run: terraform fmt -check -diff -recursive infra

      - name: terraform init + validate (backend disabled)
        shell: bash
        run: |
          set -euo pipefail
          # Treat infra/<module>/ as "root modules" and require that they commit a
          # provider lockfile. This avoids accidentally treating reusable child
          # modules as roots, while still catching missing lockfiles early.
          mapfile -t root_candidates < <(find infra -mindepth 2 -maxdepth 2 -type f -name '*.tf' -print0 | xargs -0 -r -n1 dirname | sort -u)
          for module in "${root_candidates[@]}"; do
            if [[ ! -f "$module/.terraform.lock.hcl" ]]; then
              echo "Terraform module '$module' is missing .terraform.lock.hcl."
              echo "Run: terraform -chdir=\"$module\" init (and commit the generated lockfile)."
              exit 1
            fi
          done

          mapfile -t modules < <(find infra -name '.terraform.lock.hcl' -print0 | xargs -0 -r -n1 dirname | sort -u)
          if [[ ${#modules[@]} -eq 0 ]]; then
            echo "No Terraform modules found under infra/ (expected at least one infra/**/.terraform.lock.hcl)"
            exit 1
          fi

          printf '%s\n' "${modules[@]}" | tee /tmp/terraform-modules.txt

          while IFS= read -r module; do
            echo "::group::terraform init/validate ($module)"
            terraform -chdir="$module" init -backend=false -input=false -lockfile=readonly
            terraform -chdir="$module" validate -no-color
            echo "::endgroup::"
          done < /tmp/terraform-modules.txt

      - name: tflint
        shell: bash
        run: |
          set -euo pipefail
          while IFS= read -r module; do
            echo "::group::tflint ($module)"
            tflint --chdir="$module" --init
            tflint --chdir="$module" --format compact
            echo "::endgroup::"
          done < /tmp/terraform-modules.txt

  k8s:
    name: Helm + kubeconform
    runs-on: ubuntu-latest
    timeout-minutes: 10
    env:
      K8S_VERSION: "1.28.0"
      KUBECONFORM_VERSION: "0.6.6"
      KUBECONFORM_SHA256: "2ff56999a6ed9e96fe5ab9ee52271f2db5335baf7f17789035b9561970cdd3eb"
      KUBECONFORM_CRD_SCHEMA: "https://raw.githubusercontent.com/datreeio/CRDs-catalog/main/{{.Group}}/{{.ResourceKind}}_{{.ResourceAPIVersion}}.json"
    steps:
      - uses: actions/checkout@v6

      - name: Setup Helm
        uses: azure/setup-helm@v4
        with:
          version: v3.14.4

      - name: Install kubeconform
        shell: bash
        run: |
          set -euo pipefail
          curl -fsSL -o /tmp/kubeconform.tar.gz "https://github.com/yannh/kubeconform/releases/download/v${KUBECONFORM_VERSION}/kubeconform-linux-amd64.tar.gz"
          echo "${KUBECONFORM_SHA256}  /tmp/kubeconform.tar.gz" | sha256sum -c -
          tar -C /tmp -xzf /tmp/kubeconform.tar.gz kubeconform
          sudo mv /tmp/kubeconform /usr/local/bin/kubeconform
          kubeconform -v

      - name: Cache kubeconform schemas
        uses: actions/cache@v4
        with:
          path: ~/.cache/kubeconform
          key: ${{ runner.os }}-kubeconform-${{ env.K8S_VERSION }}-${{ env.KUBECONFORM_VERSION }}
          restore-keys: |
            ${{ runner.os }}-kubeconform-

      - name: helm lint (example values)
        shell: bash
        run: |
          set -euo pipefail
          CHART="deploy/k8s/chart/aero-gateway"
          helm lint "$CHART" --strict --kube-version "$K8S_VERSION" -f "$CHART/values-dev.yaml"
          helm lint "$CHART" --strict --kube-version "$K8S_VERSION" -f "$CHART/values-prod.yaml"
          helm lint "$CHART" --strict --kube-version "$K8S_VERSION" -f "$CHART/values-prod-with-l2.yaml"
          helm lint "$CHART" --strict --kube-version "$K8S_VERSION" -f "$CHART/values-traefik.yaml"
          helm lint "$CHART" --strict --kube-version "$K8S_VERSION" -f "$CHART/values-prod-certmanager.yaml"
          helm lint "$CHART" --strict --kube-version "$K8S_VERSION" -f "$CHART/values-prod-certmanager-issuer.yaml"
          helm lint "$CHART" --strict --kube-version "$K8S_VERSION" -f "$CHART/values-prod-appheaders.yaml"

      - name: helm template + kubeconform (example values)
        shell: bash
        run: |
          set -euo pipefail
          CHART="deploy/k8s/chart/aero-gateway"
          KUBECONFORM_CACHE_DIR="$HOME/.cache/kubeconform"
          mkdir -p "$KUBECONFORM_CACHE_DIR"

          for values in \
            values-dev.yaml \
            values-prod.yaml \
            values-prod-with-l2.yaml \
            values-traefik.yaml \
            values-prod-certmanager.yaml \
            values-prod-certmanager-issuer.yaml \
            values-prod-appheaders.yaml; do
            out="/tmp/aero-gateway-${values%.yaml}.yaml"
            helm template aero-gateway "$CHART" -n aero --kube-version "$K8S_VERSION" -f "$CHART/$values" > "$out"

            kubeconform \
              -cache "$KUBECONFORM_CACHE_DIR" \
              -strict \
              -schema-location default \
              -schema-location "$KUBECONFORM_CRD_SCHEMA" \
              -kubernetes-version "$K8S_VERSION" \
              -summary \
              "$out"

            # Ensure cross-origin isolation + CSP strategy is present in the ingress layer
            # when using ingress-level header injection.
            #
            # `values-prod-appheaders.yaml` intentionally disables ingress header injection
            # (COOP/COEP/CSP are set at the app/proxy layer instead).
            if [[ "$values" != "values-prod-appheaders.yaml" ]]; then
              python3 - "$out" <<'PY'
          import json
          import sys
          from pathlib import Path

          out_path = sys.argv[1]
          text = Path(out_path).read_text(encoding="utf-8")

          headers = json.loads(Path("scripts/headers.json").read_text(encoding="utf-8"))
          expected = {}
          expected.update(headers.get("crossOriginIsolation", {}))
          expected.update(headers.get("baseline", {}))
          expected.update(headers.get("contentSecurityPolicy", {}))

          missing = []
          for key, value in expected.items():
              # nginx snippet form:
              if f'add_header {key} "{value}"' in text:
                  continue
              # Traefik middleware YAML form:
              if f'{key}: "{value}"' in text:
                  continue
              missing.append(key)

          if missing:
              print(f"Rendered Helm manifests missing canonical headers: {', '.join(missing)}", file=sys.stderr)
              sys.exit(1)

          print("Validated ingress header strategy against scripts/headers.json")
          PY
            fi
          done

      - name: kubeconform (raw manifests)
        shell: bash
        run: |
          set -euo pipefail
          KUBECONFORM_CACHE_DIR="$HOME/.cache/kubeconform"
          mkdir -p "$KUBECONFORM_CACHE_DIR"
          kubeconform -cache "$KUBECONFORM_CACHE_DIR" -strict -schema-location default -schema-location "$KUBECONFORM_CRD_SCHEMA" -kubernetes-version "$K8S_VERSION" -summary deploy/k8s/aero-storage-server
          kubeconform -cache "$KUBECONFORM_CACHE_DIR" -strict -schema-location default -schema-location "$KUBECONFORM_CRD_SCHEMA" -kubernetes-version "$K8S_VERSION" -summary deploy/k8s/examples/cert-manager

  deploy-hygiene:
    name: Deploy manifest hygiene
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@v6

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version-file: .nvmrc

      - name: Check deployment manifest labels
        run: node scripts/ci/check-deploy-manifests.mjs

      - name: Check security header templates
        run: node scripts/ci/check-security-headers.mjs
