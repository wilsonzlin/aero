name: CI

on:
  pull_request:
  push:
    branches:
      - main
  workflow_dispatch:
  merge_group:

concurrency:
  group: ci-${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  checks: write

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: "1"
  # PR CI should never require WebGPU.
  AERO_REQUIRE_WEBGPU: "0"
  AERO_WASM_CRATE_DIR: ${{ vars.AERO_WASM_CRATE_DIR }}

jobs:
  policy:
    name: Repo policy (fixtures & binaries)
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      code_changed: ${{ steps.changes.outputs.code_changed }}
      docs_only: ${{ steps.changes.outputs.docs_only }}
      win7_virtio_snd_changed: ${{ steps.changes.outputs.win7_virtio_snd_changed }}
    env:
      BASE_REF: ${{ github.event_name == 'pull_request' && github.event.pull_request.base.sha || github.event_name == 'merge_group' && github.event.merge_group.base_sha || github.event.before }}
      HEAD_REF: ${{ github.event_name == 'merge_group' && github.event.merge_group.head_sha || github.sha }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check Cargo.lock syntax (no duplicates / no conflict markers)
        run: python3 scripts/ci/check-cargo-lockfile-syntax.py
      - name: Check Cargo config syntax (no duplicate keys / no conflict markers)
        run: python3 scripts/ci/check-cargo-config-syntax.py
      - name: Check Cargo.toml syntax (no duplicate keys / no conflict markers)
        run: python3 scripts/ci/check-cargo-toml-syntax.py

      - name: Detect docs-only changes
        id: changes
        shell: bash
        run: |
          set -euo pipefail

          base="$BASE_REF"
          head="$HEAD_REF"

          # `github.event.before` can be all zeros in some edge cases (e.g. branch creation).
          # Fall back to full CI rather than skipping checks.
          if [[ -z "${base:-}" || "$base" == "0000000000000000000000000000000000000000" ]]; then
            echo "code_changed=true" >> "$GITHUB_OUTPUT"
            echo "docs_only=false" >> "$GITHUB_OUTPUT"
            echo "win7_virtio_snd_changed=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          files="$(git diff --name-only "$base" "$head")"
          echo "Changed files:";
          echo "$files"

          code_changed=false
          while IFS= read -r file; do
            [[ -z "$file" ]] && continue
            if [[ "$file" != docs/* && "$file" != *.md ]]; then
              code_changed=true
              break
            fi
          done <<< "$files"

          echo "code_changed=$code_changed" >> "$GITHUB_OUTPUT"
          if [[ "$code_changed" == "true" ]]; then
            echo "docs_only=false" >> "$GITHUB_OUTPUT"
          else
            echo "docs_only=true" >> "$GITHUB_OUTPUT"
          fi

          win7_virtio_snd_changed=false
          while IFS= read -r file; do
            [[ -z "$file" ]] && continue
            if [[ "$file" == drivers/windows7/virtio-snd/* || "$file" == drivers/windows7/virtio/common/* || "$file" == .github/workflows/ci.yml ]]; then
              win7_virtio_snd_changed=true
              break
            fi
          done <<< "$files"

          echo "win7_virtio_snd_changed=$win7_virtio_snd_changed" >> "$GITHUB_OUTPUT"

      - name: Change filter summary
        if: always()
        shell: bash
        run: |
          {
            echo "### CI change filter"
            echo ""
            echo "- Docs-only: \`${{ steps.changes.outputs.docs_only }}\`"
            echo "- Code changed: \`${{ steps.changes.outputs.code_changed }}\`"
            echo "- Win7 virtio-snd/common changed: \`${{ steps.changes.outputs.win7_virtio_snd_changed }}\`"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Check repository policy
        run: scripts/ci/check-repo-policy.sh

      - name: Check legacy net-stack 4CC does not reappear
        run: bash scripts/ci/check-no-legacy-net-stack-4cc.sh

      - name: Check Guest Tools devices.cmd is generated
        run: python3 scripts/ci/gen-guest-tools-devices-cmd.py --check

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version-file: .nvmrc

      - name: Check scancode generated files are up-to-date
        run: npm run check:scancodes

      - name: Check security header templates
        run: node scripts/ci/check-security-headers.mjs

      - name: Check deployment manifest labels
        run: node scripts/ci/check-deploy-manifests.mjs

      - name: Check repository layout
        run: scripts/ci/check-repo-layout.sh

      - name: Check safe-run rustc retry detection
        shell: bash
        run: bash scripts/tests/safe-run-retry-detection.sh
      - name: Check safe-run Cargo home isolation
        shell: bash
        run: bash scripts/tests/safe-run-cargo-home.sh
      - name: Check safe-run RUSTFLAGS sanitization
        shell: bash
        run: bash scripts/tests/safe-run-rustflags-sanitization.sh
      - name: Check safe-run Playwright timeout bump
        shell: bash
        run: bash scripts/tests/safe-run-playwright-timeout.sh
      - name: Check safe-run Playwright memory-limit bump
        shell: bash
        run: bash scripts/tests/safe-run-playwright-mem-limit.sh

      - name: Check AeroGPU WDK guard macros
        run: python3 scripts/ci/check-aerogpu-wdk-guards.py

      - name: Check AeroGPU KMD submit size hardening
        run: python3 scripts/ci/check-aerogpu-kmd-submit-size-guards.py

      - name: Check AeroGPU KMD atomic 64-bit access (x86 tearing guard)
        run: python3 scripts/ci/check-aerogpu-kmd-fence-atomics.py

      - name: Check AeroGPU KMD IRQ_ENABLE writeback semantics
        run: python3 scripts/ci/check-aerogpu-kmd-irq-enable-mask-writeback.py

      - name: Check aero-d3d11 guest-memory imports
        run: python3 scripts/ci/check-aero-d3d11-guest-memory-imports.py

      - name: Check Node workflow pinning
        run: node scripts/ci/check-node-workflows.mjs

      - name: Check Rust workflow policy (setup-rust)
        run: scripts/ci/check-rust-workflows.sh

  toolchains:
    name: Toolchain policy (pinned stable + pinned nightly)
    needs: policy
    if: needs.policy.result == 'success' && needs.policy.outputs.code_changed == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version-file: .nvmrc

      - name: Check pinned Rust toolchains
        run: node scripts/ci/check-toolchains.mjs

  wasm-threaded:
    name: WASM (threaded smoke build)
    needs: policy
    if: needs.policy.result == 'success' && needs.policy.outputs.code_changed == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version-file: .nvmrc

      - name: Setup Rust (pinned nightly for threaded WASM)
        uses: ./.github/actions/setup-rust
        with:
          toolchain: nightly
          targets: wasm32-unknown-unknown
          components: rust-src
          locked: always

      - name: Install wasm-pack
        uses: jetli/wasm-pack-action@v0.4.0

      - name: Threaded WASM build (dev, smoke)
        run: cargo xtask wasm threaded dev

  rust:
    name: Rust (fmt, clippy, test)
    needs: policy
    if: needs.policy.result == 'success' && needs.policy.outputs.code_changed == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - uses: actions/checkout@v4

      - name: Setup Rust
        id: setup-rust
        uses: ./.github/actions/setup-rust
        with:
          toolchain: stable
          components: rustfmt, clippy
          targets: wasm32-unknown-unknown
          locked: always

      - name: Verify Cargo.lock files are present and in sync
        run: scripts/ci/check-cargo-lockfiles.sh

      - name: Check workspace crate naming policy
        run: python3 scripts/ci/check-crate-name-collisions.py

      - name: Prepare net traces dir
        run: mkdir -p target/net-traces
      - name: Check deterministic fixtures are up-to-date
        run: cargo xtask fixtures --check
      - name: Check BIOS ROM fixture is up-to-date
        run: cargo xtask bios-rom --check

      - name: cargo fmt
        run: cargo fmt --all -- --check

      - name: cargo clippy
        run: cargo clippy ${{ steps.setup-rust.outputs.cargo_locked_flag }} --workspace --all-targets --all-features -- -D warnings

      - name: cargo test (wasm32, workspace, no-run)
        run: cargo test ${{ steps.setup-rust.outputs.cargo_locked_flag }} --target wasm32-unknown-unknown --workspace --tests --no-run

      - name: wasm32 compile check (aero-devices-gpu + aero-machine + aero-wasm)
        run: cargo run ${{ steps.setup-rust.outputs.cargo_locked_flag }} -p xtask -- wasm-check

      - name: cargo test (wasm32, aero-gpu, no-run)
        run: cargo test ${{ steps.setup-rust.outputs.cargo_locked_flag }} --target wasm32-unknown-unknown -p aero-gpu --tests --no-run

      - name: cargo test (wasm32, aero-d3d9, no-run)
        run: cargo test ${{ steps.setup-rust.outputs.cargo_locked_flag }} --target wasm32-unknown-unknown -p aero-d3d9 --tests --no-run

      - name: cargo test (wasm32, aero-webgpu, no-run)
        run: cargo test ${{ steps.setup-rust.outputs.cargo_locked_flag }} --target wasm32-unknown-unknown -p aero-webgpu --tests --no-run

      - name: cargo test (wasm32, aero-gpu-wasm, no-run)
        run: cargo test ${{ steps.setup-rust.outputs.cargo_locked_flag }} --target wasm32-unknown-unknown -p aero-gpu-wasm --tests --no-run

      - name: Install cargo-nextest
        uses: taiki-e/install-action@v2
        with:
          tool: nextest

      - name: Prepare test-results directory
        run: mkdir -p test-results

      - name: cargo nextest (workspace)
        run: |
          set -euo pipefail
          scripts/ci/run-nextest-with-junit.sh --output test-results/rust-workspace.xml -- ${{ steps.setup-rust.outputs.cargo_locked_flag }} --workspace --all-features --exclude aero-storage-server

      - name: cargo test (doc tests)
        run: cargo test ${{ steps.setup-rust.outputs.cargo_locked_flag }} --workspace --all-features --doc

      - name: cargo nextest (guest tools packager)
        run: |
          set -euo pipefail
          scripts/ci/run-nextest-with-junit.sh --output test-results/rust-aero-packager.xml -- ${{ steps.setup-rust.outputs.cargo_locked_flag }} --manifest-path tools/packaging/aero_packager/Cargo.toml

      - name: cargo nextest (disk-gateway reference server)
        run: |
          set -euo pipefail
          scripts/ci/run-nextest-with-junit.sh --output test-results/rust-disk-gateway.xml -- ${{ steps.setup-rust.outputs.cargo_locked_flag }} --manifest-path server/disk-gateway/Cargo.toml

      - name: cargo nextest (aero-storage-server)
        run: |
          set -euo pipefail
          scripts/ci/run-nextest-with-junit.sh --output test-results/rust-aero-storage-server.xml -- ${{ steps.setup-rust.outputs.cargo_locked_flag }} -p aero-storage-server --all-features

      - name: Publish Rust test report
        if: always()
        uses: dorny/test-reporter@v1
        with:
          name: Rust tests
          path: test-results/rust-*.xml
          reporter: java-junit
          fail-on-error: false

      - name: Upload Rust test artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: rust-test-results
          path: test-results/rust-*.xml
          if-no-files-found: warn
          retention-days: 7

      - name: Upload net traces
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: net-traces
          path: target/net-traces
          if-no-files-found: ignore
          retention-days: 7

      - name: Upload network captures (pcapng)
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: net-captures
          path: target/nt-test-artifacts/**/*.pcapng
          if-no-files-found: ignore
          retention-days: 7

      - name: Rust job summary
        if: always()
        shell: bash
        run: |
          {
            echo "### Rust test reports"
            echo ""
            echo "- JUnit: \`test-results/rust-*.xml\`"
            echo "- Artifact: \`rust-test-results\`"
            echo ""
            echo "Network artifacts (only on failure):"
            echo "- \`net-traces\`"
            echo "- \`net-captures\`"
          } >> "$GITHUB_STEP_SUMMARY"

  acpi-iasl:
    name: ACPI (iasl)
    needs: policy
    if: needs.policy.result == 'success' && needs.policy.outputs.code_changed == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@v4

      - name: Install ACPICA tools (iasl)
        run: |
          sudo apt-get update
          sudo apt-get install -y acpica-tools

      - name: Validate ACPI tables (decompile + compile)
        run: bash scripts/validate-acpi.sh

  win7-virtio-portable-tests:
    name: Win7 virtio (portable tests)
    needs: policy
    if: needs.policy.result == 'success' && needs.policy.outputs.code_changed == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@v4
      - name: Win7 virtqueue_split guardrails (headers + driver build files)
        run: |
          set -euo pipefail
          python3 scripts/ci/check-win7-virtqueue-split-headers.py
          python3 scripts/ci/check-virtio-snd-vcxproj-sources.py
          python3 scripts/ci/check-virtqueue-split-driver-builds.py
          python3 scripts/ci/check-win7-virtio-header-collisions.py
      - name: Build + run virtio-pci cap parser tests
        run: |
          set -euo pipefail
          ./drivers/win7/virtio/tests/build_and_run.sh
          if command -v clang >/dev/null 2>&1; then
            CC=clang ./drivers/win7/virtio/tests/build_and_run.sh
          fi
      - name: Build + run virtio-snd host tests
        if: needs.policy.outputs.win7_virtio_snd_changed == 'true'
        run: |
          set -euo pipefail
          cmake -S drivers/windows7/virtio-snd/tests -B out/virtiosnd-host-tests -DCMAKE_BUILD_TYPE=Release
          cmake --build out/virtiosnd-host-tests --parallel --config Release
          ctest --test-dir out/virtiosnd-host-tests --output-on-failure --no-tests=error --timeout 60 -C Release
          if command -v clang >/dev/null 2>&1; then
            CC=clang cmake -S drivers/windows7/virtio-snd/tests -B out/virtiosnd-host-tests-clang -DCMAKE_BUILD_TYPE=Release
            cmake --build out/virtiosnd-host-tests-clang --parallel --config Release
            ctest --test-dir out/virtiosnd-host-tests-clang --output-on-failure --no-tests=error --timeout 60 -C Release
          fi

  aerogpu-d3d9-portable-tests:
    name: AeroGPU D3D9 UMD (portable tests)
    needs: policy
    if: needs.policy.result == 'success' && needs.policy.outputs.code_changed == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@v4
      - name: Build + run AeroGPU D3D9 UMD portable tests
        run: |
          set -euo pipefail
          cmake -S drivers/aerogpu/umd/d3d9/tests -B out/aerogpu-d3d9-tests -DCMAKE_BUILD_TYPE=Release
          cmake --build out/aerogpu-d3d9-tests --parallel --config Release
          ctest --test-dir out/aerogpu-d3d9-tests --output-on-failure --no-tests=error --timeout 60 -C Release
          if command -v clang >/dev/null 2>&1; then
            CC=clang CXX=clang++ cmake -S drivers/aerogpu/umd/d3d9/tests -B out/aerogpu-d3d9-tests-clang -DCMAKE_BUILD_TYPE=Release
            cmake --build out/aerogpu-d3d9-tests-clang --parallel --config Release
            ctest --test-dir out/aerogpu-d3d9-tests-clang --output-on-failure --no-tests=error --timeout 60 -C Release
          fi
  qemu-boot:
    name: QEMU boot tests (boot sector + FreeDOS)
    needs: policy
    if: needs.policy.result == 'success' && needs.policy.outputs.code_changed == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 20
    env:
      AERO_REQUIRE_TEST_IMAGES: "1"
      # Bump to intentionally bust the FreeDOS download cache.
      FREEDOS_CACHE_VERSION: v1
    steps:
      - uses: actions/checkout@v4

      - name: Setup Rust
        id: setup-rust
        uses: ./.github/actions/setup-rust
        with:
          toolchain: stable
          locked: always

      - name: Verify deterministic fixtures are up-to-date
        run: cargo xtask fixtures --check

      - name: Install QEMU + tooling
        run: |
          sudo apt-get update
          sudo apt-get install -y qemu-system-x86 mtools unzip

      - name: Prepare FreeDOS cache directories
        run: mkdir -p test-images/cache test-images/freedos

      - name: Read FreeDOS download metadata (for cache key)
        id: freedos-cache-key
        shell: bash
        run: |
          set -euo pipefail

          python3 - << 'PY' >> "$GITHUB_OUTPUT"
          import hashlib
          import pathlib
          import re

          text = pathlib.Path("scripts/prepare-freedos.sh").read_text(encoding="utf-8")

          m_url = re.search(r'^ZIP_URL="([^"]+)"', text, re.M)
          m_sha = re.search(r'^ZIP_SHA256="([^"]+)"', text, re.M)
          if not m_url or not m_sha:
              raise SystemExit("error: failed to extract ZIP_URL/ZIP_SHA256 from scripts/prepare-freedos.sh")

          zip_url = m_url.group(1)
          zip_sha256 = m_sha.group(1)

          # Cache keys only allow `[A-Za-z0-9_.-]`, so sanitize the URL to keep it human-auditable.
          zip_url_sanitized = re.sub(r"[^A-Za-z0-9_.-]+", "-", zip_url).strip("-")

          # Also emit a hash if we ever want a shorter key component.
          zip_url_hash = hashlib.sha256(zip_url.encode("utf-8")).hexdigest()

          print(f"zip_url_sanitized={zip_url_sanitized}")
          print(f"zip_url_hash={zip_url_hash}")
          print(f"zip_sha256={zip_sha256}")
          PY

      - name: Cache FreeDOS download (FD14-FloppyEdition.zip)
        id: freedos-zip-cache
        uses: actions/cache@v4
        with:
          path: test-images/cache/FD14-FloppyEdition.zip
          key: freedos-zip-${{ runner.os }}-${{ env.FREEDOS_CACHE_VERSION }}-${{ steps.freedos-cache-key.outputs.zip_url_sanitized }}-${{ steps.freedos-cache-key.outputs.zip_sha256 }}

      - name: Cache patched FreeDOS boot image (fd14-boot-aero.img)
        id: freedos-img-cache
        uses: actions/cache@v4
        with:
          path: |
            test-images/freedos/fd14-boot-aero.img
            test-images/freedos/fd14-boot-aero.stamp
          key: freedos-img-${{ runner.os }}-${{ env.FREEDOS_CACHE_VERSION }}-${{ steps.freedos-cache-key.outputs.zip_url_sanitized }}-${{ steps.freedos-cache-key.outputs.zip_sha256 }}-${{ hashFiles('scripts/prepare-freedos.sh') }}

      - name: Prepare open-source test images
        run: bash scripts/prepare-freedos.sh

      - name: FreeDOS cache summary
        if: always()
        shell: bash
        run: |
          {
            echo "### FreeDOS cache"
            echo ""
            echo "- ZIP cache hit: \`${{ steps.freedos-zip-cache.outputs.cache-hit }}\`"
            echo "- Image cache hit: \`${{ steps.freedos-img-cache.outputs.cache-hit }}\`"
            echo "- URL: \`${{ steps.freedos-cache-key.outputs.zip_url_sanitized }}\`"
            echo "- Expected SHA256: \`${{ steps.freedos-cache-key.outputs.zip_sha256 }}\`"
            echo "- Cache version: \`${{ env.FREEDOS_CACHE_VERSION }}\`"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Run QEMU boot tests
        run: cargo test ${{ steps.setup-rust.outputs.cargo_locked_flag }} -p aero-boot-tests --test boot_sector --test freedos_boot

  wasm:
    name: WASM (wasm-pack build + test)
    needs: policy
    if: needs.policy.result == 'success' && needs.policy.outputs.code_changed == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - uses: actions/checkout@v4

      - name: Setup Rust
        id: setup-rust
        uses: ./.github/actions/setup-rust
        with:
          toolchain: stable
          targets: wasm32-unknown-unknown
          locked: always

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version-file: .nvmrc

      - name: Resolve wasm crate
        id: wasm-crate
        uses: ./.github/actions/resolve-wasm-crate
        with:
          install-wasm-pack: "true"

      - name: wasm-pack build (single, release)
        run: cargo xtask wasm single release

      - name: wasm-pack test (node)
        run: cargo run ${{ steps.setup-rust.outputs.cargo_locked_flag }} -p xtask -- test-all --skip-rust --skip-ts --skip-e2e --wasm-crate-dir "${{ steps.wasm-crate.outputs.dir }}"

      - name: Upload wasm-pack output (on failure)
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: wasm-pack-pkg
          path: |
            web/src/wasm/pkg-single/
            ${{ steps.wasm-crate.outputs.dir }}/pkg/
          if-no-files-found: ignore
          retention-days: 7

  node-unit:
    name: Node (lint, unit, build)
    needs: policy
    if: needs.policy.result == 'success' && needs.policy.outputs.code_changed == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - uses: actions/checkout@v4

      - name: Setup Rust (for Node black-box tests that spawn Rust binaries)
        id: setup-rust
        uses: ./.github/actions/setup-rust
        with:
          toolchain: stable
          locked: always

      - name: Setup Node workspace
        id: node-workspace
        uses: ./.github/actions/setup-node-workspace
        env:
          PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: "1"

      # Authoritative golden determinism check for PR gating:
      # `tests/golden/` must always match the output of `npm run generate:goldens`.
      # (Historically this lived in `.github/workflows/gpu_golden.yml`, but that workflow
      # is not always required for merges; `ci.yml` is.)
      - name: Check golden images are up-to-date (determinism)
        working-directory: ${{ steps.node-workspace.outputs.dir }}
        run: npm run check:goldens

      - name: Lint (if present)
        working-directory: ${{ steps.node-workspace.outputs.dir }}
        run: npm run lint --if-present

      - name: Protocol tests (AeroGPU TypeScript ABI)
        working-directory: ${{ steps.node-workspace.outputs.dir }}
        run: npm run test:protocol

      - name: Unit tests
        working-directory: ${{ steps.node-workspace.outputs.dir }}
        run: npm run test:unit

      - name: Publish Node unit test report
        if: always()
        uses: dorny/test-reporter@v1
        with:
          name: Node unit tests
          path: ${{ steps.node-workspace.outputs.dir }}/test-results/node-junit.xml
          reporter: java-junit
          fail-on-error: false

      - name: Publish Vitest report
        if: always()
        uses: dorny/test-reporter@v1
        with:
          name: Vitest
          path: ${{ steps.node-workspace.outputs.dir }}/test-results/vitest-junit.xml
          reporter: java-junit
          fail-on-error: false

      - name: Upload unit test artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: unit-test-results
          path: |
            ${{ steps.node-workspace.outputs.dir }}/test-results/node-junit.xml
            ${{ steps.node-workspace.outputs.dir }}/test-results/vitest-junit.xml
          if-no-files-found: warn
          retention-days: 7

      - name: Node unit job summary
        if: always()
        shell: bash
        run: |
          {
            echo "### Unit test reports"
            echo ""
            echo "- Node JUnit: \`${{ steps.node-workspace.outputs.dir }}/test-results/node-junit.xml\`"
            echo "- Vitest JUnit: \`${{ steps.node-workspace.outputs.dir }}/test-results/vitest-junit.xml\`"
            echo "- Artifact: \`unit-test-results\`"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Production build
        working-directory: ${{ steps.node-workspace.outputs.dir }}
        run: npm run build

  node-contracts-windows:
    name: Node contracts (Windows)
    needs: policy
    if: needs.policy.result == 'success' && needs.policy.outputs.code_changed == 'true'
    runs-on: windows-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node workspace
        id: node-workspace
        uses: ./.github/actions/setup-node-workspace
        env:
          PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: "1"

      - name: Contract tests
        working-directory: ${{ steps.node-workspace.outputs.dir }}
        run: npm run test:contracts

  smoke-matrix:
    name: Smoke matrix (${{ matrix.os }})
    needs: policy
    if: needs.policy.result == 'success' && needs.policy.outputs.code_changed == 'true'
    runs-on: ${{ matrix.os }}
    timeout-minutes: 20
    strategy:
      fail-fast: false
      matrix:
        os:
          - ubuntu-latest
          - windows-latest
          - macos-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Rust
        id: setup-rust
        uses: ./.github/actions/setup-rust
        with:
          toolchain: stable
          locked: always

      - name: cargo build
        run: cargo build ${{ steps.setup-rust.outputs.cargo_locked_flag }} --workspace

      - name: Build offline cert injector (Windows)
        if: matrix.os == 'windows-latest'
        run: cargo build ${{ steps.setup-rust.outputs.cargo_locked_flag }} --manifest-path tools/win-offline-cert-injector/Cargo.toml

      - name: Test offline cert injector (Windows)
        if: matrix.os == 'windows-latest'
        run: cargo test ${{ steps.setup-rust.outputs.cargo_locked_flag }} --manifest-path tools/win-offline-cert-injector/Cargo.toml

      - name: Setup Node workspace
        id: node-workspace
        uses: ./.github/actions/setup-node-workspace
        env:
          PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: "1"

      - name: Typecheck (if present)
        working-directory: ${{ steps.node-workspace.outputs.dir }}
        run: npm run typecheck --if-present

      - name: Unit tests
        working-directory: ${{ steps.node-workspace.outputs.dir }}
        run: npm run test:unit --if-present

      - name: Production build
        working-directory: ${{ steps.node-workspace.outputs.dir }}
        run: npm run build

      - name: Job summary
        if: always()
        shell: bash
        run: |
          {
            echo "### Smoke matrix (${{ matrix.os }})"
            echo ""
            echo "- Node dir: \\`${{ steps.node-workspace.outputs.dir }}\\`"
            echo "- Lockfile: \\`${{ steps.node-workspace.outputs.lockfile }}\\`"
          } >> "$GITHUB_STEP_SUMMARY"

  playwright:
    name: Playwright (browser automation)
    needs: policy
    if: needs.policy.result == 'success' && needs.policy.outputs.code_changed == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 30
    env:
      PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: "1"
    steps:
      - uses: actions/checkout@v4

      - name: Setup Rust
        id: setup-rust
        uses: ./.github/actions/setup-rust
        with:
          toolchain: stable
          targets: wasm32-unknown-unknown
          locked: always

      - name: Install wasm-pack
        uses: jetli/wasm-pack-action@v0.4.0

      - name: Setup Node workspace
        id: node-workspace
        uses: ./.github/actions/setup-node-workspace
        env:
          PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: "1"

      - name: Setup Rust (pinned nightly for threaded WASM)
        uses: ./.github/actions/setup-rust
        with:
          toolchain: nightly
          targets: wasm32-unknown-unknown
          components: rust-src
          locked: always

      - name: Threaded WASM build (release, required for SharedArrayBuffer tests)
        working-directory: ${{ steps.node-workspace.outputs.dir }}
        run: npm -w web run wasm:build:threaded

      - name: Prepare test-results directory
        working-directory: ${{ steps.node-workspace.outputs.dir }}
        run: mkdir -p test-results

      - name: Setup Playwright (cached)
        uses: ./.github/actions/setup-playwright
        with:
          browsers: chromium
          working-directory: ${{ steps.node-workspace.outputs.dir }}
          lockfile: ${{ steps.node-workspace.outputs.lockfile }}

      - name: Playwright tests (non-WebGPU)
        env:
          AERO_NODE_DIR: ${{ steps.node-workspace.outputs.dir }}
          # Ensure we keep running CI on the pinned stable toolchain (the nightly toolchain is installed
          # above only to build the threaded WASM bundle).
          RUSTUP_TOOLCHAIN: ${{ steps.setup-rust.outputs.rust_toolchain }}
        run: cargo xtask test-all --skip-rust --skip-wasm --skip-ts --pw-project chromium

      - name: Publish E2E test report
        if: always()
        uses: dorny/test-reporter@v1
        with:
          name: Playwright
          path: ${{ steps.node-workspace.outputs.dir }}/test-results/junit.xml
          reporter: java-junit
          fail-on-error: false

      - name: Upload Playwright report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-report
          path: |
            ${{ steps.node-workspace.outputs.dir }}/playwright-report/
            ${{ steps.node-workspace.outputs.dir }}/test-results/
          if-no-files-found: warn
          retention-days: 7

      - name: Playwright job summary
        if: always()
        shell: bash
        run: |
          {
            echo "### Playwright reports"
            echo ""
            echo "- JUnit: \`${{ steps.node-workspace.outputs.dir }}/test-results/junit.xml\`"
            echo "- HTML report artifact: \`playwright-report\`"
          } >> "$GITHUB_STEP_SUMMARY"

  disk-streaming-browser-e2e:
    name: Disk streaming browser E2E (COOP/COEP + Range)
    needs: policy
    if: needs.policy.result == 'success' && needs.policy.outputs.code_changed == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 30
    env:
      PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: "1"
    steps:
      - uses: actions/checkout@v4

      - name: Setup Rust
        uses: ./.github/actions/setup-rust
        with:
          toolchain: stable
          locked: always

      - name: Setup Node workspace
        id: node-workspace
        uses: ./.github/actions/setup-node-workspace

      - name: Setup Playwright (cached)
        uses: ./.github/actions/setup-playwright
        with:
          browsers: chromium
          working-directory: tools/disk-streaming-browser-e2e
          lockfile: ${{ steps.node-workspace.outputs.lockfile }}

      - name: Run disk streaming browser E2E tests
        run: npm -w tools/disk-streaming-browser-e2e test

      - name: Upload Playwright report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: disk-streaming-browser-e2e-report
          path: |
            tools/disk-streaming-browser-e2e/playwright-report/
            tools/disk-streaming-browser-e2e/test-results/
          if-no-files-found: warn
          retention-days: 7

  ci-gate:
    name: CI gate
    needs:
      - policy
      - toolchains
      - wasm-threaded
      - rust
      - acpi-iasl
      - win7-virtio-portable-tests
      - aerogpu-d3d9-portable-tests
      - qemu-boot
      - wasm
      - node-unit
      - node-contracts-windows
      - smoke-matrix
      - playwright
      - disk-streaming-browser-e2e
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Evaluate CI results
        shell: bash
        run: |
          set -euo pipefail

          echo "policy: ${{ needs.policy.result }}"
          echo "code_changed: ${{ needs.policy.outputs.code_changed }}"
          echo "docs_only: ${{ needs.policy.outputs.docs_only }}"

          if [[ "${{ needs.policy.result }}" != "success" ]]; then
            echo "::error::policy job failed"
            exit 1
          fi

          if [[ "${{ needs.policy.outputs.code_changed }}" != "true" ]]; then
            echo "Docs-only change; skipping expensive build/test jobs."
            exit 0
          fi

          failures=0

          if [[ "${{ needs.toolchains.result }}" != "success" ]]; then
            echo "::error::toolchains job result: ${{ needs.toolchains.result }}"
            failures=1
          fi

          if [[ "${{ needs['wasm-threaded'].result }}" != "success" ]]; then
            echo "::error::wasm-threaded job result: ${{ needs['wasm-threaded'].result }}"
            failures=1
          fi

          if [[ "${{ needs.rust.result }}" != "success" ]]; then
            echo "::error::rust job result: ${{ needs.rust.result }}"
            failures=1
          fi

          if [[ "${{ needs['acpi-iasl'].result }}" != "success" ]]; then
            echo "::error::acpi-iasl job result: ${{ needs['acpi-iasl'].result }}"
            failures=1
          fi

           if [[ "${{ needs['win7-virtio-portable-tests'].result }}" != "success" ]]; then
             echo "::error::win7-virtio-portable-tests job result: ${{ needs['win7-virtio-portable-tests'].result }}"
             failures=1
           fi

           if [[ "${{ needs['aerogpu-d3d9-portable-tests'].result }}" != "success" ]]; then
             echo "::error::aerogpu-d3d9-portable-tests job result: ${{ needs['aerogpu-d3d9-portable-tests'].result }}"
             failures=1
           fi

           if [[ "${{ needs['qemu-boot'].result }}" != "success" ]]; then
             echo "::error::qemu-boot job result: ${{ needs['qemu-boot'].result }}"
             failures=1
           fi

          if [[ "${{ needs.wasm.result }}" != "success" ]]; then
            echo "::error::wasm job result: ${{ needs.wasm.result }}"
            failures=1
          fi

          if [[ "${{ needs['node-unit'].result }}" != "success" ]]; then
            echo "::error::node-unit job result: ${{ needs['node-unit'].result }}"
            failures=1
          fi

          if [[ "${{ needs['node-contracts-windows'].result }}" != "success" ]]; then
            echo "::error::node-contracts-windows job result: ${{ needs['node-contracts-windows'].result }}"
            failures=1
          fi

          if [[ "${{ needs['smoke-matrix'].result }}" != "success" ]]; then
            echo "::error::smoke-matrix job result: ${{ needs['smoke-matrix'].result }}"
            failures=1
          fi

          if [[ "${{ needs.playwright.result }}" != "success" ]]; then
            echo "::error::playwright job result: ${{ needs.playwright.result }}"
            failures=1
          fi

          if [[ "${{ needs['disk-streaming-browser-e2e'].result }}" != "success" ]]; then
            echo "::error::disk-streaming-browser-e2e job result: ${{ needs['disk-streaming-browser-e2e'].result }}"
            failures=1
          fi

          exit "$failures"
