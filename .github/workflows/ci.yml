name: CI

on:
  pull_request:
  push:
    branches:
      - main
  workflow_dispatch:
  merge_group:

concurrency:
  group: ci-${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  checks: write

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: "1"
  # PR CI should never require WebGPU.
  AERO_REQUIRE_WEBGPU: "0"
  AERO_NODE_DIR: ${{ vars.AERO_NODE_DIR }}
  AERO_WASM_CRATE_DIR: ${{ vars.AERO_WASM_CRATE_DIR }}

jobs:
  policy:
    name: Repo policy (fixtures & binaries)
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      code_changed: ${{ steps.changes.outputs.code_changed }}
      docs_only: ${{ steps.changes.outputs.docs_only }}
    env:
      BASE_REF: ${{ github.event_name == 'pull_request' && github.event.pull_request.base.sha || github.event_name == 'merge_group' && github.event.merge_group.base_sha || github.event.before }}
      HEAD_REF: ${{ github.event_name == 'merge_group' && github.event.merge_group.head_sha || github.sha }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect docs-only changes
        id: changes
        shell: bash
        run: |
          set -euo pipefail

          base="$BASE_REF"
          head="$HEAD_REF"

          # `github.event.before` can be all zeros in some edge cases (e.g. branch creation).
          # Fall back to full CI rather than skipping checks.
          if [[ -z "${base:-}" || "$base" == "0000000000000000000000000000000000000000" ]]; then
            echo "code_changed=true" >> "$GITHUB_OUTPUT"
            echo "docs_only=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          files="$(git diff --name-only "$base" "$head")"
          echo "Changed files:";
          echo "$files"

          code_changed=false
          while IFS= read -r file; do
            [[ -z "$file" ]] && continue
            if [[ "$file" != docs/* && "$file" != *.md ]]; then
              code_changed=true
              break
            fi
          done <<< "$files"

          echo "code_changed=$code_changed" >> "$GITHUB_OUTPUT"
          if [[ "$code_changed" == "true" ]]; then
            echo "docs_only=false" >> "$GITHUB_OUTPUT"
          else
            echo "docs_only=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Change filter summary
        if: always()
        shell: bash
        run: |
          {
            echo "### CI change filter"
            echo ""
            echo "- Docs-only: \`${{ steps.changes.outputs.docs_only }}\`"
            echo "- Code changed: \`${{ steps.changes.outputs.code_changed }}\`"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Check repository policy
        run: scripts/ci/check-repo-policy.sh

  rust:
    name: Rust (fmt, clippy, test)
    needs: policy
    if: needs.policy.result == 'success' && needs.policy.outputs.code_changed == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt, clippy
          targets: wasm32-unknown-unknown

      - name: Rust cache
        uses: Swatinem/rust-cache@v2

      - name: Use --locked when Cargo.lock exists
        id: cargo-locked
        run: |
          set -euo pipefail
          if [[ -f Cargo.lock ]]; then
            echo "locked=--locked" >> "$GITHUB_OUTPUT"
          else
            echo "locked=" >> "$GITHUB_OUTPUT"
          fi

      - name: Prepare net traces dir
        run: mkdir -p target/net-traces

      - name: Run Rust checks via test-all runner
        run: ./scripts/test-all.sh --skip-wasm --skip-ts --skip-e2e

      - name: Test guest tools packager
        run: cargo test --manifest-path tools/packaging/aero_packager/Cargo.toml --locked

      - name: cargo test (disk-gateway reference server)
        run: cargo test --manifest-path server/disk-gateway/Cargo.toml --locked

      - name: Upload net traces
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: net-traces
          path: target/net-traces
          if-no-files-found: ignore
          retention-days: 7

      - name: cargo test (aero-storage-server)
        run: cargo test ${{ steps.cargo-locked.outputs.locked }} -p aero-storage-server --all-features

      - name: Upload network captures (pcapng)
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: net-captures
          path: target/nt-test-artifacts/**/*.pcapng
          if-no-files-found: ignore
          retention-days: 7

  acpi-iasl:
    name: ACPI (iasl)
    needs: policy
    if: needs.policy.result == 'success' && needs.policy.outputs.code_changed == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@v4

      - name: Install ACPICA tools (iasl)
        run: |
          sudo apt-get update
          sudo apt-get install -y acpica-tools

      - name: Validate ACPI tables (decompile + compile)
        run: bash scripts/validate-acpi.sh

  win7-virtio-portable-tests:
    name: Win7 virtio (portable tests)
    needs: policy
    if: needs.policy.result == 'success' && needs.policy.outputs.code_changed == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@v4
      - name: Build + run virtio-pci cap parser tests
        run: |
          set -euo pipefail
          ./drivers/win7/virtio/tests/build_and_run.sh
          if command -v clang >/dev/null 2>&1; then
            CC=clang ./drivers/win7/virtio/tests/build_and_run.sh
          fi
  qemu-boot:
    name: QEMU boot tests (boot sector + FreeDOS)
    needs: policy
    if: needs.policy.result == 'success' && needs.policy.outputs.code_changed == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 20
    env:
      AERO_REQUIRE_TEST_IMAGES: "1"
    steps:
      - uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Rust cache
        uses: Swatinem/rust-cache@v2

      - name: Use --locked when Cargo.lock exists
        id: cargo-locked
        run: |
          set -euo pipefail
          if [[ -f Cargo.lock ]]; then
            echo "locked=--locked" >> "$GITHUB_OUTPUT"
          else
            echo "locked=" >> "$GITHUB_OUTPUT"
          fi

      - name: Install QEMU + tooling
        run: |
          sudo apt-get update
          sudo apt-get install -y qemu-system-x86 mtools nasm unzip

      - name: Prepare open-source test images
        run: bash scripts/prepare-freedos.sh

      - name: Verify boot sector binary is up-to-date
        run: |
          bash scripts/build-bootsector.sh
          bash scripts/build-int-sanity-bootsector.sh
          git diff --exit-code

      - name: Run QEMU boot tests
        run: cargo test ${{ steps.cargo-locked.outputs.locked }} -p emulator --test boot_sector --test freedos_boot

  wasm:
    name: WASM (wasm-pack build + test)
    needs: policy
    if: needs.policy.result == 'success' && needs.policy.outputs.code_changed == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: wasm32-unknown-unknown

      - name: Rust cache
        uses: Swatinem/rust-cache@v2

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install wasm-pack
        uses: jetli/wasm-pack-action@v0.4.0

      - name: Determine wasm crate directory
        id: wasm-crate
        run: |
          set -euo pipefail

          if [[ -n "${AERO_WASM_CRATE_DIR:-}" ]]; then
            dir="$AERO_WASM_CRATE_DIR"
          elif [[ -f crates/aero-wasm/Cargo.toml ]]; then
            dir="crates/aero-wasm"
          else
            if [[ ! -f Cargo.toml ]]; then
              echo "Cargo.toml not found at repo root; set AERO_WASM_CRATE_DIR to the crate directory containing Cargo.toml." >&2
              exit 1
            fi

            manifest_path="$(
              python3 - <<'PY'
          import json
          import subprocess
          import sys

          meta = json.loads(
              subprocess.check_output(["cargo", "metadata", "--no-deps", "--format-version=1"])
          )
          for pkg in meta.get("packages", []):
              for tgt in pkg.get("targets", []):
                  if "cdylib" in tgt.get("kind", []):
                      print(pkg.get("manifest_path", ""))
                      sys.exit(0)
          print("")
          PY
            )"
            if [[ -z "$manifest_path" || "$manifest_path" == "null" ]]; then
              echo "Unable to auto-detect a wasm-pack crate (cdylib). Set AERO_WASM_CRATE_DIR to the wasm crate directory." >&2
              exit 1
            fi
            dir="$(dirname "$manifest_path")"
          fi

          if [[ ! -f "$dir/Cargo.toml" ]]; then
            echo "WASM crate directory '$dir' does not contain Cargo.toml." >&2
            exit 1
          fi

          echo "dir=$dir" >> "$GITHUB_OUTPUT"

      - name: Use --locked when Cargo.lock exists
        id: cargo-locked
        run: |
          set -euo pipefail
          if [[ -f Cargo.lock ]]; then
            echo "locked=--locked" >> "$GITHUB_OUTPUT"
          else
            echo "locked=" >> "$GITHUB_OUTPUT"
          fi

      - name: wasm-pack build
        working-directory: ${{ steps.wasm-crate.outputs.dir }}
        run: wasm-pack build --release --target web -- ${{ steps.cargo-locked.outputs.locked }}

      - name: wasm-pack test (node)
        run: ./scripts/test-all.sh --skip-rust --skip-ts --skip-e2e --wasm-crate-dir "${{ steps.wasm-crate.outputs.dir }}"

      - name: Upload wasm-pack output (on failure)
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: wasm-pack-pkg
          path: ${{ steps.wasm-crate.outputs.dir }}/pkg/
          if-no-files-found: ignore
          retention-days: 7

  node-unit:
    name: Node (lint, unit, build)
    needs: policy
    if: needs.policy.result == 'success' && needs.policy.outputs.code_changed == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - uses: actions/checkout@v4

      - name: Determine Node workspace directory
        id: node-dir
        run: |
          set -euo pipefail

          if [[ -n "${AERO_NODE_DIR:-}" ]]; then
            dir="$AERO_NODE_DIR"
          elif [[ -f package.json ]]; then
            dir="."
          elif [[ -f frontend/package.json ]]; then
            dir="frontend"
          elif [[ -f web/package.json ]]; then
            dir="web"
          else
            echo "package.json not found. Set AERO_NODE_DIR to the directory containing package.json." >&2
            exit 1
          fi

          lockfile=""
          if [[ "$dir" == "." ]]; then
            if [[ -f package-lock.json ]]; then
              lockfile="package-lock.json"
            fi
          elif [[ -f "$dir/package-lock.json" ]]; then
            lockfile="$dir/package-lock.json"
          fi

          echo "dir=$dir" >> "$GITHUB_OUTPUT"
          echo "lockfile=$lockfile" >> "$GITHUB_OUTPUT"

      - name: Setup Node
        if: steps.node-dir.outputs.lockfile == ''
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Setup Node (npm cache)
        if: steps.node-dir.outputs.lockfile != ''
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
          cache-dependency-path: ${{ steps.node-dir.outputs.lockfile }}

      - name: Install dependencies (npm ci)
        if: steps.node-dir.outputs.lockfile != ''
        working-directory: ${{ steps.node-dir.outputs.dir }}
        run: npm ci
        env:
          PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: "1"

      - name: Install dependencies (npm install)
        if: steps.node-dir.outputs.lockfile == ''
        working-directory: ${{ steps.node-dir.outputs.dir }}
        run: npm install --no-audit --no-fund
        env:
          PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: "1"

      - name: Lint (if present)
        working-directory: ${{ steps.node-dir.outputs.dir }}
        run: npm run lint --if-present

      - name: Typecheck (if present)
        working-directory: ${{ steps.node-dir.outputs.dir }}
        run: npm run typecheck --if-present

      - name: Unit tests
        working-directory: ${{ steps.node-dir.outputs.dir }}
        run: npm run test:unit

      - name: Publish Node unit test report
        if: always()
        uses: dorny/test-reporter@v1
        with:
          name: Node unit tests
          path: ${{ steps.node-dir.outputs.dir }}/test-results/node-junit.xml
          reporter: java-junit
          fail-on-error: false

      - name: Publish Vitest report
        if: always()
        uses: dorny/test-reporter@v1
        with:
          name: Vitest
          path: ${{ steps.node-dir.outputs.dir }}/test-results/vitest-junit.xml
          reporter: java-junit
          fail-on-error: false

      - name: Upload unit test artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: unit-test-results
          path: |
            ${{ steps.node-dir.outputs.dir }}/test-results/node-junit.xml
            ${{ steps.node-dir.outputs.dir }}/test-results/vitest-junit.xml
          if-no-files-found: warn
          retention-days: 7

      - name: Production build
        working-directory: ${{ steps.node-dir.outputs.dir }}
        run: npm run build

  smoke-matrix:
    name: Smoke matrix (${{ matrix.os }})
    needs: policy
    if: needs.policy.result == 'success' && needs.policy.outputs.code_changed == 'true'
    runs-on: ${{ matrix.os }}
    timeout-minutes: 20
    strategy:
      fail-fast: false
      matrix:
        os:
          - ubuntu-latest
          - windows-latest
          - macos-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Rust cache
        uses: Swatinem/rust-cache@v2

      - name: cargo build
        run: cargo build --locked --workspace

      - name: Build offline cert injector (Windows)
        if: matrix.os == 'windows-latest'
        run: cargo build --manifest-path tools/win-offline-cert-injector/Cargo.toml --locked

      - name: Test offline cert injector (Windows)
        if: matrix.os == 'windows-latest'
        run: cargo test --manifest-path tools/win-offline-cert-injector/Cargo.toml --locked

      - name: Determine Node workspace directory
        id: node-dir
        shell: pwsh
        run: |
          $dir = $env:AERO_NODE_DIR

          if ([string]::IsNullOrWhiteSpace($dir)) {
            if (Test-Path "package.json") {
              $dir = "."
            } elseif (Test-Path "frontend/package.json") {
              $dir = "frontend"
            } elseif (Test-Path "web/package.json") {
              $dir = "web"
            } else {
              Write-Error "package.json not found. Set AERO_NODE_DIR to the directory containing package.json."
              exit 1
            }
          }

          # Normalise to forward slashes so downstream tools/actions behave the
          # same across OSes (esp. cache-dependency-path on Windows).
          $dir = $dir.Trim() -replace '\\', '/'
          if ($dir -ne "." -and $dir -ne "/" -and $dir -notmatch '^[A-Za-z]:/$') {
            $dir = $dir.TrimEnd('/')
          }

          # Cache/dependency install strategy:
          # - If a lockfile exists, use `npm ci` and enable npm caching.
          # - If there is no lockfile (e.g. new package / local experimentation),
          #   fall back to `npm install` (without npm caching).
          $lockfile = ""
          if ($dir -eq ".") {
            if (Test-Path -LiteralPath "package-lock.json") {
              $lockfile = "package-lock.json"
            }
          } else {
            $candidate = "$dir/package-lock.json"
            if (Test-Path -LiteralPath $candidate) {
              $lockfile = $candidate
            }
          }

          "dir=$dir" >> $env:GITHUB_OUTPUT
          "lockfile=$lockfile" >> $env:GITHUB_OUTPUT

      - name: Setup Node
        if: steps.node-dir.outputs.lockfile == ''
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Setup Node (npm cache)
        if: steps.node-dir.outputs.lockfile != ''
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
          cache-dependency-path: ${{ steps.node-dir.outputs.lockfile }}

      - name: Install dependencies (npm ci)
        if: steps.node-dir.outputs.lockfile != ''
        working-directory: ${{ steps.node-dir.outputs.dir }}
        run: npm ci
        env:
          PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: "1"

      - name: Install dependencies (npm install)
        if: steps.node-dir.outputs.lockfile == ''
        working-directory: ${{ steps.node-dir.outputs.dir }}
        run: npm install --no-audit --no-fund
        env:
          PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: "1"

      - name: Typecheck (if present)
        working-directory: ${{ steps.node-dir.outputs.dir }}
        run: npm run typecheck --if-present

      - name: Unit tests
        working-directory: ${{ steps.node-dir.outputs.dir }}
        run: npm run test:unit --if-present

      - name: Production build
        working-directory: ${{ steps.node-dir.outputs.dir }}
        run: npm run build

      - name: Job summary
        if: always()
        shell: bash
        run: |
          {
            echo "### Smoke matrix (${{ matrix.os }})"
            echo ""
            echo "- Node dir: \\`${{ steps.node-dir.outputs.dir }}\\`"
            echo "- Lockfile: \\`${{ steps.node-dir.outputs.lockfile }}\\`"
          } >> "$GITHUB_STEP_SUMMARY"

  playwright:
    name: Playwright (browser automation)
    needs: policy
    if: needs.policy.result == 'success' && needs.policy.outputs.code_changed == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v4

      - name: Determine Node workspace directory
        id: node-dir
        run: |
          set -euo pipefail

          if [[ -n "${AERO_NODE_DIR:-}" ]]; then
            dir="$AERO_NODE_DIR"
          elif [[ -f package.json ]]; then
            dir="."
          elif [[ -f frontend/package.json ]]; then
            dir="frontend"
          elif [[ -f web/package.json ]]; then
            dir="web"
          else
            echo "package.json not found. Set AERO_NODE_DIR to the directory containing package.json." >&2
            exit 1
          fi

          lockfile=""
          if [[ "$dir" == "." ]]; then
            if [[ -f package-lock.json ]]; then
              lockfile="package-lock.json"
            fi
          elif [[ -f "$dir/package-lock.json" ]]; then
            lockfile="$dir/package-lock.json"
          fi

          echo "dir=$dir" >> "$GITHUB_OUTPUT"
          echo "lockfile=$lockfile" >> "$GITHUB_OUTPUT"

      - name: Setup Node
        if: steps.node-dir.outputs.lockfile == ''
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Setup Node (npm cache)
        if: steps.node-dir.outputs.lockfile != ''
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
          cache-dependency-path: ${{ steps.node-dir.outputs.lockfile }}

      - name: Cache Playwright browsers
        uses: actions/cache@v4
        with:
          path: ~/.cache/ms-playwright
          key: ${{ runner.os }}-playwright-${{ hashFiles(steps.node-dir.outputs.lockfile || format('{0}/package.json', steps.node-dir.outputs.dir)) }}
          restore-keys: |
            ${{ runner.os }}-playwright-

      - name: Install dependencies (npm ci)
        if: steps.node-dir.outputs.lockfile != ''
        working-directory: ${{ steps.node-dir.outputs.dir }}
        run: npm ci
        env:
          PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: "1"

      - name: Install dependencies (npm install)
        if: steps.node-dir.outputs.lockfile == ''
        working-directory: ${{ steps.node-dir.outputs.dir }}
        run: npm install --no-audit --no-fund
        env:
          PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: "1"

      - name: Install Playwright browsers
        working-directory: ${{ steps.node-dir.outputs.dir }}
        run: npx playwright install --with-deps chromium

      - name: Playwright tests (non-WebGPU)
        env:
          AERO_NODE_DIR: ${{ steps.node-dir.outputs.dir }}
        run: ./scripts/test-all.sh --skip-rust --skip-wasm --skip-ts --pw-project chromium

      - name: Publish E2E test report
        if: always()
        uses: dorny/test-reporter@v1
        with:
          name: Playwright
          path: ${{ steps.node-dir.outputs.dir }}/test-results/junit.xml
          reporter: java-junit
          fail-on-error: false

      - name: Upload Playwright report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-report
          path: |
            ${{ steps.node-dir.outputs.dir }}/playwright-report/
            ${{ steps.node-dir.outputs.dir }}/test-results/
          if-no-files-found: warn
          retention-days: 7

  disk-streaming-browser-e2e:
    name: Disk streaming browser E2E (COOP/COEP + Range)
    needs: policy
    if: needs.policy.result == 'success' && needs.policy.outputs.code_changed == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Rust cache
        uses: Swatinem/rust-cache@v2

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
          cache-dependency-path: tools/disk-streaming-browser-e2e/package-lock.json

      - name: Cache Playwright browsers
        uses: actions/cache@v4
        with:
          path: ~/.cache/ms-playwright
          key: ${{ runner.os }}-playwright-disk-streaming-${{ hashFiles('tools/disk-streaming-browser-e2e/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-playwright-disk-streaming-

      - name: Install dependencies
        working-directory: tools/disk-streaming-browser-e2e
        run: npm ci
        env:
          PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: "1"

      - name: Install Playwright browser (with OS deps)
        working-directory: tools/disk-streaming-browser-e2e
        run: npx playwright install --with-deps chromium

      - name: Run disk streaming browser E2E tests
        working-directory: tools/disk-streaming-browser-e2e
        run: npm test

      - name: Upload Playwright report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: disk-streaming-browser-e2e-report
          path: |
            tools/disk-streaming-browser-e2e/playwright-report/
            tools/disk-streaming-browser-e2e/test-results/
          if-no-files-found: warn
          retention-days: 7

  ci-gate:
    name: CI gate
    needs:
      - policy
      - rust
      - acpi-iasl
      - win7-virtio-portable-tests
      - qemu-boot
      - wasm
      - node-unit
      - smoke-matrix
      - playwright
      - disk-streaming-browser-e2e
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Evaluate CI results
        shell: bash
        run: |
          set -euo pipefail

          echo "policy: ${{ needs.policy.result }}"
          echo "code_changed: ${{ needs.policy.outputs.code_changed }}"
          echo "docs_only: ${{ needs.policy.outputs.docs_only }}"

          if [[ "${{ needs.policy.result }}" != "success" ]]; then
            echo "::error::policy job failed"
            exit 1
          fi

          if [[ "${{ needs.policy.outputs.code_changed }}" != "true" ]]; then
            echo "Docs-only change; skipping expensive build/test jobs."
            exit 0
          fi

          failures=0

          if [[ "${{ needs.rust.result }}" != "success" ]]; then
            echo "::error::rust job result: ${{ needs.rust.result }}"
            failures=1
          fi

          if [[ "${{ needs['acpi-iasl'].result }}" != "success" ]]; then
            echo "::error::acpi-iasl job result: ${{ needs['acpi-iasl'].result }}"
            failures=1
          fi

          if [[ "${{ needs['win7-virtio-portable-tests'].result }}" != "success" ]]; then
            echo "::error::win7-virtio-portable-tests job result: ${{ needs['win7-virtio-portable-tests'].result }}"
            failures=1
          fi

          if [[ "${{ needs['qemu-boot'].result }}" != "success" ]]; then
            echo "::error::qemu-boot job result: ${{ needs['qemu-boot'].result }}"
            failures=1
          fi

          if [[ "${{ needs.wasm.result }}" != "success" ]]; then
            echo "::error::wasm job result: ${{ needs.wasm.result }}"
            failures=1
          fi

          if [[ "${{ needs['node-unit'].result }}" != "success" ]]; then
            echo "::error::node-unit job result: ${{ needs['node-unit'].result }}"
            failures=1
          fi

          if [[ "${{ needs['smoke-matrix'].result }}" != "success" ]]; then
            echo "::error::smoke-matrix job result: ${{ needs['smoke-matrix'].result }}"
            failures=1
          fi

          if [[ "${{ needs.playwright.result }}" != "success" ]]; then
            echo "::error::playwright job result: ${{ needs.playwright.result }}"
            failures=1
          fi

          if [[ "${{ needs['disk-streaming-browser-e2e'].result }}" != "success" ]]; then
            echo "::error::disk-streaming-browser-e2e job result: ${{ needs['disk-streaming-browser-e2e'].result }}"
            failures=1
          fi

          exit "$failures"
