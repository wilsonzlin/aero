name: Win7 Drivers (build + catalog + test-sign)

on:
  pull_request:
    paths:
      - "drivers/**"
      - "ci/**"
      - "tools/packaging/**"
      - "guest-tools/**"
      - ".github/workflows/drivers-win7.yml"
    paths-ignore:
      - "docs/**"
      - "drivers/**/*.md"
      - "ci/**/*.md"
  push:
    branches:
      - main
    paths:
      - "drivers/**"
      - "ci/**"
      - "tools/packaging/**"
      - "guest-tools/**"
      - ".github/workflows/drivers-win7.yml"
    paths-ignore:
      - "docs/**"
      - "drivers/**/*.md"
      - "ci/**/*.md"
  workflow_dispatch:

jobs:
  virtio-host-tests-linux:
    name: Virtio host tests (Linux)
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Run virtio host tests (CMake)
        shell: bash
        run: |
          set -euo pipefail

          has_win7_virtio_common=false
          has_win7_virtio_modern_common=false
          has_portable_virtq_split=false

          if [[ -f "drivers/windows7/virtio/common/tests/CMakeLists.txt" ]]; then
            has_win7_virtio_common=true
          fi
          if [[ -f "drivers/windows7/virtio-modern/common/tests/CMakeLists.txt" ]]; then
            has_win7_virtio_modern_common=true
          fi
          if [[ -f "drivers/windows/virtio/common/tests/CMakeLists.txt" ]]; then
            has_portable_virtq_split=true
          fi

          if [[ "$has_win7_virtio_common" != "true" && "$has_win7_virtio_modern_common" != "true" && "$has_portable_virtq_split" != "true" ]]; then
            echo "No virtio host tests found; skipping."
            exit 0
          fi

          cmake -S . -B build-virtio-host-tests-linux -DAERO_VIRTIO_BUILD_TESTS=ON
          cmake --build build-virtio-host-tests-linux
          ctest --test-dir build-virtio-host-tests-linux --output-on-failure

  drivers-win7:
    runs-on: windows-latest
    outputs:
      skip: ${{ steps.detect.outputs.skip }}
      has_sys: ${{ steps.built.outputs.has_sys }}
    env:
      # Cache only the installer/downloads (not the installed WDK toolchain).
      WDK_DOWNLOAD_CACHE: C:\wdk-download-cache
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          # Version stamping derives from git tags/commits; fetch full history + tags so
          # `git describe` and commit-distance calculations are accurate.
          fetch-depth: 0
          fetch-tags: true

      - name: Run virtio host tests (CMake)
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          $hasWin7VirtioCommon = Test-Path -LiteralPath 'drivers/windows7/virtio/common/tests/CMakeLists.txt'
          $hasWin7VirtioModernCommon = Test-Path -LiteralPath 'drivers/windows7/virtio-modern/common/tests/CMakeLists.txt'
          $hasPortableVirtqSplit = Test-Path -LiteralPath 'drivers/windows/virtio/common/tests/CMakeLists.txt'

          if (!$hasWin7VirtioCommon -and !$hasWin7VirtioModernCommon -and !$hasPortableVirtqSplit) {
            Write-Host "No virtio host tests found; skipping."
            exit 0
          }

          # Validate both architectures (x86 + x64) without requiring any VM.
          cmake -S . -B build-virtio-common-x64 -A x64 -DAERO_VIRTIO_BUILD_TESTS=ON
          cmake --build build-virtio-common-x64 --config Release
          ctest --test-dir build-virtio-common-x64 --output-on-failure -C Release

          cmake -S . -B build-virtio-common-x86 -A Win32 -DAERO_VIRTIO_BUILD_TESTS=ON
          cmake --build build-virtio-common-x86 --config Release
          ctest --test-dir build-virtio-common-x86 --output-on-failure -C Release

      - name: Detect driver projects
        id: detect
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          $driversDir = Join-Path $env:GITHUB_WORKSPACE 'drivers'
          if (!(Test-Path -LiteralPath $driversDir)) {
            Write-Host "No drivers/ directory found; skipping Win7 driver build."
            "skip=true" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            exit 0
          }

          $entries = Get-ChildItem -LiteralPath $driversDir -ErrorAction SilentlyContinue
          if (!$entries) {
            Write-Host "drivers/ exists but is empty; skipping Win7 driver build."
            "skip=true" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            exit 0
          }

          function Test-IsMakefileVcxproj {
            param([Parameter(Mandatory = $true)][string]$Path)
            $content = $null
            try {
              $content = Get-Content -LiteralPath $Path -Raw -ErrorAction Stop
            } catch {
              # If we cannot inspect the project, treat it as buildable so CI does not silently skip.
              return $false
            }
            if ([string]::IsNullOrWhiteSpace($content)) {
              # Malformed/empty project; treat as buildable so CI surfaces the error.
              return $false
            }
            return (
              $content -match '<Keyword>\s*MakeFileProj\s*</Keyword>' -or
              $content -match '<ConfigurationType>\s*Makefile\s*</ConfigurationType>'
            )
          }

          function Test-SlnHasBuildableProjects {
            param([Parameter(Mandatory = $true)][string]$SlnPath)

            $lines = $null
            try {
              $lines = Get-Content -LiteralPath $SlnPath -ErrorAction Stop
            } catch {
              # If we cannot read the solution, err on the side of running CI.
              return $true
            }
            if (-not $lines) { return $true }

            $slnDir = Split-Path -Path $SlnPath -Parent
            $projectPaths = New-Object System.Collections.Generic.List[string]

            foreach ($line in $lines) {
              # Example: Project("{GUID}") = "name", "path\\to\\proj.vcxproj", "{GUID}"
              if ($line -match '^Project\(".*?"\)\s*=\s*".*?",\s*"(.*?)",\s*".*?"\s*$') {
                $p = [string]$Matches[1]
                if (-not [string]::IsNullOrWhiteSpace($p)) {
                  [void]$projectPaths.Add($p)
                }
              }
            }

            if ($projectPaths.Count -eq 0) {
              # Unknown/empty solution; treat as buildable to avoid silent skips.
              return $true
            }

            foreach ($projRel in $projectPaths) {
              $ext = [IO.Path]::GetExtension($projRel)
              if ([string]::IsNullOrWhiteSpace($ext)) {
                # Likely a Solution Folder entry.
                continue
              }

              if ($ext -ieq '.vcxproj') {
                $full = [IO.Path]::GetFullPath((Join-Path $slnDir $projRel))
                if (!(Test-Path -LiteralPath $full -PathType Leaf)) {
                  # If the solution references a missing project, run CI so it fails loudly.
                  return $true
                }
                if (-not (Test-IsMakefileVcxproj -Path $full)) {
                  return $true
                }
                continue
              }

              # Any other MSBuild project type (.csproj, .vcproj, etc) should run in CI.
              return $true
            }

            # Every referenced project was a MakeFileProj wrapper (or solution folders only).
            return $false
          }

          function Try-GetDriverBuildTarget {
            param(
              [Parameter(Mandatory = $true)][System.IO.DirectoryInfo]$Directory,
              [Parameter(Mandatory = $true)][string]$DriversRootResolved
            )

            $name = $Directory.Name
            $sln = Join-Path $Directory.FullName ("{0}.sln" -f $name)
            if (Test-Path -LiteralPath $sln -PathType Leaf) {
              $kind = 'sln'
              $buildPath = (Resolve-Path -LiteralPath $sln).Path
            } else {
              $vcxprojs = @(Get-ChildItem -LiteralPath $Directory.FullName -File -Filter '*.vcxproj' -ErrorAction SilentlyContinue)
              if ($vcxprojs.Count -eq 0) { return $null }
              if ($vcxprojs.Count -eq 1) {
                $kind = 'vcxproj'
                $buildPath = (Resolve-Path -LiteralPath $vcxprojs[0].FullName).Path
              } else {
                # Mirrors ci/build-drivers.ps1 behaviour: without a matching <dir>.sln, the build
                # target is ambiguous. Treat this as "buildable" so CI runs and surfaces the issue.
                $kind = 'ambiguous'
                $buildPath = $Directory.FullName
              }
            }

            $sep = [IO.Path]::DirectorySeparatorChar
            $altSep = [IO.Path]::AltDirectorySeparatorChar
            $driversRootNormalized = $DriversRootResolved.TrimEnd($sep, $altSep)
            $dirResolved = (Resolve-Path -LiteralPath $Directory.FullName).Path.TrimEnd($sep, $altSep)
            $prefix = $driversRootNormalized + $sep
            if (-not $dirResolved.StartsWith($prefix, [StringComparison]::OrdinalIgnoreCase)) {
              return $null
            }

            $relativePath = $dirResolved.Substring($prefix.Length)
            $displayName = $relativePath.Replace($sep, '/')
            if ($altSep -ne $sep) {
              $displayName = $displayName.Replace($altSep, '/')
            }

            return [pscustomobject]@{
              Name = $displayName
              Kind = $kind
              BuildPath = $buildPath
            }
          }

          # Only run CI when we have *CI-buildable* driver targets as discovered by ci/build-drivers.ps1:
          #   - drivers/<name>/<name>.sln OR drivers/<name>/*.vcxproj
          #   - drivers/<group>/<name>/<name>.sln OR drivers/<group>/<name>/*.vcxproj
          #
          # We intentionally ignore classic WDK 7.1 NMake wrapper projects that invoke build.exe
          # (Keyword=MakeFileProj / ConfigurationType=Makefile), because this workflow provisions
          # a modern Windows Kits toolchain and does not guarantee a WDK 7.1 build environment.
          #
          # We do *not* require .inf files to be colocated with projects; packaging INFs may live
          # elsewhere under a driver root (e.g. drivers/aerogpu/packaging/win7/*.inf).

          $driversRootResolved = (Resolve-Path -LiteralPath $driversDir).Path
          $level1 = @(Get-ChildItem -LiteralPath $driversDir -Directory -ErrorAction SilentlyContinue | Sort-Object -Property Name)

          $targets = New-Object System.Collections.Generic.List[object]
          foreach ($dir1 in $level1) {
            $t1 = Try-GetDriverBuildTarget -Directory $dir1 -DriversRootResolved $driversRootResolved
            if ($null -ne $t1) {
              [void]$targets.Add($t1)
              continue
            }

            $level2 = @(Get-ChildItem -LiteralPath $dir1.FullName -Directory -ErrorAction SilentlyContinue | Sort-Object -Property Name)
            foreach ($dir2 in $level2) {
              $t2 = Try-GetDriverBuildTarget -Directory $dir2 -DriversRootResolved $driversRootResolved
              if ($null -ne $t2) {
                [void]$targets.Add($t2)
              }
            }
          }

          $buildable = New-Object System.Collections.Generic.List[object]
          foreach ($t in $targets) {
            if ($t.Kind -eq 'vcxproj') {
              if (-not (Test-IsMakefileVcxproj -Path $t.BuildPath)) {
                [void]$buildable.Add($t)
              }
              continue
            }

            if ($t.Kind -eq 'sln') {
              if (Test-SlnHasBuildableProjects -SlnPath $t.BuildPath) {
                [void]$buildable.Add($t)
              }
              continue
            }

            # "ambiguous" target (multiple vcxproj, no matching <dir>.sln): run CI to surface it.
            [void]$buildable.Add($t)
          }

          if ($buildable.Count -eq 0) {
            Write-Host "No CI-buildable Win7 driver targets were found (expected MSBuild-based solution/project under drivers/<name>/ or drivers/<group>/<name>/; ignoring WDK 7.1 NMake/build.exe wrappers). Skipping."
            "skip=true" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            exit 0
          }

          Write-Host "Found $($buildable.Count) CI-buildable driver target(s); running Win7 driver build:"
          foreach ($t in $buildable) {
            Write-Host ("- {0} ({1}): {2}" -f $t.Name, $t.Kind, $t.BuildPath)
          }
          "skip=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: Prepare WDK download cache directory
        if: steps.detect.outputs.skip != 'true'
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          New-Item -ItemType Directory -Force -Path $env:WDK_DOWNLOAD_CACHE | Out-Null

      - name: Cache WDK downloads
        if: steps.detect.outputs.skip != 'true'
        uses: actions/cache@v4
        with:
          path: ${{ env.WDK_DOWNLOAD_CACHE }}
          key: wdk-download-${{ runner.os }}-${{ hashFiles('ci/install-wdk.ps1', 'ci/lib/Toolchain.psm1') }}
          restore-keys: |
            wdk-download-${{ runner.os }}-

      - name: Provision toolchain (ci/install-wdk.ps1)
        if: steps.detect.outputs.skip != 'true'
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          if (!(Test-Path -LiteralPath 'ci\install-wdk.ps1')) {
            throw "Expected script ci\install-wdk.ps1 to exist."
          }
          pwsh -NoProfile -ExecutionPolicy Bypass -File 'ci\install-wdk.ps1'

      - name: Build drivers (ci/build-drivers.ps1)
        if: steps.detect.outputs.skip != 'true'
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          if (!(Test-Path -LiteralPath 'ci\build-drivers.ps1')) {
            throw "Expected script ci\build-drivers.ps1 to exist."
          }
          pwsh -NoProfile -ExecutionPolicy Bypass -File 'ci\build-drivers.ps1' -ToolchainJson 'out\toolchain.json'

      - name: Detect built driver binaries
        id: built
        if: steps.detect.outputs.skip != 'true'
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          $outDrivers = Join-Path $env:GITHUB_WORKSPACE 'out\drivers'
          if (!(Test-Path -LiteralPath $outDrivers)) {
            Write-Host "No out/drivers/ directory produced by build step; skipping catalog/sign/package."
            "has_sys=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            exit 0
          }

          $sys = Get-ChildItem -LiteralPath $outDrivers -Recurse -File -Filter '*.sys' -ErrorAction SilentlyContinue | Select-Object -First 1
          if (-not $sys) {
            Write-Host "No .sys files found under out/drivers/; skipping catalog/sign/package."
            "has_sys=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            exit 0
          }

          Write-Host "Found driver binary: $($sys.FullName)"
          "has_sys=true" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: Generate catalogs (ci/make-catalogs.ps1)
        if: steps.detect.outputs.skip != 'true' && steps.built.outputs.has_sys == 'true'
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          if (!(Test-Path -LiteralPath 'ci\make-catalogs.ps1')) {
            throw "Expected script ci\make-catalogs.ps1 to exist."
          }
          pwsh -NoProfile -ExecutionPolicy Bypass -File 'ci\make-catalogs.ps1' -ToolchainJson 'out\toolchain.json'

      - name: Test-sign drivers (ci/sign-drivers.ps1)
        if: steps.detect.outputs.skip != 'true' && steps.built.outputs.has_sys == 'true'
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          if (!(Test-Path -LiteralPath 'ci\sign-drivers.ps1')) {
            throw "Expected script ci\sign-drivers.ps1 to exist."
          }
          pwsh -NoProfile -ExecutionPolicy Bypass -File 'ci\sign-drivers.ps1' -ToolchainJson 'out\toolchain.json'

      - name: Upload signed packages (out/packages + aero-test.cer)
        if: steps.detect.outputs.skip != 'true' && steps.built.outputs.has_sys == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: win7-drivers-signed-packages
          path: |
            out/packages/**
            out/certs/aero-test.cer
          if-no-files-found: error

      - name: Package artifacts (ci/package-drivers.ps1)
        if: steps.detect.outputs.skip != 'true' && steps.built.outputs.has_sys == 'true'
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          if (!(Test-Path -LiteralPath 'ci\package-drivers.ps1')) {
            throw "Expected script ci\package-drivers.ps1 to exist."
          }
          pwsh -NoProfile -ExecutionPolicy Bypass -File 'ci\package-drivers.ps1' -MakeFatImage

      - name: Upload artifacts (out/artifacts/)
        if: steps.detect.outputs.skip != 'true' && steps.built.outputs.has_sys == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: win7-drivers
          path: out/artifacts/
          if-no-files-found: error

  guest-tools:
    name: Guest Tools (ISO + zip)
    runs-on: ubuntu-latest
    needs: drivers-win7
    if: needs.drivers-win7.outputs.skip != 'true' && needs.drivers-win7.outputs.has_sys == 'true'
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          # Version stamping derives from git tags/commits; fetch full history + tags so
          # `git describe` and commit-distance calculations are accurate.
          fetch-depth: 0
          fetch-tags: true

      - name: Setup Rust (for aero_packager)
        uses: ./.github/actions/setup-rust
        with:
          toolchain: stable
          cache: false
          locked: auto

      - name: Download signed packages
        uses: actions/download-artifact@v4
        with:
          name: win7-drivers-signed-packages
          path: .

      - name: Package Guest Tools (ci/package-guest-tools.ps1)
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          if (!(Test-Path -LiteralPath 'ci/package-guest-tools.ps1')) {
            throw "Expected script ci/package-guest-tools.ps1 to exist."
          }
          if (!(Test-Path -LiteralPath 'out/packages')) {
            throw "Expected signed driver packages at out/packages (download artifact step may have failed)."
          }
          if (!(Test-Path -LiteralPath 'out/certs/aero-test.cer')) {
            throw "Expected signing cert at out/certs/aero-test.cer (download artifact step may have failed)."
          }

          pwsh -NoProfile -ExecutionPolicy Bypass -File 'ci/package-guest-tools.ps1' `
            -InputRoot 'out/packages' `
            -CertPath 'out/certs/aero-test.cer' `
            -OutDir 'out/guest-tools'

      - name: Verify Guest Tools outputs
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          # ci/package-guest-tools.ps1 writes `aero-guest-tools.manifest.json`; provide
          # a `manifest.json` alias for downstream tooling that expects the raw packager name.
          Copy-Item -LiteralPath 'out/guest-tools/aero-guest-tools.manifest.json' -Destination 'out/guest-tools/manifest.json' -Force
          foreach ($path in @(
            'out/guest-tools/aero-guest-tools.iso',
            'out/guest-tools/aero-guest-tools.zip',
            'out/guest-tools/aero-guest-tools.manifest.json',
            'out/guest-tools/manifest.json'
          )) {
            if (!(Test-Path -LiteralPath $path)) {
              throw "Missing expected Guest Tools output: $path"
            }
          }

      - name: Upload Guest Tools artifacts
        uses: actions/upload-artifact@v4
        with:
          name: aero-guest-tools
          path: |
            out/guest-tools/aero-guest-tools.iso
            out/guest-tools/aero-guest-tools.zip
            out/guest-tools/aero-guest-tools.manifest.json
            out/guest-tools/manifest.json
          if-no-files-found: error
