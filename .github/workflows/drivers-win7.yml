name: Win7 Drivers (build + catalog + test-sign)

on:
  pull_request:
    paths:
      - "drivers/**"
      - "guest-tools/**"
      - "tools/packaging/**"
      - "ci/**"
      - "scripts/ci/check-windows7-virtio-contract-consistency.py"
      - "scripts/ci/check-win7-harness-constants.py"
      - "scripts/ci/check-virtio-snd-vcxproj-sources.py"
      - "scripts/ci/check-win7-virtio-snd-contiguous-free.py"
      - "scripts/ci/check-win7-virtqueue-split-headers.py"
      - "scripts/ci/check-virtqueue-split-driver-builds.py"
      - "scripts/ci/check-win7-virtio-header-collisions.py"
      - "scripts/ci/check-win7-contiguous-free-mismatch.py"
      - "scripts/ci/check-win7-virtio-input-hid-descriptor-sync.py"
      - "scripts/ci/check-win7-virtio-input-hidtest-readme-flags.py"
      - "scripts/ci/check-aerogpu-d3d9-def-stdcall.py"
      - "scripts/ci/check-aerogpu-d3d10-def-stdcall.py"
      - ".github/actions/setup-rust/**"
      - ".github/workflows/drivers-win7.yml"
      - "drivers/windows7/virtio-snd/aero_virtio_snd.vcxproj"
      - "drivers/windows7/virtio-snd/inf/aero_virtio_snd.inf"
      - "drivers/windows7/virtio-snd/inf/virtio-snd.inf.disabled"
    paths-ignore:
      - "docs/**"
      # Do not ignore Guest Tools markdown: `guest-tools/THIRD_PARTY_NOTICES.md`
      # is shipped inside the packaged ISO/zip and should rebuild artifacts.
      - "drivers/**/*.md"
      - "ci/**/*.md"
      - ".github/**/*.md"
  push:
    branches:
      - main
    paths:
      - "drivers/**"
      - "guest-tools/**"
      - "tools/packaging/**"
      - "ci/**"
      - "scripts/ci/check-windows7-virtio-contract-consistency.py"
      - "scripts/ci/check-win7-harness-constants.py"
      - "scripts/ci/check-virtio-snd-vcxproj-sources.py"
      - "scripts/ci/check-win7-virtio-snd-contiguous-free.py"
      - "scripts/ci/check-win7-virtqueue-split-headers.py"
      - "scripts/ci/check-virtqueue-split-driver-builds.py"
      - "scripts/ci/check-win7-virtio-header-collisions.py"
      - "scripts/ci/check-win7-contiguous-free-mismatch.py"
      - "scripts/ci/check-win7-virtio-input-hid-descriptor-sync.py"
      - "scripts/ci/check-win7-virtio-input-hidtest-readme-flags.py"
      - "scripts/ci/check-aerogpu-d3d9-def-stdcall.py"
      - "scripts/ci/check-aerogpu-d3d10-def-stdcall.py"
      - ".github/actions/setup-rust/**"
      - ".github/workflows/drivers-win7.yml"
      - "drivers/windows7/virtio-snd/aero_virtio_snd.vcxproj"
      - "drivers/windows7/virtio-snd/inf/aero_virtio_snd.inf"
      - "drivers/windows7/virtio-snd/inf/virtio-snd.inf.disabled"
    paths-ignore:
      - "docs/**"
      # Do not ignore Guest Tools markdown: `guest-tools/THIRD_PARTY_NOTICES.md`
      # is shipped inside the packaged ISO/zip and should rebuild artifacts.
      - "drivers/**/*.md"
      - "ci/**/*.md"
      - ".github/**/*.md"
  workflow_dispatch:

jobs:
  virtio-snd-vcxproj-guardrail:
    name: Guardrails (Win7 virtio build wiring + header collisions)
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Check Windows 7 virtio contract consistency (docs + INFs)
        run: python3 scripts/ci/check-windows7-virtio-contract-consistency.py

      - name: Lint Win7 virtio-snd INF (contract v1 invariants)
        shell: bash
        run: |
          set -euo pipefail
          cd drivers/windows7/virtio-snd
          ./scripts/lint-inf.sh

      - name: Check virtio-snd INF alias stays in sync (byte-for-byte)
        run: python3 drivers/windows7/virtio-snd/scripts/check-inf-alias.py

      - name: Check virtio-input INF alias stays in sync (byte-for-byte from [Version])
        run: python3 drivers/windows7/virtio-input/scripts/check-inf-alias.py

      - name: Unit tests (Win7 host harness wav verification)
        run: python3 -m unittest discover -s drivers/windows7/tests/host-harness/tests -p 'test_*.py'

      - name: Guardrail (Win7 guest selftest â†” host harness constants)
        run: python3 scripts/ci/check-win7-harness-constants.py

      - name: Check virtio-snd.vcxproj sources (modern vs legacy)
        shell: bash
        run: |
          set -euo pipefail
          python3 scripts/ci/check-virtio-snd-vcxproj-sources.py

      - name: Check Win7 virtio-snd contiguous alloc/free pairing
        run: python3 scripts/ci/check-win7-virtio-snd-contiguous-free.py

      - name: Check Win7 virtqueue_split header ambiguity
        shell: bash
        run: |
          set -euo pipefail
          python3 scripts/ci/check-win7-virtqueue-split-headers.py

      - name: Check virtqueue_split driver build files (blk/net/input/snd)
        shell: bash
        run: |
          set -euo pipefail
          python3 scripts/ci/check-virtqueue-split-driver-builds.py

      - name: Check Win7 virtio-input HID descriptor length sync
        run: python3 scripts/ci/check-win7-virtio-input-hid-descriptor-sync.py

      - name: Check Win7 virtio-input hidtest docs flags match implementation
        run: python3 scripts/ci/check-win7-virtio-input-hidtest-readme-flags.py

      - name: Check Win7 virtio header collisions
        shell: bash
        run: |
          set -euo pipefail
          python3 scripts/ci/check-win7-virtio-header-collisions.py

      - name: Check Win7 virtio-blk teardown helper is not duplicated
        run: python3 scripts/ci/check-win7-virtio-blk-no-duplicate-freeresources.py

      - name: Check Win7 contiguous alloc/free pairing (Mm*ContiguousMemorySpecifyCache)
        run: python3 scripts/ci/check-win7-contiguous-free-mismatch.py

  virtio-host-tests-linux:
    name: Virtio host tests (Linux, ${{ matrix.cc }})
    runs-on: ubuntu-latest
    needs: virtio-snd-vcxproj-guardrail
    strategy:
      fail-fast: false
      matrix:
        cc:
          - gcc
          - clang
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Check virtio driver uniqueness (INF HWIDs + MSBuild)
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          pwsh -NoProfile -ExecutionPolicy Bypass -File 'ci/check-virtio-driver-uniqueness.ps1'

      - name: Run virtio host tests (CMake)
        shell: bash
        env:
          CC: ${{ matrix.cc }}
        run: |
          set -euo pipefail

          has_win7_virtio_common=false
          has_win7_virtio_snd=false
          has_portable_virtq_split=false
          has_portable_virtio_pci_modern=false
          has_win7_virtio_cap_parser=false

          if [[ -f "drivers/windows7/virtio/common/tests/CMakeLists.txt" ]]; then
            has_win7_virtio_common=true
          fi
          if [[ -f "drivers/windows7/virtio-snd/tests/CMakeLists.txt" ]]; then
            has_win7_virtio_snd=true
          fi
          if [[ -f "drivers/windows/virtio/common/tests/CMakeLists.txt" ]]; then
            has_portable_virtq_split=true
          fi
          if [[ -f "drivers/windows/virtio/pci-modern/tests/CMakeLists.txt" ]]; then
            has_portable_virtio_pci_modern=true
          fi
          if [[ -f "drivers/win7/virtio/tests/CMakeLists.txt" ]]; then
            has_win7_virtio_cap_parser=true
          fi

          if [[ "$has_win7_virtio_common" != "true" && "$has_win7_virtio_snd" != "true" && "$has_portable_virtq_split" != "true" && "$has_portable_virtio_pci_modern" != "true" && "$has_win7_virtio_cap_parser" != "true" ]]; then
            echo "No virtio host tests found; skipping."
            exit 0
          fi

          # Use Release to keep runtimes low and to exercise optimized builds.
          # Disable unrelated driver test suites to keep this job focused and fast.
          cmake -S . -B build-virtio-host-tests-linux -DAERO_VIRTIO_BUILD_TESTS=ON -DAERO_AEROGPU_BUILD_TESTS=OFF -DCMAKE_BUILD_TYPE=Release
          cmake --build build-virtio-host-tests-linux
          ctest --test-dir build-virtio-host-tests-linux --output-on-failure

  aerogpu-host-tests-linux:
    name: AeroGPU host tests (Linux)
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Run AeroGPU host tests (CMake)
        shell: bash
        run: |
          set -euo pipefail

          # Use Release to keep runtimes low and to exercise optimized builds.
          # Disable unrelated driver test suites to keep this job focused and fast.
          cmake -S . -B build-aerogpu-host-tests-linux -DAERO_AEROGPU_BUILD_TESTS=ON -DAERO_VIRTIO_BUILD_TESTS=OFF -DCMAKE_BUILD_TYPE=Release
          cmake --build build-aerogpu-host-tests-linux
          ctest --test-dir build-aerogpu-host-tests-linux --output-on-failure --no-tests=error

  aerogpu-host-tests-windows:
    name: AeroGPU host tests (Windows, x86 + x64)
    runs-on: windows-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Run AeroGPU host tests (CMake)
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          # Validate both architectures (x86 + x64) to catch pointer-size/layout differences.
          cmake -S . -B build-aerogpu-host-tests-x64 -A x64 -DAERO_AEROGPU_BUILD_TESTS=ON -DAERO_VIRTIO_BUILD_TESTS=OFF
          cmake --build build-aerogpu-host-tests-x64 --config Release
          ctest --test-dir build-aerogpu-host-tests-x64 --output-on-failure --no-tests=error -C Release

          cmake -S . -B build-aerogpu-host-tests-x86 -A Win32 -DAERO_AEROGPU_BUILD_TESTS=ON -DAERO_VIRTIO_BUILD_TESTS=OFF
          cmake --build build-aerogpu-host-tests-x86 --config Release
          ctest --test-dir build-aerogpu-host-tests-x86 --output-on-failure --no-tests=error -C Release

  drivers-win7:
    runs-on: windows-latest
    needs: virtio-snd-vcxproj-guardrail
    outputs:
      skip: ${{ steps.detect.outputs.skip }}
      has_sys: ${{ steps.built.outputs.has_sys }}
    env:
      # Cache only the installer/downloads (not the installed WDK toolchain).
      WDK_DOWNLOAD_CACHE: C:\wdk-download-cache
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          # Version stamping derives from git tags/commits; fetch full history + tags so
          # `git describe` and commit-distance calculations are accurate.
          fetch-depth: 0
          fetch-tags: true

      - name: Check virtio driver uniqueness (INF HWIDs + MSBuild)
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          pwsh -NoProfile -ExecutionPolicy Bypass -File 'ci/check-virtio-driver-uniqueness.ps1'

      - name: Run virtio host tests (CMake)
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          $hasWin7VirtioCommon = Test-Path -LiteralPath 'drivers/windows7/virtio/common/tests/CMakeLists.txt'
          $hasWin7VirtioSnd = Test-Path -LiteralPath 'drivers/windows7/virtio-snd/tests/CMakeLists.txt'
          $hasPortableVirtqSplit = Test-Path -LiteralPath 'drivers/windows/virtio/common/tests/CMakeLists.txt'
          $hasPortableVirtioPciModern = Test-Path -LiteralPath 'drivers/windows/virtio/pci-modern/tests/CMakeLists.txt'
          $hasWin7VirtioCapParser = Test-Path -LiteralPath 'drivers/win7/virtio/tests/CMakeLists.txt'

          if (!$hasWin7VirtioCommon -and !$hasWin7VirtioSnd -and !$hasPortableVirtqSplit -and !$hasPortableVirtioPciModern -and !$hasWin7VirtioCapParser) {
            Write-Host "No virtio host tests found; skipping."
            exit 0
          }

          # Validate both architectures (x86 + x64) without requiring any VM.
          cmake -S . -B build-virtio-common-x64 -A x64 -DAERO_VIRTIO_BUILD_TESTS=ON -DAERO_AEROGPU_BUILD_TESTS=OFF
          cmake --build build-virtio-common-x64 --config Release
          ctest --test-dir build-virtio-common-x64 --output-on-failure -C Release

          cmake -S . -B build-virtio-common-x86 -A Win32 -DAERO_VIRTIO_BUILD_TESTS=ON -DAERO_AEROGPU_BUILD_TESTS=OFF
          cmake --build build-virtio-common-x86 --config Release
          ctest --test-dir build-virtio-common-x86 --output-on-failure -C Release

      - name: Detect driver projects
        id: detect
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          $driversDir = Join-Path $env:GITHUB_WORKSPACE 'drivers'
          if (!(Test-Path -LiteralPath $driversDir)) {
            Write-Host "No drivers/ directory found; skipping Win7 driver build."
            "skip=true" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            exit 0
          }

          $entries = Get-ChildItem -LiteralPath $driversDir -ErrorAction SilentlyContinue
          if (!$entries) {
            Write-Host "drivers/ exists but is empty; skipping Win7 driver build."
            "skip=true" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            exit 0
          }

          function Test-HasInfInTree {
            param([Parameter(Mandatory = $true)][string]$RootDir)

            if (!(Test-Path -LiteralPath $RootDir -PathType Container)) {
              return $false
            }

            # Mirror ci/build-drivers.ps1 INF discovery: require at least one INF under the
            # driver root, excluding common build output directories.
            $exclude = @{
              'obj' = $true
              'out' = $true
              'build' = $true
              'target' = $true
            }

            $stack = New-Object System.Collections.Generic.Stack[string]
            $stack.Push((Resolve-Path -LiteralPath $RootDir).Path)
            while ($stack.Count -gt 0) {
              $current = $stack.Pop()
              try {
                $inf = Get-ChildItem -LiteralPath $current -File -Filter '*.inf' -ErrorAction Stop | Select-Object -First 1
                if ($inf) { return $true }

                $dirs = Get-ChildItem -LiteralPath $current -Directory -ErrorAction Stop
                foreach ($dir in $dirs) {
                  $name = $dir.Name.ToLowerInvariant()
                  if ($exclude.ContainsKey($name)) { continue }
                  $stack.Push($dir.FullName)
                }
              } catch {
                # If we can't inspect the directory tree, err on the side of running CI so we
                # don't silently skip a buildable driver.
                return $true
              }
            }

            return $false
          }

          function Test-IsMakefileVcxproj {
            param([Parameter(Mandatory = $true)][string]$Path)
            $content = $null
            try {
              $content = Get-Content -LiteralPath $Path -Raw -ErrorAction Stop
            } catch {
              # If we cannot inspect the project, treat it as buildable so CI does not silently skip.
              return $false
            }
            if ([string]::IsNullOrWhiteSpace($content)) {
              # Malformed/empty project; treat as buildable so CI surfaces the error.
              return $false
            }
            return (
              $content -match '<Keyword>\s*MakeFileProj\s*</Keyword>' -or
              $content -match '<ConfigurationType>\s*Makefile\s*</ConfigurationType>'
            )
          }

          function Test-SlnHasBuildableProjects {
            param([Parameter(Mandatory = $true)][string]$SlnPath)

            $lines = $null
            try {
              $lines = Get-Content -LiteralPath $SlnPath -ErrorAction Stop
            } catch {
              # If we cannot read the solution, err on the side of running CI.
              return $true
            }
            if (-not $lines) { return $true }

            $slnDir = Split-Path -Path $SlnPath -Parent
            $projectPaths = New-Object System.Collections.Generic.List[string]

            foreach ($line in $lines) {
              # Example: Project("{GUID}") = "name", "path\\to\\proj.vcxproj", "{GUID}"
              if ($line -match '^Project\(".*?"\)\s*=\s*".*?",\s*"(.*?)",\s*".*?"\s*$') {
                $p = [string]$Matches[1]
                if (-not [string]::IsNullOrWhiteSpace($p)) {
                  [void]$projectPaths.Add($p)
                }
              }
            }

            if ($projectPaths.Count -eq 0) {
              # Unknown/empty solution; treat as buildable to avoid silent skips.
              return $true
            }

            foreach ($projRel in $projectPaths) {
              $ext = [IO.Path]::GetExtension($projRel)
              if ([string]::IsNullOrWhiteSpace($ext)) {
                # Likely a Solution Folder entry.
                continue
              }

              if ($ext -ieq '.vcxproj') {
                $full = [IO.Path]::GetFullPath((Join-Path $slnDir $projRel))
                if (!(Test-Path -LiteralPath $full -PathType Leaf)) {
                  # If the solution references a missing project, run CI so it fails loudly.
                  return $true
                }
                if (-not (Test-IsMakefileVcxproj -Path $full)) {
                  return $true
                }
                continue
              }

              # Any other MSBuild project type (.csproj, .vcproj, etc) should run in CI.
              return $true
            }

            # Every referenced project was a MakeFileProj wrapper (or solution folders only).
            return $false
          }

          function Try-GetDriverBuildTarget {
            param(
              [Parameter(Mandatory = $true)][System.IO.DirectoryInfo]$Directory,
              [Parameter(Mandatory = $true)][string]$DriversRootResolved
            )

            $manifestPath = Join-Path $Directory.FullName 'ci-package.json'
            if (!(Test-Path -LiteralPath $manifestPath -PathType Leaf)) {
              return $null
            }

            $name = $Directory.Name
            $sln = Join-Path $Directory.FullName ("{0}.sln" -f $name)
            if (Test-Path -LiteralPath $sln -PathType Leaf) {
              $kind = 'sln'
              $buildPath = (Resolve-Path -LiteralPath $sln).Path
            } else {
              $vcxprojs = @(Get-ChildItem -LiteralPath $Directory.FullName -File -Filter '*.vcxproj' -ErrorAction SilentlyContinue)
              if ($vcxprojs.Count -eq 0) { return $null }
              if ($vcxprojs.Count -eq 1) {
                $kind = 'vcxproj'
                $buildPath = (Resolve-Path -LiteralPath $vcxprojs[0].FullName).Path
              } else {
                # Mirrors ci/build-drivers.ps1 behaviour: without a matching <dir>.sln, the build
                # target is ambiguous. Treat this as "buildable" so CI runs and surfaces the issue.
                $kind = 'ambiguous'
                $buildPath = $Directory.FullName
              }
            }

            if (-not (Test-HasInfInTree -RootDir $Directory.FullName)) {
              return $null
            }

            $sep = [IO.Path]::DirectorySeparatorChar
            $altSep = [IO.Path]::AltDirectorySeparatorChar
            $driversRootNormalized = $DriversRootResolved.TrimEnd($sep, $altSep)
            $dirResolved = (Resolve-Path -LiteralPath $Directory.FullName).Path.TrimEnd($sep, $altSep)
            $prefix = $driversRootNormalized + $sep
            if (-not $dirResolved.StartsWith($prefix, [StringComparison]::OrdinalIgnoreCase)) {
              return $null
            }

            $relativePath = $dirResolved.Substring($prefix.Length)
            $displayName = $relativePath.Replace($sep, '/')
            if ($altSep -ne $sep) {
              $displayName = $displayName.Replace($altSep, '/')
            }

            return [pscustomobject]@{
              Name = $displayName
              Kind = $kind
              BuildPath = $buildPath
              ManifestPath = (Resolve-Path -LiteralPath $manifestPath).Path
            }
          }

          # Only run CI when we have *CI-packaged* driver targets as discovered by ci/build-drivers.ps1:
          #   - contains ci-package.json at the driver root (explicit opt-in)
          #   - contains <dirName>.sln OR exactly one *.vcxproj at the driver root
          #   - contains at least one .inf somewhere under the driver directory tree (excluding obj/out/build/target)
          #
          # We intentionally ignore classic WDK 7.1 NMake wrapper projects that invoke build.exe
          # (Keyword=MakeFileProj / ConfigurationType=Makefile), because this workflow provisions
          # a modern Windows Kits toolchain and does not guarantee a WDK 7.1 build environment.

          $driversRootResolved = (Resolve-Path -LiteralPath $driversDir).Path

          $manifestFiles = @(Get-ChildItem -LiteralPath $driversDir -Recurse -File -Filter 'ci-package.json' -ErrorAction SilentlyContinue | Sort-Object -Property FullName)
          $targets = New-Object System.Collections.Generic.List[object]

          foreach ($mf in $manifestFiles) {
            if (-not $mf.Directory) { continue }
            $t = Try-GetDriverBuildTarget -Directory $mf.Directory -DriversRootResolved $driversRootResolved
            if ($null -ne $t) {
              [void]$targets.Add($t)
            }
          }

          $buildable = New-Object System.Collections.Generic.List[object]
          foreach ($t in $targets) {
            if ($t.Kind -eq 'vcxproj') {
              if (-not (Test-IsMakefileVcxproj -Path $t.BuildPath)) {
                [void]$buildable.Add($t)
              }
              continue
            }

            if ($t.Kind -eq 'sln') {
              if (Test-SlnHasBuildableProjects -SlnPath $t.BuildPath) {
                [void]$buildable.Add($t)
              }
              continue
            }

            # "ambiguous" target (multiple vcxproj, no matching <dir>.sln):
            # still run CI to surface the ambiguity.
            [void]$buildable.Add($t)
          }

          if ($buildable.Count -eq 0) {
            Write-Host "No CI-packaged Win7 driver targets were found (expected drivers/**/ci-package.json + build target + INF; ignoring WDK 7.1 NMake/build.exe wrappers). Skipping."
            "skip=true" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            exit 0
          }

          Write-Host "Found $($buildable.Count) CI-packaged Win7 driver target(s); running Win7 driver build:"
          foreach ($t in ($buildable | Sort-Object -Property Name)) {
            Write-Host ("- {0} ({1}): {2}" -f $t.Name, $t.Kind, $t.BuildPath)
            Write-Host ("    manifest: {0}" -f $t.ManifestPath)
          }
          "skip=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: Prepare WDK download cache directory
        if: steps.detect.outputs.skip != 'true'
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          New-Item -ItemType Directory -Force -Path $env:WDK_DOWNLOAD_CACHE | Out-Null

      - name: Cache WDK downloads
        if: steps.detect.outputs.skip != 'true'
        uses: actions/cache@v4
        with:
          path: ${{ env.WDK_DOWNLOAD_CACHE }}
          key: wdk-download-${{ runner.os }}-${{ hashFiles('ci/install-wdk.ps1', 'ci/lib/Toolchain.psm1') }}
          restore-keys: |
            wdk-download-${{ runner.os }}-

      - name: Provision toolchain (ci/install-wdk.ps1)
        if: steps.detect.outputs.skip != 'true'
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          if (!(Test-Path -LiteralPath 'ci\install-wdk.ps1')) {
            throw "Expected script ci\install-wdk.ps1 to exist."
          }
          pwsh -NoProfile -ExecutionPolicy Bypass -File 'ci\install-wdk.ps1'

      - name: Validate AeroGPU D3D9 UMD exports (.def stdcall decoration)
        if: steps.detect.outputs.skip != 'true'
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          python scripts/ci/check-aerogpu-d3d9-def-stdcall.py
      - name: Validate AeroGPU D3D10/11 UMD exports (.def stdcall decoration)
        if: steps.detect.outputs.skip != 'true'
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          python scripts/ci/check-aerogpu-d3d10-def-stdcall.py

      - name: Build drivers (ci/build-drivers.ps1)
        if: steps.detect.outputs.skip != 'true'
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          if (!(Test-Path -LiteralPath 'ci\build-drivers.ps1')) {
            throw "Expected script ci\build-drivers.ps1 to exist."
          }
          pwsh -NoProfile -ExecutionPolicy Bypass -File 'ci\build-drivers.ps1' -ToolchainJson 'out\toolchain.json'

      - name: Detect built driver binaries
        id: built
        if: steps.detect.outputs.skip != 'true'
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          $outDrivers = Join-Path $env:GITHUB_WORKSPACE 'out\drivers'
          if (!(Test-Path -LiteralPath $outDrivers)) {
            Write-Host "No out/drivers/ directory produced by build step; skipping catalog/sign/package."
            "has_sys=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            exit 0
          }

          $sys = Get-ChildItem -LiteralPath $outDrivers -Recurse -File -Filter '*.sys' -ErrorAction SilentlyContinue | Select-Object -First 1
          if (-not $sys) {
            Write-Host "No .sys files found under out/drivers/; skipping catalog/sign/package."
            "has_sys=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            exit 0
          }

          Write-Host "Found driver binary: $($sys.FullName)"
          "has_sys=true" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: Build AeroGPU dbgctl tool (ci/build-aerogpu-dbgctl.ps1)
        if: steps.detect.outputs.skip != 'true' && steps.built.outputs.has_sys == 'true'
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          if (!(Test-Path -LiteralPath 'ci\build-aerogpu-dbgctl.ps1')) {
            throw "Expected script ci\build-aerogpu-dbgctl.ps1 to exist."
          }
          pwsh -NoProfile -ExecutionPolicy Bypass -File 'ci\build-aerogpu-dbgctl.ps1' -ToolchainJson 'out\toolchain.json'

      - name: Generate catalogs (ci/make-catalogs.ps1)
        if: steps.detect.outputs.skip != 'true' && steps.built.outputs.has_sys == 'true'
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          if (!(Test-Path -LiteralPath 'ci\make-catalogs.ps1')) {
            throw "Expected script ci\make-catalogs.ps1 to exist."
          }
          pwsh -NoProfile -ExecutionPolicy Bypass -File 'ci\make-catalogs.ps1' -ToolchainJson 'out\toolchain.json'

      - name: Test-sign drivers (ci/sign-drivers.ps1)
        if: steps.detect.outputs.skip != 'true' && steps.built.outputs.has_sys == 'true'
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          if (!(Test-Path -LiteralPath 'ci\sign-drivers.ps1')) {
            throw "Expected script ci\sign-drivers.ps1 to exist."
          }
          pwsh -NoProfile -ExecutionPolicy Bypass -File 'ci\sign-drivers.ps1' -ToolchainJson 'out\toolchain.json'

      - name: Verify signed package staging (out/packages + aero-test.cer)
        if: steps.detect.outputs.skip != 'true' && steps.built.outputs.has_sys == 'true'
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          if (!(Test-Path -LiteralPath 'out/packages')) {
            throw "Expected signed driver packages to exist at out/packages."
          }
          $inf = Get-ChildItem -LiteralPath 'out/packages' -Recurse -File -Filter '*.inf' -ErrorAction SilentlyContinue | Select-Object -First 1
          if (-not $inf) {
            throw "Expected at least one .inf file under out/packages after catalog/signing."
          }
          if (!(Test-Path -LiteralPath 'out/certs/aero-test.cer')) {
            throw "Expected signing certificate to exist at out/certs/aero-test.cer."
          }

          foreach ($p in @(
            'out/packages/aerogpu/x86/tools/win7_dbgctl/bin/aerogpu_dbgctl.exe',
            'out/packages/aerogpu/x64/tools/win7_dbgctl/bin/aerogpu_dbgctl.exe'
          )) {
            if (!(Test-Path -LiteralPath $p -PathType Leaf)) {
              throw "Expected AeroGPU dbgctl tool to be staged in signed package output: $p"
            }
          }

      - name: Upload signed packages (out/packages + aero-test.cer)
        if: steps.detect.outputs.skip != 'true' && steps.built.outputs.has_sys == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: win7-drivers-signed-packages
          path: |
            out/packages/**
            out/certs/aero-test.cer
          if-no-files-found: error

      - name: Setup Rust (for aero_packager)
        if: steps.detect.outputs.skip != 'true' && steps.built.outputs.has_sys == 'true'
        uses: ./.github/actions/setup-rust
        with:
          toolchain: stable
          cache: false
          locked: always

      - name: Package artifacts (ci/package-drivers.ps1)
        if: steps.detect.outputs.skip != 'true' && steps.built.outputs.has_sys == 'true'
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          if (!(Test-Path -LiteralPath 'ci\package-drivers.ps1')) {
            throw "Expected script ci\package-drivers.ps1 to exist."
          }
          pwsh -NoProfile -ExecutionPolicy Bypass -File 'ci\package-drivers.ps1' -MakeFatImage

      - name: Package Guest Tools media (ci/package-guest-tools.ps1)
        if: steps.detect.outputs.skip != 'true' && steps.built.outputs.has_sys == 'true'
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          if (!(Test-Path -LiteralPath 'ci\package-guest-tools.ps1')) {
            throw "Expected script ci\package-guest-tools.ps1 to exist."
          }
          pwsh -NoProfile -ExecutionPolicy Bypass -File 'ci\package-guest-tools.ps1' -SpecPath 'tools\packaging\specs\win7-signed.json'

      - name: Smoke check Guest Tools outputs (sizes)
        if: steps.detect.outputs.skip != 'true' && steps.built.outputs.has_sys == 'true'
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          foreach ($name in @('aero-guest-tools.iso', 'aero-guest-tools.zip', 'manifest.json')) {
            $p = Join-Path 'out\artifacts' $name
            if (!(Test-Path -LiteralPath $p -PathType Leaf)) {
              throw "Expected Guest Tools output missing: $p"
            }
            $f = Get-Item -LiteralPath $p
            Write-Host ("{0} - {1} bytes" -f $f.Name, $f.Length)
          }

          $manifestPath = 'out\artifacts\manifest.json'
          $manifest = Get-Content -LiteralPath $manifestPath -Raw | ConvertFrom-Json
          $paths = @()
          foreach ($f in $manifest.files) { $paths += ("" + $f.path) }
          foreach ($required in @(
            'drivers/x86/aerogpu/tools/win7_dbgctl/bin/aerogpu_dbgctl.exe',
            'drivers/amd64/aerogpu/tools/win7_dbgctl/bin/aerogpu_dbgctl.exe'
          )) {
            if (-not ($paths -contains $required)) {
              throw "Guest Tools manifest is missing required dbgctl payload: $required"
            }
          }

      - name: Upload artifacts (out/artifacts/)
        if: steps.detect.outputs.skip != 'true' && steps.built.outputs.has_sys == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: win7-drivers
          path: out/artifacts/
          if-no-files-found: error

  guest-tools:
    name: Guest Tools (ISO + zip)
    runs-on: ubuntu-latest
    needs: drivers-win7
    if: needs.drivers-win7.outputs.skip != 'true' && needs.drivers-win7.outputs.has_sys == 'true'
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          # Version stamping derives from git tags/commits; fetch full history + tags so
          # `git describe` and commit-distance calculations are accurate.
          fetch-depth: 0
          fetch-tags: true

      - name: Setup Rust (for aero_packager)
        uses: ./.github/actions/setup-rust
        with:
          toolchain: stable
          cache: false
          locked: always

      - name: Download signed packages
        uses: actions/download-artifact@v4
        with:
          name: win7-drivers-signed-packages
          # The signed-packages artifact is uploaded with `out/` as its root,
          # so it contains `packages/` + `certs/`. Download into `out/` to
          # recreate the expected `out/packages` + `out/certs` layout.
          path: out

      - name: Normalize signed package layout
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          if ((Test-Path -LiteralPath 'out/packages') -and (Test-Path -LiteralPath 'out/certs')) {
            Write-Host "Signed packages layout OK (out/packages + out/certs)."
            exit 0
          }

          if ((Test-Path -LiteralPath 'out/out/packages') -and (Test-Path -LiteralPath 'out/out/certs')) {
            Write-Host "Detected nested signed packages layout (out/out/*); normalizing..."
            Move-Item -LiteralPath 'out/out/packages' -Destination 'out/packages' -Force
            Move-Item -LiteralPath 'out/out/certs' -Destination 'out/certs' -Force
            Remove-Item -LiteralPath 'out/out' -Recurse -Force -ErrorAction SilentlyContinue
            exit 0
          }

          throw "Unexpected signed packages layout after download. Expected out/packages + out/certs (or nested out/out/*)."

      - name: Package Guest Tools (ci/package-guest-tools.ps1)
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          if (!(Test-Path -LiteralPath 'ci/package-guest-tools.ps1')) {
            throw "Expected script ci/package-guest-tools.ps1 to exist."
          }
          if (!(Test-Path -LiteralPath 'out/packages')) {
            throw "Expected signed driver packages at out/packages (download artifact step may have failed)."
          }
          if (!(Test-Path -LiteralPath 'out/certs/aero-test.cer')) {
            throw "Expected signing cert at out/certs/aero-test.cer (download artifact step may have failed)."
          }

           pwsh -NoProfile -ExecutionPolicy Bypass -File 'ci/package-guest-tools.ps1' `
             -InputRoot 'out/packages' `
             -CertPath 'out/certs/aero-test.cer' `
             -SpecPath 'tools/packaging/specs/win7-signed.json' `
             -OutDir 'out/guest-tools'

      - name: Verify Guest Tools outputs
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          # The Guest Tools wrapper script previously emitted `aero-guest-tools.manifest.json`,
          # but now emits `manifest.json` directly. Keep both filenames available for
          # downstream tooling by copying whichever one exists to the other path.
          $manifest = 'out/guest-tools/manifest.json'
          $manifestAlias = 'out/guest-tools/aero-guest-tools.manifest.json'
          if (Test-Path -LiteralPath $manifest) {
            Copy-Item -LiteralPath $manifest -Destination $manifestAlias -Force
          } elseif (Test-Path -LiteralPath $manifestAlias) {
            Copy-Item -LiteralPath $manifestAlias -Destination $manifest -Force
          } else {
            throw "Missing expected Guest Tools manifest (expected either $manifest or $manifestAlias)."
          }
          foreach ($path in @(
            'out/guest-tools/aero-guest-tools.iso',
            'out/guest-tools/aero-guest-tools.zip',
            'out/guest-tools/aero-guest-tools.manifest.json',
            'out/guest-tools/manifest.json'
          )) {
            if (!(Test-Path -LiteralPath $path)) {
              throw "Missing expected Guest Tools output: $path"
            }
          }

      - name: Upload Guest Tools artifacts
        uses: actions/upload-artifact@v4
        with:
          name: aero-guest-tools
          # Upload the output directory so the artifact root contains the files
          # directly (no `out/guest-tools/` path prefix when downloaded).
          path: out/guest-tools
          if-no-files-found: error
