# Example environment file for deploy/docker-compose.yml
#
# Copy to deploy/.env and adjust values:
#   cp deploy/.env.example deploy/.env

# Domain / hostname to serve.
# - local dev: localhost
# - production: aero.example.com
AERO_DOMAIN=localhost

# HSTS toggle for production. 0 disables.
# Recommended production value: 31536000 (1 year) or higher.
AERO_HSTS_MAX_AGE=0

# Directory to serve as the static frontend root (mounted into Caddy at /srv).
# - Default: ./static (the smoke-test page under deploy/static/)
# - Recommended: ../dist (after building the real frontend)
#AERO_FRONTEND_ROOT=../dist

# Gateway image override (optional).
# - When unset, docker compose builds `backend/aero-gateway` from source.
#AERO_GATEWAY_IMAGE=ghcr.io/your-org/aero-gateway:latest

# Optional build arg used by backend/aero-gateway for /version.
#AERO_GATEWAY_GIT_SHA=$(git rev-parse HEAD)

# L2 tunnel proxy image override (optional).
# - When unset, docker compose builds `crates/aero-l2-proxy` from source.
#AERO_L2_PROXY_IMAGE=ghcr.io/your-org/aero-l2-proxy:latest

# WebRTC UDP relay image override (optional).
# - When unset, docker compose builds `proxy/webrtc-udp-relay` from source.
#AERO_WEBRTC_UDP_RELAY_IMAGE=ghcr.io/your-org/aero-webrtc-udp-relay:latest

# Optional: additional origins to allow in the edge proxy CSP `connect-src`.
# Example: "https://proxy.example.com wss://proxy.example.com"
#AERO_CSP_CONNECT_SRC_EXTRA=

# L2 tunnel proxy upstream (used by deploy/caddy/Caddyfile).
# Only change if your L2 proxy listens on a different host/port inside docker.
AERO_L2_PROXY_UPSTREAM=aero-l2-proxy:8090

# Optional: append additional allowed browser origins for the L2 tunnel proxy.
#
# The L2 proxy enforces an Origin allowlist by default (configured by deploy/docker-compose.yml
# to allow https://$AERO_DOMAIN). Append additional comma-prefixed origins here if you need to
# connect from a different origin (e.g. a dev server):
#AERO_L2_ALLOWED_ORIGINS_EXTRA=,https://localhost:5173

# L2 tunnel auth (Option C).
#
# By default, `deploy/docker-compose.yml` does not require authentication on `/l2` (it enforces an
# Origin allowlist). For production deployments, enable auth.
#
# Session cookie auth (recommended for same-origin browser clients):
#AERO_L2_AUTH_MODE=session
# (Legacy alias: cookie)
#
# This validates the `aero_session` cookie minted by `backend/aero-gateway` (`POST /session`).
#
# For production deployments, you should set SESSION_SECRET explicitly so you control rotation/backups.
#
# If SESSION_SECRET is unset, `deploy/docker-compose.yml` generates and persists a random secret in a
# Docker volume (sessions survive restarts until `docker compose down -v`).
#
# `crates/aero-l2-proxy` reads the cookie signing secret from `AERO_GATEWAY_SESSION_SECRET` (preferred)
# and falls back to `SESSION_SECRET` / `AERO_L2_SESSION_SECRET` (legacy), so this deploy stack can
# share one secret across services.
#
# To disable auth (local dev only; NOT recommended for internet-exposed deployments):
#AERO_L2_AUTH_MODE=none
#
# For non-browser / cross-origin clients, you can switch to token/JWT auth, or accept both:
#
# - Accept either a session cookie OR a JWT (useful for internal bridges):
#AERO_L2_AUTH_MODE=cookie_or_jwt
#AERO_L2_JWT_SECRET=REPLACE_WITH_SECRET
# (Note: canonical spelling is `cookie_or_jwt`; there is no `session_or_jwt` alias.)
#
# - Accept either a session cookie OR a token:
#AERO_L2_AUTH_MODE=session_or_token
#AERO_L2_API_KEY=REPLACE_WITH_SECRET
# (Legacy alias: cookie_or_api_key)
#
# - Require both a session cookie AND a token (defense in depth):
#AERO_L2_AUTH_MODE=session_and_token
#AERO_L2_API_KEY=REPLACE_WITH_SECRET
# (Legacy alias: cookie_and_api_key)
#
# - Token/JWT-only auth:
#AERO_L2_AUTH_MODE=token
#AERO_L2_API_KEY=REPLACE_WITH_SECRET
#AERO_L2_AUTH_MODE=jwt
#AERO_L2_JWT_SECRET=REPLACE_WITH_SECRET
#
# Legacy (still supported): static token alias for token auth.
# - `deploy/docker-compose.yml` defaults AERO_L2_AUTH_MODE=none, so set `AERO_L2_AUTH_MODE=token`
#   (or `session_or_token` / `session_and_token`) to enable token auth.
#   (Legacy aliases: api_key / cookie_or_api_key / cookie_and_api_key)
# - In `AERO_L2_AUTH_MODE=token|session_or_token|session_and_token`, it is accepted as a fallback for `AERO_L2_API_KEY`.
# - Ignored when `AERO_L2_AUTH_MODE` is explicitly set to `session`, `jwt`, `cookie_or_jwt`,
#   or `none`.
#AERO_L2_TOKEN=REPLACE_WITH_SECRET
#
# Credential delivery (token/jwt):
# - Query params: `?token=<value>` (preferred) / `?apiKey=<value>` (compat)
# - Preferred (avoids secrets in URLs/logs): offer an additional `Sec-WebSocket-Protocol` entry
#   `aero-l2-token.<value>` (alongside `aero-l2-tunnel-v1`; requires the value be valid for the
#   WebSocket subprotocol token grammar).

# Optional: L2 tunnel payload limits (bytes).
#
# These should generally be kept in sync across:
# - `aero-l2-proxy` (enforcement via `AERO_L2_MAX_*`), and
# - `aero-gateway` (advertising via `POST /session` `limits.l2.*`).
#
# Defaults (recommended): 2048 for Ethernet frame payloads, 256 for control payloads.
#AERO_L2_MAX_FRAME_PAYLOAD=2048
#AERO_L2_MAX_CONTROL_PAYLOAD=256

# WebRTC UDP relay upstream (HTTP signaling / ICE discovery) used by deploy/caddy/Caddyfile.
# Only change if your relay listens on a different host/port inside docker.
AERO_WEBRTC_UDP_RELAY_UPSTREAM=aero-webrtc-udp-relay:8080

# L2 proxy egress policy (recommended for production deployments).
# By default, the proxy denies private/reserved IP ranges but allows outbound to any public IP/port.
# Tighten this to reduce abuse/open-proxy risk:
#AERO_L2_ALLOWED_TCP_PORTS=80,443
#AERO_L2_ALLOWED_UDP_PORTS=
#AERO_L2_ALLOWED_DOMAINS=
#AERO_L2_BLOCKED_DOMAINS=
#AERO_L2_ALLOW_PRIVATE_IPS=0

# Gateway upstream (used by deploy/caddy/Caddyfile).
# Only change if your gateway listens on a different host/port inside docker.
#AERO_GATEWAY_UPSTREAM=aero-gateway:8080

# Sessions / authentication
#
# IMPORTANT (production): set a strong random SESSION_SECRET.
#
# This signs the `aero_session` cookie issued by `aero-gateway` (used for `/session` + `/tcp`).
#
# If you enable session-cookie auth for `/l2` (`AERO_L2_AUTH_MODE=session|cookie_or_jwt|session_or_token|session_and_token`
# on `aero-l2-proxy`; legacy aliases: `cookie`, `cookie_or_api_key`, `cookie_and_api_key`), the gateway and L2 proxy must
# share the same secret so they can validate the same cookie.
#
# Example:
#   SESSION_SECRET=$(openssl rand -hex 32)
#
# If unset, the deploy stack generates a random secret and persists it in a Docker volume (sessions
# survive restarts until `docker compose down -v`).
#SESSION_SECRET=REPLACE_WITH_SECRET
#
# Optional comma-separated origin allowlist (CORS/Origin checks):
#ALLOWED_ORIGINS=https://localhost
TRUST_PROXY=1
CROSS_ORIGIN_ISOLATION=0

# WebRTC UDP relay port range (must match the published UDP range in deploy/docker-compose.yml).
#
# If `docker compose up` fails with "port is already allocated", pick a different range.
WEBRTC_UDP_PORT_MIN=50000
WEBRTC_UDP_PORT_MAX=50100

# Optional: append additional allowed browser origins for the UDP relay.
# Example: allow a separate dev server (only if it also sets COOP/COEP headers):
#AERO_WEBRTC_UDP_RELAY_ALLOWED_ORIGINS_EXTRA=,https://localhost:5173

# Auth for WebRTC UDP relay (proxy/webrtc-udp-relay) + gateway session integration.
#
# deploy/docker-compose.yml wires these into both:
# - aero-webrtc-udp-relay (enforces auth on /webrtc/* and /udp)
# - aero-gateway (mints udpRelay.token in POST /session and POST /udp-relay/token)
#
# Default (when unset): AUTH_MODE=none (unauthenticated; good for local dev).
# For production, prefer `api_key` or `jwt` and set matching credentials.
#AUTH_MODE=none
#
# API key auth (recommended if exposing the relay publicly):
#AUTH_MODE=api_key
#API_KEY=REPLACE_WITH_SECRET
#
# JWT auth (HS256):
#AUTH_MODE=jwt
#JWT_SECRET=REPLACE_WITH_SECRET
#UDP_RELAY_TOKEN_TTL_SECONDS=300

# Optional: WebRTC relay L2 bridging (DataChannel label `l2`).
#
# The `l2` DataChannel MUST be fully reliable and ordered:
# - ordered=true
# - do not set maxRetransmits/maxPacketLifeTime (partial reliability)
#
# Enable backend L2 WebSocket bridging to `aero-l2-proxy`:
#L2_BACKEND_WS_URL=ws://aero-l2-proxy:8090/l2
#
# Optional knobs:
# - Forward the client's Origin to the backend (recommended for same-origin deployments):
#L2_BACKEND_FORWARD_ORIGIN=1
# - Forward the caller's `aero_session` cookie to the backend (recommended when the backend uses session-cookie auth: AERO_L2_AUTH_MODE=session).
#   The relay extracts `aero_session=...` from signaling and sends `Cookie: aero_session=<...>` on the backend `/l2` dial:
#L2_BACKEND_FORWARD_AERO_SESSION=1
# - Forward the client's credential to the backend:
#L2_BACKEND_AUTH_FORWARD_MODE=query        # default
#L2_BACKEND_AUTH_FORWARD_MODE=subprotocol  # offer Sec-WebSocket-Protocol entry aero-l2-token.<credential> alongside aero-l2-tunnel-v1
# - Override the Origin header sent to the backend:
#L2_BACKEND_ORIGIN=https://example.com     # alias for L2_BACKEND_ORIGIN_OVERRIDE
#L2_BACKEND_ORIGIN_OVERRIDE=https://example.com
# - Fixed backend token (offered as Sec-WebSocket-Protocol entry aero-l2-token.<token> alongside aero-l2-tunnel-v1):
#L2_BACKEND_TOKEN=REPLACE_WITH_SECRET      # alias for L2_BACKEND_WS_TOKEN (static backend token subprotocol)
# - Limit relay DataChannel message size (bytes):
#L2_MAX_MESSAGE_BYTES=4096

# UDP relay destination policy (required for real UDP egress).
#
# Note: `proxy/webrtc-udp-relay` defaults to `DESTINATION_POLICY_PRESET=production`
# (deny-by-default). For local dev/testing, you can set:
#DESTINATION_POLICY_PRESET=dev
#
# See proxy/webrtc-udp-relay/README.md for full policy docs and production examples.
#DESTINATION_POLICY_PRESET=production
#ALLOW_UDP_CIDRS=1.1.1.1/32,8.8.8.8/32
#ALLOW_UDP_PORTS=53

# Optional TURN (coturn) configuration (requires `--profile turn`).
# The coturn config defaults to user=aero:aero for local dev.
#AERO_TURN_URLS=turn:localhost:3478?transport=udp
#AERO_TURN_USERNAME=aero
#AERO_TURN_CREDENTIAL=aero
