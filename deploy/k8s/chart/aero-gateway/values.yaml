# Default values are intentionally "safe" and should be overridden for real environments.
# Create a local values file (do not commit it) and set at minimum:
#   - gateway.image.tag
#   - ingress.host (+ TLS settings for production)
#   - secrets.data.SESSION_SECRET / secrets.data.ADMIN_API_KEY

nameOverride: ""
fullnameOverride: ""

imagePullSecrets: []

serviceAccount:
  create: false
  name: ""
  annotations: {}
  # Security hardening: this service does not need to talk to the Kubernetes API.
  # Set to true only if your deployment requires in-cluster auth (e.g. cloud workload identity).
  automountServiceAccountToken: false

gateway:
  replicaCount: 1

  image:
    repository: ghcr.io/wilsonzlin/aero-gateway
    tag: "" # Defaults to Chart.appVersion if unset.
    pullPolicy: IfNotPresent

  containerPort: 8080

  # The URL that browser clients use to reach the gateway.
  # If unset and ingress.enabled=true, this chart derives it from ingress.host + TLS.
  publicBaseUrl: ""

  # Optional comma-separated origin allowlist for CORS/Origin checks.
  # If unset, aero-gateway defaults it to PUBLIC_BASE_URL's origin.
  allowedOrigins: ""

  # Enable COOP/COEP headers at the application layer (alternative to ingress injection).
  # NOTE: Do not enable this at the same time as ingress.coopCoep.enabled to avoid
  # duplicate COOP/COEP headers.
  crossOriginIsolation:
    enabled: false

  logLevel: info
  shutdownGraceMs: 10000
  rateLimit:
    requestsPerMinute: 0

  # Extra environment variables to set directly on the container.
  # Example:
  # extraEnv:
  #   - name: LOG_LEVEL
  #     value: debug
  extraEnv: []

  podAnnotations: {}
  podSecurityContext: {}
  securityContext: {}

  resources: {}

  nodeSelector: {}
  tolerations: []
  affinity: {}
  topologySpreadConstraints: []

service:
  type: ClusterIP
  port: 80

config:
  create: true
  name: ""
  data: {}

secrets:
  # For production, prefer ExternalSecrets/SealedSecrets/etc and set create=false + existingSecret.
  create: true
  name: ""
  existingSecret: ""
  data:
    # Placeholders only; override in your local values file.
    SESSION_SECRET: "__REPLACE_ME__"
    ADMIN_API_KEY: "__REPLACE_ME__"

ingress:
  enabled: true
  className: nginx
  host: aero.example.com
  path: /
  pathType: Prefix

  tls:
    enabled: false
    secretName: ""

  annotations: {}

  websocket:
    enabled: true
    readTimeoutSeconds: 3600
    sendTimeoutSeconds: 3600

  coopCoep:
    enabled: true
    # mode:
    #   - auto (default): nginx unless ingress.className contains "traefik"
    #   - nginx: use ingress-nginx snippet annotations
    #   - traefik: use a Traefik Middleware resource
    mode: auto
    coop: same-origin
    coep: require-corp
    corp: same-origin
    originAgentCluster: "?1"

  traefik:
    createMiddleware: true
    middlewareApiVersion: traefik.io/v1alpha1

redis:
  enabled: false
  port: 6379

  # If you use an external Redis, leave redis.enabled=false and set redis.url instead.
  url: ""

  image:
    repository: redis
    tag: 7-alpine
    pullPolicy: IfNotPresent

  persistence:
    enabled: false
    size: 1Gi
    storageClass: ""

networkPolicy:
  enabled: false

  # Namespaces allowed to connect to the gateway.
  # For ingress-nginx the namespace is typically "ingress-nginx".
  ingress:
    allowedNamespaces:
      - ingress-nginx

  egress:
    # Destination CIDRs to allow (example: ["0.0.0.0/0"] to allow all).
    allowedCIDRs: []
    # CIDRs to exclude from allowed ranges (only applies when allowedCIDRs is set).
    # Useful for blocking private ranges to reduce SSRF/blast radius.
    exceptCIDRs: []

certManager:
  # If enabled, this chart can create a cert-manager Certificate resource to
  # provision the Ingress TLS secret automatically.
  enabled: false

  # Issuer reference used by the generated Certificate.
  # Requires cert-manager to be installed in the cluster.
  issuerRef:
    kind: ClusterIssuer
    name: letsencrypt-prod

  # Optional: have this chart create a namespace-scoped Issuer resource so TLS
  # can be provisioned with a single `helm install` (assuming cert-manager is
  # already installed in the cluster).
  #
  # When enabled, the Certificate will reference the created Issuer instead of
  # issuerRef above.
  createIssuer: false

  issuer:
    # If empty, defaults to "<release>-aero-gateway".
    name: ""
    # ACME account email (required when createIssuer=true).
    email: ""
    # Let's Encrypt production endpoint by default. For testing use:
    # https://acme-staging-v02.api.letsencrypt.org/directory
    server: https://acme-v02.api.letsencrypt.org/directory
    # Where cert-manager stores the ACME account private key.
    # If empty, defaults to "<issuer-name>-account-key".
    privateKeySecretName: ""
    http01:
      # Which ingress class should solve the ACME HTTP-01 challenge.
      # If empty, defaults to ingress.className.
      ingressClass: ""

podDisruptionBudget:
  enabled: false
  minAvailable: 1
