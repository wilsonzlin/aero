# Default values are intentionally "safe" and should be overridden for real environments.
# Create a local values file (do not commit it) and set at minimum:
#   - gateway.image.tag
#   - ingress.host (+ TLS settings for production)
#   - secrets.data.SESSION_SECRET

nameOverride: ""
fullnameOverride: ""

imagePullSecrets: []

serviceAccount:
  create: false
  name: ""
  annotations: {}
  # Security hardening: this service does not need to talk to the Kubernetes API.
  # Set to true only if your deployment requires in-cluster auth (e.g. cloud workload identity).
  automountServiceAccountToken: false

gateway:
  replicaCount: 1

  image:
    repository: ghcr.io/wilsonzlin/aero-gateway
    tag: "" # Defaults to Chart.appVersion if unset.
    pullPolicy: IfNotPresent

  containerPort: 8080

  # Whether to trust X-Forwarded-* headers for scheme/client IP.
  # - Default: true when ingress.enabled=true, else false
  # - Set explicitly to true only when the Service is NOT directly exposed to untrusted clients.
  trustProxy: null

  # The URL that browser clients use to reach the gateway.
  # If unset and ingress.enabled=true, this chart derives it from ingress.host + TLS.
  publicBaseUrl: ""

  # Optional comma-separated origin allowlist for CORS/Origin checks.
  # If unset, aero-gateway defaults it to PUBLIC_BASE_URL's origin.
  allowedOrigins: ""

  # Enable COOP/COEP headers at the application layer (alternative to ingress injection).
  # NOTE: Do not enable this at the same time as ingress.coopCoep.enabled to avoid
  # duplicate COOP/COEP headers.
  crossOriginIsolation:
    enabled: false

  logLevel: info
  shutdownGraceMs: 10000
  # If unset (null), terminationGracePeriodSeconds is derived from shutdownGraceMs
  # with a small buffer. Override explicitly if your environment needs more time.
  terminationGracePeriodSeconds: null
  rateLimit:
    requestsPerMinute: 0

  # Extra environment variables to set directly on the container.
  # Example:
  # extraEnv:
  #   - name: LOG_LEVEL
  #     value: debug
  extraEnv: []

  podAnnotations: {}
  podSecurityContext: {}
  securityContext: {}

  resources: {}

  nodeSelector: {}
  tolerations: []
  affinity: {}
  topologySpreadConstraints: []

autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 5
  targetCPUUtilizationPercentage: 80
  targetMemoryUtilizationPercentage: null

serviceMonitor:
  enabled: false
  interval: 30s
  scrapeTimeout: 10s
  path: /metrics
  additionalLabels: {}

service:
  type: ClusterIP
  port: 80

config:
  create: true
  # If create=false and name is set, the Deployment will reference an existing ConfigMap.
  name: ""
  data: {}

secrets:
  # For production, prefer ExternalSecrets/SealedSecrets/etc and set create=false + existingSecret.
  create: true
  name: ""
  existingSecret: ""
  data:
    # Placeholders only; override in your local values file.
    SESSION_SECRET: "__REPLACE_ME__"

ingress:
  enabled: true
  className: nginx
  host: aero.example.com
  path: /
  pathType: Prefix

  tls:
    enabled: false
    secretName: ""

  annotations: {}

  websocket:
    enabled: true
    readTimeoutSeconds: 3600
    sendTimeoutSeconds: 3600

  coopCoep:
    enabled: true
    # mode:
    #   - auto (default): nginx unless ingress.className contains "traefik"
    #   - nginx: use ingress-nginx snippet annotations
    #   - traefik: use a Traefik Middleware resource
    mode: auto
    coop: same-origin
    coep: require-corp
    corp: same-origin
    originAgentCluster: "?1"

  # Security headers injected at the ingress/proxy layer.
  #
  # The gateway sets some baseline headers itself, but CSP is typically an edge
  # concern when serving the frontend from the same origin.
  securityHeaders:
    enabled: true
    xContentTypeOptions: nosniff
    referrerPolicy: no-referrer
    permissionsPolicy: "camera=(), geolocation=(), microphone=(self), usb=(self)"
    # Keep this aligned with `scripts/headers.json` / `docs/security-headers.md`.
    #
    # Note: `connect-src 'self'` is sufficient for single-origin deployments;
    # the `aero-gateway.invalid` placeholders are safe no-ops that make it obvious
    # where to extend the policy when needed.
    contentSecurityPolicy: "default-src 'none'; base-uri 'none'; object-src 'none'; frame-ancestors 'none'; script-src 'self' 'wasm-unsafe-eval'; worker-src 'self' blob:; connect-src 'self' https://aero-gateway.invalid wss://aero-gateway.invalid; img-src 'self' data: blob:; style-src 'self'; font-src 'self'"

  traefik:
    createMiddleware: true
    middlewareApiVersion: traefik.io/v1alpha1

redis:
  enabled: false
  port: 6379

  # If you use an external Redis, leave redis.enabled=false and set redis.url instead.
  url: ""

  image:
    repository: redis
    tag: 7-alpine
    pullPolicy: IfNotPresent

  persistence:
    enabled: false
    size: 1Gi
    storageClass: ""

networkPolicy:
  enabled: false

  # Namespaces allowed to connect to the gateway.
  # For ingress-nginx the namespace is typically "ingress-nginx".
  ingress:
    allowedNamespaces:
      - ingress-nginx

  egress:
    # Destination CIDRs to allow (example: ["0.0.0.0/0"] to allow all).
    allowedCIDRs: []
    # CIDRs to exclude from allowed ranges (only applies when allowedCIDRs is set).
    # Useful for blocking private ranges to reduce SSRF/blast radius.
    exceptCIDRs: []

certManager:
  # If enabled, this chart can create a cert-manager Certificate resource to
  # provision the Ingress TLS secret automatically.
  enabled: false

  # Issuer reference used by the generated Certificate.
  # Requires cert-manager to be installed in the cluster.
  issuerRef:
    kind: ClusterIssuer
    name: letsencrypt-prod

  # Optional: have this chart create a namespace-scoped Issuer resource so TLS
  # can be provisioned with a single `helm install` (assuming cert-manager is
  # already installed in the cluster).
  #
  # When enabled, the Certificate will reference the created Issuer instead of
  # issuerRef above.
  createIssuer: false

  issuer:
    # If empty, defaults to "<release>-aero-gateway".
    name: ""
    # ACME account email (required when createIssuer=true).
    email: ""
    # Let's Encrypt production endpoint by default. For testing use:
    # https://acme-staging-v02.api.letsencrypt.org/directory
    server: https://acme-v02.api.letsencrypt.org/directory
    # Where cert-manager stores the ACME account private key.
    # If empty, defaults to "<issuer-name>-account-key".
    privateKeySecretName: ""
    http01:
      # Which ingress class should solve the ACME HTTP-01 challenge.
      # If empty, defaults to ingress.className.
      ingressClass: ""

podDisruptionBudget:
  enabled: false
  minAvailable: 1
