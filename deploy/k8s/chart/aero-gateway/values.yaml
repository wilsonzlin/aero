# Default values are intentionally "safe" and should be overridden for real environments.
# Create a local values file (do not commit it) and set at minimum:
#   - gateway.image.tag
#   - ingress.host (+ TLS settings for production)
#   - secrets.data.SESSION_SECRET

nameOverride: ""
fullnameOverride: ""

imagePullSecrets: []

serviceAccount:
  create: false
  name: ""
  annotations: {}
  # Security hardening: this service does not need to talk to the Kubernetes API.
  # Set to true only if your deployment requires in-cluster auth (e.g. cloud workload identity).
  automountServiceAccountToken: false

gateway:
  replicaCount: 1

  image:
    repository: ghcr.io/wilsonzlin/aero-gateway
    tag: "" # Defaults to Chart.appVersion if unset.
    pullPolicy: IfNotPresent

  containerPort: 8080

  # Whether to trust X-Forwarded-* headers for scheme/client IP.
  # - Default: true when ingress.enabled=true, else false
  # - Set explicitly to true only when the Service is NOT directly exposed to untrusted clients.
  trustProxy: null

  # The URL that browser clients use to reach the gateway.
  # If unset and ingress.enabled=true, this chart derives it from ingress.host + TLS.
  publicBaseUrl: ""

  # Optional comma-separated origin allowlist for CORS/Origin checks.
  # If unset, aero-gateway defaults it to PUBLIC_BASE_URL's origin.
  allowedOrigins: ""

  # Enable COOP/COEP headers at the application layer (alternative to ingress injection).
  # NOTE: Do not enable this at the same time as ingress.coopCoep.enabled to avoid
  # duplicate COOP/COEP headers.
  crossOriginIsolation:
    enabled: false

  logLevel: info
  shutdownGraceMs: 10000
  # If unset (null), terminationGracePeriodSeconds is derived from shutdownGraceMs
  # with a small buffer. Override explicitly if your environment needs more time.
  terminationGracePeriodSeconds: null
  rateLimit:
    requestsPerMinute: 0

  # Extra environment variables to set directly on the container.
  # Example:
  # extraEnv:
  #   - name: LOG_LEVEL
  #     value: debug
  extraEnv: []

  podAnnotations: {}
  podSecurityContext: {}
  securityContext: {}

  resources: {}

  nodeSelector: {}
  tolerations: []
  affinity: {}
  topologySpreadConstraints: []

## L2 tunnel protocol payload limits (Option C).
##
## These values are enforced by `aero-l2-proxy` and surfaced to clients via
## `aero-gateway` `POST /session` `limits.l2.*`.
##
## Leave as `null` to use the protocol recommended defaults (2048/256).
##
l2Tunnel:
  # Max payload bytes for FRAME messages (excluding the 4-byte L2 tunnel header).
  maxFramePayloadBytes: null
  # Max payload bytes for control messages (PING/PONG/ERROR) (excluding the 4-byte header).
  maxControlPayloadBytes: null

## Optional: L2 tunnel proxy (`aero-l2-proxy`) for Option C (ADR 0005).
##
## When enabled, this chart deploys a second service that terminates the `/l2` WebSocket tunnel and
## runs the user-space NAT/egress policy stack (Rust service under `crates/aero-l2-proxy`).
##
## The chart's Ingress will add a path rule so:
##   - `/l2` → `aero-l2-proxy`
##   - everything else (e.g. `/tcp`, `/dns-query`) → `aero-gateway`
##
l2Proxy:
  enabled: false

  replicaCount: 1

  image:
    repository: ghcr.io/wilsonzlin/aero-l2-proxy
    tag: "" # Defaults to Chart.appVersion if unset.
    pullPolicy: IfNotPresent

  containerPort: 8090

  service:
    # `aero-l2-proxy` listens on 8090 by default.
    port: 8090

  ingress:
    path: /l2
    pathType: Prefix

  # Security / auth.
  #
  # Origin allowlist:
  # - If ingress.enabled=true, the chart will automatically allow the derived ingress origin
  #   (http/https + ingress.host).
  # - Add additional exact origins here if you serve the frontend from more than one origin.
  extraAllowedOrigins: []

  # Disable Origin enforcement (trusted local dev only).
  open: false

  auth:
    # Auth mode for `/l2` WebSocket upgrades (`AERO_L2_AUTH_MODE` on `aero-l2-proxy`).
    #
    # Supported values:
    #   - "none"
    #   - "session" (recommended for same-origin browser clients in production; legacy alias: "cookie")
    #   - "token" (legacy alias: "api_key")
    #   - "jwt"
    #   - "cookie_or_jwt"
    #   - "session_or_token" (legacy alias: "cookie_or_api_key")
    #   - "session_and_token" (legacy alias: "cookie_and_api_key")
    #
    # Default: "session" (matches the gateway's session-cookie auth used by `/tcp`).
    #
    # Note: when using `"session"` / `"cookie_or_jwt"` / `"session_or_token"` / `"session_and_token"`, `aero-l2-proxy` must share the gateway
    # `SESSION_SECRET` so it can validate `aero_session` cookies (see `l2Proxy.sessionSecret`).
    mode: "session"

  # Session cookie auth wiring.
  #
  # When using `auth.mode: "session"` (or `"cookie_or_jwt"` / `"session_or_token"` / `"session_and_token"`), the L2 proxy must be able to verify the
  # gateway-issued session cookie. This requires sharing the signing secret used by the gateway
  # (`SESSION_SECRET`).
  #
  # By default, this chart reuses the gateway secret (secrets.*). To use a separate Secret:
  #   l2Proxy.sessionSecret.existingSecret: "<secret-name>"
  #   l2Proxy.sessionSecret.key: "SESSION_SECRET"
  sessionSecret:
    existingSecret: ""
    key: SESSION_SECRET

  # Extra environment variables to set directly on the container.
  extraEnv: []

  podAnnotations: {}
  podLabels: {}
  podSecurityContext: {}
  securityContext: {}

  resources: {}

  nodeSelector: {}
  tolerations: []
  affinity: {}
  topologySpreadConstraints: []

  autoscaling:
    enabled: false
    minReplicas: 1
    maxReplicas: 5
    targetCPUUtilizationPercentage: 80
    targetMemoryUtilizationPercentage: null

  serviceMonitor:
    enabled: false
    interval: 30s
    scrapeTimeout: 10s
    path: /metrics
    additionalLabels: {}

autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 5
  targetCPUUtilizationPercentage: 80
  targetMemoryUtilizationPercentage: null

serviceMonitor:
  enabled: false
  interval: 30s
  scrapeTimeout: 10s
  path: /metrics
  additionalLabels: {}

service:
  type: ClusterIP
  port: 80

config:
  create: true
  # If create=false and name is set, the Deployment will reference an existing ConfigMap.
  name: ""
  data: {}

secrets:
  # For production, prefer ExternalSecrets/SealedSecrets/etc and set create=false + existingSecret.
  create: true
  name: ""
  existingSecret: ""
  data:
    # Placeholders only; override in your local values file.
    SESSION_SECRET: "__REPLACE_ME__"

ingress:
  enabled: true
  className: nginx
  host: aero.example.com
  path: /
  pathType: Prefix

  tls:
    enabled: false
    secretName: ""

  annotations: {}

  websocket:
    enabled: true
    readTimeoutSeconds: 3600
    sendTimeoutSeconds: 3600

  coopCoep:
    enabled: true
    # mode:
    #   - auto (default): nginx unless ingress.className contains "traefik"
    #   - nginx: use ingress-nginx snippet annotations
    #   - traefik: use a Traefik Middleware resource
    mode: auto
    coop: same-origin
    coep: require-corp
    corp: same-origin
    originAgentCluster: "?1"

  # Security headers injected at the ingress/proxy layer.
  #
  # The gateway sets some baseline headers itself, but CSP is typically an edge
  # concern when serving the frontend from the same origin.
  securityHeaders:
    enabled: true
    xContentTypeOptions: nosniff
    referrerPolicy: no-referrer
    permissionsPolicy: "camera=(), geolocation=(), microphone=(self), usb=(self)"
    # Keep this aligned with `scripts/headers.json` / `docs/security-headers.md`.
    #
    # Note: `connect-src 'self'` is sufficient for single-origin deployments;
    # the `aero-gateway.invalid` placeholders are safe no-ops that make it obvious
    # where to extend the policy when needed.
    contentSecurityPolicy: "default-src 'none'; base-uri 'none'; object-src 'none'; frame-ancestors 'none'; script-src 'self' 'wasm-unsafe-eval'; worker-src 'self' blob:; connect-src 'self' https://aero-gateway.invalid wss://aero-gateway.invalid; img-src 'self' data: blob:; style-src 'self'; font-src 'self'"

  traefik:
    createMiddleware: true
    middlewareApiVersion: traefik.io/v1alpha1

redis:
  enabled: false
  port: 6379

  # If you use an external Redis, leave redis.enabled=false and set redis.url instead.
  url: ""

  image:
    repository: redis
    tag: 7-alpine
    pullPolicy: IfNotPresent

  persistence:
    enabled: false
    size: 1Gi
    storageClass: ""

networkPolicy:
  enabled: false

  # Namespaces allowed to connect to the gateway.
  # For ingress-nginx the namespace is typically "ingress-nginx".
  ingress:
    allowedNamespaces:
      - ingress-nginx

  egress:
    # Destination CIDRs to allow (example: ["0.0.0.0/0"] to allow all).
    allowedCIDRs: []
    # CIDRs to exclude from allowed ranges (only applies when allowedCIDRs is set).
    # Useful for blocking private ranges to reduce SSRF/blast radius.
    exceptCIDRs: []

certManager:
  # If enabled, this chart can create a cert-manager Certificate resource to
  # provision the Ingress TLS secret automatically.
  enabled: false

  # Issuer reference used by the generated Certificate.
  # Requires cert-manager to be installed in the cluster.
  issuerRef:
    kind: ClusterIssuer
    name: letsencrypt-prod

  # Optional: have this chart create a namespace-scoped Issuer resource so TLS
  # can be provisioned with a single `helm install` (assuming cert-manager is
  # already installed in the cluster).
  #
  # When enabled, the Certificate will reference the created Issuer instead of
  # issuerRef above.
  createIssuer: false

  issuer:
    # If empty, defaults to "<release>-aero-gateway".
    name: ""
    # ACME account email (required when createIssuer=true).
    email: ""
    # Let's Encrypt production endpoint by default. For testing use:
    # https://acme-staging-v02.api.letsencrypt.org/directory
    server: https://acme-v02.api.letsencrypt.org/directory
    # Where cert-manager stores the ACME account private key.
    # If empty, defaults to "<issuer-name>-account-key".
    privateKeySecretName: ""
    http01:
      # Which ingress class should solve the ACME HTTP-01 challenge.
      # If empty, defaults to ingress.className.
      ingressClass: ""

podDisruptionBudget:
  enabled: false
  minAvailable: 1
