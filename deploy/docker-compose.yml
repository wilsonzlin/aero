# CANONICAL: Edge deployment for Aero (TLS termination + COOP/COEP/CSP security headers).
# Root-level compose files are service-specific examples; see `deploy/README.md`.

name: aero

services:
  # Shared gateway session secret (session-cookie signing).
  #
  # `backend/aero-gateway` uses a signed `aero_session` cookie for privileged endpoints (e.g. `/tcp`).
  # `crates/aero-l2-proxy` can optionally validate the same cookie when `AERO_L2_AUTH_MODE` includes
  # session cookies (e.g. `session` (legacy alias: `cookie`), `cookie_or_jwt`, `session_or_token`
  # (legacy: `cookie_or_api_key`), `session_and_token` (legacy: `cookie_and_api_key`)).
  #
  # To keep `docker compose up` working out of the box (and keep sessions stable across restarts),
  # this helper generates a random secret (once) and stores it in a Docker volume. You can (and should)
  # override it for production via `.env`.
  aero-session-secret:
    image: alpine:3.19
    restart: "no"
    volumes:
      - session_secret:/session_secret
    command: >
      sh -c 'set -e;
      if [ ! -f /session_secret/SESSION_SECRET ]; then
        umask 077;
        head -c 32 /dev/urandom | base64 | tr -d "\n" > /session_secret/SESSION_SECRET;
        chmod 0644 /session_secret/SESSION_SECRET;
      fi'

  # Reverse proxy / TLS terminator.
  #
  # Responsibilities:
  # - Terminates TLS on :443 (HTTP/2 enabled by default)
  # - Forces COOP/COEP/CORP headers at the edge for SharedArrayBuffer + WASM threads
  # - Proxies WebSocket upgrades (e.g. /tcp) and HTTP APIs (e.g. /dns-query) to the gateway
  aero-proxy:
    image: caddy:2.8.4
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    environment:
      # Hostname / domain name to serve.
      # - Local dev: "localhost"
      # - Production: "aero.example.com"
      AERO_DOMAIN: ${AERO_DOMAIN:-localhost}

      # Gateway upstream within the docker network.
      AERO_GATEWAY_UPSTREAM: ${AERO_GATEWAY_UPSTREAM:-aero-gateway:8080}

      # L2 tunnel proxy upstream within the docker network.
      AERO_L2_PROXY_UPSTREAM: ${AERO_L2_PROXY_UPSTREAM:-aero-l2-proxy:8090}

      # WebRTC UDP relay upstream (HTTP signaling / ICE discovery) within the docker network.
      AERO_WEBRTC_UDP_RELAY_UPSTREAM: ${AERO_WEBRTC_UDP_RELAY_UPSTREAM:-aero-webrtc-udp-relay:8080}

      # HSTS toggle (0 disables, recommended 31536000+ for production).
      AERO_HSTS_MAX_AGE: ${AERO_HSTS_MAX_AGE:-0}

      # Optional: additional `connect-src` origins to allow in the CSP.
      # Example: "https://proxy.example.com wss://proxy.example.com"
      AERO_CSP_CONNECT_SRC_EXTRA: ${AERO_CSP_CONNECT_SRC_EXTRA:-}
    volumes:
      - ./caddy/Caddyfile:/etc/caddy/Caddyfile:ro

      # Caddy data stores ACME certs (production) and its local CA (localhost).
      - caddy_data:/data
      - caddy_config:/config

      # Optional: serve a built frontend from the same origin as the gateway.
      #
      # Recommended production setup:
      #   - Build the repo-root Vite app to ../dist
      #   - Set AERO_FRONTEND_ROOT=../dist (or edit this file)
      #
      # Default: serve the deploy smoke-test frontend under deploy/static/.
      - type: bind
        source: ${AERO_FRONTEND_ROOT:-./static}
        target: /srv
        read_only: true
    depends_on:
      - aero-gateway
      - aero-l2-proxy
      - aero-webrtc-udp-relay

  # Backend "gateway" (HTTP + WS) that the browser talks to.
  #
  # This compose file assumes the gateway listens on plain HTTP inside the
  # docker network (TLS is terminated at the proxy).
  aero-gateway:
    # Canonical gateway implementation lives in `backend/aero-gateway`.
    #
    # For production, prefer a published image and remove the `build:` stanza,
    # or override it with your own compose file.
    image: ${AERO_GATEWAY_IMAGE:-aero-gateway:dev}
    build:
      context: ..
      dockerfile: backend/aero-gateway/Dockerfile
      args:
        GIT_SHA: ${AERO_GATEWAY_GIT_SHA:-dev}
    restart: unless-stopped
    depends_on:
      aero-session-secret:
        condition: service_completed_successfully
    expose:
      - "8080"
    volumes:
      - session_secret:/session_secret:ro
    command: >
      sh -c 'set -e;
      if [ -z "$$SESSION_SECRET" ]; then
        export SESSION_SECRET="$$(cat /session_secret/SESSION_SECRET)";
      fi;
      export AERO_GATEWAY_SESSION_SECRET="$$SESSION_SECRET";
      exec node dist/index.js'
    environment:
      # Common gateway deployment knobs (supported by backend/aero-gateway).
      #
      # When running behind the reverse proxy, use the public HTTPS origin for
      # origin allowlisting / absolute URL generation.
      PUBLIC_BASE_URL: https://${AERO_DOMAIN:-localhost}

      # Session signing secret (gateway session cookie). Strongly recommended for production.
      #
      # If unset, `aero-session-secret` generates a random secret and persists it in a Docker volume
      # so sessions survive restarts (until `docker compose down -v`).
      #
      # When using session-cookie auth for the L2 tunnel (`AERO_L2_AUTH_MODE=session` /
      # `cookie_or_jwt` / `session_or_token` / `session_and_token` on `aero-l2-proxy`), the L2 proxy
      # must share this secret so it can validate the same `aero_session` cookies minted by the
      # gateway.
      SESSION_SECRET: ${SESSION_SECRET:-}

      # Optional explicit origin allowlist (comma-separated). When unset/empty, the
      # gateway defaults to allowing the origin derived from PUBLIC_BASE_URL.
      ALLOWED_ORIGINS: ${ALLOWED_ORIGINS:-}

      # Optional: L2 tunnel payload limits surfaced in `POST /session`.
      #
      # These are owned/enforced by `crates/aero-l2-proxy`, but the browser client
      # uses `limits.l2` to cap outbound frames. Keep gateway + L2 proxy in sync
      # when overriding.
      AERO_L2_MAX_FRAME_PAYLOAD: ${AERO_L2_MAX_FRAME_PAYLOAD:-}
      AERO_L2_MAX_CONTROL_PAYLOAD: ${AERO_L2_MAX_CONTROL_PAYLOAD:-}

      # Same-origin UDP relay integration.
      #
      # This enables `POST /session` to return `udpRelay` connection info for browser
      # clients, pointing at the relay behind the same Caddy origin.
      UDP_RELAY_BASE_URL: https://${AERO_DOMAIN:-localhost}
      UDP_RELAY_AUTH_MODE: ${AUTH_MODE:-none}
      UDP_RELAY_API_KEY: ${API_KEY:-}
      UDP_RELAY_JWT_SECRET: ${JWT_SECRET:-}
      UDP_RELAY_TOKEN_TTL_SECONDS: ${UDP_RELAY_TOKEN_TTL_SECONDS:-300}
      UDP_RELAY_AUDIENCE: ${UDP_RELAY_AUDIENCE:-}
      UDP_RELAY_ISSUER: ${UDP_RELAY_ISSUER:-}

      # Enable trust for X-Forwarded-* only when the gateway is not directly
      # exposed to the public internet.
      TRUST_PROXY: ${TRUST_PROXY:-1}

      # Optional defense-in-depth: also set COOP/COEP headers at the gateway.
      # (The proxy already sets these at the edge.)
      CROSS_ORIGIN_ISOLATION: ${CROSS_ORIGIN_ISOLATION:-0}

  # L2 tunnel proxy (WebSocket).
  #
  # Receives Ethernet frames over WebSocket upgrades at /l2 and provides a
  # server-side network stack / egress policy for the VM.
  aero-l2-proxy:
    image: ${AERO_L2_PROXY_IMAGE:-aero-l2-proxy:dev}
    build:
      context: ..
      dockerfile: crates/aero-l2-proxy/Dockerfile
    restart: unless-stopped
    depends_on:
      aero-session-secret:
        condition: service_completed_successfully
    volumes:
      - session_secret:/session_secret:ro
    entrypoint:
      - sh
      - -c
      - >-
        set -e;
        if [ -z "$$AERO_L2_SESSION_SECRET" ] && [ -z "$$SESSION_SECRET" ]; then
          export SESSION_SECRET="$$(cat /session_secret/SESSION_SECRET)";
        fi;
        if [ -z "$$AERO_L2_SESSION_SECRET" ]; then
          export AERO_L2_SESSION_SECRET="$$SESSION_SECRET";
        fi;
        exec aero-l2-proxy
    environment:
      # L2 proxy listen address inside the container.
      AERO_L2_PROXY_LISTEN_ADDR: ${AERO_L2_PROXY_LISTEN_ADDR:-0.0.0.0:8090}

      # Origin enforcement (recommended).
      #
      # By default, only allow the same HTTPS origin served by the reverse proxy.
      # The L2 proxy accepts the shared `ALLOWED_ORIGINS` env var (also used by the gateway + WebRTC relay).
      # Append additional dev origins (comma-prefixed) via:
      #   AERO_L2_ALLOWED_ORIGINS_EXTRA=",https://localhost:5173"
      ALLOWED_ORIGINS: https://${AERO_DOMAIN:-localhost}
      AERO_L2_ALLOWED_ORIGINS_EXTRA: ${AERO_L2_ALLOWED_ORIGINS_EXTRA:-}

      # Optional: L2 tunnel payload limits (defense in depth).
      #
      # Keep these in sync with the gateway `POST /session` response (gateway reads
      # the same env vars when present).
      AERO_L2_MAX_FRAME_PAYLOAD: ${AERO_L2_MAX_FRAME_PAYLOAD:-}
      AERO_L2_MAX_CONTROL_PAYLOAD: ${AERO_L2_MAX_CONTROL_PAYLOAD:-}

      # L2 tunnel auth (Option C).
      #
      # Default: no authentication (`none`), only Origin allowlisting.
      #
      # Note: `crates/aero-l2-proxy` will auto-select an auth mode when `AERO_L2_AUTH_MODE` is unset
      # and a credential is present (e.g. `session_or_token` (legacy: `cookie_or_api_key`) when a
      # session secret is configured).
      # This deploy stack always has a session secret via `aero-session-secret`, so we explicitly
      # default `AERO_L2_AUTH_MODE` to `none` to keep `/l2` unauthenticated unless opted into.
      #
      # Session cookie auth (recommended for same-origin browser clients) validates the
      # `aero_session` cookie minted by `backend/aero-gateway` at `POST /session`.
      #
      # IMPORTANT: session-cookie auth requires the L2 proxy and gateway to share the same signing secret.
      # `crates/aero-l2-proxy` reads this from AERO_GATEWAY_SESSION_SECRET (preferred) and falls back to
      # SESSION_SECRET / AERO_L2_SESSION_SECRET (legacy).
      #
      # Supported auth modes: none, session, token, session_or_token, session_and_token, jwt, cookie_or_jwt
      # (legacy aliases: cookie, api_key, cookie_or_api_key, cookie_and_api_key)
      AERO_L2_AUTH_MODE: ${AERO_L2_AUTH_MODE:-none}
      AERO_L2_SESSION_SECRET: ${AERO_L2_SESSION_SECRET:-}
      SESSION_SECRET: ${SESSION_SECRET:-}
      AERO_GATEWAY_SESSION_SECRET: ${SESSION_SECRET:-}

      # Token/JWT auth configuration (only required when enabled via AERO_L2_AUTH_MODE).
      #
      AERO_L2_API_KEY: ${AERO_L2_API_KEY:-}
      AERO_L2_JWT_SECRET: ${AERO_L2_JWT_SECRET:-}
      AERO_L2_JWT_AUDIENCE: ${AERO_L2_JWT_AUDIENCE:-}
      AERO_L2_JWT_ISSUER: ${AERO_L2_JWT_ISSUER:-}

      # Legacy token (backwards compatibility).
      #
      # Note: this compose file defaults AERO_L2_AUTH_MODE=none, so setting AERO_L2_TOKEN has no
      # effect unless you explicitly enable token auth (e.g. `AERO_L2_AUTH_MODE=token`,
      # `session_or_token`, or `session_and_token`; legacy aliases: `api_key`, `cookie_or_api_key`,
      # `cookie_and_api_key`).
      #
      # Clients then provide the credential via:
      # - `?token=<value>` (preferred; `?apiKey=<value>` for compatibility), OR
      # - an additional `Sec-WebSocket-Protocol` entry `aero-l2-token.<value>` (offered alongside
      #   `aero-l2-tunnel-v1`).
      #
      # In token auth modes (`token`, `session_or_token`, `session_and_token`), this is also
      # accepted as a fallback value for `AERO_L2_API_KEY`.
      #
      # This is ignored when `AERO_L2_AUTH_MODE` is explicitly set to `session` (legacy: `cookie`),
      # `jwt`, `cookie_or_jwt`, or `none`.
      AERO_L2_TOKEN: ${AERO_L2_TOKEN:-}

      # Egress policy (highly recommended to set allowlists for production deployments).
      AERO_L2_ALLOW_PRIVATE_IPS: ${AERO_L2_ALLOW_PRIVATE_IPS:-0}
      # NOTE: Leave these unset by default; setting them to an empty string means
      # "deny all" (for port allowlists). Set them explicitly in `deploy/.env` to
      # opt into a deny-by-default policy.
      AERO_L2_ALLOWED_TCP_PORTS:
      AERO_L2_ALLOWED_UDP_PORTS:
      AERO_L2_ALLOWED_DOMAINS:
      AERO_L2_BLOCKED_DOMAINS:
    expose:
      - "8090"

  # WebRTC signaling + UDP relay for browser clients.
  #
  # IMPORTANT: WebRTC uses UDP ports directly; these cannot be reverse-proxied
  # through Caddy. Publish a UDP port range (and keep it aligned with
  # WEBRTC_UDP_PORT_MIN/MAX and firewall rules).
  aero-webrtc-udp-relay:
    image: ${AERO_WEBRTC_UDP_RELAY_IMAGE:-aero-webrtc-udp-relay:dev}
    build:
      context: ../proxy/webrtc-udp-relay
      args:
        BUILD_COMMIT: ${BUILD_COMMIT:-}
        BUILD_TIME: ${BUILD_TIME:-}
    restart: unless-stopped
    expose:
      - "8080"
    ports:
      # Must align with WEBRTC_UDP_PORT_MIN/MAX and any firewall rules.
      - "${WEBRTC_UDP_PORT_MIN:-50000}-${WEBRTC_UDP_PORT_MAX:-50100}:${WEBRTC_UDP_PORT_MIN:-50000}-${WEBRTC_UDP_PORT_MAX:-50100}/udp"
    environment:
      # Bind to all interfaces in containers (the binary defaults to 127.0.0.1).
      - AERO_WEBRTC_UDP_RELAY_LISTEN_ADDR=0.0.0.0:8080
      # Keep deployments same-origin by default. Append additional dev origins via:
      #   AERO_WEBRTC_UDP_RELAY_ALLOWED_ORIGINS_EXTRA=",https://localhost:5173"
      - ALLOWED_ORIGINS=https://${AERO_DOMAIN:-localhost}${AERO_WEBRTC_UDP_RELAY_ALLOWED_ORIGINS_EXTRA:-}

      # WebRTC ICE UDP port range (must match the published UDP range above).
      - WEBRTC_UDP_PORT_MIN=${WEBRTC_UDP_PORT_MIN:-50000}
      - WEBRTC_UDP_PORT_MAX=${WEBRTC_UDP_PORT_MAX:-50100}

      # Default STUN server (override via env or set AERO_ICE_SERVERS_JSON).
      - AERO_STUN_URLS=${AERO_STUN_URLS:-stun:stun.l.google.com:19302}

      # Optional auth / policy configuration (passed through when set in deploy/.env).
      - AUTH_MODE=${AUTH_MODE:-none}
      - API_KEY=${API_KEY:-}
      - JWT_SECRET=${JWT_SECRET:-}
      - SIGNALING_AUTH_TIMEOUT
      - MAX_SIGNALING_MESSAGE_BYTES
      - MAX_SIGNALING_MESSAGES_PER_SECOND

      # Optional: L2 tunnel bridging (WebRTC DataChannel label `l2` <-> backend WS `/l2`).
      #
      # The `l2` DataChannel MUST be fully reliable and ordered:
      #   - ordered=true
      #   - do not set maxRetransmits/maxPacketLifeTime (partial reliability)
      #
      # Enable by setting in `deploy/.env`:
      #   L2_BACKEND_WS_URL=ws://aero-l2-proxy:8090/l2
      #
      # Optional backend hardening:
      #   L2_BACKEND_ORIGIN=https://example.com       # alias: L2_BACKEND_ORIGIN_OVERRIDE
      #   L2_BACKEND_TOKEN=sekrit                     # offer Sec-WebSocket-Protocol entry aero-l2-token.<token> alongside aero-l2-tunnel-v1
      #
      # Then ensure the relay can forward auth material / headers to the backend:
      #   L2_BACKEND_AUTH_FORWARD_MODE=query
      #   L2_BACKEND_FORWARD_ORIGIN=1
      #   L2_BACKEND_FORWARD_AERO_SESSION=1           # forwards Cookie: aero_session=... (for AERO_L2_AUTH_MODE=session)
      - L2_BACKEND_WS_URL
      - L2_BACKEND_ORIGIN
      - L2_BACKEND_TOKEN
      - L2_BACKEND_ORIGIN_OVERRIDE
      - L2_BACKEND_WS_ORIGIN
      - L2_BACKEND_WS_TOKEN
      - L2_BACKEND_AUTH_FORWARD_MODE=${L2_BACKEND_AUTH_FORWARD_MODE:-query}
      - L2_BACKEND_FORWARD_ORIGIN=${L2_BACKEND_FORWARD_ORIGIN:-1}
      - L2_BACKEND_FORWARD_AERO_SESSION=${L2_BACKEND_FORWARD_AERO_SESSION:-0}
      - L2_MAX_MESSAGE_BYTES

      # UDP egress policy (highly recommended for public deployments).
      - DESTINATION_POLICY_PRESET
      - ALLOW_PRIVATE_NETWORKS
      - ALLOW_UDP_CIDRS
      - DENY_UDP_CIDRS
      - ALLOW_UDP_PORTS
      - DENY_UDP_PORTS

      # ICE server configuration / optional TURN REST.
      - AERO_ICE_SERVERS_JSON
      - AERO_TURN_URLS
      - AERO_TURN_USERNAME
      - AERO_TURN_CREDENTIAL
      - TURN_REST_SHARED_SECRET
      - TURN_REST_TTL_SECONDS
      - TURN_REST_USERNAME_PREFIX
      - TURN_REST_REALM
      - WEBRTC_NAT_1TO1_IPS
      - WEBRTC_NAT_1TO1_IP_CANDIDATE_TYPE
      - WEBRTC_UDP_LISTEN_IP

  # Optional TURN server (coturn) for NAT traversal.
  #
  # Enable with:
  #   docker compose -f deploy/docker-compose.yml --profile turn up --build
  coturn:
    image: coturn/coturn:latest
    profiles: ["turn"]
    restart: unless-stopped
    command: ["-c", "/etc/coturn/turnserver.conf", "--no-cli"]
    volumes:
      - ../proxy/webrtc-udp-relay/turn/turnserver.conf:/etc/coturn/turnserver.conf:ro
    ports:
      - "3478:3478/udp"
      # Must align with min-port/max-port in turnserver.conf.
      - "49152-49200:49152-49200/udp"

volumes:
  caddy_data:
  caddy_config:
  session_secret:
