# CANONICAL: Edge deployment for Aero (TLS termination + COOP/COEP/CSP security headers).
# Root-level compose files are service-specific examples; see `deploy/README.md`.

name: aero

services:
  # Reverse proxy / TLS terminator.
  #
  # Responsibilities:
  # - Terminates TLS on :443 (HTTP/2 enabled by default)
  # - Forces COOP/COEP/CORP headers at the edge for SharedArrayBuffer + WASM threads
  # - Proxies WebSocket upgrades (e.g. /tcp) and HTTP APIs (e.g. /dns-query) to the gateway
  aero-proxy:
    image: caddy:2.8.4
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    environment:
      # Hostname / domain name to serve.
      # - Local dev: "localhost"
      # - Production: "aero.example.com"
      AERO_DOMAIN: ${AERO_DOMAIN:-localhost}

      # Gateway upstream within the docker network.
      AERO_GATEWAY_UPSTREAM: ${AERO_GATEWAY_UPSTREAM:-aero-gateway:8080}

      # L2 tunnel proxy upstream within the docker network.
      AERO_L2_PROXY_UPSTREAM: ${AERO_L2_PROXY_UPSTREAM:-aero-l2-proxy:8090}

      # WebRTC UDP relay upstream (HTTP signaling / ICE discovery) within the docker network.
      AERO_WEBRTC_UDP_RELAY_UPSTREAM: ${AERO_WEBRTC_UDP_RELAY_UPSTREAM:-aero-webrtc-udp-relay:8080}

      # HSTS toggle (0 disables, recommended 31536000+ for production).
      AERO_HSTS_MAX_AGE: ${AERO_HSTS_MAX_AGE:-0}

      # Optional: additional `connect-src` origins to allow in the CSP.
      # Example: "https://proxy.example.com wss://proxy.example.com"
      AERO_CSP_CONNECT_SRC_EXTRA: ${AERO_CSP_CONNECT_SRC_EXTRA:-}
    volumes:
      - ./caddy/Caddyfile:/etc/caddy/Caddyfile:ro

      # Caddy data stores ACME certs (production) and its local CA (localhost).
      - caddy_data:/data
      - caddy_config:/config

      # Optional: serve a built frontend from the same origin as the gateway.
      #
      # Recommended production setup:
      #   - Build the web app to ../web/dist
      #   - Set AERO_FRONTEND_ROOT=../web/dist (or edit this file)
      #
      # Default: serve the deploy smoke-test frontend under deploy/static/.
      - type: bind
        source: ${AERO_FRONTEND_ROOT:-./static}
        target: /srv
        read_only: true
    depends_on:
      - aero-gateway
      - aero-l2-proxy
      - aero-webrtc-udp-relay

  # Backend "gateway" (HTTP + WS) that the browser talks to.
  #
  # This compose file assumes the gateway listens on plain HTTP inside the
  # docker network (TLS is terminated at the proxy).
  aero-gateway:
    # Canonical gateway implementation lives in `backend/aero-gateway`.
    #
    # For production, prefer a published image and remove the `build:` stanza,
    # or override it with your own compose file.
    image: ${AERO_GATEWAY_IMAGE:-aero-gateway:dev}
    build:
      context: ..
      dockerfile: backend/aero-gateway/Dockerfile
      args:
        GIT_SHA: ${AERO_GATEWAY_GIT_SHA:-dev}
    restart: unless-stopped
    expose:
      - "8080"
    environment:
      # Common gateway deployment knobs (supported by backend/aero-gateway).
      #
      # When running behind the reverse proxy, use the public HTTPS origin for
      # origin allowlisting / absolute URL generation.
      PUBLIC_BASE_URL: https://${AERO_DOMAIN:-localhost}

      # Optional explicit origin allowlist (comma-separated). When unset/empty, the
      # gateway defaults to allowing the origin derived from PUBLIC_BASE_URL.
      ALLOWED_ORIGINS: ${ALLOWED_ORIGINS:-}

      # Enable trust for X-Forwarded-* only when the gateway is not directly
      # exposed to the public internet.
      TRUST_PROXY: ${TRUST_PROXY:-1}

      # Optional defense-in-depth: also set COOP/COEP headers at the gateway.
      # (The proxy already sets these at the edge.)
      CROSS_ORIGIN_ISOLATION: ${CROSS_ORIGIN_ISOLATION:-0}

  # L2 tunnel proxy (WebSocket).
  #
  # Receives Ethernet frames over WebSocket upgrades at /l2 and provides a
  # server-side network stack / egress policy for the VM.
  aero-l2-proxy:
    image: ${AERO_L2_PROXY_IMAGE:-aero-l2-proxy:dev}
    build:
      context: ..
      dockerfile: crates/aero-l2-proxy/Dockerfile
    restart: unless-stopped
    environment:
      # L2 proxy listen address inside the container.
      AERO_L2_PROXY_LISTEN_ADDR: ${AERO_L2_PROXY_LISTEN_ADDR:-0.0.0.0:8090}

      # Egress policy (highly recommended to set allowlists for production deployments).
      AERO_L2_ALLOW_PRIVATE_IPS: ${AERO_L2_ALLOW_PRIVATE_IPS:-0}
      AERO_L2_ALLOWED_TCP_PORTS: ${AERO_L2_ALLOWED_TCP_PORTS:-}
      AERO_L2_ALLOWED_UDP_PORTS: ${AERO_L2_ALLOWED_UDP_PORTS:-}
      AERO_L2_ALLOWED_DOMAINS: ${AERO_L2_ALLOWED_DOMAINS:-}
      AERO_L2_BLOCKED_DOMAINS: ${AERO_L2_BLOCKED_DOMAINS:-}
    expose:
      - "8090"

  # WebRTC signaling + UDP relay for browser clients.
  #
  # IMPORTANT: WebRTC uses UDP ports directly; these cannot be reverse-proxied
  # through Caddy. Publish a UDP port range (and keep it aligned with
  # WEBRTC_UDP_PORT_MIN/MAX and firewall rules).
  aero-webrtc-udp-relay:
    image: ${AERO_WEBRTC_UDP_RELAY_IMAGE:-aero-webrtc-udp-relay:dev}
    build:
      context: ../proxy/webrtc-udp-relay
      args:
        BUILD_COMMIT: ${BUILD_COMMIT:-}
        BUILD_TIME: ${BUILD_TIME:-}
    restart: unless-stopped
    expose:
      - "8080"
    ports:
      # Must align with WEBRTC_UDP_PORT_MIN/MAX and any firewall rules.
      - "${WEBRTC_UDP_PORT_MIN:-50000}-${WEBRTC_UDP_PORT_MAX:-50100}:${WEBRTC_UDP_PORT_MIN:-50000}-${WEBRTC_UDP_PORT_MAX:-50100}/udp"
    environment:
      # Bind to all interfaces in containers (the binary defaults to 127.0.0.1).
      - AERO_WEBRTC_UDP_RELAY_LISTEN_ADDR=0.0.0.0:8080
      # Keep deployments same-origin by default. Append additional dev origins via:
      #   AERO_WEBRTC_UDP_RELAY_ALLOWED_ORIGINS_EXTRA=",https://localhost:5173"
      - ALLOWED_ORIGINS=https://${AERO_DOMAIN:-localhost}${AERO_WEBRTC_UDP_RELAY_ALLOWED_ORIGINS_EXTRA:-}

      # WebRTC ICE UDP port range (must match the published UDP range above).
      - WEBRTC_UDP_PORT_MIN=${WEBRTC_UDP_PORT_MIN:-50000}
      - WEBRTC_UDP_PORT_MAX=${WEBRTC_UDP_PORT_MAX:-50100}

      # Default STUN server (override via env or set AERO_ICE_SERVERS_JSON).
      - AERO_STUN_URLS=${AERO_STUN_URLS:-stun:stun.l.google.com:19302}

      # Optional auth / policy configuration (passed through when set in deploy/.env).
      - AUTH_MODE
      - API_KEY
      - JWT_SECRET
      - SIGNALING_AUTH_TIMEOUT
      - MAX_SIGNALING_MESSAGE_BYTES
      - MAX_SIGNALING_MESSAGES_PER_SECOND

      # UDP egress policy (highly recommended for public deployments).
      - DESTINATION_POLICY_PRESET
      - ALLOW_PRIVATE_NETWORKS
      - ALLOW_UDP_CIDRS
      - DENY_UDP_CIDRS
      - ALLOW_UDP_PORTS
      - DENY_UDP_PORTS

      # ICE server configuration / optional TURN REST.
      - AERO_ICE_SERVERS_JSON
      - AERO_TURN_URLS
      - AERO_TURN_USERNAME
      - AERO_TURN_CREDENTIAL
      - TURN_REST_SHARED_SECRET
      - TURN_REST_TTL_SECONDS
      - TURN_REST_USERNAME_PREFIX
      - TURN_REST_REALM
      - WEBRTC_NAT_1TO1_IPS
      - WEBRTC_NAT_1TO1_IP_CANDIDATE_TYPE
      - WEBRTC_UDP_LISTEN_IP

  # Optional TURN server (coturn) for NAT traversal.
  #
  # Enable with:
  #   docker compose -f deploy/docker-compose.yml --profile turn up --build
  coturn:
    image: coturn/coturn:latest
    profiles: ["turn"]
    restart: unless-stopped
    command: ["-c", "/etc/coturn/turnserver.conf", "--no-cli"]
    volumes:
      - ../proxy/webrtc-udp-relay/turn/turnserver.conf:/etc/coturn/turnserver.conf:ro
    ports:
      - "3478:3478/udp"
      # Must align with min-port/max-port in turnserver.conf.
      - "49152-49200:49152-49200/udp"

volumes:
  caddy_data:
  caddy_config:
