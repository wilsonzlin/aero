{
	# Global options.
	#
	# We intentionally do not set a global ACME email here because it would make
	# the file invalid when an env var is unset. If you want an email contact
	# for certificate expiry notices, configure it explicitly in your own fork.
	# Note: auto_https is enabled by default.
}

(aero_headers) {
	# Required for:
	# - SharedArrayBuffer + WASM threads (cross-origin isolated pages)
	# - Origin-keyed agent clusters (consistent browsing context separation)
	header {
		Cross-Origin-Opener-Policy "same-origin"
		Cross-Origin-Embedder-Policy "require-corp"
		Cross-Origin-Resource-Policy "same-origin"
		Origin-Agent-Cluster "?1"

		# Basic hardening.
		X-Content-Type-Options "nosniff"
		Referrer-Policy "no-referrer"
		Permissions-Policy "camera=(), geolocation=(), microphone=(self), usb=(self)"

		# CSP: allow same-origin ESM, WASM JIT via `wasm-unsafe-eval`, and module workers.
		#
		# Keep the origin single-tenant: if you need to connect to a separate proxy
		# origin, tighten/extend `connect-src` deliberately (see docs/security-headers.md).
		# `aero-gateway.invalid` is a documentation-only placeholder (the `.invalid` TLD will never
		# resolve). Replace it with the exact gateway/proxy origin(s) you want to allow, or remove
		# it entirely for strict single-origin deployments.
		# Optionally append additional allowed connect-src origins via env var:
		#   AERO_CSP_CONNECT_SRC_EXTRA="https://proxy.example.com wss://proxy.example.com"
		Content-Security-Policy "default-src 'none'; base-uri 'none'; object-src 'none'; frame-ancestors 'none'; script-src 'self' 'wasm-unsafe-eval'; worker-src 'self' blob:; connect-src 'self' https://aero-gateway.invalid wss://aero-gateway.invalid {$AERO_CSP_CONNECT_SRC_EXTRA}; img-src 'self' data: blob:; style-src 'self'; font-src 'self'"

		# HSTS is enabled by setting a non-zero max-age.
		# - Local dev default: max-age=0 (disabled)
		# - Production recommended: 31536000 (1 year) or higher
		Strict-Transport-Security "max-age={$AERO_HSTS_MAX_AGE:0}"
	}
}

{$AERO_DOMAIN:localhost} {
	encode zstd gzip

	# WebSocket L2 tunnel proxy endpoint.
	@aero_l2 path /l2*
	handle @aero_l2 {
		import aero_headers
		reverse_proxy {$AERO_L2_PROXY_UPSTREAM:aero-l2-proxy:8090}
	}

	# WebRTC signaling / ICE discovery for the UDP relay service.
	# NOTE: `GET /udp` is a WebSocket UDP relay fallback endpoint. Do not use `/udp*`
	# here, otherwise `/udp-relay/*` (gateway endpoints) would be routed to the relay.
	@aero_webrtc_udp_relay path /webrtc* /offer /udp
	handle @aero_webrtc_udp_relay {
		import aero_headers
		reverse_proxy {$AERO_WEBRTC_UDP_RELAY_UPSTREAM:aero-webrtc-udp-relay:8080}
	}

	# WebSocket TCP proxy endpoint and HTTP APIs.
	@aero_gateway path /tcp* /tcp-mux* /session* /udp-relay* /dns-query* /dns-json* /api* /healthz* /readyz* /version* /metrics*
	handle @aero_gateway {
		import aero_headers
		reverse_proxy {$AERO_GATEWAY_UPSTREAM:aero-gateway:8080}
	}

	# Static frontend assets (optional).
	#
	# Mount your built frontend to /srv (see docker-compose.yml) to serve the
	# UI and the gateway from the same origin.
	@aero_wasm path_regexp aero_wasm ^/assets/.*\.wasm$
	@aero_assets path /assets/*
	handle @aero_assets {
		import aero_headers
		header Cache-Control "public, max-age=31536000, immutable"
		# `WebAssembly.compileStreaming` requires `application/wasm`.
		header @aero_wasm Content-Type "application/wasm"
		root * /srv
		file_server
	}

	handle {
		import aero_headers
		header Cache-Control "no-cache"
		root * /srv
		try_files {path} {path}/ /index.html
		file_server
	}
}
