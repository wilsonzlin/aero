<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Input Capture â†’ IO worker fixture</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        height: 100%;
      }
      canvas {
        width: 640px;
        height: 480px;
        border: 1px solid #000;
      }
    </style>
  </head>
  <body>
    <canvas id="emu" width="640" height="480"></canvas>
      <script type="module">
        import { InputCapture } from "/web/src/input/input_capture.ts";
        import { allocateSharedMemorySegments, createSharedMemoryViews, StatusIndex } from "/web/src/runtime/shared_layout.ts";
        import { emptySetBootDisksMessage } from "/web/src/runtime/boot_disks_protocol.ts";

      const canvas = /** @type {HTMLCanvasElement} */ (document.getElementById("emu"));

      // Deterministic pointer lock shim for headless tests.
      let plElement = null;
      Object.defineProperty(document, "pointerLockElement", {
        configurable: true,
        get() {
          return plElement;
        },
      });

      canvas.requestPointerLock = () => {
        window.__plRequestCount = (window.__plRequestCount || 0) + 1;
        plElement = canvas;
        document.dispatchEvent(new Event("pointerlockchange"));
      };

      document.exitPointerLock = () => {
        plElement = null;
        document.dispatchEvent(new Event("pointerlockchange"));
      };

      // Create a real IO worker and expose its shared status view so Playwright can assert receipt.
      const segments = allocateSharedMemorySegments();
      const views = createSharedMemoryViews(segments);
       window.__ioStatus = views.status;
       window.__ioReadyIndex = StatusIndex.IoReady;
        window.__ioInputBatchCounterIndex = StatusIndex.IoInputBatchCounter;
        window.__ioInputEventCounterIndex = StatusIndex.IoInputEventCounter;

       // Capture the most recent input batch payload (decoded) so Playwright tests can assert that
       // specific event types (e.g. consumer/media keys) are present, while still exercising the
       // real IO worker as the receiver.
       window.__lastInputBatchEvents = null;
       const onBeforeSendBatch = (_buffer, words, count, _recycle) => {
         const out = [];
         const base = 2;
         for (let i = 0; i < count; i++) {
           const off = base + i * 4;
           out.push([words[off] >>> 0, words[off + 1] >>> 0, words[off + 2] | 0, words[off + 3] | 0]);
         }
         window.__lastInputBatchEvents = out;
       };

          // WebKit can fail to load large module workers directly via `new Worker(httpUrl, { type: "module" })`
          // (it emits an `error` event without useful details). Wrap the module entrypoint in a tiny
          // blob-based module worker and import the real worker from there for cross-browser stability.
          const ioWorkerEntrypoint = new URL("/web/src/workers/io.worker.ts", location.href).toString();
          const ioWorkerWrapperUrl = URL.createObjectURL(
            new Blob(
              [
                `\n            (async () => {\n              try {\n                await import(${JSON.stringify(ioWorkerEntrypoint)});\n                setTimeout(() => self.postMessage({ type: \"__aero_io_worker_imported\" }), 0);\n              } catch (err) {\n                const msg = err instanceof Error ? err.message : String(err);\n                setTimeout(() => self.postMessage({ type: \"__aero_io_worker_import_failed\", message: msg }), 0);\n              }\n            })();\n          `,
              ],
              { type: "text/javascript" },
            ),
          );
          const ioWorker = new Worker(ioWorkerWrapperUrl, { type: "module" });

          const ioWorkerImported = new Promise((resolve, reject) => {
            let timer = 0;
            const cleanup = () => {
              if (timer) clearTimeout(timer);
              ioWorker.removeEventListener("message", onMessage);
              ioWorker.removeEventListener("error", onError);
            };
            const onMessage = (ev) => {
              const data = ev.data;
              if (!data || typeof data !== "object") return;
              if (data.type === "__aero_io_worker_imported") {
                cleanup();
                resolve();
                return;
              }
              if (data.type === "__aero_io_worker_import_failed") {
                cleanup();
                reject(new Error(`io.worker wrapper import failed: ${typeof data.message === "string" ? data.message : "unknown error"}`));
              }
            };
            const onError = (ev) => {
              cleanup();
              reject(new Error(`io.worker wrapper error during import: ${ev?.message || "worker error"}`));
            };
            ioWorker.addEventListener("message", onMessage);
            ioWorker.addEventListener("error", onError);
            timer = setTimeout(() => {
              cleanup();
              reject(new Error("Timed out waiting for io.worker import marker"));
            }, 20_000);
          });

          await ioWorkerImported;

          // io.worker waits for an initial boot disk selection message before reporting READY.
          // This fixture doesn't mount any disks, but it still needs the worker to reach READY so
          // input batching can be tested deterministically.
          ioWorker.postMessage(emptySetBootDisksMessage());
          ioWorker.postMessage({
            kind: "init",
            role: "io",
            controlSab: segments.control,
            guestMemory: segments.guestMemory,
            ioIpcSab: segments.ioIpc,
            sharedFramebuffer: segments.sharedFramebuffer,
            sharedFramebufferOffsetBytes: segments.sharedFramebufferOffsetBytes,
            scanoutState: segments.scanoutState,
            scanoutStateOffsetBytes: segments.scanoutStateOffsetBytes,
          });

       window.__capture = new InputCapture(canvas, ioWorker, {
         flushHz: 1000,
         mouseSensitivity: 1.0,
         onBeforeSendBatch,
       });

      window.__capture.start();
    </script>
  </body>
</html>
