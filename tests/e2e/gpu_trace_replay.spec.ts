import { test, expect } from "@playwright/test";
import fs from "node:fs";
import path from "node:path";

test("gpu trace replays deterministically (triangle)", async ({ page }) => {
  const toolPath = path.resolve(__dirname, "../../web/tools/gpu_trace_replay.ts");
  const tracePath = path.resolve(__dirname, "../fixtures/triangle.aerogputrace");

  const traceBytes = fs.readFileSync(tracePath);
  const traceB64 = traceBytes.toString("base64");

  await page.setContent(`
    <canvas id="record" width="64" height="64"></canvas>
    <canvas id="replay" width="64" height="64"></canvas>
  `);
  await page.addScriptTag({ path: toolPath });

  const analysis = await page.evaluate(async (b64) => {
    const raw = atob(b64);
    const bytes = new Uint8Array(raw.length);
    for (let i = 0; i < raw.length; i++) bytes[i] = raw.charCodeAt(i);

    const recordCanvas = document.getElementById("record");
    const replayCanvas = document.getElementById("replay");
    if (!recordCanvas || !replayCanvas) throw new Error("missing canvas");

    const rec = await window.AeroGpuTraceReplay.recordTriangleTrace(recordCanvas, { backend: "webgl2" });

    // Ensure our browser-side recorder emits identical bytes to the committed fixture
    // generated by the Rust `aero-gpu-trace` test.
    let recStr = "";
    for (let i = 0; i < rec.bytes.length; i++) recStr += String.fromCharCode(rec.bytes[i]);
    const recordedB64 = btoa(recStr);
    const bytesMatch = recordedB64 === b64;

    const replayer = await window.AeroGpuTraceReplay.load(rec.bytes, replayCanvas, { backend: "webgl2" });
    await replayer.replayFrame(0);

    const pixels = replayer.readPixels();

    let nonRed = 0;
    for (let i = 0; i < pixels.length; i += 4) {
      const r = pixels[i + 0];
      const g = pixels[i + 1];
      const b = pixels[i + 2];
      const a = pixels[i + 3];
      // Allow tiny error. (In practice, this should be exact.)
      if (r < 250 || g > 5 || b > 5 || a < 250) nonRed++;
    }

    return { bytesMatch, nonRed, totalPixels: pixels.length / 4 };
  }, traceB64);

  expect(analysis.nonRed).toBe(0);
  expect(analysis.bytesMatch).toBe(true);
});
