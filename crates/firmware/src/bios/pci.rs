use super::Bios;
use aero_pci_routing as pci_routing;

/// Access to PCI configuration space used by BIOS during enumeration.
///
/// The BIOS only needs config mechanism 1-style dword accesses to:
/// - discover devices (vendor/device ID at 0x00)
/// - read `Interrupt Pin` (0x3D, high byte of 0x3C dword)
/// - program `Interrupt Line` (0x3C, low byte)
pub trait PciConfigSpace {
    /// Read a 32-bit PCI config register (`offset` must be 4-byte aligned).
    fn read_config_dword(&mut self, bus: u8, device: u8, function: u8, offset: u8) -> u32;

    /// Write a 32-bit PCI config register (`offset` must be 4-byte aligned).
    fn write_config_dword(&mut self, bus: u8, device: u8, function: u8, offset: u8, value: u32);
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct PciDevice {
    pub bus: u8,
    pub device: u8,
    pub function: u8,
    pub vendor_id: u16,
    pub device_id: u16,
    /// 24-bit class/subclass/prog-if.
    pub class_code: u32,
    /// Value written to the Interrupt Line register (0x3C).
    pub irq_line: u8,
}

impl Bios {
    pub(super) fn enumerate_pci(&mut self, pci: &mut dyn PciConfigSpace) {
        self.pci_devices.clear();

        for bus in 0u8..=0xFF {
            for device in 0u8..32 {
                for function in 0u8..8 {
                    let id = pci.read_config_dword(bus, device, function, 0x00);
                    let vendor_id = (id & 0xFFFF) as u16;
                    if vendor_id == 0xFFFF {
                        if function == 0 {
                            break;
                        }
                        continue;
                    }

                    let device_id = (id >> 16) as u16;
                    let class_reg = pci.read_config_dword(bus, device, function, 0x08);
                    let class_code = (class_reg >> 8) & 0x00FF_FFFF;

                    // Interrupt Line / Pin.
                    let reg_3c = pci.read_config_dword(bus, device, function, 0x3C);
                    let interrupt_pin = ((reg_3c >> 8) & 0xFF) as u8; // 1=INTA#, 2=INTB#, ...
                    let irq_line = assign_pci_irq(self.config.pirq_to_gsi, device, interrupt_pin);

                    // Program Interrupt Line register (0x3C, low byte).
                    let new_3c = (reg_3c & 0xFFFF_FF00) | irq_line as u32;
                    pci.write_config_dword(bus, device, function, 0x3C, new_3c);

                    self.pci_devices.push(PciDevice {
                        bus,
                        device,
                        function,
                        vendor_id,
                        device_id,
                        class_code,
                        irq_line,
                    });

                    if function == 0 {
                        // Header Type lives at 0x0E (bits 23:16 of config dword at 0x0C).
                        let header = pci.read_config_dword(bus, device, function, 0x0C);
                        let header_type = ((header >> 16) & 0xFF) as u8;
                        let is_multifunction = (header_type & 0x80) != 0;
                        if !is_multifunction {
                            break;
                        }
                    }
                }
            }
        }
    }
}

fn assign_pci_irq(pirq_to_gsi: [u32; 4], device: u8, interrupt_pin: u8) -> u8 {
    // Keep BIOS Interrupt Line programming consistent with the ACPI DSDT `_PRT` generated by
    // `aero-acpi` and the device-model INTx router (`aero-devices`).
    pci_routing::irq_line_for_intx(pirq_to_gsi, device, interrupt_pin)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::bios::BiosConfig;
    use crate::bios::{InMemoryDisk, TestMemory};
    use aero_cpu_core::state::{CpuMode, CpuState};

    #[derive(Clone, Debug)]
    struct DevCfg {
        id: u32,
        class: u32,
        header: u32,
        reg_3c: u32,
    }

    struct TestPciCfg {
        devs: Vec<(u8, u8, u8, DevCfg)>,
    }

    impl TestPciCfg {
        fn new() -> Self {
            Self { devs: Vec::new() }
        }

        fn add_dev(
            &mut self,
            bus: u8,
            device: u8,
            function: u8,
            vendor: u16,
            dev_id: u16,
            pin: u8,
        ) {
            let id = u32::from(dev_id) << 16 | u32::from(vendor);
            let reg_3c = u32::from(pin) << 8;
            self.devs.push((
                bus,
                device,
                function,
                DevCfg {
                    id,
                    class: 0,
                    header: 0,
                    reg_3c,
                },
            ));
        }

        fn dev_mut(&mut self, bus: u8, device: u8, function: u8) -> Option<&mut DevCfg> {
            self.devs.iter_mut().find_map(|(b, d, f, cfg)| {
                (*b == bus && *d == device && *f == function).then_some(cfg)
            })
        }
    }

    impl PciConfigSpace for TestPciCfg {
        fn read_config_dword(&mut self, bus: u8, device: u8, function: u8, offset: u8) -> u32 {
            let Some(cfg) = self.dev_mut(bus, device, function) else {
                return 0xFFFF_FFFF;
            };

            match offset {
                0x00 => cfg.id,
                0x08 => cfg.class,
                0x0C => cfg.header,
                0x3C => cfg.reg_3c,
                _ => 0,
            }
        }

        fn write_config_dword(
            &mut self,
            bus: u8,
            device: u8,
            function: u8,
            offset: u8,
            value: u32,
        ) {
            let Some(cfg) = self.dev_mut(bus, device, function) else {
                return;
            };

            if offset == 0x3C {
                cfg.reg_3c = value;
            }
        }
    }

    #[test]
    fn post_programs_pci_interrupt_line_using_intx_swizzle_and_pirq_map() {
        let mut mem = TestMemory::new(16 * 1024 * 1024);
        let mut cpu = CpuState::new(CpuMode::Real);
        let mut sector = [0u8; 512];
        sector[510] = 0x55;
        sector[511] = 0xAA;
        let mut disk = InMemoryDisk::from_boot_sector(sector);

        let mut pci = TestPciCfg::new();
        // Bus 0, device 1, function 0, INTA#.
        pci.add_dev(0, 1, 0, 0x1234, 0x5678, 1);
        // Bus 0, device 2, function 0, INTD#.
        pci.add_dev(0, 2, 0, 0x1234, 0x9999, 4);
        // Bus 0, device 3, function 0, no INTx pin (Interrupt Pin=0).
        pci.add_dev(0, 3, 0, 0x1234, 0xAAAA, 0);

        let mut bios = crate::bios::Bios::new(BiosConfig {
            enable_acpi: false,
            ..BiosConfig::default()
        });
        let pirq_to_gsi = bios.config.pirq_to_gsi;

        bios.post_with_pci(&mut cpu, &mut mem, &mut disk, None, Some(&mut pci));

        let dev1 = pci.dev_mut(0, 1, 0).unwrap();
        assert_eq!(
            dev1.reg_3c & 0xFF,
            u32::from(pci_routing::irq_line_for_intx(pirq_to_gsi, 1, 1))
        );
        assert_eq!((dev1.reg_3c >> 8) & 0xFF, 1); // pin preserved

        let dev2 = pci.dev_mut(0, 2, 0).unwrap();
        assert_eq!(
            dev2.reg_3c & 0xFF,
            u32::from(pci_routing::irq_line_for_intx(pirq_to_gsi, 2, 4))
        );
        assert_eq!((dev2.reg_3c >> 8) & 0xFF, 4); // pin preserved

        // interrupt_pin_cfg=0 => BIOS should program the conventional 0xFF sentinel.
        let dev3 = pci.dev_mut(0, 3, 0).unwrap();
        assert_eq!(dev3.reg_3c & 0xFF, 0xFF);
        assert_eq!((dev3.reg_3c >> 8) & 0xFF, 0); // pin preserved

        // BIOS bookkeeping should reflect the assigned line too.
        let seen = bios
            .pci_devices()
            .iter()
            .map(|d| (d.bus, d.device, d.function, d.irq_line))
            .collect::<Vec<_>>();
        assert!(seen.contains(&(0, 1, 0, pci_routing::irq_line_for_intx(pirq_to_gsi, 1, 1))));
        assert!(seen.contains(&(0, 2, 0, pci_routing::irq_line_for_intx(pirq_to_gsi, 2, 4))));
        assert!(seen.contains(&(0, 3, 0, 0xFF)));
    }

    #[test]
    fn enumerate_pci_scans_all_functions_when_multifunction_bit_set() {
        let mut pci = TestPciCfg::new();
        let dev = 5;

        // Present function 0 with the multifunction bit set, and also populate function 1.
        pci.add_dev(0, dev, 0, 0x1234, 0x1112, 1);
        pci.add_dev(0, dev, 1, 0x1234, 0x2222, 1);
        pci.dev_mut(0, dev, 0).unwrap().header = 0x80u32 << 16;

        let mut bios = Bios::new(BiosConfig {
            enable_acpi: false,
            ..BiosConfig::default()
        });
        bios.enumerate_pci(&mut pci);

        let funcs = bios
            .pci_devices()
            .iter()
            .filter(|d| d.bus == 0 && d.device == dev)
            .map(|d| d.function)
            .collect::<Vec<_>>();
        assert_eq!(funcs, vec![0, 1]);
    }

    #[test]
    fn enumerate_pci_does_not_scan_additional_functions_when_multifunction_bit_clear() {
        let mut pci = TestPciCfg::new();
        let dev = 6;

        // Present function 0 with the multifunction bit clear, but also populate function 1.
        // BIOS enumeration should stop after function 0 and never touch function 1.
        pci.add_dev(0, dev, 0, 0x1234, 0x1112, 1);
        pci.add_dev(0, dev, 1, 0x1234, 0x2222, 1);
        pci.dev_mut(0, dev, 0).unwrap().header = 0x00u32 << 16;

        let mut bios = Bios::new(BiosConfig {
            enable_acpi: false,
            ..BiosConfig::default()
        });
        bios.enumerate_pci(&mut pci);

        let funcs = bios
            .pci_devices()
            .iter()
            .filter(|d| d.bus == 0 && d.device == dev)
            .map(|d| d.function)
            .collect::<Vec<_>>();
        assert_eq!(funcs, vec![0]);

        // Since fn1 wasn't scanned, it shouldn't have had its Interrupt Line programmed.
        let fn1 = pci.dev_mut(0, dev, 1).unwrap();
        assert_eq!(fn1.reg_3c & 0xFF, 0);
    }
}
