use super::Bios;

/// Access to PCI configuration space used by BIOS during enumeration.
///
/// The BIOS only needs config mechanism 1-style dword accesses to:
/// - discover devices (vendor/device ID at 0x00)
/// - read `Interrupt Pin` (0x3D, high byte of 0x3C dword)
/// - program `Interrupt Line` (0x3C, low byte)
pub trait PciConfigSpace {
    /// Read a 32-bit PCI config register (`offset` must be 4-byte aligned).
    fn read_config_dword(&mut self, bus: u8, device: u8, function: u8, offset: u8) -> u32;

    /// Write a 32-bit PCI config register (`offset` must be 4-byte aligned).
    fn write_config_dword(&mut self, bus: u8, device: u8, function: u8, offset: u8, value: u32);
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct PciDevice {
    pub bus: u8,
    pub device: u8,
    pub function: u8,
    pub vendor_id: u16,
    pub device_id: u16,
    /// 24-bit class/subclass/prog-if.
    pub class_code: u32,
    /// Value written to the Interrupt Line register (0x3C).
    pub irq_line: u8,
}

impl Bios {
    pub(super) fn enumerate_pci(&mut self, pci: &mut dyn PciConfigSpace) {
        self.pci_devices.clear();

        for bus in 0u8..=0xFF {
            for device in 0u8..32 {
                for function in 0u8..8 {
                    let id = pci.read_config_dword(bus, device, function, 0x00);
                    let vendor_id = (id & 0xFFFF) as u16;
                    if vendor_id == 0xFFFF {
                        if function == 0 {
                            break;
                        }
                        continue;
                    }

                    let device_id = (id >> 16) as u16;
                    let class_reg = pci.read_config_dword(bus, device, function, 0x08);
                    let class_code = (class_reg >> 8) & 0x00FF_FFFF;

                    // Interrupt Line / Pin.
                    let reg_3c = pci.read_config_dword(bus, device, function, 0x3C);
                    let interrupt_pin = ((reg_3c >> 8) & 0xFF) as u8; // 1=INTA#, 2=INTB#, ...
                    let irq_line = assign_pci_irq(self.config.pirq_to_gsi, device, interrupt_pin);

                    // Program Interrupt Line register (0x3C, low byte).
                    let new_3c = (reg_3c & 0xFFFF_FF00) | irq_line as u32;
                    pci.write_config_dword(bus, device, function, 0x3C, new_3c);

                    self.pci_devices.push(PciDevice {
                        bus,
                        device,
                        function,
                        vendor_id,
                        device_id,
                        class_code,
                        irq_line,
                    });

                    if function == 0 {
                        // Header Type lives at 0x0E (bits 23:16 of config dword at 0x0C).
                        let header = pci.read_config_dword(bus, device, function, 0x0C);
                        let header_type = ((header >> 16) & 0xFF) as u8;
                        let is_multifunction = (header_type & 0x80) != 0;
                        if !is_multifunction {
                            break;
                        }
                    }
                }
            }
        }
    }
}

fn assign_pci_irq(pirq_to_gsi: [u32; 4], device: u8, interrupt_pin: u8) -> u8 {
    // Deterministic, QEMU-style INTx swizzle:
    //
    // - Compute PIRQ from the slot device number + the function's Interrupt Pin:
    //     PIRQ = (pin + device) mod 4
    //   where `pin` is 0 for INTA#, 1 for INTB#, etc.
    // - Map PIRQ[A-D] -> platform GSI (commonly 10-13).
    //
    // This must match the mapping used by the ACPI DSDT `_PRT` generated by `aero-acpi`.
    if interrupt_pin == 0 {
        return 0xFF;
    }
    let pin_index = interrupt_pin.wrapping_sub(1) & 0x03;
    let pirq = device.wrapping_add(pin_index) & 0x03;
    let gsi = pirq_to_gsi[pirq as usize];
    u8::try_from(gsi).unwrap_or(0xFF)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::bios::BiosConfig;
    use machine::{CpuState, InMemoryDisk, PhysicalMemory};

    #[derive(Clone, Debug)]
    struct DevCfg {
        id: u32,
        class: u32,
        header: u32,
        reg_3c: u32,
    }

    struct TestPciCfg {
        devs: Vec<(u8, u8, u8, DevCfg)>,
    }

    impl TestPciCfg {
        fn new() -> Self {
            Self { devs: Vec::new() }
        }

        fn add_dev(
            &mut self,
            bus: u8,
            device: u8,
            function: u8,
            vendor: u16,
            dev_id: u16,
            pin: u8,
        ) {
            let id = u32::from(dev_id) << 16 | u32::from(vendor);
            let reg_3c = u32::from(pin) << 8;
            self.devs.push((
                bus,
                device,
                function,
                DevCfg {
                    id,
                    class: 0,
                    header: 0,
                    reg_3c,
                },
            ));
        }

        fn dev_mut(&mut self, bus: u8, device: u8, function: u8) -> Option<&mut DevCfg> {
            self.devs.iter_mut().find_map(|(b, d, f, cfg)| {
                (*b == bus && *d == device && *f == function).then_some(cfg)
            })
        }
    }

    impl PciConfigSpace for TestPciCfg {
        fn read_config_dword(&mut self, bus: u8, device: u8, function: u8, offset: u8) -> u32 {
            let Some(cfg) = self.dev_mut(bus, device, function) else {
                return 0xFFFF_FFFF;
            };

            match offset {
                0x00 => cfg.id,
                0x08 => cfg.class,
                0x0C => cfg.header,
                0x3C => cfg.reg_3c,
                _ => 0,
            }
        }

        fn write_config_dword(
            &mut self,
            bus: u8,
            device: u8,
            function: u8,
            offset: u8,
            value: u32,
        ) {
            let Some(cfg) = self.dev_mut(bus, device, function) else {
                return;
            };

            if offset == 0x3C {
                cfg.reg_3c = value;
            }
        }
    }

    #[test]
    fn post_programs_pci_interrupt_line_using_intx_swizzle_and_pirq_map() {
        let mut mem = PhysicalMemory::new(16 * 1024 * 1024);
        let mut cpu = CpuState::default();
        let mut sector = [0u8; 512];
        sector[510] = 0x55;
        sector[511] = 0xAA;
        let mut disk = InMemoryDisk::from_boot_sector(sector);

        let mut pci = TestPciCfg::new();
        // Bus 0, device 1, function 0, INTA#.
        pci.add_dev(0, 1, 0, 0x1234, 0x5678, 1);
        // Bus 0, device 2, function 0, INTD#.
        pci.add_dev(0, 2, 0, 0x1234, 0x9999, 4);

        let mut bios = crate::bios::Bios::new(BiosConfig {
            enable_acpi: false,
            ..BiosConfig::default()
        });

        bios.post_with_pci(&mut cpu, &mut mem, &mut disk, Some(&mut pci));

        // With PIRQ[A-D] -> [10,11,12,13] and swizzle (pin+device)%4:
        // dev1 INTA (pin=0) -> index 1 -> 11.
        let dev1 = pci.dev_mut(0, 1, 0).unwrap();
        assert_eq!(dev1.reg_3c & 0xFF, 11);
        assert_eq!((dev1.reg_3c >> 8) & 0xFF, 1); // pin preserved

        // dev2 INTD (pin=3) -> index (2+3)%4=1 -> 11.
        let dev2 = pci.dev_mut(0, 2, 0).unwrap();
        assert_eq!(dev2.reg_3c & 0xFF, 11);
        assert_eq!((dev2.reg_3c >> 8) & 0xFF, 4); // pin preserved

        // BIOS bookkeeping should reflect the assigned line too.
        let seen = bios
            .pci_devices()
            .iter()
            .map(|d| (d.bus, d.device, d.function, d.irq_line))
            .collect::<Vec<_>>();
        assert!(seen.contains(&(0, 1, 0, 11)));
        assert!(seen.contains(&(0, 2, 0, 11)));
    }
}
