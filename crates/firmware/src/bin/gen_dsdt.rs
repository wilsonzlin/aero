//! Utility to regenerate the checked-in ACPI DSDT fixture (`acpi/dsdt.aml`).
//!
//! The runtime ACPI tables are generated by the `aero-acpi` Rust generator. This binary exists so
//! CI/tests/docs can point to a deterministic regeneration command for the checked-in fixture
//! (`crates/firmware/acpi/dsdt.aml`), which is used by `scripts/validate-acpi.sh` and drift tests.

use aero_acpi::{AcpiConfig, AcpiPlacement, AcpiTables};
use std::ffi::OsString;
use std::fmt;
use std::fs;
use std::io;
use std::io::Write;
use std::path::{Path, PathBuf};

const OUTPUT_PATH_REPO_REL: &str = "crates/firmware/acpi/dsdt.aml";

// Preferred regeneration command (covers all deterministic in-repo fixtures).
const REGEN_CMD: &str = "cargo xtask fixtures";
const CHECK_CMD: &str = "cargo xtask fixtures --check";

// Convenience for regenerating/checking just this DSDT fixture.
const REGEN_CMD_ALT: &str = "cargo run -p firmware --bin gen_dsdt --locked";
// When invoking `--check` via `cargo run`, the `--` separator is required so Cargo forwards the
// flag to the binary rather than trying to parse it itself.
const CHECK_CMD_ALT: &str = "cargo run -p firmware --bin gen_dsdt --locked -- --check";

#[derive(Debug)]
enum Error {
    Usage(String),
    Io {
        action: &'static str,
        path: PathBuf,
        source: io::Error,
    },
    OutOfDate {
        path: PathBuf,
        on_disk_len: Option<usize>,
        generated_len: usize,
        first_diff_offset: Option<usize>,
    },
}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Error::Usage(msg) => write!(f, "{msg}"),
            Error::Io {
                action,
                path,
                source,
            } => write!(f, "failed to {action} {}: {source}", path.display()),
            Error::OutOfDate {
                path,
                on_disk_len,
                generated_len,
                first_diff_offset,
            } => {
                writeln!(f, "{OUTPUT_PATH_REPO_REL} is out of date.")?;
                writeln!(f)?;
                writeln!(f, "Path: {}", path.display())?;
                match on_disk_len {
                    Some(len) => writeln!(f, "On-disk length: {len}")?,
                    None => writeln!(f, "On-disk length: missing")?,
                }
                writeln!(f, "Generated length: {generated_len}")?;
                if let Some(off) = first_diff_offset {
                    writeln!(f, "First differing byte offset: {off}")?;
                }
                writeln!(f)?;
                writeln!(f, "Regenerate with:")?;
                writeln!(f, "  {REGEN_CMD}")?;
                write!(f, "(or: {REGEN_CMD_ALT})")
            }
        }
    }
}

impl std::error::Error for Error {}

fn first_diff_offset(a: &[u8], b: &[u8]) -> Option<usize> {
    let n = a.len().min(b.len());
    for i in 0..n {
        if a[i] != b[i] {
            return Some(i);
        }
    }
    if a.len() != b.len() {
        return Some(n);
    }
    None
}

fn main() {
    if let Err(e) = run() {
        eprintln!("error: {e}");
        std::process::exit(1);
    }
}

fn run() -> Result<(), Error> {
    let args: Vec<OsString> = std::env::args_os().skip(1).collect();
    let mut check = false;

    for arg in args {
        if arg == "--check" {
            check = true;
        } else if arg == "--help" || arg == "-h" {
            print_usage();
            return Ok(());
        } else {
            return Err(Error::Usage(format!(
                "unknown argument {:?}\n\nUsage: gen_dsdt [--check]\n\n- --check: verify {OUTPUT_PATH_REPO_REL} is up to date without modifying it",
                arg
            )));
        }
    }

    let generated = generate_dsdt();
    let out_path = dsdt_fixture_path();

    if check {
        check_dsdt_fixture(&out_path, &generated)?;
        println!(
            "OK: {OUTPUT_PATH_REPO_REL} matches aero-acpi generator ({} bytes)",
            generated.len()
        );
        return Ok(());
    }

    write_atomically(&out_path, &generated)?;
    println!("Wrote {OUTPUT_PATH_REPO_REL} ({} bytes)", generated.len());
    Ok(())
}

fn print_usage() {
    println!(
        "Usage: gen_dsdt [--check]\n\nRegenerates the checked-in ACPI DSDT fixture at {OUTPUT_PATH_REPO_REL}.\n\nExamples:\n  {REGEN_CMD}\n  {CHECK_CMD}\n  {REGEN_CMD_ALT}\n  {CHECK_CMD_ALT}"
    );
}

fn generate_dsdt() -> Vec<u8> {
    // Keep this in sync with `crates/firmware/tests/acpi_tables.rs`.
    AcpiTables::build(&AcpiConfig::default(), AcpiPlacement::default()).dsdt
}

fn dsdt_fixture_path() -> PathBuf {
    PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .join("acpi")
        .join("dsdt.aml")
}

fn check_dsdt_fixture(path: &Path, generated: &[u8]) -> Result<(), Error> {
    match fs::read(path) {
        Ok(on_disk) => {
            if on_disk == generated {
                Ok(())
            } else {
                Err(Error::OutOfDate {
                    path: path.to_path_buf(),
                    on_disk_len: Some(on_disk.len()),
                    generated_len: generated.len(),
                    first_diff_offset: first_diff_offset(&on_disk, generated),
                })
            }
        }
        Err(e) if e.kind() == io::ErrorKind::NotFound => Err(Error::OutOfDate {
            path: path.to_path_buf(),
            on_disk_len: None,
            generated_len: generated.len(),
            first_diff_offset: None,
        }),
        Err(e) => Err(Error::Io {
            action: "read",
            path: path.to_path_buf(),
            source: e,
        }),
    }
}

fn write_atomically(path: &Path, bytes: &[u8]) -> Result<(), Error> {
    let Some(parent) = path.parent() else {
        return Err(Error::Usage(format!(
            "output path {} has no parent directory",
            path.display()
        )));
    };

    fs::create_dir_all(parent).map_err(|e| Error::Io {
        action: "create parent directory for",
        path: parent.to_path_buf(),
        source: e,
    })?;

    let file_name = path
        .file_name()
        .and_then(|n| n.to_str())
        .unwrap_or("dsdt.aml");
    let tmp_path = path.with_file_name(format!("{file_name}.tmp.{}", std::process::id()));

    {
        let mut f = fs::File::create(&tmp_path).map_err(|e| Error::Io {
            action: "create temporary file",
            path: tmp_path.clone(),
            source: e,
        })?;
        f.write_all(bytes).map_err(|e| Error::Io {
            action: "write",
            path: tmp_path.clone(),
            source: e,
        })?;
        // Best-effort: make sure the bytes hit disk before we rename.
        f.sync_all().map_err(|e| Error::Io {
            action: "sync",
            path: tmp_path.clone(),
            source: e,
        })?;
    }

    // `rename` is atomic on POSIX when the destination is on the same filesystem
    // (which it is, since we place the temp file next to the destination).
    //
    // On Windows, `rename` will fail if the destination exists, so fall back to
    // `remove_file` + `rename` to keep the tool working cross-platform.
    match fs::rename(&tmp_path, path) {
        Ok(()) => Ok(()),
        Err(rename_err) => {
            if cfg!(windows) && path.exists() {
                fs::remove_file(path).map_err(|e| Error::Io {
                    action: "remove existing file before replacing",
                    path: path.to_path_buf(),
                    source: e,
                })?;
                fs::rename(&tmp_path, path).map_err(|e| Error::Io {
                    action: "rename temporary file into place",
                    path: path.to_path_buf(),
                    source: e,
                })?;
                Ok(())
            } else {
                // Best-effort cleanup if we couldn't swap into place.
                let _ = fs::remove_file(&tmp_path);
                Err(Error::Io {
                    action: "rename temporary file into place",
                    path: path.to_path_buf(),
                    source: rename_err,
                })
            }
        }
    }
}
