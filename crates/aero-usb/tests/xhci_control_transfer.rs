use aero_usb::hid::UsbHidKeyboardHandle;
use aero_usb::xhci::context::SlotContext;
use aero_usb::xhci::interrupter::IMAN_IE;
use aero_usb::xhci::trb::{CompletionCode, Trb, TrbType, TRB_LEN};
use aero_usb::xhci::{regs, CommandCompletionCode, XhciController};
use aero_usb::{ControlResponse, MemoryBus, SetupPacket, UsbDeviceModel};

mod util;

use util::{Alloc, TestMemory};

fn write_erst_entry(mem: &mut TestMemory, erstba: u64, seg_base: u64, seg_size_trbs: u32) {
    MemoryBus::write_u64(mem, erstba, seg_base);
    MemoryBus::write_u32(mem, erstba + 8, seg_size_trbs);
    MemoryBus::write_u32(mem, erstba + 12, 0);
}

#[test]
fn xhci_control_get_descriptor_device_keyboard_short_packet_event() {
    let mut mem = TestMemory::new(0x20_000);
    let mut alloc = Alloc::new(0x1000);

    // Guest structures.
    let dcbaa = alloc.alloc(0x100, 0x40) as u64;
    let erstba = alloc.alloc(16, 0x10) as u64;
    let transfer_ring_base = alloc.alloc((TRB_LEN as u32) * 4, 0x10) as u64;
    let event_ring_base = alloc.alloc((TRB_LEN as u32) * 4, 0x10) as u64;
    let data_buf = alloc.alloc(64, 0x10) as u64;

    write_erst_entry(&mut mem, erstba, event_ring_base, 4);

    // Build the expected descriptor bytes using the real device model.
    let setup = SetupPacket {
        bm_request_type: 0x80, // DeviceToHost | Standard | Device
        b_request: 0x06,       // GET_DESCRIPTOR
        w_value: 0x0100,       // DEVICE descriptor, index 0
        w_index: 0,
        w_length: 64,
    };
    let expected = match UsbHidKeyboardHandle::new().handle_control_request(setup, None) {
        ControlResponse::Data(data) => data,
        other => panic!("expected Data response, got {other:?}"),
    };
    assert_eq!(expected.len(), 18);

    // Transfer ring TRBs: SetupStage, DataStage(IN), StatusStage(OUT), Link.
    let mut setup_trb = Trb::default();
    setup_trb.parameter = u64::from_le_bytes([
        setup.bm_request_type,
        setup.b_request,
        (setup.w_value & 0x00ff) as u8,
        (setup.w_value >> 8) as u8,
        (setup.w_index & 0x00ff) as u8,
        (setup.w_index >> 8) as u8,
        (setup.w_length & 0x00ff) as u8,
        (setup.w_length >> 8) as u8,
    ]);
    setup_trb.set_cycle(true);
    setup_trb.set_trb_type(TrbType::SetupStage);
    setup_trb.write_to(&mut mem, transfer_ring_base);

    let mut data_trb = Trb::default();
    data_trb.parameter = data_buf;
    data_trb.status = 64; // TRB Transfer Length
    data_trb.control |= Trb::CONTROL_DIR; // IN
    data_trb.set_cycle(true);
    data_trb.set_trb_type(TrbType::DataStage);
    data_trb.write_to(&mut mem, transfer_ring_base + TRB_LEN as u64);

    let mut status_trb = Trb::default();
    status_trb.set_cycle(true);
    status_trb.set_trb_type(TrbType::StatusStage);
    status_trb.control |= Trb::CONTROL_IOC; // request Transfer Event
                                            // DIR=0 (Status OUT) for a control read.
    status_trb.write_to(&mut mem, transfer_ring_base + 2 * TRB_LEN as u64);

    let mut link_trb = Trb::default();
    link_trb.parameter = transfer_ring_base;
    link_trb.set_cycle(true);
    link_trb.set_trb_type(TrbType::Link);
    link_trb.set_link_toggle_cycle(true);
    link_trb.write_to(&mut mem, transfer_ring_base + 3 * TRB_LEN as u64);

    // Wire up the controller.
    let mut xhci = XhciController::new();
    xhci.set_dcbaap(dcbaa);
    xhci.attach_device(0, Box::new(UsbHidKeyboardHandle::new()));

    // Drain the port-status-change event generated by attaching a device so the event ring only
    // contains the control-transfer completion.
    while xhci.pop_pending_event().is_some() {}

    let completion = xhci.enable_slot(&mut mem);
    assert_eq!(completion.completion_code, CommandCompletionCode::Success);
    let slot_id = completion.slot_id;
    assert_ne!(slot_id, 0);

    let mut slot_ctx = SlotContext::default();
    slot_ctx.set_root_hub_port_number(1);
    let completion = xhci.address_device(slot_id, slot_ctx);
    assert_eq!(completion.completion_code, CommandCompletionCode::Success);

    // Configure interrupter 0 to deliver events into our guest event ring.
    xhci.mmio_write(&mut mem, regs::REG_INTR0_ERSTSZ, 4, 1);
    xhci.mmio_write(&mut mem, regs::REG_INTR0_ERSTBA_LO, 4, erstba as u32);
    xhci.mmio_write(
        &mut mem,
        regs::REG_INTR0_ERSTBA_HI,
        4,
        (erstba >> 32) as u32,
    );
    xhci.mmio_write(&mut mem, regs::REG_INTR0_ERDP_LO, 4, event_ring_base as u32);
    xhci.mmio_write(
        &mut mem,
        regs::REG_INTR0_ERDP_HI,
        4,
        (event_ring_base >> 32) as u32,
    );
    xhci.mmio_write(&mut mem, regs::REG_INTR0_IMAN, 4, IMAN_IE);

    // Endpoint 0 uses DCI=1.
    xhci.set_endpoint_ring(slot_id, 1, transfer_ring_base, true);

    // Ring the endpoint doorbell then tick to process.
    let doorbell_offset = u64::from(regs::DBOFF_VALUE)
        + u64::from(slot_id) * u64::from(regs::doorbell::DOORBELL_STRIDE);
    xhci.mmio_write(&mut mem, doorbell_offset, 4, 1);
    xhci.tick_1ms_and_service_event_ring(&mut mem);

    // Verify the device descriptor bytes landed in guest memory.
    let mut got = vec![0u8; expected.len()];
    mem.read_physical(data_buf, &mut got);
    assert_eq!(got, expected);

    // Verify we got a Transfer Event for the status stage, reporting the short packet residue.
    let ev = Trb::read_from(&mut mem, event_ring_base);
    assert_eq!(ev.trb_type(), TrbType::TransferEvent);
    assert_eq!(ev.slot_id(), slot_id);
    assert_eq!(ev.endpoint_id(), 1);
    assert_eq!(
        ev.parameter & !0x0f,
        transfer_ring_base + 2 * TRB_LEN as u64
    );
    assert_eq!(ev.completion_code_raw(), CompletionCode::ShortPacket.raw());

    let residue = (ev.status & 0x00ff_ffff) as usize;
    assert_eq!(residue, 64 - expected.len());
}
