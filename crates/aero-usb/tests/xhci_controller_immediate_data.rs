use std::cell::RefCell;
use std::rc::Rc;

use aero_usb::xhci::context::SlotContext;
use aero_usb::xhci::interrupter::IMAN_IE;
use aero_usb::xhci::trb::{CompletionCode, Trb, TrbType, TRB_LEN};
use aero_usb::xhci::{regs, CommandCompletionCode, XhciController};
use aero_usb::{ControlResponse, MemoryBus, SetupPacket, UsbDeviceModel};

mod util;

use util::{Alloc, TestMemory};

const TRB_IDT: u32 = 1 << 6;

fn write_erst_entry(mem: &mut TestMemory, erstba: u64, seg_base: u64, seg_size_trbs: u32) {
    MemoryBus::write_u64(mem, erstba, seg_base);
    MemoryBus::write_u32(mem, erstba + 8, seg_size_trbs);
    MemoryBus::write_u32(mem, erstba + 12, 0);
}

#[derive(Clone)]
struct CaptureControlOutDevice {
    captured: Rc<RefCell<Vec<u8>>>,
}

impl UsbDeviceModel for CaptureControlOutDevice {
    fn handle_control_request(
        &mut self,
        setup: SetupPacket,
        data_stage: Option<&[u8]>,
    ) -> ControlResponse {
        assert_eq!(setup.bm_request_type, 0x40);
        assert_eq!(setup.b_request, 0x55);
        assert_eq!(setup.w_value, 0);
        assert_eq!(setup.w_index, 0);
        assert_eq!(setup.w_length, 4);

        let data = data_stage.expect("expected OUT data stage");
        self.captured.borrow_mut().clear();
        self.captured.borrow_mut().extend_from_slice(data);
        ControlResponse::Ack
    }
}

struct ImmediateControlInDevice;

impl UsbDeviceModel for ImmediateControlInDevice {
    fn handle_control_request(
        &mut self,
        setup: SetupPacket,
        _data_stage: Option<&[u8]>,
    ) -> ControlResponse {
        assert_eq!(setup.bm_request_type, 0xC0);
        assert_eq!(setup.b_request, 0x66);
        assert_eq!(setup.w_value, 0);
        assert_eq!(setup.w_index, 0);
        assert_eq!(setup.w_length, 4);

        ControlResponse::Data(vec![0x11, 0x22, 0x33, 0x44])
    }
}

fn setup_controller_with_transfer_ring(
    mem: &mut TestMemory,
    alloc: &mut Alloc,
    device: Box<dyn UsbDeviceModel>,
) -> (XhciController, u8, u64, u64, u64) {
    let dcbaa = alloc.alloc(0x100, 0x40) as u64;
    let erstba = alloc.alloc(16, 0x10) as u64;
    let transfer_ring_base = alloc.alloc((TRB_LEN as u32) * 4, 0x10) as u64;
    let event_ring_base = alloc.alloc((TRB_LEN as u32) * 8, 0x10) as u64;

    write_erst_entry(mem, erstba, event_ring_base, 8);

    let mut xhci = XhciController::new();
    xhci.set_dcbaap(dcbaa);
    xhci.attach_device(0, device);

    // Drain the port-status-change event generated by attaching a device.
    while xhci.pop_pending_event().is_some() {}

    let completion = xhci.enable_slot(mem);
    assert_eq!(completion.completion_code, CommandCompletionCode::Success);
    let slot_id = completion.slot_id;
    assert_ne!(slot_id, 0);

    let mut slot_ctx = SlotContext::default();
    slot_ctx.set_root_hub_port_number(1);
    let completion = xhci.address_device(slot_id, slot_ctx);
    assert_eq!(completion.completion_code, CommandCompletionCode::Success);

    // Configure interrupter 0 to deliver events into our guest event ring.
    xhci.mmio_write(regs::REG_INTR0_ERSTSZ, 4, 1);
    xhci.mmio_write(regs::REG_INTR0_ERSTBA_LO, 4, erstba);
    xhci.mmio_write(regs::REG_INTR0_ERSTBA_HI, 4, erstba >> 32);
    xhci.mmio_write(regs::REG_INTR0_ERDP_LO, 4, event_ring_base);
    xhci.mmio_write(regs::REG_INTR0_ERDP_HI, 4, event_ring_base >> 32);
    xhci.mmio_write(regs::REG_INTR0_IMAN, 4, u64::from(IMAN_IE));
    xhci.mmio_write(regs::REG_USBCMD, 4, u64::from(regs::USBCMD_RUN));

    xhci.set_endpoint_ring(slot_id, 1, transfer_ring_base, true);

    (xhci, slot_id, transfer_ring_base, event_ring_base, erstba)
}

#[test]
fn xhci_controller_control_out_immediate_data_stage_is_delivered() {
    let mut mem = TestMemory::new(0x20_000);
    let mut alloc = Alloc::new(0x1000);

    let captured = Rc::new(RefCell::new(Vec::new()));
    let dev = CaptureControlOutDevice {
        captured: captured.clone(),
    };

    let (mut xhci, slot_id, transfer_ring_base, event_ring_base, _erstba) =
        setup_controller_with_transfer_ring(&mut mem, &mut alloc, Box::new(dev));

    // SetupStage, DataStage (OUT + IDT), StatusStage (IN), Link.
    let setup = SetupPacket {
        bm_request_type: 0x40,
        b_request: 0x55,
        w_value: 0,
        w_index: 0,
        w_length: 4,
    };

    let mut setup_trb = Trb {
        parameter: u64::from_le_bytes([
            setup.bm_request_type,
            setup.b_request,
            (setup.w_value & 0x00ff) as u8,
            (setup.w_value >> 8) as u8,
            (setup.w_index & 0x00ff) as u8,
            (setup.w_index >> 8) as u8,
            (setup.w_length & 0x00ff) as u8,
            (setup.w_length >> 8) as u8,
        ]),
        status: 8,
        ..Default::default()
    };
    setup_trb.set_cycle(true);
    setup_trb.set_trb_type(TrbType::SetupStage);
    setup_trb.write_to(&mut mem, transfer_ring_base);

    let payload = [0xde, 0xad, 0xbe, 0xef, 0, 0, 0, 0];
    let mut data_trb = Trb {
        parameter: u64::from_le_bytes(payload),
        status: 4,
        control: TRB_IDT,
    };
    data_trb.set_cycle(true);
    data_trb.set_trb_type(TrbType::DataStage);
    data_trb.write_to(&mut mem, transfer_ring_base + TRB_LEN as u64);

    let mut status_trb = Trb {
        control: Trb::CONTROL_DIR | Trb::CONTROL_IOC,
        ..Default::default()
    };
    status_trb.set_cycle(true);
    status_trb.set_trb_type(TrbType::StatusStage);
    status_trb.write_to(&mut mem, transfer_ring_base + 2 * TRB_LEN as u64);

    let mut link_trb = Trb {
        parameter: transfer_ring_base,
        ..Default::default()
    };
    link_trb.set_cycle(true);
    link_trb.set_trb_type(TrbType::Link);
    link_trb.set_link_toggle_cycle(true);
    link_trb.write_to(&mut mem, transfer_ring_base + 3 * TRB_LEN as u64);

    // Ring the endpoint doorbell then tick to process.
    let doorbell_offset = u64::from(regs::DBOFF_VALUE)
        + u64::from(slot_id) * u64::from(regs::doorbell::DOORBELL_STRIDE);
    xhci.mmio_write(doorbell_offset, 4, 1);
    xhci.tick(&mut mem);
    xhci.service_event_ring(&mut mem);

    assert_eq!(&*captured.borrow(), &[0xde, 0xad, 0xbe, 0xef]);

    // Verify we got a Transfer Event for the status stage.
    let ev = Trb::read_from(&mut mem, event_ring_base);
    assert_eq!(ev.trb_type(), TrbType::TransferEvent);
    assert_eq!(ev.slot_id(), slot_id);
    assert_eq!(ev.endpoint_id(), 1);
    assert_eq!(
        ev.parameter & !0x0f,
        transfer_ring_base + 2 * TRB_LEN as u64
    );
    assert_eq!(ev.completion_code_raw(), CompletionCode::Success.raw());
    assert_eq!(ev.status & 0x00ff_ffff, 0);
}

#[test]
fn xhci_controller_control_in_immediate_data_stage_writes_trb_parameter() {
    let mut mem = TestMemory::new(0x20_000);
    let mut alloc = Alloc::new(0x1000);

    let (mut xhci, slot_id, transfer_ring_base, event_ring_base, _erstba) =
        setup_controller_with_transfer_ring(
            &mut mem,
            &mut alloc,
            Box::new(ImmediateControlInDevice),
        );

    // SetupStage, DataStage (IN + IDT), StatusStage (OUT), Link.
    let setup = SetupPacket {
        bm_request_type: 0xC0,
        b_request: 0x66,
        w_value: 0,
        w_index: 0,
        w_length: 4,
    };

    let mut setup_trb = Trb {
        parameter: u64::from_le_bytes([
            setup.bm_request_type,
            setup.b_request,
            (setup.w_value & 0x00ff) as u8,
            (setup.w_value >> 8) as u8,
            (setup.w_index & 0x00ff) as u8,
            (setup.w_index >> 8) as u8,
            (setup.w_length & 0x00ff) as u8,
            (setup.w_length >> 8) as u8,
        ]),
        status: 8,
        ..Default::default()
    };
    setup_trb.set_cycle(true);
    setup_trb.set_trb_type(TrbType::SetupStage);
    setup_trb.write_to(&mut mem, transfer_ring_base);

    let mut data_trb = Trb {
        parameter: 0x8877_6655_4433_2211, // would fault if treated as a pointer.
        status: 4,
        control: TRB_IDT | Trb::CONTROL_DIR, // IN + immediate
    };
    data_trb.set_cycle(true);
    data_trb.set_trb_type(TrbType::DataStage);
    data_trb.write_to(&mut mem, transfer_ring_base + TRB_LEN as u64);

    let mut status_trb = Trb {
        control: Trb::CONTROL_IOC, // request event
        ..Default::default()
    };
    status_trb.set_cycle(true);
    status_trb.set_trb_type(TrbType::StatusStage);
    status_trb.write_to(&mut mem, transfer_ring_base + 2 * TRB_LEN as u64);

    let mut link_trb = Trb {
        parameter: transfer_ring_base,
        ..Default::default()
    };
    link_trb.set_cycle(true);
    link_trb.set_trb_type(TrbType::Link);
    link_trb.set_link_toggle_cycle(true);
    link_trb.write_to(&mut mem, transfer_ring_base + 3 * TRB_LEN as u64);

    // Ring the endpoint doorbell then tick to process.
    let doorbell_offset = u64::from(regs::DBOFF_VALUE)
        + u64::from(slot_id) * u64::from(regs::doorbell::DOORBELL_STRIDE);
    xhci.mmio_write(doorbell_offset, 4, 1);
    xhci.tick(&mut mem);
    xhci.service_event_ring(&mut mem);

    // Verify the controller wrote the response bytes back into the DataStage TRB parameter field.
    let data_trb = Trb::read_from(&mut mem, transfer_ring_base + TRB_LEN as u64);
    assert_eq!(
        data_trb.parameter.to_le_bytes(),
        [0x11, 0x22, 0x33, 0x44, 0, 0, 0, 0]
    );

    // Verify we got a Transfer Event for the status stage.
    let ev = Trb::read_from(&mut mem, event_ring_base);
    assert_eq!(ev.trb_type(), TrbType::TransferEvent);
    assert_eq!(ev.slot_id(), slot_id);
    assert_eq!(ev.endpoint_id(), 1);
    assert_eq!(
        ev.parameter & !0x0f,
        transfer_ring_base + 2 * TRB_LEN as u64
    );
    assert_eq!(ev.completion_code_raw(), CompletionCode::Success.raw());
    assert_eq!(ev.status & 0x00ff_ffff, 0);
}
