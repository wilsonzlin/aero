//! Small opcode/prefix tables used by the decoder.
//!
//! A full production decoder typically has large autogenerated opcode tables.
//! For now, we only keep the tables that are required to correctly scan legacy
//! prefixes and classify basic control-flow opcodes.

use crate::inst::SegmentReg;

/// Returns the segment override prefix corresponding to `byte`, if any.
#[inline]
#[must_use]
pub const fn segment_override(byte: u8) -> Option<SegmentReg> {
    match byte {
        0x26 => Some(SegmentReg::ES),
        0x2E => Some(SegmentReg::CS),
        0x36 => Some(SegmentReg::SS),
        0x3E => Some(SegmentReg::DS),
        0x64 => Some(SegmentReg::FS),
        0x65 => Some(SegmentReg::GS),
        _ => None,
    }
}

/// True for "group 1" legacy prefixes (LOCK/REP/REPNZ).
#[inline]
#[must_use]
pub const fn is_group1_prefix(byte: u8) -> bool {
    matches!(byte, 0xF0 | 0xF2 | 0xF3)
}

/// True for operand-size override (0x66).
#[inline]
#[must_use]
pub const fn is_operand_size_prefix(byte: u8) -> bool {
    byte == 0x66
}

/// True for address-size override (0x67).
#[inline]
#[must_use]
pub const fn is_address_size_prefix(byte: u8) -> bool {
    byte == 0x67
}
