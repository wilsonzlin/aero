---
source: crates/aero-d3d9/tests/fixed_function_wgsl_snapshots.rs
expression: shaders_snapshot(&desc)
---
// hash: 0x2986a1db51476a47

// --- vertex.wgsl ---

struct Globals {
  world_view_proj: mat4x4<f32>,
  viewport: vec4<f32>,
  alpha_test: vec4<f32>,
  fog_color: vec4<f32>,
  fog_params: vec4<f32>,
  material_diffuse: vec4<f32>,
  material_ambient: vec4<f32>,
  light_dir: vec4<f32>,
  light_color: vec4<f32>,
  lighting_flags: vec4<u32>,
  texture_factor: vec4<f32>,
  stage_constants: array<vec4<f32>, 8>,
};

@group(0) @binding(0) var<uniform> globals: Globals;

fn d3dcolor_bgra_to_rgba(c: vec4<f32>) -> vec4<f32> {
  // `D3DCOLOR` is 0xAARRGGBB in little-endian memory; when consumed as `unorm8x4` it arrives as
  // (b, g, r, a).
  return c.zyxw;
}

struct VertexIn {
  @location(0) position: vec3<f32>,
  @location(3) diffuse: vec4<f32>,
  @location(5) tex0: vec2<f32>,
}

struct VertexOut {
  @builtin(position) position: vec4<f32>,
  @location(0) diffuse: vec4<f32>,
  @location(1) specular: vec4<f32>,
  @location(2) tex0: vec4<f32>,
}

@vertex
fn vs_main(input: VertexIn) -> VertexOut {
  var out: VertexOut;
  let base_diffuse = d3dcolor_bgra_to_rgba(input.diffuse);
  out.diffuse = base_diffuse;
  out.specular = vec4<f32>(0.0, 0.0, 0.0, 0.0);
  out.tex0 = vec4<f32>(input.tex0, 0.0, 1.0);
  out.position = globals.world_view_proj * vec4<f32>(input.position, 1.0);
  return out;
}


// --- fragment.wgsl ---

struct Globals {
  world_view_proj: mat4x4<f32>,
  viewport: vec4<f32>,
  alpha_test: vec4<f32>,
  fog_color: vec4<f32>,
  fog_params: vec4<f32>,
  material_diffuse: vec4<f32>,
  material_ambient: vec4<f32>,
  light_dir: vec4<f32>,
  light_color: vec4<f32>,
  lighting_flags: vec4<u32>,
  texture_factor: vec4<f32>,
  stage_constants: array<vec4<f32>, 8>,
};

@group(0) @binding(0) var<uniform> globals: Globals;

fn d3dcolor_bgra_to_rgba(c: vec4<f32>) -> vec4<f32> {
  // `D3DCOLOR` is 0xAARRGGBB in little-endian memory; when consumed as `unorm8x4` it arrives as
  // (b, g, r, a).
  return c.zyxw;
}

@group(1) @binding(0) var tex0: texture_2d<f32>;
@group(1) @binding(1) var samp0: sampler;

@group(1) @binding(2) var tex1: texture_2d<f32>;
@group(1) @binding(3) var samp1: sampler;

@group(1) @binding(4) var tex2: texture_2d<f32>;
@group(1) @binding(5) var samp2: sampler;

@group(1) @binding(6) var tex3: texture_2d<f32>;
@group(1) @binding(7) var samp3: sampler;

@group(1) @binding(8) var tex4: texture_2d<f32>;
@group(1) @binding(9) var samp4: sampler;

@group(1) @binding(10) var tex5: texture_2d<f32>;
@group(1) @binding(11) var samp5: sampler;

@group(1) @binding(12) var tex6: texture_2d<f32>;
@group(1) @binding(13) var samp6: sampler;

@group(1) @binding(14) var tex7: texture_2d<f32>;
@group(1) @binding(15) var samp7: sampler;

struct FragmentIn {
  @location(0) diffuse: vec4<f32>,
  @location(1) specular: vec4<f32>,
  @location(2) tex0: vec4<f32>,
}

@fragment
fn fs_main(input: FragmentIn) -> @location(0) vec4<f32> {
  var current = input.diffuse;
  let tex0_color = textureSample(tex0, samp0, input.tex0.xy);
  {
    let rgb_raw = ((tex0_color.rgb) * (input.diffuse.rgb));
    let a_raw = tex0_color.a;
    let rgb = clamp(rgb_raw, vec3<f32>(0.0), vec3<f32>(1.0));
    let a = clamp(a_raw, 0.0, 1.0);
    current = vec4<f32>(rgb, a);
  }
  return current;
}
