#!/usr/bin/env node

// `bench/run` serves two audiences:
//
// 1) CI/browser microbenches (delegates to `tools/perf/run.mjs`).
// 2) Aero macrobench runs that consume `window.aero.perf.export()` (implemented in `bench/runner.js`).
//
// Mode selection:
// - If macro-only flags like `--output` / `--results-dir` / `--warmup` are present, we run the macrobench harness.
// - Otherwise, we keep the existing `tools/perf` wrapper behavior for contributor docs and CI parity.

import fs from "node:fs";
import path from "node:path";
import { spawnSync } from "node:child_process";
import { fileURLToPath } from "node:url";
import { parseArgs as parseNodeArgs } from "node:util";
import { createRequire } from "node:module";
import { formatOneLineError, truncateUtf8 } from "../src/text.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

function usagePerfWrapper(exitCode = 0) {
  const installCmd = "npm ci && npx playwright install chromium";

  // Keep this in sync with `docs/16-performance-tooling.md`.
  console.log(`Usage: node bench/run --scenario <name> --iterations <n> [--url <url>] [--out-dir <dir>]

Scenarios:
  - microbench         Browser JS microbenchmark (default)
  - chromium_startup   Chromium launch + navigation timing
  - all                Run all scenarios and print a short summary

This wrapper delegates to:
  node tools/perf/run.mjs --out-dir <dir> --iterations <n> [--url <url>]

Additional flags are passed through to tools/perf/run.mjs:
  --trace
  --trace-duration-ms <n>
  --include-aero-bench

Notes:
  - You must install tool dependencies first:
      ${installCmd}
`);
  process.exit(exitCode);
}

function parsePerfWrapperArgs(argv) {
  const opts = {
    scenario: "microbench",
    iterations: 7,
    url: undefined,
    outDir: "perf-results/local",
    trace: false,
    traceDurationMs: undefined,
    includeAeroBench: false,
  };

  for (let i = 0; i < argv.length; i += 1) {
    const arg = argv[i];
    switch (arg) {
      case "--help":
      case "-h":
        usagePerfWrapper(0);
        break;
      case "--scenario":
        opts.scenario = argv[++i];
        break;
      case "--iterations":
        opts.iterations = Number.parseInt(argv[++i], 10);
        break;
      case "--url":
        opts.url = argv[++i];
        break;
      case "--out-dir":
        opts.outDir = argv[++i];
        break;
      case "--trace":
        opts.trace = true;
        break;
      case "--trace-duration-ms":
        opts.trace = true;
        opts.traceDurationMs = Number.parseInt(argv[++i], 10);
        break;
      case "--include-aero-bench":
        opts.includeAeroBench = true;
        break;
      default:
        console.error(`Unknown arg: ${arg}`);
        usagePerfWrapper(1);
    }
  }

  if (!opts.scenario) {
    console.error("--scenario is required");
    usagePerfWrapper(1);
  }
  if (!Number.isFinite(opts.iterations) || opts.iterations <= 0) {
    console.error("--iterations must be a positive integer");
    usagePerfWrapper(1);
  }
  if (
    opts.traceDurationMs !== undefined &&
    (!Number.isFinite(opts.traceDurationMs) || opts.traceDurationMs <= 0)
  ) {
    console.error("--trace-duration-ms must be a positive integer");
    usagePerfWrapper(1);
  }

  return opts;
}

function fmtMs(ms) {
  if (!Number.isFinite(ms)) return "n/a";
  return `${ms.toFixed(2)}ms`;
}

function fmtCv(cv) {
  if (!Number.isFinite(cv)) return "n/a";
  return cv === 0 ? "0" : `${(cv * 100).toFixed(2)}%`;
}

function runPerfWrapper(argv) {
  const opts = parsePerfWrapperArgs(argv);

  const repoRoot = path.resolve(__dirname, "..");
  const runnerPath = path.join(repoRoot, "tools", "perf", "run.mjs");
  if (!fs.existsSync(runnerPath)) {
    console.error(`Missing perf runner: ${path.relative(process.cwd(), runnerPath)}`);
    process.exit(1);
  }

  // `npm ci` for this repo installs workspace dependencies at the repo root and may
  // not create a nested `tools/perf/node_modules/` directory (npm hoisting).
  // Resolve Playwright the same way `tools/perf/run.mjs` will.
  const perfRequire = createRequire(runnerPath);
  try {
    perfRequire.resolve("playwright-core/package.json");
  } catch {
    console.error("[bench/run] Missing playwright-core dependency.");
    console.error("Run: npm ci && npx playwright install chromium");
    process.exit(1);
  }

  const outDir = path.isAbsolute(opts.outDir) ? opts.outDir : path.join(repoRoot, opts.outDir);
  fs.mkdirSync(outDir, { recursive: true });

  const childArgs = [runnerPath, "--out-dir", outDir, "--iterations", String(opts.iterations)];
  if (opts.url) childArgs.push("--url", opts.url);
  if (opts.trace) {
    childArgs.push("--trace");
    if (opts.traceDurationMs !== undefined) {
      childArgs.push("--trace-duration-ms", String(opts.traceDurationMs));
    }
  }
  if (opts.includeAeroBench) {
    childArgs.push("--include-aero-bench");
  }

  const child = spawnSync(process.execPath, childArgs, { stdio: "inherit", cwd: repoRoot });
  if (child.status !== 0) {
    process.exit(child.status ?? 1);
  }

  const summaryPath = path.join(outDir, "summary.json");
  if (!fs.existsSync(summaryPath)) {
    console.warn(`[bench/run] Missing expected output: ${summaryPath}`);
    return;
  }

  const summary = JSON.parse(fs.readFileSync(summaryPath, "utf8"));
  const benches = Array.isArray(summary.benchmarks) ? summary.benchmarks : [];
  const map = new Map(benches.map((b) => [b.name, b]));

  const scenarioToBench = {
    microbench: "microbench_ms",
    chromium_startup: "chromium_startup_ms",
    startup: "chromium_startup_ms",
  };

  const printBench = (benchName) => {
    const b = map.get(benchName);
    if (!b) {
      console.warn(`[bench/run] Missing benchmark in summary.json: ${benchName}`);
      return;
    }
    const stats = b.stats ?? {};
    const median = stats.median;
    const cv = stats.cv;
    console.log(`${benchName}: median=${fmtMs(median)} cv=${fmtCv(cv)} n=${stats.n ?? "?"}`);
    if (Number.isFinite(cv) && cv >= 0.5) {
      console.warn(`WARNING: extremely high variance (cv=${fmtCv(cv)}). Re-run with more iterations or reduce noise.`);
    }
  };

  if (opts.scenario === "all") {
    const names = ["chromium_startup_ms", "microbench_ms"];
    if (opts.includeAeroBench) {
      names.push("aero_microbench_suite_ms");
    }
    for (const name of names) printBench(name);
    return;
  }

  const benchName = scenarioToBench[opts.scenario] ?? opts.scenario;
  printBench(benchName);
}

function usageMacro(exitCode = 0) {
  console.log(`Usage: node bench/run --scenario <name> --iterations <n> --output <path> [macro options]

Macrobench scenarios:
  - startup
  - microbench
  - idle_raf

Macrobench options:
  --warmup <n>              Warmup iterations per scenario (default: 1)
  --idle-seconds <n>        idle_raf duration per iteration (default: 5)
  --url <url>               Use an existing URL instead of building/serving
  --skip-build              Skip build step when --url is not provided
  --output <path>           Write summary JSON to this path (in addition to bench/results)
  --results-dir <path>      Results directory (default: bench/results)
  --run-id <id>             Override run id
  --timeout-ms <n>          Per-page readiness timeout (default: 60000)
  --unstable-cov <n>        Mark metric unstable if CoV exceeds this (default: 0.1)
  --headed                  Run Chromium headed (default: headless)
`);
  process.exit(exitCode);
}

function parseMacroArgs(argv) {
  const parsed = parseNodeArgs({
    options: {
      scenario: { type: "string", multiple: true },
      iterations: { type: "string" },
      warmup: { type: "string" },
      "idle-seconds": { type: "string" },
      url: { type: "string" },
      output: { type: "string" },
      "results-dir": { type: "string" },
      "run-id": { type: "string" },
      "timeout-ms": { type: "string" },
      "unstable-cov": { type: "string" },
      "skip-build": { type: "boolean", default: false },
      headed: { type: "boolean", default: false },
      help: { type: "boolean", default: false },
    },
    allowPositionals: false,
    args: argv,
  });

  if (parsed.values.help) usageMacro(0);

  const scenariosRaw = parsed.values.scenario ?? [];
  const scenarios = scenariosRaw.flatMap((s) => String(s).split(",").map((v) => v.trim()).filter(Boolean));

  const iterations = parsed.values.iterations ? Number(parsed.values.iterations) : 5;
  const warmupIterations = parsed.values.warmup ? Number(parsed.values.warmup) : 1;
  const idleSeconds = parsed.values["idle-seconds"] ? Number(parsed.values["idle-seconds"]) : 5;
  const timeoutMs = parsed.values["timeout-ms"] ? Number(parsed.values["timeout-ms"]) : 60_000;
  const unstableCov = parsed.values["unstable-cov"] ? Number(parsed.values["unstable-cov"]) : 0.1;

  for (const [name, value] of [
    ["iterations", iterations],
    ["warmup", warmupIterations],
    ["idle-seconds", idleSeconds],
    ["timeout-ms", timeoutMs],
    ["unstable-cov", unstableCov],
  ]) {
    if (!Number.isFinite(value) || value < 0) throw new Error(`Invalid --${name}: ${value}`);
  }

  return {
    scenarios,
    iterations,
    warmupIterations,
    idleSeconds,
    url: parsed.values.url,
    outputPath: parsed.values.output,
    resultsDir: parsed.values["results-dir"],
    runId: parsed.values["run-id"],
    timeoutMs,
    unstableCov,
    skipBuild: parsed.values["skip-build"],
    headless: !parsed.values.headed,
  };
}

async function runMacro(argv) {
  const opts = parseMacroArgs(argv);
  const mod = await import("./runner.js");
  const runBench = mod.runBench ?? mod.default?.runBench;
  if (typeof runBench !== "function") throw new Error("bench/runner.js did not export runBench()");
  await runBench(opts);
}

function extractScenarioFlags(argv) {
  /** @type {string[]} */
  const out = [];
  for (let i = 0; i < argv.length; i += 1) {
    if (argv[i] === "--scenario" && argv[i + 1]) {
      out.push(...argv[i + 1].split(",").map((v) => v.trim()).filter(Boolean));
      i += 1;
    }
  }
  return out;
}

function shouldUseMacroHarness(argv) {
  const macroFlags = new Set([
    "--output",
    "--results-dir",
    "--warmup",
    "--idle-seconds",
    "--timeout-ms",
    "--unstable-cov",
    "--run-id",
    "--skip-build",
    "--headed",
  ]);
  if (argv.some((a) => macroFlags.has(a))) return true;
  const scenarios = extractScenarioFlags(argv);
  return scenarios.includes("idle_raf");
}

async function main() {
  const argv = process.argv.slice(2);
  if (shouldUseMacroHarness(argv)) await runMacro(argv);
  else runPerfWrapper(argv);
}

try {
  await main();
} catch (err) {
  let stack = null;
  if (err && typeof err === "object") {
    try {
      const raw = err.stack;
      if (typeof raw === "string" && raw) stack = raw;
    } catch {
      // ignore getters throwing
    }
  }
  console.error(stack ? truncateUtf8(stack, 8 * 1024) : formatOneLineError(err, 512));
  process.exitCode = 1;
}
